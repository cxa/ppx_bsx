module Result = struct type ('a, 'b) result = Ok of 'a | Error of 'b end open Result
module Ast_404
= struct
#1 "ast_404.ml"
# 1 "src/ast_404.ml"
# 1 "src/ast_404.ml"
# 1 "src/ast_404.ml"
# 1 "src/ast_404.ml"
# 1 "src/ast_404.ml"
# 1 "src/ast_404.ml"
# 1 "src/ast_404.ml"
# 1 "src/ast_404.ml"
# 1 "src/ast_404.ml"
# 1 "src/ast_404.ml"
# 1 "src/ast_404.ml"
# 1 "src/ast_404.ml"
# 1 "src/ast_404.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*            Jérémie Dimino and Leo White, Jane Street Europe            *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt            *)
(*                         Alain Frisch, LexiFi                           *)
(*       Daniel de Rauglaudre, projet Cristal, INRIA Rocquencourt         *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

module Location = Location
module Longident = Longident

module Asttypes = struct
  (** Auxiliary AST types used by parsetree and typedtree. *)

  type constant (*IF_CURRENT = Asttypes.constant *) =
      Const_int of int
    | Const_char of char
    | Const_string of string * string option
    | Const_float of string
    | Const_int32 of int32
    | Const_int64 of int64
    | Const_nativeint of nativeint

  type rec_flag (*IF_CURRENT = Asttypes.rec_flag *) = Nonrecursive | Recursive

  type direction_flag (*IF_CURRENT = Asttypes.direction_flag *) = Upto | Downto

  (* Order matters, used in polymorphic comparison *)
  type private_flag (*IF_CURRENT = Asttypes.private_flag *) = Private | Public

  type mutable_flag (*IF_CURRENT = Asttypes.mutable_flag *) = Immutable | Mutable

  type virtual_flag (*IF_CURRENT = Asttypes.virtual_flag *) = Virtual | Concrete

  type override_flag (*IF_CURRENT = Asttypes.override_flag *) = Override | Fresh

  type closed_flag (*IF_CURRENT = Asttypes.closed_flag *) = Closed | Open

  type label = string

  type arg_label (*IF_CURRENT = Asttypes.arg_label *) =
      Nolabel
    | Labelled of string (*  label:T -> ... *)
    | Optional of string (* ?label:T -> ... *)

  type 'a loc = 'a Location.loc = {
    txt : 'a;
    loc : Location.t;
  }


  type variance (*IF_CURRENT = Asttypes.variance *) =
    | Covariant
    | Contravariant
    | Invariant
end

module Parsetree = struct
  (** Abstract syntax tree produced by parsing *)

  open Asttypes

  type constant (*IF_CURRENT = Parsetree.constant *) =
      Pconst_integer of string * char option
    (* 3 3l 3L 3n

       Suffixes [g-z][G-Z] are accepted by the parser.
       Suffixes except 'l', 'L' and 'n' are rejected by the typechecker
    *)
    | Pconst_char of char
    (* 'c' *)
    | Pconst_string of string * string option
    (* "constant"
       {delim|other constant|delim}
    *)
    | Pconst_float of string * char option
    (* 3.4 2e5 1.4e-4

       Suffixes [g-z][G-Z] are accepted by the parser.
       Suffixes are rejected by the typechecker.
    *)

  (** {2 Extension points} *)

  type attribute = string loc * payload
         (* [@id ARG]
            [@@id ARG]

            Metadata containers passed around within the AST.
            The compiler ignores unknown attributes.
         *)

  and extension = string loc * payload
        (* [%id ARG]
           [%%id ARG]

           Sub-language placeholder -- rejected by the typechecker.
        *)

  and attributes = attribute list

  and payload (*IF_CURRENT = Parsetree.payload *) =
    | PStr of structure
    | PSig of signature (* : SIG *)
    | PTyp of core_type  (* : T *)
    | PPat of pattern * expression option  (* ? P  or  ? P when E *)

  (** {2 Core language} *)

  (* Type expressions *)

  and core_type (*IF_CURRENT = Parsetree.core_type *) =
      {
       ptyp_desc: core_type_desc;
       ptyp_loc: Location.t;
       ptyp_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and core_type_desc (*IF_CURRENT = Parsetree.core_type_desc *) =
    | Ptyp_any
          (*  _ *)
    | Ptyp_var of string
          (* 'a *)
    | Ptyp_arrow of arg_label * core_type * core_type
          (* T1 -> T2       Simple
             ~l:T1 -> T2    Labelled
             ?l:T1 -> T2    Otional
           *)
    | Ptyp_tuple of core_type list
          (* T1 * ... * Tn

             Invariant: n >= 2
          *)
    | Ptyp_constr of Longident.t loc * core_type list
          (* tconstr
             T tconstr
             (T1, ..., Tn) tconstr
           *)
    | Ptyp_object of (string * attributes * core_type) list * closed_flag
          (* < l1:T1; ...; ln:Tn >     (flag = Closed)
             < l1:T1; ...; ln:Tn; .. > (flag = Open)
           *)
    | Ptyp_class of Longident.t loc * core_type list
          (* #tconstr
             T #tconstr
             (T1, ..., Tn) #tconstr
           *)
    | Ptyp_alias of core_type * string
          (* T as 'a *)
    | Ptyp_variant of row_field list * closed_flag * label list option
          (* [ `A|`B ]         (flag = Closed; labels = None)
             [> `A|`B ]        (flag = Open;   labels = None)
             [< `A|`B ]        (flag = Closed; labels = Some [])
             [< `A|`B > `X `Y ](flag = Closed; labels = Some ["X";"Y"])
           *)
    | Ptyp_poly of string list * core_type
          (* 'a1 ... 'an. T

             Can only appear in the following context:

             - As the core_type of a Ppat_constraint node corresponding
               to a constraint on a let-binding: let x : 'a1 ... 'an. T
               = e ...

             - Under Cfk_virtual for methods (not values).

             - As the core_type of a Pctf_method node.

             - As the core_type of a Pexp_poly node.

             - As the pld_type field of a label_declaration.

             - As a core_type of a Ptyp_object node.
           *)

    | Ptyp_package of package_type
          (* (module S) *)
    | Ptyp_extension of extension
          (* [%id] *)

  and package_type = Longident.t loc * (Longident.t loc * core_type) list
        (*
          (module S)
          (module S with type t1 = T1 and ... and tn = Tn)
         *)

  and row_field (*IF_CURRENT = Parsetree.row_field *) =
    | Rtag of label * attributes * bool * core_type list
          (* [`A]                   ( true,  [] )
             [`A of T]              ( false, [T] )
             [`A of T1 & .. & Tn]   ( false, [T1;...Tn] )
             [`A of & T1 & .. & Tn] ( true,  [T1;...Tn] )

            - The 2nd field is true if the tag contains a
              constant (empty) constructor.
            - '&' occurs when several types are used for the same constructor
              (see 4.2 in the manual)

            - TODO: switch to a record representation, and keep location
          *)
    | Rinherit of core_type
          (* [ T ] *)

  (* Patterns *)

  and pattern (*IF_CURRENT = Parsetree.pattern *) =
      {
       ppat_desc: pattern_desc;
       ppat_loc: Location.t;
       ppat_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and pattern_desc (*IF_CURRENT = Parsetree.pattern_desc *) =
    | Ppat_any
          (* _ *)
    | Ppat_var of string loc
          (* x *)
    | Ppat_alias of pattern * string loc
          (* P as 'a *)
    | Ppat_constant of constant
          (* 1, 'a', "true", 1.0, 1l, 1L, 1n *)
    | Ppat_interval of constant * constant
          (* 'a'..'z'

             Other forms of interval are recognized by the parser
             but rejected by the type-checker. *)
    | Ppat_tuple of pattern list
          (* (P1, ..., Pn)

             Invariant: n >= 2
          *)
    | Ppat_construct of Longident.t loc * pattern option
          (* C                None
             C P              Some P
             C (P1, ..., Pn)  Some (Ppat_tuple [P1; ...; Pn])
           *)
    | Ppat_variant of label * pattern option
          (* `A             (None)
             `A P           (Some P)
           *)
    | Ppat_record of (Longident.t loc * pattern) list * closed_flag
          (* { l1=P1; ...; ln=Pn }     (flag = Closed)
             { l1=P1; ...; ln=Pn; _}   (flag = Open)

             Invariant: n > 0
           *)
    | Ppat_array of pattern list
          (* [| P1; ...; Pn |] *)
    | Ppat_or of pattern * pattern
          (* P1 | P2 *)
    | Ppat_constraint of pattern * core_type
          (* (P : T) *)
    | Ppat_type of Longident.t loc
          (* #tconst *)
    | Ppat_lazy of pattern
          (* lazy P *)
    | Ppat_unpack of string loc
          (* (module P)
             Note: (module P : S) is represented as
             Ppat_constraint(Ppat_unpack, Ptyp_package)
           *)
    | Ppat_exception of pattern
          (* exception P *)
    | Ppat_extension of extension
          (* [%id] *)
    | Ppat_open of Longident.t loc * pattern

  (* Value expressions *)

  and expression (*IF_CURRENT = Parsetree.expression *) =
      {
       pexp_desc: expression_desc;
       pexp_loc: Location.t;
       pexp_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and expression_desc (*IF_CURRENT = Parsetree.expression_desc *) =
    | Pexp_ident of Longident.t loc
          (* x
             M.x
           *)
    | Pexp_constant of constant
          (* 1, 'a', "true", 1.0, 1l, 1L, 1n *)
    | Pexp_let of rec_flag * value_binding list * expression
          (* let P1 = E1 and ... and Pn = EN in E       (flag = Nonrecursive)
             let rec P1 = E1 and ... and Pn = EN in E   (flag = Recursive)
           *)
    | Pexp_function of case list
          (* function P1 -> E1 | ... | Pn -> En *)
    | Pexp_fun of arg_label * expression option * pattern * expression
          (* fun P -> E1                          (Simple, None)
             fun ~l:P -> E1                       (Labelled l, None)
             fun ?l:P -> E1                       (Optional l, None)
             fun ?l:(P = E0) -> E1                (Optional l, Some E0)

             Notes:
             - If E0 is provided, only Optional is allowed.
             - "fun P1 P2 .. Pn -> E1" is represented as nested Pexp_fun.
             - "let f P = E" is represented using Pexp_fun.
           *)
    | Pexp_apply of expression * (arg_label * expression) list
          (* E0 ~l1:E1 ... ~ln:En
             li can be empty (non labeled argument) or start with '?'
             (optional argument).

             Invariant: n > 0
           *)
    | Pexp_match of expression * case list
          (* match E0 with P1 -> E1 | ... | Pn -> En *)
    | Pexp_try of expression * case list
          (* try E0 with P1 -> E1 | ... | Pn -> En *)
    | Pexp_tuple of expression list
          (* (E1, ..., En)

             Invariant: n >= 2
          *)
    | Pexp_construct of Longident.t loc * expression option
          (* C                None
             C E              Some E
             C (E1, ..., En)  Some (Pexp_tuple[E1;...;En])
          *)
    | Pexp_variant of label * expression option
          (* `A             (None)
             `A E           (Some E)
           *)
    | Pexp_record of (Longident.t loc * expression) list * expression option
          (* { l1=P1; ...; ln=Pn }     (None)
             { E0 with l1=P1; ...; ln=Pn }   (Some E0)

             Invariant: n > 0
           *)
    | Pexp_field of expression * Longident.t loc
          (* E.l *)
    | Pexp_setfield of expression * Longident.t loc * expression
          (* E1.l <- E2 *)
    | Pexp_array of expression list
          (* [| E1; ...; En |] *)
    | Pexp_ifthenelse of expression * expression * expression option
          (* if E1 then E2 else E3 *)
    | Pexp_sequence of expression * expression
          (* E1; E2 *)
    | Pexp_while of expression * expression
          (* while E1 do E2 done *)
    | Pexp_for of
        pattern *  expression * expression * direction_flag * expression
          (* for i = E1 to E2 do E3 done      (flag = Upto)
             for i = E1 downto E2 do E3 done  (flag = Downto)
           *)
    | Pexp_constraint of expression * core_type
          (* (E : T) *)
    | Pexp_coerce of expression * core_type option * core_type
          (* (E :> T)        (None, T)
             (E : T0 :> T)   (Some T0, T)
           *)
    | Pexp_send of expression * string
          (*  E # m *)
    | Pexp_new of Longident.t loc
          (* new M.c *)
    | Pexp_setinstvar of string loc * expression
          (* x <- 2 *)
    | Pexp_override of (string loc * expression) list
          (* {< x1 = E1; ...; Xn = En >} *)
    | Pexp_letmodule of string loc * module_expr * expression
          (* let module M = ME in E *)
    | Pexp_letexception of extension_constructor * expression
          (* let exception C in E *)
    | Pexp_assert of expression
          (* assert E
             Note: "assert false" is treated in a special way by the
             type-checker. *)
    | Pexp_lazy of expression
          (* lazy E *)
    | Pexp_poly of expression * core_type option
          (* Used for method bodies.

             Can only be used as the expression under Cfk_concrete
             for methods (not values). *)
    | Pexp_object of class_structure
          (* object ... end *)
    | Pexp_newtype of string * expression
          (* fun (type t) -> E *)
    | Pexp_pack of module_expr
          (* (module ME)

             (module ME : S) is represented as
             Pexp_constraint(Pexp_pack, Ptyp_package S) *)
    | Pexp_open of override_flag * Longident.t loc * expression
          (* let open M in E
             let! open M in E
          *)
    | Pexp_extension of extension
          (* [%id] *)
    | Pexp_unreachable
          (* . *)

  and case (*IF_CURRENT = Parsetree.case *) =   (* (P -> E) or (P when E0 -> E) *)
      {
       pc_lhs: pattern;
       pc_guard: expression option;
       pc_rhs: expression;
      }

  (* Value descriptions *)

  and value_description (*IF_CURRENT = Parsetree.value_description *) =
      {
       pval_name: string loc;
       pval_type: core_type;
       pval_prim: string list;
       pval_attributes: attributes;  (* ... [@@id1] [@@id2] *)
       pval_loc: Location.t;
      }

  (*
    val x: T                            (prim = [])
    external x: T = "s1" ... "sn"       (prim = ["s1";..."sn"])
  *)

  (* Type declarations *)

  and type_declaration (*IF_CURRENT = Parsetree.type_declaration *) =
      {
       ptype_name: string loc;
       ptype_params: (core_type * variance) list;
             (* ('a1,...'an) t; None represents  _*)
       ptype_cstrs: (core_type * core_type * Location.t) list;
             (* ... constraint T1=T1'  ... constraint Tn=Tn' *)
       ptype_kind: type_kind;
       ptype_private: private_flag;   (* = private ... *)
       ptype_manifest: core_type option;  (* = T *)
       ptype_attributes: attributes;   (* ... [@@id1] [@@id2] *)
       ptype_loc: Location.t;
      }

  (*
    type t                     (abstract, no manifest)
    type t = T0                (abstract, manifest=T0)
    type t = C of T | ...      (variant,  no manifest)
    type t = T0 = C of T | ... (variant,  manifest=T0)
    type t = {l: T; ...}       (record,   no manifest)
    type t = T0 = {l : T; ...} (record,   manifest=T0)
    type t = ..                (open,     no manifest)
  *)

  and type_kind (*IF_CURRENT = Parsetree.type_kind *) =
    | Ptype_abstract
    | Ptype_variant of constructor_declaration list
          (* Invariant: non-empty list *)
    | Ptype_record of label_declaration list
          (* Invariant: non-empty list *)
    | Ptype_open

  and label_declaration (*IF_CURRENT = Parsetree.label_declaration *) =
      {
       pld_name: string loc;
       pld_mutable: mutable_flag;
       pld_type: core_type;
       pld_loc: Location.t;
       pld_attributes: attributes; (* l [@id1] [@id2] : T *)
      }

  (*  { ...; l: T; ... }            (mutable=Immutable)
      { ...; mutable l: T; ... }    (mutable=Mutable)

      Note: T can be a Ptyp_poly.
  *)

  and constructor_declaration (*IF_CURRENT = Parsetree.constructor_declaration *) =
      {
       pcd_name: string loc;
       pcd_args: constructor_arguments;
       pcd_res: core_type option;
       pcd_loc: Location.t;
       pcd_attributes: attributes; (* C [@id1] [@id2] of ... *)
      }

  and constructor_arguments (*IF_CURRENT = Parsetree.constructor_arguments *) =
    | Pcstr_tuple of core_type list
    | Pcstr_record of label_declaration list

  (*
    | C of T1 * ... * Tn     (res = None,    args = Pcstr_tuple [])
    | C: T0                  (res = Some T0, args = [])
    | C: T1 * ... * Tn -> T0 (res = Some T0, args = Pcstr_tuple)
    | C of {...}             (res = None,    args = Pcstr_record)
    | C: {...} -> T0         (res = Some T0, args = Pcstr_record)
    | C of {...} as t        (res = None,    args = Pcstr_record)
  *)

  and type_extension (*IF_CURRENT = Parsetree.type_extension *) =
      {
       ptyext_path: Longident.t loc;
       ptyext_params: (core_type * variance) list;
       ptyext_constructors: extension_constructor list;
       ptyext_private: private_flag;
       ptyext_attributes: attributes;   (* ... [@@id1] [@@id2] *)
      }
  (*
    type t += ...
  *)

  and extension_constructor (*IF_CURRENT = Parsetree.extension_constructor *) =
      {
       pext_name: string loc;
       pext_kind : extension_constructor_kind;
       pext_loc : Location.t;
       pext_attributes: attributes; (* C [@id1] [@id2] of ... *)
      }

  and extension_constructor_kind (*IF_CURRENT = Parsetree.extension_constructor_kind *) =
      Pext_decl of constructor_arguments * core_type option
        (*
           | C of T1 * ... * Tn     ([T1; ...; Tn], None)
           | C: T0                  ([], Some T0)
           | C: T1 * ... * Tn -> T0 ([T1; ...; Tn], Some T0)
         *)
    | Pext_rebind of Longident.t loc
        (*
           | C = D
         *)

  (** {2 Class language} *)

  (* Type expressions for the class language *)

  and class_type (*IF_CURRENT = Parsetree.class_type *) =
      {
       pcty_desc: class_type_desc;
       pcty_loc: Location.t;
       pcty_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and class_type_desc (*IF_CURRENT = Parsetree.class_type_desc *) =
    | Pcty_constr of Longident.t loc * core_type list
          (* c
             ['a1, ..., 'an] c *)
    | Pcty_signature of class_signature
          (* object ... end *)
    | Pcty_arrow of arg_label * core_type * class_type
          (* T -> CT       Simple
             ~l:T -> CT    Labelled l
             ?l:T -> CT    Optional l
           *)
    | Pcty_extension of extension
          (* [%id] *)

  and class_signature (*IF_CURRENT = Parsetree.class_signature *) =
      {
       pcsig_self: core_type;
       pcsig_fields: class_type_field list;
      }
  (* object('selfpat) ... end
     object ... end             (self = Ptyp_any)
   *)

  and class_type_field (*IF_CURRENT = Parsetree.class_type_field *) =
      {
       pctf_desc: class_type_field_desc;
       pctf_loc: Location.t;
       pctf_attributes: attributes; (* ... [@@id1] [@@id2] *)
      }

  and class_type_field_desc (*IF_CURRENT = Parsetree.class_type_field_desc *) =
    | Pctf_inherit of class_type
          (* inherit CT *)
    | Pctf_val of (string * mutable_flag * virtual_flag * core_type)
          (* val x: T *)
    | Pctf_method  of (string * private_flag * virtual_flag * core_type)
          (* method x: T

             Note: T can be a Ptyp_poly.
           *)
    | Pctf_constraint  of (core_type * core_type)
          (* constraint T1 = T2 *)
    | Pctf_attribute of attribute
          (* [@@@id] *)
    | Pctf_extension of extension
          (* [%%id] *)

  and 'a class_infos (*IF_CURRENT = 'a Parsetree.class_infos *) =
      {
       pci_virt: virtual_flag;
       pci_params: (core_type * variance) list;
       pci_name: string loc;
       pci_expr: 'a;
       pci_loc: Location.t;
       pci_attributes: attributes;  (* ... [@@id1] [@@id2] *)
      }
  (* class c = ...
     class ['a1,...,'an] c = ...
     class virtual c = ...

     Also used for "class type" declaration.
  *)

  and class_description = class_type class_infos

  and class_type_declaration = class_type class_infos

  (* Value expressions for the class language *)

  and class_expr (*IF_CURRENT = Parsetree.class_expr *) =
      {
       pcl_desc: class_expr_desc;
       pcl_loc: Location.t;
       pcl_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and class_expr_desc (*IF_CURRENT = Parsetree.class_expr_desc *) =
    | Pcl_constr of Longident.t loc * core_type list
          (* c
             ['a1, ..., 'an] c *)
    | Pcl_structure of class_structure
          (* object ... end *)
    | Pcl_fun of arg_label * expression option * pattern * class_expr
          (* fun P -> CE                          (Simple, None)
             fun ~l:P -> CE                       (Labelled l, None)
             fun ?l:P -> CE                       (Optional l, None)
             fun ?l:(P = E0) -> CE                (Optional l, Some E0)
           *)
    | Pcl_apply of class_expr * (arg_label * expression) list
          (* CE ~l1:E1 ... ~ln:En
             li can be empty (non labeled argument) or start with '?'
             (optional argument).

             Invariant: n > 0
           *)
    | Pcl_let of rec_flag * value_binding list * class_expr
          (* let P1 = E1 and ... and Pn = EN in CE      (flag = Nonrecursive)
             let rec P1 = E1 and ... and Pn = EN in CE  (flag = Recursive)
           *)
    | Pcl_constraint of class_expr * class_type
          (* (CE : CT) *)
    | Pcl_extension of extension
          (* [%id] *)

  and class_structure (*IF_CURRENT = Parsetree.class_structure *) =
      {
       pcstr_self: pattern;
       pcstr_fields: class_field list;
      }
  (* object(selfpat) ... end
     object ... end           (self = Ppat_any)
   *)

  and class_field (*IF_CURRENT = Parsetree.class_field *) =
      {
       pcf_desc: class_field_desc;
       pcf_loc: Location.t;
       pcf_attributes: attributes; (* ... [@@id1] [@@id2] *)
      }

  and class_field_desc (*IF_CURRENT = Parsetree.class_field_desc *) =
    | Pcf_inherit of override_flag * class_expr * string option
          (* inherit CE
             inherit CE as x
             inherit! CE
             inherit! CE as x
           *)
    | Pcf_val of (string loc * mutable_flag * class_field_kind)
          (* val x = E
             val virtual x: T
           *)
    | Pcf_method of (string loc * private_flag * class_field_kind)
          (* method x = E            (E can be a Pexp_poly)
             method virtual x: T     (T can be a Ptyp_poly)
           *)
    | Pcf_constraint of (core_type * core_type)
          (* constraint T1 = T2 *)
    | Pcf_initializer of expression
          (* initializer E *)
    | Pcf_attribute of attribute
          (* [@@@id] *)
    | Pcf_extension of extension
          (* [%%id] *)

  and class_field_kind (*IF_CURRENT = Parsetree.class_field_kind *) =
    | Cfk_virtual of core_type
    | Cfk_concrete of override_flag * expression

  and class_declaration = class_expr class_infos

  (** {2 Module language} *)

  (* Type expressions for the module language *)

  and module_type (*IF_CURRENT = Parsetree.module_type *) =
      {
       pmty_desc: module_type_desc;
       pmty_loc: Location.t;
       pmty_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and module_type_desc (*IF_CURRENT = Parsetree.module_type_desc *) =
    | Pmty_ident of Longident.t loc
          (* S *)
    | Pmty_signature of signature
          (* sig ... end *)
    | Pmty_functor of string loc * module_type option * module_type
          (* functor(X : MT1) -> MT2 *)
    | Pmty_with of module_type * with_constraint list
          (* MT with ... *)
    | Pmty_typeof of module_expr
          (* module type of ME *)
    | Pmty_extension of extension
          (* [%id] *)
    | Pmty_alias of Longident.t loc
          (* (module M) *)

  and signature = signature_item list

  and signature_item (*IF_CURRENT = Parsetree.signature_item *) =
      {
       psig_desc: signature_item_desc;
       psig_loc: Location.t;
      }

  and signature_item_desc (*IF_CURRENT = Parsetree.signature_item_desc *) =
    | Psig_value of value_description
          (*
            val x: T
            external x: T = "s1" ... "sn"
           *)
    | Psig_type of rec_flag * type_declaration list
          (* type t1 = ... and ... and tn = ... *)
    | Psig_typext of type_extension
          (* type t1 += ... *)
    | Psig_exception of extension_constructor
          (* exception C of T *)
    | Psig_module of module_declaration
          (* module X : MT *)
    | Psig_recmodule of module_declaration list
          (* module rec X1 : MT1 and ... and Xn : MTn *)
    | Psig_modtype of module_type_declaration
          (* module type S = MT
             module type S *)
    | Psig_open of open_description
          (* open X *)
    | Psig_include of include_description
          (* include MT *)
    | Psig_class of class_description list
          (* class c1 : ... and ... and cn : ... *)
    | Psig_class_type of class_type_declaration list
          (* class type ct1 = ... and ... and ctn = ... *)
    | Psig_attribute of attribute
          (* [@@@id] *)
    | Psig_extension of extension * attributes
          (* [%%id] *)

  and module_declaration (*IF_CURRENT = Parsetree.module_declaration *) =
      {
       pmd_name: string loc;
       pmd_type: module_type;
       pmd_attributes: attributes; (* ... [@@id1] [@@id2] *)
       pmd_loc: Location.t;
      }
  (* S : MT *)

  and module_type_declaration (*IF_CURRENT = Parsetree.module_type_declaration *) =
      {
       pmtd_name: string loc;
       pmtd_type: module_type option;
       pmtd_attributes: attributes; (* ... [@@id1] [@@id2] *)
       pmtd_loc: Location.t;
      }
  (* S = MT
     S       (abstract module type declaration, pmtd_type = None)
  *)

  and open_description (*IF_CURRENT = Parsetree.open_description *) =
      {
       popen_lid: Longident.t loc;
       popen_override: override_flag;
       popen_loc: Location.t;
       popen_attributes: attributes;
      }
  (* open! X - popen_override = Override (silences the 'used identifier
                                shadowing' warning)
     open  X - popen_override = Fresh
   *)

  and 'a include_infos (*IF_CURRENT = 'a Parsetree.include_infos *) =
      {
       pincl_mod: 'a;
       pincl_loc: Location.t;
       pincl_attributes: attributes;
      }

  and include_description = module_type include_infos
  (* include MT *)

  and include_declaration = module_expr include_infos
  (* include ME *)

  and with_constraint (*IF_CURRENT = Parsetree.with_constraint *) =
    | Pwith_type of Longident.t loc * type_declaration
          (* with type X.t = ...

             Note: the last component of the longident must match
             the name of the type_declaration. *)
    | Pwith_module of Longident.t loc * Longident.t loc
          (* with module X.Y = Z *)
    | Pwith_typesubst of type_declaration
          (* with type t := ... *)
    | Pwith_modsubst of string loc * Longident.t loc
          (* with module X := Z *)

  (* Value expressions for the module language *)

  and module_expr (*IF_CURRENT = Parsetree.module_expr *) =
      {
       pmod_desc: module_expr_desc;
       pmod_loc: Location.t;
       pmod_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and module_expr_desc (*IF_CURRENT = Parsetree.module_expr_desc *) =
    | Pmod_ident of Longident.t loc
          (* X *)
    | Pmod_structure of structure
          (* struct ... end *)
    | Pmod_functor of string loc * module_type option * module_expr
          (* functor(X : MT1) -> ME *)
    | Pmod_apply of module_expr * module_expr
          (* ME1(ME2) *)
    | Pmod_constraint of module_expr * module_type
          (* (ME : MT) *)
    | Pmod_unpack of expression
          (* (val E) *)
    | Pmod_extension of extension
          (* [%id] *)

  and structure = structure_item list

  and structure_item (*IF_CURRENT = Parsetree.structure_item *) =
      {
       pstr_desc: structure_item_desc;
       pstr_loc: Location.t;
      }

  and structure_item_desc (*IF_CURRENT = Parsetree.structure_item_desc *) =
    | Pstr_eval of expression * attributes
          (* E *)
    | Pstr_value of rec_flag * value_binding list
          (* let P1 = E1 and ... and Pn = EN       (flag = Nonrecursive)
             let rec P1 = E1 and ... and Pn = EN   (flag = Recursive)
           *)
    | Pstr_primitive of value_description
          (*  val x: T
              external x: T = "s1" ... "sn" *)
    | Pstr_type of rec_flag * type_declaration list
          (* type t1 = ... and ... and tn = ... *)
    | Pstr_typext of type_extension
          (* type t1 += ... *)
    | Pstr_exception of extension_constructor
          (* exception C of T
             exception C = M.X *)
    | Pstr_module of module_binding
          (* module X = ME *)
    | Pstr_recmodule of module_binding list
          (* module rec X1 = ME1 and ... and Xn = MEn *)
    | Pstr_modtype of module_type_declaration
          (* module type S = MT *)
    | Pstr_open of open_description
          (* open X *)
    | Pstr_class of class_declaration list
          (* class c1 = ... and ... and cn = ... *)
    | Pstr_class_type of class_type_declaration list
          (* class type ct1 = ... and ... and ctn = ... *)
    | Pstr_include of include_declaration
          (* include ME *)
    | Pstr_attribute of attribute
          (* [@@@id] *)
    | Pstr_extension of extension * attributes
          (* [%%id] *)

  and value_binding (*IF_CURRENT = Parsetree.value_binding *) =
    {
      pvb_pat: pattern;
      pvb_expr: expression;
      pvb_attributes: attributes;
      pvb_loc: Location.t;
    }

  and module_binding (*IF_CURRENT = Parsetree.module_binding *) =
      {
       pmb_name: string loc;
       pmb_expr: module_expr;
       pmb_attributes: attributes;
       pmb_loc: Location.t;
      }
  (* X = ME *)

  (** {2 Toplevel} *)

  (* Toplevel phrases *)

  type toplevel_phrase (*IF_CURRENT = Parsetree.toplevel_phrase *) =
    | Ptop_def of structure
    | Ptop_dir of string * directive_argument
       (* #use, #load ... *)

  and directive_argument (*IF_CURRENT = Parsetree.directive_argument *) =
    | Pdir_none
    | Pdir_string of string
    | Pdir_int of string * char option
    | Pdir_ident of Longident.t
    | Pdir_bool of bool
end

module Docstrings : sig
  (** {3 Docstrings} *)

  (** Documentation comments *)
  type docstring

  (** Create a docstring *)
  val docstring : string -> Location.t -> docstring

  (** Get the text of a docstring *)
  val docstring_body : docstring -> string

  (** Get the location of a docstring *)
  val docstring_loc : docstring -> Location.t

  (** {3 Items}

      The {!docs} type represents documentation attached to an item. *)

  type docs =
    { docs_pre: docstring option;
      docs_post: docstring option; }

  val empty_docs : docs

  val docs_attr : docstring -> Parsetree.attribute

  (** Convert item documentation to attributes and add them to an
      attribute list *)
  val add_docs_attrs : docs -> Parsetree.attributes -> Parsetree.attributes

  (** {3 Fields and constructors}

      The {!info} type represents documentation attached to a field or
      constructor. *)

  type info = docstring option

  val empty_info : info

  val info_attr : docstring -> Parsetree.attribute

  (** Convert field info to attributes and add them to an
      attribute list *)
  val add_info_attrs : info -> Parsetree.attributes -> Parsetree.attributes

  (** {3 Unattached comments}

      The {!text} type represents documentation which is not attached to
      anything. *)

  type text = docstring list

  val empty_text : text

  val text_attr : docstring -> Parsetree.attribute

  (** Convert text to attributes and add them to an attribute list *)
  val add_text_attrs : text -> Parsetree.attributes -> Parsetree.attributes

end = struct
  open Location

  (* Docstrings *)

  type docstring =
    { ds_body: string;
      ds_loc: Location.t; }

  (* Docstring constructors and destructors *)

  let docstring body loc =
    let ds =
      { ds_body = body;
        ds_loc = loc; }
    in
    ds

  let docstring_body ds = ds.ds_body

  let docstring_loc ds = ds.ds_loc

  (* Docstrings attached to items *)

  type docs =
    { docs_pre: docstring option;
      docs_post: docstring option; }

  let empty_docs = { docs_pre = None; docs_post = None }

  let doc_loc = {txt = "ocaml.doc"; loc = Location.none}

  let docs_attr ds =
    let open Parsetree in
    let exp =
      { pexp_desc = Pexp_constant (Pconst_string(ds.ds_body, None));
        pexp_loc = ds.ds_loc;
        pexp_attributes = []; }
    in
    let item =
      { pstr_desc = Pstr_eval (exp, []); pstr_loc = exp.pexp_loc }
    in
      (doc_loc, PStr [item])

  let add_docs_attrs docs attrs =
    let attrs =
      match docs.docs_pre with
      | None | Some { ds_body=""; _ } -> attrs
      | Some ds -> docs_attr ds :: attrs
    in
    let attrs =
      match docs.docs_post with
      | None | Some { ds_body=""; _ } -> attrs
      | Some ds -> attrs @ [docs_attr ds]
    in
    attrs

  (* Docstrings attached to constructors or fields *)

  type info = docstring option

  let empty_info = None

  let info_attr = docs_attr

  let add_info_attrs info attrs =
    match info with
    | None | Some {ds_body=""; _} -> attrs
    | Some ds -> attrs @ [info_attr ds]

  (* Docstrings not attached to a specific item *)

  type text = docstring list

  let empty_text = []

  let text_loc = {txt = "ocaml.text"; loc = Location.none}

  let text_attr ds =
    let open Parsetree in
    let exp =
      { pexp_desc = Pexp_constant (Pconst_string(ds.ds_body, None));
        pexp_loc = ds.ds_loc;
        pexp_attributes = []; }
    in
    let item =
      { pstr_desc = Pstr_eval (exp, []); pstr_loc = exp.pexp_loc }
    in
      (text_loc, PStr [item])

  let add_text_attrs dsl attrs =
    let fdsl = List.filter (function {ds_body=""; _} -> false| _ ->true) dsl in
    (List.map text_attr fdsl) @ attrs

end

module Ast_helper : sig
  (** Helpers to produce Parsetree fragments *)

  open Asttypes
  open Docstrings
  open Parsetree

  type lid = Longident.t loc
  type str = string loc
  type loc = Location.t
  type attrs = attribute list

  (** {2 Default locations} *)

  val default_loc: loc ref
      (** Default value for all optional location arguments. *)

  val with_default_loc: loc -> (unit -> 'a) -> 'a
      (** Set the [default_loc] within the scope of the execution
          of the provided function. *)

  (** {2 Constants} *)

  module Const : sig
    val char : char -> constant
    val string : ?quotation_delimiter:string -> string -> constant
    val integer : ?suffix:char -> string -> constant
    val int : ?suffix:char -> int -> constant
    val int32 : ?suffix:char -> int32 -> constant
    val int64 : ?suffix:char -> int64 -> constant
    val nativeint : ?suffix:char -> nativeint -> constant
    val float : ?suffix:char -> string -> constant
  end

  (** {2 Core language} *)

  (** Type expressions *)
  module Typ :
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> core_type_desc -> core_type
      val attr: core_type -> attribute -> core_type

      val any: ?loc:loc -> ?attrs:attrs -> unit -> core_type
      val var: ?loc:loc -> ?attrs:attrs -> string -> core_type
      val arrow: ?loc:loc -> ?attrs:attrs -> arg_label -> core_type -> core_type
                 -> core_type
      val tuple: ?loc:loc -> ?attrs:attrs -> core_type list -> core_type
      val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> core_type
      val object_: ?loc:loc -> ?attrs:attrs ->
                    (string * attributes * core_type) list -> closed_flag ->
                    core_type
      val class_: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> core_type
      val alias: ?loc:loc -> ?attrs:attrs -> core_type -> string -> core_type
      val variant: ?loc:loc -> ?attrs:attrs -> row_field list -> closed_flag
                   -> label list option -> core_type
      val poly: ?loc:loc -> ?attrs:attrs -> string list -> core_type -> core_type
      val package: ?loc:loc -> ?attrs:attrs -> lid -> (lid * core_type) list
                   -> core_type
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> core_type

      val force_poly: core_type -> core_type
    end

  (** Patterns *)
  module Pat:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> pattern_desc -> pattern
      val attr:pattern -> attribute -> pattern

      val any: ?loc:loc -> ?attrs:attrs -> unit -> pattern
      val var: ?loc:loc -> ?attrs:attrs -> str -> pattern
      val alias: ?loc:loc -> ?attrs:attrs -> pattern -> str -> pattern
      val constant: ?loc:loc -> ?attrs:attrs -> constant -> pattern
      val interval: ?loc:loc -> ?attrs:attrs -> constant -> constant -> pattern
      val tuple: ?loc:loc -> ?attrs:attrs -> pattern list -> pattern
      val construct: ?loc:loc -> ?attrs:attrs -> lid -> pattern option -> pattern
      val variant: ?loc:loc -> ?attrs:attrs -> label -> pattern option -> pattern
      val record: ?loc:loc -> ?attrs:attrs -> (lid * pattern) list -> closed_flag
                  -> pattern
      val array: ?loc:loc -> ?attrs:attrs -> pattern list -> pattern
      val or_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern -> pattern
      val constraint_: ?loc:loc -> ?attrs:attrs -> pattern -> core_type -> pattern
      val type_: ?loc:loc -> ?attrs:attrs -> lid -> pattern
      val lazy_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern
      val unpack: ?loc:loc -> ?attrs:attrs -> str -> pattern
      val open_: ?loc:loc -> ?attrs:attrs  -> lid -> pattern -> pattern
      val exception_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> pattern
    end

  (** Expressions *)
  module Exp:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> expression_desc -> expression
      val attr: expression -> attribute -> expression

      val ident: ?loc:loc -> ?attrs:attrs -> lid -> expression
      val constant: ?loc:loc -> ?attrs:attrs -> constant -> expression
      val let_: ?loc:loc -> ?attrs:attrs -> rec_flag -> value_binding list
                -> expression -> expression
      val fun_: ?loc:loc -> ?attrs:attrs -> arg_label -> expression option
                -> pattern -> expression -> expression
      val function_: ?loc:loc -> ?attrs:attrs -> case list -> expression
      val apply: ?loc:loc -> ?attrs:attrs -> expression
                 -> (arg_label * expression) list -> expression
      val match_: ?loc:loc -> ?attrs:attrs -> expression -> case list
                  -> expression
      val try_: ?loc:loc -> ?attrs:attrs -> expression -> case list -> expression
      val tuple: ?loc:loc -> ?attrs:attrs -> expression list -> expression
      val construct: ?loc:loc -> ?attrs:attrs -> lid -> expression option
                     -> expression
      val variant: ?loc:loc -> ?attrs:attrs -> label -> expression option
                   -> expression
      val record: ?loc:loc -> ?attrs:attrs -> (lid * expression) list
                  -> expression option -> expression
      val field: ?loc:loc -> ?attrs:attrs -> expression -> lid -> expression
      val setfield: ?loc:loc -> ?attrs:attrs -> expression -> lid -> expression
                    -> expression
      val array: ?loc:loc -> ?attrs:attrs -> expression list -> expression
      val ifthenelse: ?loc:loc -> ?attrs:attrs -> expression -> expression
                      -> expression option -> expression
      val sequence: ?loc:loc -> ?attrs:attrs -> expression -> expression
                    -> expression
      val while_: ?loc:loc -> ?attrs:attrs -> expression -> expression
                  -> expression
      val for_: ?loc:loc -> ?attrs:attrs -> pattern -> expression -> expression
                -> direction_flag -> expression -> expression
      val coerce: ?loc:loc -> ?attrs:attrs -> expression -> core_type option
                  -> core_type -> expression
      val constraint_: ?loc:loc -> ?attrs:attrs -> expression -> core_type
                       -> expression
      val send: ?loc:loc -> ?attrs:attrs -> expression -> string -> expression
      val new_: ?loc:loc -> ?attrs:attrs -> lid -> expression
      val setinstvar: ?loc:loc -> ?attrs:attrs -> str -> expression -> expression
      val override: ?loc:loc -> ?attrs:attrs -> (str * expression) list
                    -> expression
      val letmodule: ?loc:loc -> ?attrs:attrs -> str -> module_expr -> expression
                     -> expression
      val letexception:
        ?loc:loc -> ?attrs:attrs -> extension_constructor -> expression
        -> expression
      val assert_: ?loc:loc -> ?attrs:attrs -> expression -> expression
      val lazy_: ?loc:loc -> ?attrs:attrs -> expression -> expression
      val poly: ?loc:loc -> ?attrs:attrs -> expression -> core_type option
                -> expression
      val object_: ?loc:loc -> ?attrs:attrs -> class_structure -> expression
      val newtype: ?loc:loc -> ?attrs:attrs -> string -> expression -> expression
      val pack: ?loc:loc -> ?attrs:attrs -> module_expr -> expression
      val open_: ?loc:loc -> ?attrs:attrs -> override_flag -> lid -> expression
                 -> expression
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> expression
      val unreachable: ?loc:loc -> ?attrs:attrs -> unit -> expression

      val case: pattern -> ?guard:expression -> expression -> case
    end

  (** Value declarations *)
  module Val:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs ->
        ?prim:string list -> str -> core_type -> value_description
    end

  (** Type declarations *)
  module Type:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        ?params:(core_type * variance) list ->
        ?cstrs:(core_type * core_type * loc) list ->
        ?kind:type_kind -> ?priv:private_flag -> ?manifest:core_type -> str ->
        type_declaration

      val constructor: ?loc:loc -> ?attrs:attrs -> ?info:info ->
        ?args:constructor_arguments -> ?res:core_type -> str ->
        constructor_declaration
      val field: ?loc:loc -> ?attrs:attrs -> ?info:info ->
        ?mut:mutable_flag -> str -> core_type -> label_declaration
    end

  (** Type extensions *)
  module Te:
    sig
      val mk: ?attrs:attrs -> ?docs:docs ->
        ?params:(core_type * variance) list -> ?priv:private_flag ->
        lid -> extension_constructor list -> type_extension

      val constructor: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->
        str -> extension_constructor_kind -> extension_constructor

      val decl: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->
        ?args:constructor_arguments -> ?res:core_type -> str ->
        extension_constructor
      val rebind: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->
        str -> lid -> extension_constructor
    end

  (** {2 Module language} *)

  (** Module type expressions *)
  module Mty:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> module_type_desc -> module_type
      val attr: module_type -> attribute -> module_type

      val ident: ?loc:loc -> ?attrs:attrs -> lid -> module_type
      val alias: ?loc:loc -> ?attrs:attrs -> lid -> module_type
      val signature: ?loc:loc -> ?attrs:attrs -> signature -> module_type
      val functor_: ?loc:loc -> ?attrs:attrs ->
        str -> module_type option -> module_type -> module_type
      val with_: ?loc:loc -> ?attrs:attrs -> module_type ->
        with_constraint list -> module_type
      val typeof_: ?loc:loc -> ?attrs:attrs -> module_expr -> module_type
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> module_type
    end

  (** Module expressions *)
  module Mod:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> module_expr_desc -> module_expr
      val attr: module_expr -> attribute -> module_expr

      val ident: ?loc:loc -> ?attrs:attrs -> lid -> module_expr
      val structure: ?loc:loc -> ?attrs:attrs -> structure -> module_expr
      val functor_: ?loc:loc -> ?attrs:attrs ->
        str -> module_type option -> module_expr -> module_expr
      val apply: ?loc:loc -> ?attrs:attrs -> module_expr -> module_expr ->
        module_expr
      val constraint_: ?loc:loc -> ?attrs:attrs -> module_expr -> module_type ->
        module_expr
      val unpack: ?loc:loc -> ?attrs:attrs -> expression -> module_expr
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> module_expr
    end

  (** Signature items *)
  module Sig:
    sig
      val mk: ?loc:loc -> signature_item_desc -> signature_item

      val value: ?loc:loc -> value_description -> signature_item
      val type_: ?loc:loc -> rec_flag -> type_declaration list -> signature_item
      val type_extension: ?loc:loc -> type_extension -> signature_item
      val exception_: ?loc:loc -> extension_constructor -> signature_item
      val module_: ?loc:loc -> module_declaration -> signature_item
      val rec_module: ?loc:loc -> module_declaration list -> signature_item
      val modtype: ?loc:loc -> module_type_declaration -> signature_item
      val open_: ?loc:loc -> open_description -> signature_item
      val include_: ?loc:loc -> include_description -> signature_item
      val class_: ?loc:loc -> class_description list -> signature_item
      val class_type: ?loc:loc -> class_type_declaration list -> signature_item
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> signature_item
      val attribute: ?loc:loc -> attribute -> signature_item
      val text: text -> signature_item list
    end

  (** Structure items *)
  module Str:
    sig
      val mk: ?loc:loc -> structure_item_desc -> structure_item

      val eval: ?loc:loc -> ?attrs:attributes -> expression -> structure_item
      val value: ?loc:loc -> rec_flag -> value_binding list -> structure_item
      val primitive: ?loc:loc -> value_description -> structure_item
      val type_: ?loc:loc -> rec_flag -> type_declaration list -> structure_item
      val type_extension: ?loc:loc -> type_extension -> structure_item
      val exception_: ?loc:loc -> extension_constructor -> structure_item
      val module_: ?loc:loc -> module_binding -> structure_item
      val rec_module: ?loc:loc -> module_binding list -> structure_item
      val modtype: ?loc:loc -> module_type_declaration -> structure_item
      val open_: ?loc:loc -> open_description -> structure_item
      val class_: ?loc:loc -> class_declaration list -> structure_item
      val class_type: ?loc:loc -> class_type_declaration list -> structure_item
      val include_: ?loc:loc -> include_declaration -> structure_item
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> structure_item
      val attribute: ?loc:loc -> attribute -> structure_item
      val text: text -> structure_item list
    end

  (** Module declarations *)
  module Md:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        str -> module_type -> module_declaration
    end

  (** Module type declarations *)
  module Mtd:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        ?typ:module_type -> str -> module_type_declaration
    end

  (** Module bindings *)
  module Mb:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        str -> module_expr -> module_binding
    end

  (** Opens *)
  module Opn:
    sig
      val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs ->
        ?override:override_flag -> lid -> open_description
    end

  (** Includes *)
  module Incl:
    sig
      val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs -> 'a -> 'a include_infos
    end

  (** Value bindings *)
  module Vb:
    sig
      val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        pattern -> expression -> value_binding
    end


  (** {2 Class language} *)

  (** Class type expressions *)
  module Cty:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> class_type_desc -> class_type
      val attr: class_type -> attribute -> class_type

      val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> class_type
      val signature: ?loc:loc -> ?attrs:attrs -> class_signature -> class_type
      val arrow: ?loc:loc -> ?attrs:attrs -> arg_label -> core_type ->
        class_type -> class_type
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_type
    end

  (** Class type fields *)
  module Ctf:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs ->
        class_type_field_desc -> class_type_field
      val attr: class_type_field -> attribute -> class_type_field

      val inherit_: ?loc:loc -> ?attrs:attrs -> class_type -> class_type_field
      val val_: ?loc:loc -> ?attrs:attrs -> string -> mutable_flag ->
        virtual_flag -> core_type -> class_type_field
      val method_: ?loc:loc -> ?attrs:attrs -> string -> private_flag ->
        virtual_flag -> core_type -> class_type_field
      val constraint_: ?loc:loc -> ?attrs:attrs -> core_type -> core_type ->
        class_type_field
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_type_field
      val attribute: ?loc:loc -> attribute -> class_type_field
      val text: text -> class_type_field list
    end

  (** Class expressions *)
  module Cl:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> class_expr_desc -> class_expr
      val attr: class_expr -> attribute -> class_expr

      val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> class_expr
      val structure: ?loc:loc -> ?attrs:attrs -> class_structure -> class_expr
      val fun_: ?loc:loc -> ?attrs:attrs -> arg_label -> expression option ->
        pattern -> class_expr -> class_expr
      val apply: ?loc:loc -> ?attrs:attrs -> class_expr ->
        (arg_label * expression) list -> class_expr
      val let_: ?loc:loc -> ?attrs:attrs -> rec_flag -> value_binding list ->
        class_expr -> class_expr
      val constraint_: ?loc:loc -> ?attrs:attrs -> class_expr -> class_type ->
        class_expr
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_expr
    end

  (** Class fields *)
  module Cf:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> class_field_desc ->
        class_field
      val attr: class_field -> attribute -> class_field

      val inherit_: ?loc:loc -> ?attrs:attrs -> override_flag -> class_expr ->
        string option -> class_field
      val val_: ?loc:loc -> ?attrs:attrs -> str -> mutable_flag ->
        class_field_kind -> class_field
      val method_: ?loc:loc -> ?attrs:attrs -> str -> private_flag ->
        class_field_kind -> class_field
      val constraint_: ?loc:loc -> ?attrs:attrs -> core_type -> core_type ->
        class_field
      val initializer_: ?loc:loc -> ?attrs:attrs -> expression -> class_field
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_field
      val attribute: ?loc:loc -> attribute -> class_field
      val text: text -> class_field list

      val virtual_: core_type -> class_field_kind
      val concrete: override_flag -> expression -> class_field_kind

    end

  (** Classes *)
  module Ci:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        ?virt:virtual_flag -> ?params:(core_type * variance) list ->
        str -> 'a -> 'a class_infos
    end

  (** Class signatures *)
  module Csig:
    sig
      val mk: core_type -> class_type_field list -> class_signature
    end

  (** Class structures *)
  module Cstr:
    sig
      val mk: pattern -> class_field list -> class_structure
    end

end = struct
  (** Helpers to produce Parsetree fragments *)

  open Asttypes
  open Parsetree
  open Docstrings

  type lid = Longident.t loc
  type str = string loc
  type loc = Location.t
  type attrs = attribute list

  let default_loc = ref Location.none

  let with_default_loc l f =
    let old = !default_loc in
    default_loc := l;
    try let r = f () in default_loc := old; r
    with exn -> default_loc := old; raise exn

  module Const = struct
    let integer ?suffix i = Pconst_integer (i, suffix)
    let int ?suffix i = integer ?suffix (string_of_int i)
    let int32 ?(suffix='l') i = integer ~suffix (Int32.to_string i)
    let int64 ?(suffix='L') i = integer ~suffix (Int64.to_string i)
    let nativeint ?(suffix='n') i = integer ~suffix (Nativeint.to_string i)
    let float ?suffix f = Pconst_float (f, suffix)
    let char c = Pconst_char c
    let string ?quotation_delimiter s = Pconst_string (s, quotation_delimiter)
  end

  module Typ = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {ptyp_desc = d; ptyp_loc = loc; ptyp_attributes = attrs}
    let attr d a = {d with ptyp_attributes = d.ptyp_attributes @ [a]}

    let any ?loc ?attrs () = mk ?loc ?attrs Ptyp_any
    let var ?loc ?attrs a = mk ?loc ?attrs (Ptyp_var a)
    let arrow ?loc ?attrs a b c = mk ?loc ?attrs (Ptyp_arrow (a, b, c))
    let tuple ?loc ?attrs a = mk ?loc ?attrs (Ptyp_tuple a)
    let constr ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_constr (a, b))
    let object_ ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_object (a, b))
    let class_ ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_class (a, b))
    let alias ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_alias (a, b))
    let variant ?loc ?attrs a b c = mk ?loc ?attrs (Ptyp_variant (a, b, c))
    let poly ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_poly (a, b))
    let package ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_package (a, b))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Ptyp_extension a)

    let force_poly t =
      match t.ptyp_desc with
      | Ptyp_poly _ -> t
      | _ -> poly ~loc:t.ptyp_loc [] t (* -> ghost? *)
  end

  module Pat = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {ppat_desc = d; ppat_loc = loc; ppat_attributes = attrs}
    let attr d a = {d with ppat_attributes = d.ppat_attributes @ [a]}

    let any ?loc ?attrs () = mk ?loc ?attrs Ppat_any
    let var ?loc ?attrs a = mk ?loc ?attrs (Ppat_var a)
    let alias ?loc ?attrs a b = mk ?loc ?attrs (Ppat_alias (a, b))
    let constant ?loc ?attrs a = mk ?loc ?attrs (Ppat_constant a)
    let interval ?loc ?attrs a b = mk ?loc ?attrs (Ppat_interval (a, b))
    let tuple ?loc ?attrs a = mk ?loc ?attrs (Ppat_tuple a)
    let construct ?loc ?attrs a b = mk ?loc ?attrs (Ppat_construct (a, b))
    let variant ?loc ?attrs a b = mk ?loc ?attrs (Ppat_variant (a, b))
    let record ?loc ?attrs a b = mk ?loc ?attrs (Ppat_record (a, b))
    let array ?loc ?attrs a = mk ?loc ?attrs (Ppat_array a)
    let or_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_or (a, b))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_constraint (a, b))
    let type_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_type a)
    let lazy_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_lazy a)
    let unpack ?loc ?attrs a = mk ?loc ?attrs (Ppat_unpack a)
    let open_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_open (a, b))
    let exception_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_exception a)
    let extension ?loc ?attrs a = mk ?loc ?attrs (Ppat_extension a)
  end

  module Exp = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {pexp_desc = d; pexp_loc = loc; pexp_attributes = attrs}
    let attr d a = {d with pexp_attributes = d.pexp_attributes @ [a]}

    let ident ?loc ?attrs a = mk ?loc ?attrs (Pexp_ident a)
    let constant ?loc ?attrs a = mk ?loc ?attrs (Pexp_constant a)
    let let_ ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_let (a, b, c))
    let fun_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pexp_fun (a, b, c, d))
    let function_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_function a)
    let apply ?loc ?attrs a b = mk ?loc ?attrs (Pexp_apply (a, b))
    let match_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_match (a, b))
    let try_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_try (a, b))
    let tuple ?loc ?attrs a = mk ?loc ?attrs (Pexp_tuple a)
    let construct ?loc ?attrs a b = mk ?loc ?attrs (Pexp_construct (a, b))
    let variant ?loc ?attrs a b = mk ?loc ?attrs (Pexp_variant (a, b))
    let record ?loc ?attrs a b = mk ?loc ?attrs (Pexp_record (a, b))
    let field ?loc ?attrs a b = mk ?loc ?attrs (Pexp_field (a, b))
    let setfield ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_setfield (a, b, c))
    let array ?loc ?attrs a = mk ?loc ?attrs (Pexp_array a)
    let ifthenelse ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_ifthenelse (a, b, c))
    let sequence ?loc ?attrs a b = mk ?loc ?attrs (Pexp_sequence (a, b))
    let while_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_while (a, b))
    let for_ ?loc ?attrs a b c d e = mk ?loc ?attrs (Pexp_for (a, b, c, d, e))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_constraint (a, b))
    let coerce ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_coerce (a, b, c))
    let send ?loc ?attrs a b = mk ?loc ?attrs (Pexp_send (a, b))
    let new_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_new a)
    let setinstvar ?loc ?attrs a b = mk ?loc ?attrs (Pexp_setinstvar (a, b))
    let override ?loc ?attrs a = mk ?loc ?attrs (Pexp_override a)
    let letmodule ?loc ?attrs a b c= mk ?loc ?attrs (Pexp_letmodule (a, b, c))
    let letexception ?loc ?attrs a b = mk ?loc ?attrs (Pexp_letexception (a, b))
    let assert_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_assert a)
    let lazy_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_lazy a)
    let poly ?loc ?attrs a b = mk ?loc ?attrs (Pexp_poly (a, b))
    let object_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_object a)
    let newtype ?loc ?attrs a b = mk ?loc ?attrs (Pexp_newtype (a, b))
    let pack ?loc ?attrs a = mk ?loc ?attrs (Pexp_pack a)
    let open_ ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_open (a, b, c))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pexp_extension a)
    let unreachable ?loc ?attrs () = mk ?loc ?attrs Pexp_unreachable

    let case lhs ?guard rhs =
      {
       pc_lhs = lhs;
       pc_guard = guard;
       pc_rhs = rhs;
      }
  end

  module Mty = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {pmty_desc = d; pmty_loc = loc; pmty_attributes = attrs}
    let attr d a = {d with pmty_attributes = d.pmty_attributes @ [a]}

    let ident ?loc ?attrs a = mk ?loc ?attrs (Pmty_ident a)
    let alias ?loc ?attrs a = mk ?loc ?attrs (Pmty_alias a)
    let signature ?loc ?attrs a = mk ?loc ?attrs (Pmty_signature a)
    let functor_ ?loc ?attrs a b c = mk ?loc ?attrs (Pmty_functor (a, b, c))
    let with_ ?loc ?attrs a b = mk ?loc ?attrs (Pmty_with (a, b))
    let typeof_ ?loc ?attrs a = mk ?loc ?attrs (Pmty_typeof a)
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pmty_extension a)
  end

  module Mod = struct
  let mk ?(loc = !default_loc) ?(attrs = []) d =
    {pmod_desc = d; pmod_loc = loc; pmod_attributes = attrs}
    let attr d a = {d with pmod_attributes = d.pmod_attributes @ [a]}

    let ident ?loc ?attrs x = mk ?loc ?attrs (Pmod_ident x)
    let structure ?loc ?attrs x = mk ?loc ?attrs (Pmod_structure x)
    let functor_ ?loc ?attrs arg arg_ty body =
      mk ?loc ?attrs (Pmod_functor (arg, arg_ty, body))
    let apply ?loc ?attrs m1 m2 = mk ?loc ?attrs (Pmod_apply (m1, m2))
    let constraint_ ?loc ?attrs m mty = mk ?loc ?attrs (Pmod_constraint (m, mty))
    let unpack ?loc ?attrs e = mk ?loc ?attrs (Pmod_unpack e)
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pmod_extension a)
  end

  module Sig = struct
    let mk ?(loc = !default_loc) d = {psig_desc = d; psig_loc = loc}

    let value ?loc a = mk ?loc (Psig_value a)
    let type_ ?loc rec_flag a = mk ?loc (Psig_type (rec_flag, a))
    let type_extension ?loc a = mk ?loc (Psig_typext a)
    let exception_ ?loc a = mk ?loc (Psig_exception a)
    let module_ ?loc a = mk ?loc (Psig_module a)
    let rec_module ?loc a = mk ?loc (Psig_recmodule a)
    let modtype ?loc a = mk ?loc (Psig_modtype a)
    let open_ ?loc a = mk ?loc (Psig_open a)
    let include_ ?loc a = mk ?loc (Psig_include a)
    let class_ ?loc a = mk ?loc (Psig_class a)
    let class_type ?loc a = mk ?loc (Psig_class_type a)
    let extension ?loc ?(attrs = []) a = mk ?loc (Psig_extension (a, attrs))
    let attribute ?loc a = mk ?loc (Psig_attribute a)
    let text txt =
      let f_txt = List.filter (fun ds -> docstring_body ds <> "") txt in
      List.map
        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
        f_txt
  end

  module Str = struct
    let mk ?(loc = !default_loc) d = {pstr_desc = d; pstr_loc = loc}

    let eval ?loc ?(attrs = []) a = mk ?loc (Pstr_eval (a, attrs))
    let value ?loc a b = mk ?loc (Pstr_value (a, b))
    let primitive ?loc a = mk ?loc (Pstr_primitive a)
    let type_ ?loc rec_flag a = mk ?loc (Pstr_type (rec_flag, a))
    let type_extension ?loc a = mk ?loc (Pstr_typext a)
    let exception_ ?loc a = mk ?loc (Pstr_exception a)
    let module_ ?loc a = mk ?loc (Pstr_module a)
    let rec_module ?loc a = mk ?loc (Pstr_recmodule a)
    let modtype ?loc a = mk ?loc (Pstr_modtype a)
    let open_ ?loc a = mk ?loc (Pstr_open a)
    let class_ ?loc a = mk ?loc (Pstr_class a)
    let class_type ?loc a = mk ?loc (Pstr_class_type a)
    let include_ ?loc a = mk ?loc (Pstr_include a)
    let extension ?loc ?(attrs = []) a = mk ?loc (Pstr_extension (a, attrs))
    let attribute ?loc a = mk ?loc (Pstr_attribute a)
    let text txt =
      let f_txt = List.filter (fun ds -> docstring_body ds <> "") txt in
      List.map
        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
        f_txt
  end

  module Cl = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {
       pcl_desc = d;
       pcl_loc = loc;
       pcl_attributes = attrs;
      }
    let attr d a = {d with pcl_attributes = d.pcl_attributes @ [a]}

    let constr ?loc ?attrs a b = mk ?loc ?attrs (Pcl_constr (a, b))
    let structure ?loc ?attrs a = mk ?loc ?attrs (Pcl_structure a)
    let fun_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pcl_fun (a, b, c, d))
    let apply ?loc ?attrs a b = mk ?loc ?attrs (Pcl_apply (a, b))
    let let_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcl_let (a, b, c))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pcl_constraint (a, b))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pcl_extension a)
  end

  module Cty = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {
       pcty_desc = d;
       pcty_loc = loc;
       pcty_attributes = attrs;
      }
    let attr d a = {d with pcty_attributes = d.pcty_attributes @ [a]}

    let constr ?loc ?attrs a b = mk ?loc ?attrs (Pcty_constr (a, b))
    let signature ?loc ?attrs a = mk ?loc ?attrs (Pcty_signature a)
    let arrow ?loc ?attrs a b c = mk ?loc ?attrs (Pcty_arrow (a, b, c))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pcty_extension a)
  end

  module Ctf = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
             ?(docs = empty_docs) d =
      {
       pctf_desc = d;
       pctf_loc = loc;
       pctf_attributes = add_docs_attrs docs attrs;
      }

    let inherit_ ?loc ?attrs a = mk ?loc ?attrs (Pctf_inherit a)
    let val_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pctf_val (a, b, c, d))
    let method_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pctf_method (a, b, c, d))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pctf_constraint (a, b))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pctf_extension a)
    let attribute ?loc a = mk ?loc (Pctf_attribute a)
    let text txt =
     let f_txt = List.filter (fun ds -> docstring_body ds <> "") txt in
       List.map
        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
        f_txt

    let attr d a = {d with pctf_attributes = d.pctf_attributes @ [a]}

  end

  module Cf = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) d =
      {
       pcf_desc = d;
       pcf_loc = loc;
       pcf_attributes = add_docs_attrs docs attrs;
      }

    let inherit_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_inherit (a, b, c))
    let val_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_val (a, b, c))
    let method_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_method (a, b, c))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pcf_constraint (a, b))
    let initializer_ ?loc ?attrs a = mk ?loc ?attrs (Pcf_initializer a)
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pcf_extension a)
    let attribute ?loc a = mk ?loc (Pcf_attribute a)
    let text txt =
      let f_txt = List.filter (fun ds -> docstring_body ds <> "") txt in
      List.map
        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
        f_txt

    let virtual_ ct = Cfk_virtual ct
    let concrete o e = Cfk_concrete (o, e)

    let attr d a = {d with pcf_attributes = d.pcf_attributes @ [a]}

  end

  module Val = struct
    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
          ?(prim = []) name typ =
      {
       pval_name = name;
       pval_type = typ;
       pval_attributes = add_docs_attrs docs attrs;
       pval_loc = loc;
       pval_prim = prim;
      }
  end

  module Md = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = []) name typ =
      {
       pmd_name = name;
       pmd_type = typ;
       pmd_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pmd_loc = loc;
      }
  end

  module Mtd = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = []) ?typ name =
      {
       pmtd_name = name;
       pmtd_type = typ;
       pmtd_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pmtd_loc = loc;
      }
  end

  module Mb = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = []) name expr =
      {
       pmb_name = name;
       pmb_expr = expr;
       pmb_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pmb_loc = loc;
      }
  end

  module Opn = struct
    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
          ?(override = Fresh) lid =
      {
       popen_lid = lid;
       popen_override = override;
       popen_loc = loc;
       popen_attributes = add_docs_attrs docs attrs;
      }
  end

  module Incl = struct
    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs) mexpr =
      {
       pincl_mod = mexpr;
       pincl_loc = loc;
       pincl_attributes = add_docs_attrs docs attrs;
      }

  end

  module Vb = struct
    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
          ?(text = []) pat expr =
      {
       pvb_pat = pat;
       pvb_expr = expr;
       pvb_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pvb_loc = loc;
      }
  end

  module Ci = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = [])
          ?(virt = Concrete) ?(params = []) name expr =
      {
       pci_virt = virt;
       pci_params = params;
       pci_name = name;
       pci_expr = expr;
       pci_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pci_loc = loc;
      }
  end

  module Type = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = [])
        ?(params = [])
        ?(cstrs = [])
        ?(kind = Ptype_abstract)
        ?(priv = Public)
        ?manifest
        name =
      {
       ptype_name = name;
       ptype_params = params;
       ptype_cstrs = cstrs;
       ptype_kind = kind;
       ptype_private = priv;
       ptype_manifest = manifest;
       ptype_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       ptype_loc = loc;
      }

    let constructor ?(loc = !default_loc) ?(attrs = []) ?(info = empty_info)
          ?(args = Pcstr_tuple []) ?res name =
      {
       pcd_name = name;
       pcd_args = args;
       pcd_res = res;
       pcd_loc = loc;
       pcd_attributes = add_info_attrs info attrs;
      }

    let field ?(loc = !default_loc) ?(attrs = []) ?(info = empty_info)
          ?(mut = Immutable) name typ =
      {
       pld_name = name;
       pld_mutable = mut;
       pld_type = typ;
       pld_loc = loc;
       pld_attributes = add_info_attrs info attrs;
      }

  end

  (** Type extensions *)
  module Te = struct
    let mk ?(attrs = []) ?(docs = empty_docs)
          ?(params = []) ?(priv = Public) path constructors =
      {
       ptyext_path = path;
       ptyext_params = params;
       ptyext_constructors = constructors;
       ptyext_private = priv;
       ptyext_attributes = add_docs_attrs docs attrs;
      }

    let constructor ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(info = empty_info) name kind =
      {
       pext_name = name;
       pext_kind = kind;
       pext_loc = loc;
       pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);
      }

    let decl ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
               ?(info = empty_info) ?(args = Pcstr_tuple []) ?res name =
      {
       pext_name = name;
       pext_kind = Pext_decl(args, res);
       pext_loc = loc;
       pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);
      }

    let rebind ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(info = empty_info) name lid =
      {
       pext_name = name;
       pext_kind = Pext_rebind lid;
       pext_loc = loc;
       pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);
      }

  end

  module Csig = struct
    let mk self fields =
      {
       pcsig_self = self;
       pcsig_fields = fields;
      }
  end

  module Cstr = struct
    let mk self fields =
      {
       pcstr_self = self;
       pcstr_fields = fields;
      }
  end

end

module Ast_mapper : sig
  (** The interface of a -ppx rewriter

    A -ppx rewriter is a program that accepts a serialized abstract syntax
    tree and outputs another, possibly modified, abstract syntax tree.
    This module encapsulates the interface between the compiler and
    the -ppx rewriters, handling such details as the serialization format,
    forwarding of command-line flags, and storing state.

    {!mapper} allows to implement AST rewriting using open recursion.
    A typical mapper would be based on {!default_mapper}, a deep
    identity mapper, and will fall back on it for handling the syntax it
    does not modify. For example:

    {[
  open Asttypes
  open Parsetree
  open Ast_mapper

  let test_mapper argv =
    { default_mapper with
      expr = fun mapper expr ->
        match expr with
        | { pexp_desc = Pexp_extension ({ txt = "test" }, PStr [])} ->
          Ast_helper.Exp.constant (Const_int 42)
        | other -> default_mapper.expr mapper other; }

  let () =
    register "ppx_test" test_mapper]}

    This -ppx rewriter, which replaces [[%test]] in expressions with
    the constant [42], can be compiled using
    [ocamlc -o ppx_test -I +compiler-libs ocamlcommon.cma ppx_test.ml].

    *)

  open Parsetree

  (** {2 A generic Parsetree mapper} *)

  type mapper (*IF_CURRENT = Ast_mapper.mapper*) = {
    attribute: mapper -> attribute -> attribute;
    attributes: mapper -> attribute list -> attribute list;
    case: mapper -> case -> case;
    cases: mapper -> case list -> case list;
    class_declaration: mapper -> class_declaration -> class_declaration;
    class_description: mapper -> class_description -> class_description;
    class_expr: mapper -> class_expr -> class_expr;
    class_field: mapper -> class_field -> class_field;
    class_signature: mapper -> class_signature -> class_signature;
    class_structure: mapper -> class_structure -> class_structure;
    class_type: mapper -> class_type -> class_type;
    class_type_declaration: mapper -> class_type_declaration
                            -> class_type_declaration;
    class_type_field: mapper -> class_type_field -> class_type_field;
    constructor_declaration: mapper -> constructor_declaration
                             -> constructor_declaration;
    expr: mapper -> expression -> expression;
    extension: mapper -> extension -> extension;
    extension_constructor: mapper -> extension_constructor
                           -> extension_constructor;
    include_declaration: mapper -> include_declaration -> include_declaration;
    include_description: mapper -> include_description -> include_description;
    label_declaration: mapper -> label_declaration -> label_declaration;
    location: mapper -> Location.t -> Location.t;
    module_binding: mapper -> module_binding -> module_binding;
    module_declaration: mapper -> module_declaration -> module_declaration;
    module_expr: mapper -> module_expr -> module_expr;
    module_type: mapper -> module_type -> module_type;
    module_type_declaration: mapper -> module_type_declaration
                             -> module_type_declaration;
    open_description: mapper -> open_description -> open_description;
    pat: mapper -> pattern -> pattern;
    payload: mapper -> payload -> payload;
    signature: mapper -> signature -> signature;
    signature_item: mapper -> signature_item -> signature_item;
    structure: mapper -> structure -> structure;
    structure_item: mapper -> structure_item -> structure_item;
    typ: mapper -> core_type -> core_type;
    type_declaration: mapper -> type_declaration -> type_declaration;
    type_extension: mapper -> type_extension -> type_extension;
    type_kind: mapper -> type_kind -> type_kind;
    value_binding: mapper -> value_binding -> value_binding;
    value_description: mapper -> value_description -> value_description;
    with_constraint: mapper -> with_constraint -> with_constraint;
  }
  (** A mapper record implements one "method" per syntactic category,
      using an open recursion style: each method takes as its first
      argument the mapper to be applied to children in the syntax
      tree. *)

  val default_mapper: mapper
  (** A default mapper, which implements a "deep identity" mapping. *)

  (** {2 Convenience functions to write mappers} *)

  val map_opt: ('a -> 'b) -> 'a option -> 'b option

  val extension_of_error: Location.error -> extension
  (** Encode an error into an 'ocaml.error' extension node which can be
      inserted in a generated Parsetree.  The compiler will be
      responsible for reporting the error. *)

  val attribute_of_warning: Location.t -> string -> attribute
  (** Encode a warning message into an 'ocaml.ppwarning' attribute which can be
      inserted in a generated Parsetree.  The compiler will be
      responsible for reporting the warning. *)

end = struct
  (* A generic Parsetree mapping class *)

  (*
  [@@@ocaml.warning "+9"]
    (* Ensure that record patterns don't miss any field. *)
  *)


  open Parsetree
  open Ast_helper
  open Location

  type mapper (*IF_CURRENT = Ast_mapper.mapper*) = {
    attribute: mapper -> attribute -> attribute;
    attributes: mapper -> attribute list -> attribute list;
    case: mapper -> case -> case;
    cases: mapper -> case list -> case list;
    class_declaration: mapper -> class_declaration -> class_declaration;
    class_description: mapper -> class_description -> class_description;
    class_expr: mapper -> class_expr -> class_expr;
    class_field: mapper -> class_field -> class_field;
    class_signature: mapper -> class_signature -> class_signature;
    class_structure: mapper -> class_structure -> class_structure;
    class_type: mapper -> class_type -> class_type;
    class_type_declaration: mapper -> class_type_declaration
                            -> class_type_declaration;
    class_type_field: mapper -> class_type_field -> class_type_field;
    constructor_declaration: mapper -> constructor_declaration
                             -> constructor_declaration;
    expr: mapper -> expression -> expression;
    extension: mapper -> extension -> extension;
    extension_constructor: mapper -> extension_constructor
                           -> extension_constructor;
    include_declaration: mapper -> include_declaration -> include_declaration;
    include_description: mapper -> include_description -> include_description;
    label_declaration: mapper -> label_declaration -> label_declaration;
    location: mapper -> Location.t -> Location.t;
    module_binding: mapper -> module_binding -> module_binding;
    module_declaration: mapper -> module_declaration -> module_declaration;
    module_expr: mapper -> module_expr -> module_expr;
    module_type: mapper -> module_type -> module_type;
    module_type_declaration: mapper -> module_type_declaration
                             -> module_type_declaration;
    open_description: mapper -> open_description -> open_description;
    pat: mapper -> pattern -> pattern;
    payload: mapper -> payload -> payload;
    signature: mapper -> signature -> signature;
    signature_item: mapper -> signature_item -> signature_item;
    structure: mapper -> structure -> structure;
    structure_item: mapper -> structure_item -> structure_item;
    typ: mapper -> core_type -> core_type;
    type_declaration: mapper -> type_declaration -> type_declaration;
    type_extension: mapper -> type_extension -> type_extension;
    type_kind: mapper -> type_kind -> type_kind;
    value_binding: mapper -> value_binding -> value_binding;
    value_description: mapper -> value_description -> value_description;
    with_constraint: mapper -> with_constraint -> with_constraint;
  }

  let map_fst f (x, y) = (f x, y)
  let map_snd f (x, y) = (x, f y)
  let map_tuple f1 f2 (x, y) = (f1 x, f2 y)
  let map_tuple3 f1 f2 f3 (x, y, z) = (f1 x, f2 y, f3 z)
  let map_opt f = function None -> None | Some x -> Some (f x)

  let map_loc sub {loc; txt} = {loc = sub.location sub loc; txt}

  module T = struct
    (* Type expressions for the core language *)

    let row_field sub = function
      | Rtag (l, attrs, b, tl) ->
          Rtag (l, sub.attributes sub attrs, b, List.map (sub.typ sub) tl)
      | Rinherit t -> Rinherit (sub.typ sub t)

    let map sub {ptyp_desc = desc; ptyp_loc = loc; ptyp_attributes = attrs} =
      let open Typ in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Ptyp_any -> any ~loc ~attrs ()
      | Ptyp_var s -> var ~loc ~attrs s
      | Ptyp_arrow (lab, t1, t2) ->
          arrow ~loc ~attrs lab (sub.typ sub t1) (sub.typ sub t2)
      | Ptyp_tuple tyl -> tuple ~loc ~attrs (List.map (sub.typ sub) tyl)
      | Ptyp_constr (lid, tl) ->
          constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tl)
      | Ptyp_object (l, o) ->
          let f (s, a, t) = (s, sub.attributes sub a, sub.typ sub t) in
          object_ ~loc ~attrs (List.map f l) o
      | Ptyp_class (lid, tl) ->
          class_ ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tl)
      | Ptyp_alias (t, s) -> alias ~loc ~attrs (sub.typ sub t) s
      | Ptyp_variant (rl, b, ll) ->
          variant ~loc ~attrs (List.map (row_field sub) rl) b ll
      | Ptyp_poly (sl, t) -> poly ~loc ~attrs sl (sub.typ sub t)
      | Ptyp_package (lid, l) ->
          package ~loc ~attrs (map_loc sub lid)
            (List.map (map_tuple (map_loc sub) (sub.typ sub)) l)
      | Ptyp_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_type_declaration sub
        {ptype_name; ptype_params; ptype_cstrs;
         ptype_kind;
         ptype_private;
         ptype_manifest;
         ptype_attributes;
         ptype_loc} =
      Type.mk (map_loc sub ptype_name)
        ~params:(List.map (map_fst (sub.typ sub)) ptype_params)
        ~priv:ptype_private
        ~cstrs:(List.map
                  (map_tuple3 (sub.typ sub) (sub.typ sub) (sub.location sub))
                  ptype_cstrs)
        ~kind:(sub.type_kind sub ptype_kind)
        ?manifest:(map_opt (sub.typ sub) ptype_manifest)
        ~loc:(sub.location sub ptype_loc)
        ~attrs:(sub.attributes sub ptype_attributes)

    let map_type_kind sub = function
      | Ptype_abstract -> Ptype_abstract
      | Ptype_variant l ->
          Ptype_variant (List.map (sub.constructor_declaration sub) l)
      | Ptype_record l -> Ptype_record (List.map (sub.label_declaration sub) l)
      | Ptype_open -> Ptype_open

    let map_constructor_arguments sub = function
      | Pcstr_tuple l -> Pcstr_tuple (List.map (sub.typ sub) l)
      | Pcstr_record l ->
          Pcstr_record (List.map (sub.label_declaration sub) l)

    let map_type_extension sub
        {ptyext_path; ptyext_params;
         ptyext_constructors;
         ptyext_private;
         ptyext_attributes} =
      Te.mk
        (map_loc sub ptyext_path)
        (List.map (sub.extension_constructor sub) ptyext_constructors)
        ~params:(List.map (map_fst (sub.typ sub)) ptyext_params)
        ~priv:ptyext_private
        ~attrs:(sub.attributes sub ptyext_attributes)

    let map_extension_constructor_kind sub = function
        Pext_decl(ctl, cto) ->
          Pext_decl(map_constructor_arguments sub ctl, map_opt (sub.typ sub) cto)
      | Pext_rebind li ->
          Pext_rebind (map_loc sub li)

    let map_extension_constructor sub
        {pext_name;
         pext_kind;
         pext_loc;
         pext_attributes} =
      Te.constructor
        (map_loc sub pext_name)
        (map_extension_constructor_kind sub pext_kind)
        ~loc:(sub.location sub pext_loc)
        ~attrs:(sub.attributes sub pext_attributes)

  end

  module CT = struct
    (* Type expressions for the class language *)

    let map sub {pcty_loc = loc; pcty_desc = desc; pcty_attributes = attrs} =
      let open Cty in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pcty_constr (lid, tys) ->
          constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tys)
      | Pcty_signature x -> signature ~loc ~attrs (sub.class_signature sub x)
      | Pcty_arrow (lab, t, ct) ->
          arrow ~loc ~attrs lab (sub.typ sub t) (sub.class_type sub ct)
      | Pcty_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_field sub {pctf_desc = desc; pctf_loc = loc; pctf_attributes = attrs}
      =
      let open Ctf in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pctf_inherit ct -> inherit_ ~loc ~attrs (sub.class_type sub ct)
      | Pctf_val (s, m, v, t) -> val_ ~loc ~attrs s m v (sub.typ sub t)
      | Pctf_method (s, p, v, t) -> method_ ~loc ~attrs s p v (sub.typ sub t)
      | Pctf_constraint (t1, t2) ->
          constraint_ ~loc ~attrs (sub.typ sub t1) (sub.typ sub t2)
      | Pctf_attribute x -> attribute ~loc (sub.attribute sub x)
      | Pctf_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_signature sub {pcsig_self; pcsig_fields} =
      Csig.mk
        (sub.typ sub pcsig_self)
        (List.map (sub.class_type_field sub) pcsig_fields)
  end

  module MT = struct
    (* Type expressions for the module language *)

    let map sub {pmty_desc = desc; pmty_loc = loc; pmty_attributes = attrs} =
      let open Mty in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pmty_ident s -> ident ~loc ~attrs (map_loc sub s)
      | Pmty_alias s -> alias ~loc ~attrs (map_loc sub s)
      | Pmty_signature sg -> signature ~loc ~attrs (sub.signature sub sg)
      | Pmty_functor (s, mt1, mt2) ->
          functor_ ~loc ~attrs (map_loc sub s)
            (Misc.may_map (sub.module_type sub) mt1)
            (sub.module_type sub mt2)
      | Pmty_with (mt, l) ->
          with_ ~loc ~attrs (sub.module_type sub mt)
            (List.map (sub.with_constraint sub) l)
      | Pmty_typeof me -> typeof_ ~loc ~attrs (sub.module_expr sub me)
      | Pmty_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_with_constraint sub = function
      | Pwith_type (lid, d) ->
          Pwith_type (map_loc sub lid, sub.type_declaration sub d)
      | Pwith_module (lid, lid2) ->
          Pwith_module (map_loc sub lid, map_loc sub lid2)
      | Pwith_typesubst d -> Pwith_typesubst (sub.type_declaration sub d)
      | Pwith_modsubst (s, lid) ->
          Pwith_modsubst (map_loc sub s, map_loc sub lid)

    let map_signature_item sub {psig_desc = desc; psig_loc = loc} =
      let open Sig in
      let loc = sub.location sub loc in
      match desc with
      | Psig_value vd -> value ~loc (sub.value_description sub vd)
      | Psig_type (rf, l) -> type_ ~loc rf (List.map (sub.type_declaration sub) l)
      | Psig_typext te -> type_extension ~loc (sub.type_extension sub te)
      | Psig_exception ed -> exception_ ~loc (sub.extension_constructor sub ed)
      | Psig_module x -> module_ ~loc (sub.module_declaration sub x)
      | Psig_recmodule l ->
          rec_module ~loc (List.map (sub.module_declaration sub) l)
      | Psig_modtype x -> modtype ~loc (sub.module_type_declaration sub x)
      | Psig_open x -> open_ ~loc (sub.open_description sub x)
      | Psig_include x -> include_ ~loc (sub.include_description sub x)
      | Psig_class l -> class_ ~loc (List.map (sub.class_description sub) l)
      | Psig_class_type l ->
          class_type ~loc (List.map (sub.class_type_declaration sub) l)
      | Psig_extension (x, attrs) ->
          extension ~loc (sub.extension sub x) ~attrs:(sub.attributes sub attrs)
      | Psig_attribute x -> attribute ~loc (sub.attribute sub x)
  end


  module M = struct
    (* Value expressions for the module language *)

    let map sub {pmod_loc = loc; pmod_desc = desc; pmod_attributes = attrs} =
      let open Mod in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pmod_ident x -> ident ~loc ~attrs (map_loc sub x)
      | Pmod_structure str -> structure ~loc ~attrs (sub.structure sub str)
      | Pmod_functor (arg, arg_ty, body) ->
          functor_ ~loc ~attrs (map_loc sub arg)
            (Misc.may_map (sub.module_type sub) arg_ty)
            (sub.module_expr sub body)
      | Pmod_apply (m1, m2) ->
          apply ~loc ~attrs (sub.module_expr sub m1) (sub.module_expr sub m2)
      | Pmod_constraint (m, mty) ->
          constraint_ ~loc ~attrs (sub.module_expr sub m)
                      (sub.module_type sub mty)
      | Pmod_unpack e -> unpack ~loc ~attrs (sub.expr sub e)
      | Pmod_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_structure_item sub {pstr_loc = loc; pstr_desc = desc} =
      let open Str in
      let loc = sub.location sub loc in
      match desc with
      | Pstr_eval (x, attrs) ->
          eval ~loc ~attrs:(sub.attributes sub attrs) (sub.expr sub x)
      | Pstr_value (r, vbs) -> value ~loc r (List.map (sub.value_binding sub) vbs)
      | Pstr_primitive vd -> primitive ~loc (sub.value_description sub vd)
      | Pstr_type (rf, l) -> type_ ~loc rf (List.map (sub.type_declaration sub) l)
      | Pstr_typext te -> type_extension ~loc (sub.type_extension sub te)
      | Pstr_exception ed -> exception_ ~loc (sub.extension_constructor sub ed)
      | Pstr_module x -> module_ ~loc (sub.module_binding sub x)
      | Pstr_recmodule l -> rec_module ~loc (List.map (sub.module_binding sub) l)
      | Pstr_modtype x -> modtype ~loc (sub.module_type_declaration sub x)
      | Pstr_open x -> open_ ~loc (sub.open_description sub x)
      | Pstr_class l -> class_ ~loc (List.map (sub.class_declaration sub) l)
      | Pstr_class_type l ->
          class_type ~loc (List.map (sub.class_type_declaration sub) l)
      | Pstr_include x -> include_ ~loc (sub.include_declaration sub x)
      | Pstr_extension (x, attrs) ->
          extension ~loc (sub.extension sub x) ~attrs:(sub.attributes sub attrs)
      | Pstr_attribute x -> attribute ~loc (sub.attribute sub x)
  end

  module E = struct
    (* Value expressions for the core language *)

    let map sub {pexp_loc = loc; pexp_desc = desc; pexp_attributes = attrs} =
      let open Exp in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pexp_ident x -> ident ~loc ~attrs (map_loc sub x)
      | Pexp_constant x -> constant ~loc ~attrs x
      | Pexp_let (r, vbs, e) ->
          let_ ~loc ~attrs r (List.map (sub.value_binding sub) vbs)
            (sub.expr sub e)
      | Pexp_fun (lab, def, p, e) ->
          fun_ ~loc ~attrs lab (map_opt (sub.expr sub) def) (sub.pat sub p)
            (sub.expr sub e)
      | Pexp_function pel -> function_ ~loc ~attrs (sub.cases sub pel)
      | Pexp_apply (e, l) ->
          apply ~loc ~attrs (sub.expr sub e) (List.map (map_snd (sub.expr sub)) l)
      | Pexp_match (e, pel) ->
          match_ ~loc ~attrs (sub.expr sub e) (sub.cases sub pel)
      | Pexp_try (e, pel) -> try_ ~loc ~attrs (sub.expr sub e) (sub.cases sub pel)
      | Pexp_tuple el -> tuple ~loc ~attrs (List.map (sub.expr sub) el)
      | Pexp_construct (lid, arg) ->
          construct ~loc ~attrs (map_loc sub lid) (map_opt (sub.expr sub) arg)
      | Pexp_variant (lab, eo) ->
          variant ~loc ~attrs lab (map_opt (sub.expr sub) eo)
      | Pexp_record (l, eo) ->
          record ~loc ~attrs (List.map (map_tuple (map_loc sub) (sub.expr sub)) l)
            (map_opt (sub.expr sub) eo)
      | Pexp_field (e, lid) ->
          field ~loc ~attrs (sub.expr sub e) (map_loc sub lid)
      | Pexp_setfield (e1, lid, e2) ->
          setfield ~loc ~attrs (sub.expr sub e1) (map_loc sub lid)
            (sub.expr sub e2)
      | Pexp_array el -> array ~loc ~attrs (List.map (sub.expr sub) el)
      | Pexp_ifthenelse (e1, e2, e3) ->
          ifthenelse ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)
            (map_opt (sub.expr sub) e3)
      | Pexp_sequence (e1, e2) ->
          sequence ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)
      | Pexp_while (e1, e2) ->
          while_ ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)
      | Pexp_for (p, e1, e2, d, e3) ->
          for_ ~loc ~attrs (sub.pat sub p) (sub.expr sub e1) (sub.expr sub e2) d
            (sub.expr sub e3)
      | Pexp_coerce (e, t1, t2) ->
          coerce ~loc ~attrs (sub.expr sub e) (map_opt (sub.typ sub) t1)
            (sub.typ sub t2)
      | Pexp_constraint (e, t) ->
          constraint_ ~loc ~attrs (sub.expr sub e) (sub.typ sub t)
      | Pexp_send (e, s) -> send ~loc ~attrs (sub.expr sub e) s
      | Pexp_new lid -> new_ ~loc ~attrs (map_loc sub lid)
      | Pexp_setinstvar (s, e) ->
          setinstvar ~loc ~attrs (map_loc sub s) (sub.expr sub e)
      | Pexp_override sel ->
          override ~loc ~attrs
            (List.map (map_tuple (map_loc sub) (sub.expr sub)) sel)
      | Pexp_letmodule (s, me, e) ->
          letmodule ~loc ~attrs (map_loc sub s) (sub.module_expr sub me)
            (sub.expr sub e)
      | Pexp_letexception (cd, e) ->
          letexception ~loc ~attrs
            (sub.extension_constructor sub cd)
            (sub.expr sub e)
      | Pexp_assert e -> assert_ ~loc ~attrs (sub.expr sub e)
      | Pexp_lazy e -> lazy_ ~loc ~attrs (sub.expr sub e)
      | Pexp_poly (e, t) ->
          poly ~loc ~attrs (sub.expr sub e) (map_opt (sub.typ sub) t)
      | Pexp_object cls -> object_ ~loc ~attrs (sub.class_structure sub cls)
      | Pexp_newtype (s, e) -> newtype ~loc ~attrs s (sub.expr sub e)
      | Pexp_pack me -> pack ~loc ~attrs (sub.module_expr sub me)
      | Pexp_open (ovf, lid, e) ->
          open_ ~loc ~attrs ovf (map_loc sub lid) (sub.expr sub e)
      | Pexp_extension x -> extension ~loc ~attrs (sub.extension sub x)
      | Pexp_unreachable -> unreachable ~loc ~attrs ()
  end

  module P = struct
    (* Patterns *)

    let map sub {ppat_desc = desc; ppat_loc = loc; ppat_attributes = attrs} =
      let open Pat in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Ppat_any -> any ~loc ~attrs ()
      | Ppat_var s -> var ~loc ~attrs (map_loc sub s)
      | Ppat_alias (p, s) -> alias ~loc ~attrs (sub.pat sub p) (map_loc sub s)
      | Ppat_constant c -> constant ~loc ~attrs c
      | Ppat_interval (c1, c2) -> interval ~loc ~attrs c1 c2
      | Ppat_tuple pl -> tuple ~loc ~attrs (List.map (sub.pat sub) pl)
      | Ppat_construct (l, p) ->
          construct ~loc ~attrs (map_loc sub l) (map_opt (sub.pat sub) p)
      | Ppat_variant (l, p) -> variant ~loc ~attrs l (map_opt (sub.pat sub) p)
      | Ppat_record (lpl, cf) ->
          record ~loc ~attrs
                 (List.map (map_tuple (map_loc sub) (sub.pat sub)) lpl) cf
      | Ppat_array pl -> array ~loc ~attrs (List.map (sub.pat sub) pl)
      | Ppat_or (p1, p2) -> or_ ~loc ~attrs (sub.pat sub p1) (sub.pat sub p2)
      | Ppat_constraint (p, t) ->
          constraint_ ~loc ~attrs (sub.pat sub p) (sub.typ sub t)
      | Ppat_type s -> type_ ~loc ~attrs (map_loc sub s)
      | Ppat_lazy p -> lazy_ ~loc ~attrs (sub.pat sub p)
      | Ppat_unpack s -> unpack ~loc ~attrs (map_loc sub s)
      | Ppat_open (lid,p) -> open_ ~loc ~attrs (map_loc sub lid) (sub.pat sub p)
      | Ppat_exception p -> exception_ ~loc ~attrs (sub.pat sub p)
      | Ppat_extension x -> extension ~loc ~attrs (sub.extension sub x)
  end

  module CE = struct
    (* Value expressions for the class language *)

    let map sub {pcl_loc = loc; pcl_desc = desc; pcl_attributes = attrs} =
      let open Cl in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pcl_constr (lid, tys) ->
          constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tys)
      | Pcl_structure s ->
          structure ~loc ~attrs (sub.class_structure sub s)
      | Pcl_fun (lab, e, p, ce) ->
          fun_ ~loc ~attrs lab
            (map_opt (sub.expr sub) e)
            (sub.pat sub p)
            (sub.class_expr sub ce)
      | Pcl_apply (ce, l) ->
          apply ~loc ~attrs (sub.class_expr sub ce)
            (List.map (map_snd (sub.expr sub)) l)
      | Pcl_let (r, vbs, ce) ->
          let_ ~loc ~attrs r (List.map (sub.value_binding sub) vbs)
            (sub.class_expr sub ce)
      | Pcl_constraint (ce, ct) ->
          constraint_ ~loc ~attrs (sub.class_expr sub ce) (sub.class_type sub ct)
      | Pcl_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_kind sub = function
      | Cfk_concrete (o, e) -> Cfk_concrete (o, sub.expr sub e)
      | Cfk_virtual t -> Cfk_virtual (sub.typ sub t)

    let map_field sub {pcf_desc = desc; pcf_loc = loc; pcf_attributes = attrs} =
      let open Cf in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pcf_inherit (o, ce, s) -> inherit_ ~loc ~attrs o (sub.class_expr sub ce) s
      | Pcf_val (s, m, k) -> val_ ~loc ~attrs (map_loc sub s) m (map_kind sub k)
      | Pcf_method (s, p, k) ->
          method_ ~loc ~attrs (map_loc sub s) p (map_kind sub k)
      | Pcf_constraint (t1, t2) ->
          constraint_ ~loc ~attrs (sub.typ sub t1) (sub.typ sub t2)
      | Pcf_initializer e -> initializer_ ~loc ~attrs (sub.expr sub e)
      | Pcf_attribute x -> attribute ~loc (sub.attribute sub x)
      | Pcf_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_structure sub {pcstr_self; pcstr_fields} =
      {
        pcstr_self = sub.pat sub pcstr_self;
        pcstr_fields = List.map (sub.class_field sub) pcstr_fields;
      }

    let class_infos sub f {pci_virt; pci_params = pl; pci_name; pci_expr;
                           pci_loc; pci_attributes} =
      Ci.mk
       ~virt:pci_virt
       ~params:(List.map (map_fst (sub.typ sub)) pl)
        (map_loc sub pci_name)
        (f pci_expr)
        ~loc:(sub.location sub pci_loc)
        ~attrs:(sub.attributes sub pci_attributes)
  end

  (* Now, a generic AST mapper, to be extended to cover all kinds and
     cases of the OCaml grammar.  The default behavior of the mapper is
     the identity. *)

  let default_mapper =
    {
      structure = (fun this l -> List.map (this.structure_item this) l);
      structure_item = M.map_structure_item;
      module_expr = M.map;
      signature = (fun this l -> List.map (this.signature_item this) l);
      signature_item = MT.map_signature_item;
      module_type = MT.map;
      with_constraint = MT.map_with_constraint;
      class_declaration =
        (fun this -> CE.class_infos this (this.class_expr this));
      class_expr = CE.map;
      class_field = CE.map_field;
      class_structure = CE.map_structure;
      class_type = CT.map;
      class_type_field = CT.map_field;
      class_signature = CT.map_signature;
      class_type_declaration =
        (fun this -> CE.class_infos this (this.class_type this));
      class_description =
        (fun this -> CE.class_infos this (this.class_type this));
      type_declaration = T.map_type_declaration;
      type_kind = T.map_type_kind;
      typ = T.map;
      type_extension = T.map_type_extension;
      extension_constructor = T.map_extension_constructor;
      value_description =
        (fun this {pval_name; pval_type; pval_prim; pval_loc;
                   pval_attributes} ->
          Val.mk
            (map_loc this pval_name)
            (this.typ this pval_type)
            ~attrs:(this.attributes this pval_attributes)
            ~loc:(this.location this pval_loc)
            ~prim:pval_prim
        );

      pat = P.map;
      expr = E.map;

      module_declaration =
        (fun this {pmd_name; pmd_type; pmd_attributes; pmd_loc} ->
           Md.mk
             (map_loc this pmd_name)
             (this.module_type this pmd_type)
             ~attrs:(this.attributes this pmd_attributes)
             ~loc:(this.location this pmd_loc)
        );

      module_type_declaration =
        (fun this {pmtd_name; pmtd_type; pmtd_attributes; pmtd_loc} ->
           Mtd.mk
             (map_loc this pmtd_name)
             ?typ:(map_opt (this.module_type this) pmtd_type)
             ~attrs:(this.attributes this pmtd_attributes)
             ~loc:(this.location this pmtd_loc)
        );

      module_binding =
        (fun this {pmb_name; pmb_expr; pmb_attributes; pmb_loc} ->
           Mb.mk (map_loc this pmb_name) (this.module_expr this pmb_expr)
             ~attrs:(this.attributes this pmb_attributes)
             ~loc:(this.location this pmb_loc)
        );


      open_description =
        (fun this {popen_lid; popen_override; popen_attributes; popen_loc} ->
           Opn.mk (map_loc this popen_lid)
             ~override:popen_override
             ~loc:(this.location this popen_loc)
             ~attrs:(this.attributes this popen_attributes)
        );


      include_description =
        (fun this {pincl_mod; pincl_attributes; pincl_loc} ->
           Incl.mk (this.module_type this pincl_mod)
             ~loc:(this.location this pincl_loc)
             ~attrs:(this.attributes this pincl_attributes)
        );

      include_declaration =
        (fun this {pincl_mod; pincl_attributes; pincl_loc} ->
           Incl.mk (this.module_expr this pincl_mod)
             ~loc:(this.location this pincl_loc)
             ~attrs:(this.attributes this pincl_attributes)
        );


      value_binding =
        (fun this {pvb_pat; pvb_expr; pvb_attributes; pvb_loc} ->
           Vb.mk
             (this.pat this pvb_pat)
             (this.expr this pvb_expr)
             ~loc:(this.location this pvb_loc)
             ~attrs:(this.attributes this pvb_attributes)
        );


      constructor_declaration =
        (fun this {pcd_name; pcd_args; pcd_res; pcd_loc; pcd_attributes} ->
          Type.constructor
            (map_loc this pcd_name)
            ~args:(T.map_constructor_arguments this pcd_args)
            ?res:(map_opt (this.typ this) pcd_res)
            ~loc:(this.location this pcd_loc)
            ~attrs:(this.attributes this pcd_attributes)
        );

      label_declaration =
        (fun this {pld_name; pld_type; pld_loc; pld_mutable; pld_attributes} ->
           Type.field
             (map_loc this pld_name)
             (this.typ this pld_type)
             ~mut:pld_mutable
             ~loc:(this.location this pld_loc)
             ~attrs:(this.attributes this pld_attributes)
        );

      cases = (fun this l -> List.map (this.case this) l);
      case =
        (fun this {pc_lhs; pc_guard; pc_rhs} ->
           {
             pc_lhs = this.pat this pc_lhs;
             pc_guard = map_opt (this.expr this) pc_guard;
             pc_rhs = this.expr this pc_rhs;
           }
        );



      location = (fun _this l -> l);

      extension = (fun this (s, e) -> (map_loc this s, this.payload this e));
      attribute = (fun this (s, e) -> (map_loc this s, this.payload this e));
      attributes = (fun this l -> List.map (this.attribute this) l);
      payload =
        (fun this -> function
           | PStr x -> PStr (this.structure this x)
           | PSig x -> PSig (this.signature this x)
           | PTyp x -> PTyp (this.typ this x)
           | PPat (x, g) -> PPat (this.pat this x, map_opt (this.expr this) g)
        );
    }

  let rec extension_of_error {loc; msg; if_highlight; sub} =
    { loc; txt = "ocaml.error" },
    PStr ([Str.eval (Exp.constant (Pconst_string (msg, None)));
           Str.eval (Exp.constant (Pconst_string (if_highlight, None)))] @
          (List.map (fun ext -> Str.extension (extension_of_error ext)) sub))

  let attribute_of_warning loc s =
    { loc; txt = "ocaml.ppwarning" },
    PStr ([Str.eval ~loc (Exp.constant (Pconst_string (s, None)))])

end

module Outcometree = struct
  (* Module [Outcometree]: results displayed by the toplevel *)

  (* These types represent messages that the toplevel displays as normal
     results or errors. The real displaying is customisable using the hooks:
        [Toploop.print_out_value]
        [Toploop.print_out_type]
        [Toploop.print_out_sig_item]
        [Toploop.print_out_phrase] *)

  type out_ident (*IF_CURRENT = Outcometree.out_ident *) =
    | Oide_apply of out_ident * out_ident
    | Oide_dot of out_ident * string
    | Oide_ident of string

  type out_attribute (*IF_CURRENT = Outcometree.out_attribute *) =
    { oattr_name: string }

  type out_value (*IF_CURRENT = Outcometree.out_value *) =
    | Oval_array of out_value list
    | Oval_char of char
    | Oval_constr of out_ident * out_value list
    | Oval_ellipsis
    | Oval_float of float
    | Oval_int of int
    | Oval_int32 of int32
    | Oval_int64 of int64
    | Oval_nativeint of nativeint
    | Oval_list of out_value list
    | Oval_printer of (Format.formatter -> unit)
    | Oval_record of (out_ident * out_value) list
    | Oval_string of string
    | Oval_stuff of string
    | Oval_tuple of out_value list
    | Oval_variant of string * out_value option

  type out_type (*IF_CURRENT = Outcometree.out_type *) =
    | Otyp_abstract
    | Otyp_open
    | Otyp_alias of out_type * string
    | Otyp_arrow of string * out_type * out_type
    | Otyp_class of bool * out_ident * out_type list
    | Otyp_constr of out_ident * out_type list
    | Otyp_manifest of out_type * out_type
    | Otyp_object of (string * out_type) list * bool option
    | Otyp_record of (string * bool * out_type) list
    | Otyp_stuff of string
    | Otyp_sum of (string * out_type list * out_type option) list
    | Otyp_tuple of out_type list
    | Otyp_var of bool * string
    | Otyp_variant of
        bool * out_variant * bool * (string list) option
    | Otyp_poly of string list * out_type
    | Otyp_module of string * string list * out_type list
    | Otyp_attribute of out_type * out_attribute

  and out_variant (*IF_CURRENT = Outcometree.out_variant *) =
    | Ovar_fields of (string * bool * out_type list) list
    | Ovar_name of out_ident * out_type list

  type out_class_type (*IF_CURRENT = Outcometree.out_class_type *) =
    | Octy_constr of out_ident * out_type list
    | Octy_arrow of string * out_type * out_class_type
    | Octy_signature of out_type option * out_class_sig_item list
  and out_class_sig_item (*IF_CURRENT = Outcometree.out_class_sig_item *) =
    | Ocsg_constraint of out_type * out_type
    | Ocsg_method of string * bool * bool * out_type
    | Ocsg_value of string * bool * bool * out_type

  type out_module_type (*IF_CURRENT = Outcometree.out_module_type *) =
    | Omty_abstract
    | Omty_functor of string * out_module_type option * out_module_type
    | Omty_ident of out_ident
    | Omty_signature of out_sig_item list
    | Omty_alias of out_ident
  and out_sig_item (*IF_CURRENT = Outcometree.out_sig_item *) =
    | Osig_class of
        bool * string * (string * (bool * bool)) list * out_class_type *
          out_rec_status
    | Osig_class_type of
        bool * string * (string * (bool * bool)) list * out_class_type *
          out_rec_status
    | Osig_typext of out_extension_constructor * out_ext_status
    | Osig_modtype of string * out_module_type
    | Osig_module of string * out_module_type * out_rec_status
    | Osig_type of out_type_decl * out_rec_status
    | Osig_value of out_val_decl
    | Osig_ellipsis
  and out_type_decl (*IF_CURRENT = Outcometree.out_type_decl *) =
    { otype_name: string;
      otype_params: (string * (bool * bool)) list;
      otype_type: out_type;
      otype_private: Asttypes.private_flag;
      otype_immediate: bool;
      otype_unboxed: bool;
      otype_cstrs: (out_type * out_type) list }
  and out_extension_constructor (*IF_CURRENT = Outcometree.out_extension_constructor *) =
    { oext_name: string;
      oext_type_name: string;
      oext_type_params: string list;
      oext_args: out_type list;
      oext_ret_type: out_type option;
      oext_private: Asttypes.private_flag }
  and out_type_extension (*IF_CURRENT = Outcometree.out_type_extension *) =
    { otyext_name: string;
      otyext_params: string list;
      otyext_constructors: (string * out_type list * out_type option) list;
      otyext_private: Asttypes.private_flag }
  and out_val_decl (*IF_CURRENT = Outcometree.out_val_decl *) =
    { oval_name: string;
      oval_type: out_type;
      oval_prims: string list;
      oval_attributes: out_attribute list }
  and out_rec_status (*IF_CURRENT = Outcometree.out_rec_status *) =
    | Orec_not
    | Orec_first
    | Orec_next
  and out_ext_status (*IF_CURRENT = Outcometree.out_ext_status *) =
    | Oext_first
    | Oext_next
    | Oext_exception

  type out_phrase (*IF_CURRENT = Outcometree.out_phrase *) =
    | Ophr_eval of out_value * out_type
    | Ophr_signature of (out_sig_item * out_value option) list
    | Ophr_exception of (exn * out_value)

end

module Config = struct
  let ast_impl_magic_number = "Caml1999M020"
  let ast_intf_magic_number = "Caml1999N018"
end

let map_signature mapper = mapper.Ast_mapper.signature mapper
let map_structure mapper = mapper.Ast_mapper.structure mapper

let shallow_identity =
  let id _ x = x in
  {
    Ast_mapper.
    structure               = id;
    structure_item          = id;
    module_expr             = id;
    signature               = id;
    signature_item          = id;
    module_type             = id;
    with_constraint         = id;
    class_declaration       = id;
    class_expr              = id;
    class_field             = id;
    class_structure         = id;
    class_type              = id;
    class_type_field        = id;
    class_signature         = id;
    class_type_declaration  = id;
    class_description       = id;
    type_declaration        = id;
    type_kind               = id;
    typ                     = id;
    type_extension          = id;
    extension_constructor   = id;
    value_description       = id;
    pat                     = id;
    expr                    = id;
    module_declaration      = id;
    module_type_declaration = id;
    module_binding          = id;
    open_description        = id;
    include_description     = id;
    include_declaration     = id;
    value_binding           = id;
    constructor_declaration = id;
    label_declaration       = id;
    cases                   = id;
    case                    = id;
    location                = id;
    extension               = id;
    attribute               = id;
    attributes              = id;
    payload                 = id;
  }

let failing_mapper =
  let fail _ _ =
    invalid_arg "failing_mapper: this mapper function should never get called"
  in
  {
    Ast_mapper.
    structure               = fail;
    structure_item          = fail;
    module_expr             = fail;
    signature               = fail;
    signature_item          = fail;
    module_type             = fail;
    with_constraint         = fail;
    class_declaration       = fail;
    class_expr              = fail;
    class_field             = fail;
    class_structure         = fail;
    class_type              = fail;
    class_type_field        = fail;
    class_signature         = fail;
    class_type_declaration  = fail;
    class_description       = fail;
    type_declaration        = fail;
    type_kind               = fail;
    typ                     = fail;
    type_extension          = fail;
    extension_constructor   = fail;
    value_description       = fail;
    pat                     = fail;
    expr                    = fail;
    module_declaration      = fail;
    module_type_declaration = fail;
    module_binding          = fail;
    open_description        = fail;
    include_description     = fail;
    include_declaration     = fail;
    value_binding           = fail;
    constructor_declaration = fail;
    label_declaration       = fail;
    cases                   = fail;
    case                    = fail;
    location                = fail;
    extension               = fail;
    attribute               = fail;
    attributes              = fail;
    payload                 = fail;
  }

let make_top_mapper ~signature ~structure =
  {failing_mapper with Ast_mapper.
                    signature = (fun _ x -> signature x);
                    structure = (fun _ x -> structure x) }

end
module Uchar : sig 
#1 "uchar.mli"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*                          Daniel C. Buenzli                          *)
(*                                                                     *)
(*  Copyright 2014 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the GNU Library General Public License, with    *)
(*  the special exception on linking described in file ../LICENSE.     *)
(*                                                                     *)
(***********************************************************************)

(** Unicode characters.

    @since 4.03 *)

type t
(** The type for Unicode characters.

    A value of this type represents an Unicode
    {{:http://unicode.org/glossary/#unicode_scalar_value}scalar
    value} which is an integer in the ranges [0x0000]...[0xD7FF] or
    [0xE000]...[0x10FFFF]. *)

val min : t
(** [min] is U+0000. *)

val max : t
(** [max] is U+10FFFF. *)

val succ : t -> t
(** [succ u] is the scalar value after [u] in the set of Unicode scalar
    values.

    @raise Invalid_argument if [u] is {!max}. *)

val pred : t -> t
(** [pred u] is the scalar value before [u] in the set of Unicode scalar
    values.

    @raise Invalid_argument if [u] is {!min}. *)

val is_valid : int -> bool
(** [is_valid n] is [true] iff [n] is an Unicode scalar value
    (i.e. in the ranges [0x0000]...[0xD7FF] or [0xE000]...[0x10FFFF]).*)

val of_int : int -> t
(** [of_int i] is [i] as an Unicode character.

    @raise Invalid_argument if [i] does not satisfy {!is_valid}. *)

(**/**)
val unsafe_of_int : int -> t
(**/**)

val to_int : t -> int
(** [to_int u] is [u] as an integer. *)

val is_char : t -> bool
(** [is_char u] is [true] iff [u] is a latin1 OCaml character. *)

val of_char : char -> t
(** [of_char c] is [c] as an Unicode character. *)

val to_char : t -> char
(** [to_char u] is [u] as an OCaml latin1 character.

    @raise Invalid_argument if [u] does not satisfy {!is_char}. *)

(**/**)
val unsafe_to_char : t -> char
(**/**)

val equal : t -> t -> bool
(** [equal u u'] is [u = u']. *)

val compare : t -> t -> int
(** [compare u u'] is [Pervasives.compare u u']. *)

val hash : t -> int
(** [hash u] associates a non-negative integer to [u]. *)

end = struct
#1 "uchar.ml"
(***********************************************************************)
(*                                                                     *)
(*                                OCaml                                *)
(*                                                                     *)
(*                          Daniel C. Buenzli                          *)
(*                                                                     *)
(*  Copyright 2014 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the GNU Library General Public License, with    *)
(*  the special exception on linking described in file ../LICENSE.     *)
(*                                                                     *)
(***********************************************************************)

let err_no_pred = "U+0000 has no predecessor"
let err_no_succ = "U+10FFFF has no successor"
let err_not_sv i = Printf.sprintf "%X is not an Unicode scalar value" i
let err_not_latin1 u = Printf.sprintf "U+%04X is not a latin1 character" u

type t = int

let min = 0x0000
let max = 0x10FFFF
let lo_bound = 0xD7FF
let hi_bound = 0xE000

let succ u =
  if u = lo_bound then hi_bound else
  if u = max then invalid_arg err_no_succ else
  u + 1

let pred u =
  if u = hi_bound then lo_bound else
  if u = min then invalid_arg err_no_pred else
  u - 1

let is_valid i = (min <= i && i <= lo_bound) || (hi_bound <= i && i <= max)
let of_int i = if is_valid i then i else invalid_arg (err_not_sv i)
external unsafe_of_int : int -> t = "%identity"
external to_int : t -> int = "%identity"

let is_char u = u < 256
let of_char c = Char.code c
let to_char u =
  if u > 255 then invalid_arg (err_not_latin1 u) else
  Char.unsafe_chr u

let unsafe_to_char = Char.unsafe_chr

let equal : int -> int -> bool = ( = )
let compare : int -> int -> int = Pervasives.compare
let hash = to_int

end
module Uutf : sig 
#1 "uutf.mli"
(*---------------------------------------------------------------------------
   Copyright (c) 2012 Daniel C. Bünzli. All rights reserved.
   Distributed under the ISC license, see terms at the end of the file.
   %%NAME%% %%VERSION%%
  ---------------------------------------------------------------------------*)

(** Non-blocking streaming Unicode codec.

  [Uutf] is a non-blocking streaming codec to {{:#decode}decode} and
  {{:#encode}encode} the {{:http://www.ietf.org/rfc/rfc3629.txt}
  UTF-8}, {{:http://www.ietf.org/rfc/rfc2781.txt} UTF-16}, UTF-16LE
  and UTF-16BE encoding schemes. It can efficiently work character by
  character without blocking on IO. Decoders perform
  character position tracking and support {{!nln}newline normalization}.

  Functions are also provided to {{!String} fold over} the
  characters of UTF encoded OCaml string values and to
  {{!Buffer}directly encode} characters in OCaml {!Buffer.t}
  values.

  See {{:#examples}examples} of use.

  {e %%VERSION%% — {{:%%PKG_HOMEPAGE%% }homepage}}

  {3 References}
    {ul
    {- The Unicode Consortium.
    {e {{:http://www.unicode.org/versions/latest}The Unicode Standard}}.
    (latest version)}}
*)

  (** {1:ucharcsts Special Unicode characters} *)

val u_bom : Uchar.t
(** [u_bom] is the {{:http://unicode.org/glossary/#byte_order_mark}byte
    order mark} (BOM) character ([U+FEFF]). *)

val u_rep : Uchar.t
(** [u_rep] is the
    {{:http://unicode.org/glossary/#replacement_character}replacement}
    character ([U+FFFD]). *)

(** {1:schemes Unicode encoding schemes} *)

type encoding = [ `UTF_16 | `UTF_16BE | `UTF_16LE | `UTF_8 ]
(** The type for Unicode
    {{:http://unicode.org/glossary/#character_encoding_scheme}encoding
    schemes}. *)

type decoder_encoding = [ encoding | `US_ASCII | `ISO_8859_1 ]
(** The type for encoding schemes {e decoded} by [Uutf]. Unicode encoding
    schemes plus {{:http://tools.ietf.org/html/rfc20}US-ASCII} and
    {{:http://www.ecma-international.org/publications/standards/Ecma-094.htm}
    ISO/IEC 8859-1} (latin-1). *)

val encoding_of_string : string -> decoder_encoding option
(** [encoding_of_string s] converts a (case insensitive)
    {{:http://www.iana.org/assignments/character-sets}IANA character set name}
    to an encoding. *)

val encoding_to_string : [< decoder_encoding] -> string
(** [encoding_to_string e] is a
    {{:http://www.iana.org/assignments/character-sets}IANA character set name}
    for [e]. *)

(** {1:decode Decode} *)

type src = [ `Channel of in_channel | `String of string | `Manual ]
(** The type for input sources. With a [`Manual] source the client
    must provide input with {!Manual.src}. *)

type nln = [ `ASCII of Uchar.t | `NLF of Uchar.t | `Readline of Uchar.t ]
(** The type for newline normalizations. The variant argument is the
    normalization character.
    {ul
    {- [`ASCII], normalizes CR ([U+000D]), LF ([U+000A]) and CRLF
       (<[U+000D], [U+000A]>).}
    {- [`NLF], normalizes the Unicode newline function (NLF). This is
       NEL ([U+0085]) and the normalizations of [`ASCII].}
    {- [`Readline], normalizes for a Unicode readline function. This is FF
       ([U+000C]), LS ([U+2028]), PS ([U+2029]), and the normalizations
       of [`NLF].}}
    Used with an appropriate normalization character the [`NLF] and
    [`Readline] normalizations allow to implement all the different
    recommendations of Unicode's newline guidelines (section 5.8 in
    Unicode 9.0.0). *)

type decoder
(** The type for decoders. *)

val decoder : ?nln:[< nln] -> ?encoding:[< decoder_encoding] -> [< src] ->
  decoder
(** [decoder nln encoding src] is a decoder that inputs from [src].

    {b Byte order mark.}
    {{:http://unicode.org/glossary/#byte_order_mark}Byte order mark}
    (BOM) constraints are application dependent and prone to
    misunderstandings (see the
    {{:http://www.unicode.org/faq/utf_bom.html#BOM}FAQ}). Hence,
    [Uutf] decoders have a simple rule: an {e initial BOM is always
    removed from the input and not counted in character position
    tracking}. The function {!decoder_removed_bom} does however return
    [true] if a BOM was removed so that all the information can be
    recovered if needed.

    For UTF-16BE and UTF-16LE the above rule is a violation of
    conformance D96 and D97 of the standard. [Uutf] favors the idea
    that if there's a BOM, decoding with [`UTF_16] or the [`UTF_16XX]
    corresponding to the BOM should decode the same character sequence
    (this is not the case if you stick to the standard). The client
    can however regain conformance by consulting the result of
    {!decoder_removed_bom} and take appropriate action.

    {b Encoding.} [encoding] specifies the decoded encoding
    scheme. If [`UTF_16] is used the endianness is determined
    according to the standard: from a
    {{:http://unicode.org/glossary/#byte_order_mark}BOM}
    if there is one, [`UTF_16BE] otherwise.

    If [encoding] is unspecified it is guessed. The result of a guess
    can only be [`UTF_8], [`UTF_16BE] or [`UTF_16LE]. The heuristic
    looks at the first three bytes of input (or less if impossible)
    and takes the {e first} matching byte pattern in the table below.
{[
xx = any byte
.. = any byte or no byte (input too small)
pp = positive byte
uu = valid UTF-8 first byte

Bytes    | Guess     | Rationale
---------+-----------+-----------------------------------------------
EF BB BF | `UTF_8    | UTF-8 BOM
FE FF .. | `UTF_16BE | UTF-16BE BOM
FF FE .. | `UTF_16LE | UTF-16LE BOM
00 pp .. | `UTF_16BE | ASCII UTF-16BE and U+0000 is often forbidden
pp 00 .. | `UTF_16LE | ASCII UTF-16LE and U+0000 is often forbidden
uu .. .. | `UTF_8    | ASCII UTF-8 or valid UTF-8 first byte.
xx xx .. | `UTF_16BE | Not UTF-8 => UTF-16, no BOM => UTF-16BE
.. .. .. | `UTF_8    | Single malformed UTF-8 byte or no input.
]}
    This heuristic is compatible both with BOM based
    recognitition and
    {{:http://tools.ietf.org/html/rfc4627#section-3}JSON-like encoding
    recognition} that relies on ASCII being present at the beginning
    of the stream. Also, {!decoder_removed_bom} will tell the client
    if the guess was BOM based.

    {b Newline normalization.} If [nln] is specified, the given
    newline normalization is performed, see {!nln}. Otherwise
    all newlines are returned as found in the input.

    {b Character position.} The line number, column number, byte count
    and character count of the last decoded character (including
    [`Malformed] ones) are respectively returned by {!decoder_line},
    {!decoder_col}, {!decoder_byte_count} and {!decoder_count}. Before
    the first call to {!decode} the line number is [1] and the column
    is [0].  Each {!decode} returning [`Uchar] or [`Malformed]
    increments the column until a newline.  On a newline, the line
    number is incremented and the column set to zero. For example the
    line is [2] and column [0] after the first newline was
    decoded. This can be understood as if {!decode} was moving an
    insertion point to the right in the data.  A {e newline} is
    anything normalized by [`Readline], see {!nln}.

    [Uutf] assumes that each Unicode scalar value has a column width
    of 1. The same assumption may not be made by the display program
    (e.g. for [emacs]' compilation mode you need to set
    [compilation-error-screen-columns] to [nil]). The problem is in
    general difficult to solve without interaction or convention with the
    display program's rendering engine. Depending on the context better column
    increments can be implemented by using {!Uucp.Break.tty_width_hint} or
    {{:http://unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries}
    grapheme cluster boundaries} (see {!Uuseg}). *)

val decode : decoder ->
  [ `Await | `Uchar of Uchar.t | `End | `Malformed of string]
(** [decode d] is:
    {ul
    {- [`Await] if [d] has a [`Manual] input source and awaits
       for more input. The client must use {!Manual.src} to provide it.}
    {- [`Uchar u] if a Unicode scalar value [u] was decoded.}
    {- [`End] if the end of input was reached.}
    {- [`Malformed bytes] if the [bytes] sequence is malformed according to
       the decoded encoding scheme. If you are interested in a best-effort
       decoding you can still continue to decode after an error until the
       decoder synchronizes again on valid bytes. It may however be a good
       idea to signal the malformed characters by adding an {!u_rep}
       character to the parsed data, see the {{:#examples}examples}.}}

    {b Note.} Repeated invocation always eventually returns [`End], even
    in case of errors.  *)

val decoder_encoding : decoder -> decoder_encoding
(** [decoder_encoding d] is [d]'s the decoded encoding scheme of [d].

    {b Warning.} If the decoder guesses the encoding or uses [`UTF_16],
    rely on this value only after the first [`Uchar] was decoded. *)

(**/**)

(* This function is dangerous, it may destroy the current continuation.
   But it's needed for things like XML parsers. *)

val set_decoder_encoding : decoder -> [< decoder_encoding] -> unit
(** [set_decoder_encoding d enc] changes the decoded encoding
    to [enc] after decoding started.

    {b Warning.} Call only after {!decode} was called on [d] and that the
    last call to it returned something different from [`Await] or data may
    be lost. After encoding guess wait for at least three [`Uchar]s. *)

(**/**)

val decoder_line : decoder -> int
(** [decoder_line d] is the line number of the last
    decoded (or malformed) character. See {!decoder} for details. *)

val decoder_col : decoder -> int
(** [decoder_col d] is the column number of the last decoded
    (or malformed) character. See {!decoder} for details. *)

val decoder_byte_count : decoder -> int
(** [decoder_byte_count d] is the number of bytes already decoded on
    [d] (including malformed ones). This is the last {!decode}'s
    end byte offset counting from the beginning of the stream. *)

val decoder_count : decoder -> int
(** [decoder_count d] is the number of characters already decoded on [d]
    (including malformed ones). See {!decoder} for details. *)

val decoder_removed_bom : decoder -> bool
(** [decoder_removed_bom d] is [true] iff an {e initial}
    {{:http://unicode.org/glossary/#byte_order_mark}BOM} was
    removed from the input stream. See {!decoder} for details. *)

val decoder_src : decoder -> src
(** [decoder_src d] is [d]'s input source. *)

val decoder_nln : decoder -> nln option
(** [decoder_nln d] returns [d]'s newline normalization (if any). *)

val pp_decode : Format.formatter ->
  [< `Await | `Uchar of Uchar.t | `End | `Malformed of string] -> unit
(** [pp_decode ppf v] prints an unspecified representation of [v] on
    [ppf]. *)

(** {1:encode Encode} *)

type dst = [ `Channel of out_channel | `Buffer of Buffer.t | `Manual ]
(** The type for output destinations. With a [`Manual] destination the client
    must provide output storage with {!Manual.dst}. *)

type encoder
(** The type for Unicode encoders. *)

val encoder : [< encoding] -> [< dst] -> encoder
(** [encoder encoding dst] is an encoder for [encoding] that outputs
    to [dst].

    {b Note.} No initial
    {{:http://unicode.org/glossary/#byte_order_mark}BOM}
    is encoded. If needed, this duty is left to the client. *)

val encode :
  encoder -> [<`Await | `End | `Uchar of Uchar.t ] -> [`Ok | `Partial ]
(** [encode e v] is :
    {ul
    {- [`Partial] iff [e] has a [`Manual] destination and needs more output
       storage. The client must use {!Manual.dst} to provide a new buffer
       and then call {!encode} with [`Await] until [`Ok] is returned.}
    {- [`Ok] when the encoder is ready to encode a new [`Uchar] or [`End]}}

    For [`Manual] destination, encoding [`End] always returns
    [`Partial], the client should continue as usual with [`Await]
    until [`Ok] is returned at which point {!Manual.dst_rem} [e] is
    guaranteed to be the size of the last provided buffer (i.e. nothing
    was written).

    {b Raises.} [Invalid_argument] if an [`Uchar] or [`End] is encoded
    after a [`Partial] encode. *)

val encoder_encoding : encoder -> encoding
(** [encoder_encoding e] is [e]'s encoding. *)

val encoder_dst : encoder -> dst
(** [encoder_dst e] is [e]'s output destination. *)

(** {1:manual Manual sources and destinations.} *)

(** Manual sources and destinations.

    {b Warning.} Use only with [`Manual] decoder and encoders. *)
module Manual : sig
  val src : decoder -> Bytes.t -> int -> int -> unit
  (** [src d s j l] provides [d] with [l] bytes to read, starting at
      [j] in [s]. This byte range is read by calls to {!decode} with [d]
      until [`Await] is returned. To signal the end of input call the function
      with [l = 0]. *)

  val dst : encoder -> Bytes.t -> int -> int -> unit
  (** [dst e s j l] provides [e] with [l] bytes to write, starting
      at [j] in [s]. This byte range is written by calls to {!encode} with [e]
      until [`Partial] is returned. Use {!dst_rem} to know the remaining
      number of non-written free bytes in [s]. *)

  val dst_rem : encoder -> int
  (** [dst_rem e] is the remaining number of non-written, free bytes
      in the last buffer provided with {!Manual.dst}. *)
end

(** {1:strbuf String folders and Buffer encoders} *)

(** Fold over the characters of UTF encoded OCaml [string] values. *)
module String : sig

(** {1 Encoding guess} *)

  val encoding_guess : string -> [ `UTF_8 | `UTF_16BE | `UTF_16LE ] * bool
  (** [encoding_guess s] is the encoding guessed for [s] coupled with
      [true] iff there's an initial
      {{:http://unicode.org/glossary/#byte_order_mark}BOM}. *)

(** {1 String folders}

    {b Note.} Initial {{:http://unicode.org/glossary/#byte_order_mark}BOM}s
    are also folded over. *)

  type 'a folder = 'a -> int -> [ `Uchar of Uchar.t | `Malformed of string ] ->
    'a
  (** The type for character folders. The integer is the index in the
      string where the [`Uchar] or [`Malformed] starts. *)

  val fold_utf_8 : ?pos:int -> ?len:int -> 'a folder -> 'a -> string -> 'a
  (** [fold_utf_8 f a s ?pos ?len ()] is
      [f (] ... [(f (f a pos u]{_0}[) j]{_1}[ u]{_1}[)] ... [)] ... [)
      j]{_n}[ u]{_n}
      where [u]{_i}, [j]{_i} are characters and their start position
      in the UTF-8 encoded substring [s] starting at [pos] and [len]
      long. The default value for [pos] is [0] and [len] is
      [String.length s - pos]. *)

  val fold_utf_16be : ?pos:int -> ?len:int -> 'a folder -> 'a -> string -> 'a
  (** [fold_utf_16be f a s ?pos ?len ()] is
      [f (] ... [(f (f a pos u]{_0}[) j]{_1}[ u]{_1}[)] ... [)] ... [)
      j]{_n}[ u]{_n}
      where [u]{_i}, [j]{_i} are characters and their start position
      in the UTF-8 encoded substring [s] starting at [pos] and [len]
      long. The default value for [pos] is [0] and [len] is
      [String.length s - pos]. *)

  val fold_utf_16le : ?pos:int -> ?len:int -> 'a folder -> 'a -> string -> 'a
  (** [fold_utf_16le f a s ?pos ?len ()] is
      [f (] ... [(f (f a pos u]{_0}[) j]{_1}[ u]{_1}[)] ... [)] ... [)
      j]{_n}[ u]{_n}
      where [u]{_i}, [j]{_i} are characters and their start position
      in the UTF-8 encoded substring [s] starting at [pos] and [len]
      long. The default value for [pos] is [0] and [len] is
      [String.length s - pos]. *)
end

(**  UTF encode characters in OCaml {!Buffer.t} values. *)
module Buffer : sig

  (** {1 Buffer encoders} *)

  val add_utf_8 : Buffer.t -> Uchar.t -> unit
  (** [add_utf_8 b u] adds the UTF-8 encoding of [u] to [b]. *)

  val add_utf_16be : Buffer.t -> Uchar.t -> unit
  (** [add_utf_16be b u] adds the UTF-16BE encoding of [u] to [b]. *)

  val add_utf_16le : Buffer.t -> Uchar.t -> unit
  (** [add_utf_16le b u] adds the UTF-16LE encoding of [u] to [b]. *)
end

(** {1:examples Examples}

    {2:readlines Read lines}

    The value of [lines src] is the list of lines in [src] as UTF-8
    encoded OCaml strings. Line breaks are determined according to the
    recommendation R4 for a [readline] function in section 5.8 of
    Unicode 9.0.0. If a decoding error occurs we silently replace the
    malformed sequence by the replacement character {!u_rep} and continue.
{[let lines ?encoding (src : [`Channel of in_channel | `String of string]) =
  let rec loop d buf acc = match Uutf.decode d with
  | `Uchar u ->
      begin match Uchar.to_int u with
      | 0x000A ->
          let line = Buffer.contents buf in
          Buffer.clear buf; loop d buf (line :: acc)
      | _ ->
          Uutf.Buffer.add_utf_8 buf u; loop d buf acc
      end
  | `End -> List.rev (Buffer.contents buf :: acc)
  | `Malformed _ -> Uutf.Buffer.add_utf_8 buf Uutf.u_rep; loop d buf acc
  | `Await -> assert false
  in
  let nln = `Readline (Uchar.of_int 0x000A) in
  loop (Uutf.decoder ~nln ?encoding src) (Buffer.create 512) []
]}
  Using the [`Manual] interface, [lines_fd] does the same but on a Unix file
  descriptor.
{[let lines_fd ?encoding (fd : Unix.file_descr) =
  let rec loop fd s d buf acc = match Uutf.decode d with
  | `Uchar u ->
      begin match Uchar.to_int u with
      | 0x000A ->
          let line = Buffer.contents buf in
          Buffer.clear buf; loop fd s d buf (line :: acc)
      | _ ->
          Uutf.Buffer.add_utf_8 buf u; loop fd s d buf acc
      end
  | `End -> List.rev (Buffer.contents buf :: acc)
  | `Malformed _ -> Uutf.Buffer.add_utf_8 buf Uutf.u_rep; loop fd s d buf acc
  | `Await ->
      let rec unix_read fd s j l = try Unix.read fd s j l with
      | Unix.Unix_error (Unix.EINTR, _, _) -> unix_read fd s j l
      in
      let rc = unix_read fd s 0 (Bytes.length s) in
      Uutf.Manual.src d s 0 rc; loop fd s d buf acc
  in
  let s = Bytes.create 65536 (* UNIX_BUFFER_SIZE in 4.0.0 *) in
  let nln = `Readline (Uchar.of_int 0x000A) in
  loop fd s (Uutf.decoder ~nln ?encoding `Manual) (Buffer.create 512) []
]}

    {2:recode Recode}

    The result of [recode src out_encoding dst] has the characters of
    [src] written on [dst] with encoding [out_encoding].  If a
    decoding error occurs we silently replace the malformed sequence
    by the replacement character {!u_rep} and continue.  Note that we
    don't add an initial
    {{:http://unicode.org/glossary/#byte_order_mark}BOM} to [dst],
    recoding will thus loose the initial BOM [src] may have. Whether
    this is a problem or not depends on the context.
{[let recode ?nln ?encoding out_encoding
    (src : [`Channel of in_channel | `String of string])
    (dst : [`Channel of out_channel | `Buffer of Buffer.t])
  =
  let rec loop d e = match Uutf.decode d with
  | `Uchar _ as u -> ignore (Uutf.encode e u); loop d e
  | `End -> ignore (Uutf.encode e `End)
  | `Malformed _ -> ignore (Uutf.encode e (`Uchar Uutf.u_rep)); loop d e
  | `Await -> assert false
  in
  let d = Uutf.decoder ?nln ?encoding src in
  let e = Uutf.encoder out_encoding dst in
  loop d e]}
  Using the [`Manual] interface, [recode_fd] does the same but between
  Unix file descriptors.
{[let recode_fd ?nln ?encoding out_encoding
    (fdi : Unix.file_descr)
    (fdo : Unix.file_descr)
  =
  let rec encode fd s e v = match Uutf.encode e v with `Ok -> ()
  | `Partial ->
      let rec unix_write fd s j l =
        let rec write fd s j l = try Unix.single_write fd s j l with
        | Unix.Unix_error (Unix.EINTR, _, _) -> write fd s j l
        in
        let wc = write fd s j l in
        if wc < l then unix_write fd s (j + wc) (l - wc) else ()
      in
      unix_write fd s 0 (Bytes.length s - Uutf.Manual.dst_rem e);
      Uutf.Manual.dst e s 0 (Bytes.length s);
      encode fd s e `Await
  in
  let rec loop fdi fdo ds es d e = match Uutf.decode d with
  | `Uchar _ as u -> encode fdo es e u; loop fdi fdo ds es d e
  | `End -> encode fdo es e `End
  | `Malformed _ -> encode fdo es e (`Uchar Uutf.u_rep); loop fdi fdo ds es d e
  | `Await ->
      let rec unix_read fd s j l = try Unix.read fd s j l with
      | Unix.Unix_error (Unix.EINTR, _, _) -> unix_read fd s j l
      in
      let rc = unix_read fdi ds 0 (Bytes.length ds) in
      Uutf.Manual.src d ds 0 rc; loop fdi fdo ds es d e
  in
  let ds = Bytes.create 65536 (* UNIX_BUFFER_SIZE in 4.0.0 *) in
  let es = Bytes.create 65536 (* UNIX_BUFFER_SIZE in 4.0.0 *) in
  let d = Uutf.decoder ?nln ?encoding `Manual in
  let e = Uutf.encoder out_encoding `Manual in
  Uutf.Manual.dst e es 0 (Bytes.length es);
  loop fdi fdo ds es d e]}
*)

(*---------------------------------------------------------------------------
   Copyright (c) 2012 Daniel C. Bünzli

   Permission to use, copy, modify, and/or distribute this software for any
   purpose with or without fee is hereby granted, provided that the above
   copyright notice and this permission notice appear in all copies.

   THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
   WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
   ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  ---------------------------------------------------------------------------*)

end = struct
#1 "uutf.ml"
(*---------------------------------------------------------------------------
   Copyright (c) 2012 Daniel C. Bünzli. All rights reserved.
   Distributed under the ISC license, see terms at the end of the file.
   %%NAME%% %%VERSION%%
  ---------------------------------------------------------------------------*)

let io_buffer_size = 65536                           (* IO_BUFFER_SIZE 4.0.0 *)

let pp = Format.fprintf
let invalid_encode () = invalid_arg "expected `Await encode"
let invalid_bounds j l =
  invalid_arg (Printf.sprintf "invalid bounds (index %d, length %d)" j l)

(* Unsafe string byte manipulations. If you don't believe the author's
   invariants, replacing with safe versions makes everything safe in
   the module. He won't be upset. *)

let unsafe_chr = Char.unsafe_chr
let unsafe_blit = Bytes.unsafe_blit
let unsafe_array_get = Array.unsafe_get
let unsafe_byte s j = Char.code (Bytes.unsafe_get s j)
let unsafe_set_byte s j byte = Bytes.unsafe_set s j (Char.unsafe_chr byte)

(* Unicode characters *)

let u_bom = Uchar.unsafe_of_int 0xFEFF                               (* BOM. *)
let u_rep = Uchar.unsafe_of_int 0xFFFD             (* replacement character. *)

(* Unicode encoding schemes *)

type encoding = [ `UTF_8 | `UTF_16 | `UTF_16BE | `UTF_16LE ]
type decoder_encoding = [ encoding | `US_ASCII | `ISO_8859_1 ]

let encoding_of_string s = match String.uppercase s with      (* IANA names. *)
| "UTF-8" -> Some `UTF_8
| "UTF-16" -> Some `UTF_16
| "UTF-16LE" -> Some `UTF_16LE
| "UTF-16BE" -> Some `UTF_16BE
| "ANSI_X3.4-1968" | "ISO-IR-6" | "ANSI_X3.4-1986" | "ISO_646.IRV:1991"
| "ASCII" | "ISO646-US" | "US-ASCII" | "US" | "IBM367" | "CP367" | "CSASCII" ->
    Some `US_ASCII
| "ISO_8859-1:1987" | "ISO-IR-100" | "ISO_8859-1" | "ISO-8859-1"
| "LATIN1" | "L1" | "IBM819" | "CP819" | "CSISOLATIN1" ->
    Some `ISO_8859_1
| _ -> None

let encoding_to_string = function
| `UTF_8 -> "UTF-8" | `UTF_16 -> "UTF-16" | `UTF_16BE -> "UTF-16BE"
| `UTF_16LE -> "UTF-16LE" | `US_ASCII -> "US-ASCII"
| `ISO_8859_1 -> "ISO-8859-1"

(* Base character decoders. They assume enough data. *)

let malformed s j l = `Malformed (Bytes.sub_string s j l)
let malformed_pair be hi s j l =    (* missing or half low surrogate at eoi. *)
  let bs1 = Bytes.(sub s j l) in
  let bs0 = Bytes.create 2 in
  let j0, j1 = if be then (0, 1) else (1, 0) in
  unsafe_set_byte bs0 j0 (hi lsr 8);
  unsafe_set_byte bs0 j1 (hi land 0xFF);
  `Malformed Bytes.(unsafe_to_string (cat bs0 bs1))

let r_us_ascii s j =
  (* assert (0 <= j && j < String.length s); *)
  let b0 = unsafe_byte s j in
  if b0 <= 127 then `Uchar (Uchar.unsafe_of_int b0) else malformed s j 1

let r_iso_8859_1 s j =
  (* assert (0 <= j && j < String.length s); *)
  `Uchar (Uchar.unsafe_of_int @@ unsafe_byte s j)

let utf_8_len = [| (* uchar byte length according to first UTF-8 byte. *)
  1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1;
  1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1;
  1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1;
  1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1;
  1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1; 1;
  1; 1; 1; 1; 1; 1; 1; 1; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;
  0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;
  0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0;
  0; 0; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2; 2;
  2; 2; 2; 2; 2; 2; 2; 2; 3; 3; 3; 3; 3; 3; 3; 3; 3; 3; 3; 3; 3; 3; 3; 3;
  4; 4; 4; 4; 4; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0 |]

let r_utf_8 s j l =
  (* assert (0 <= j && 0 <= l && j + l <= String.length s); *)
  let uchar c = `Uchar (Uchar.unsafe_of_int c) in
  match l with
  | 1 -> uchar (unsafe_byte s j)
  | 2 ->
      let b0 = unsafe_byte s j in let b1 = unsafe_byte s (j + 1) in
      if b1 lsr 6 != 0b10 then malformed s j l else
      uchar (((b0 land 0x1F) lsl 6) lor (b1 land 0x3F))
  | 3 ->
      let b0 = unsafe_byte s j in let b1 = unsafe_byte s (j + 1) in
      let b2 = unsafe_byte s (j + 2) in
      let c = ((b0 land 0x0F) lsl 12) lor
              ((b1 land 0x3F) lsl 6) lor
              (b2 land 0x3F)
      in
      if b2 lsr 6 != 0b10 then malformed s j l else
      begin match b0 with
      | 0xE0 -> if b1 < 0xA0 || 0xBF < b1 then malformed s j l else uchar c
      | 0xED -> if b1 < 0x80 || 0x9F < b1 then malformed s j l else uchar c
      | _ -> if b1 lsr 6 != 0b10 then malformed s j l else uchar c
      end
  | 4 ->
      let b0 = unsafe_byte s j in let b1 = unsafe_byte s (j + 1) in
      let b2 = unsafe_byte s (j + 2) in let b3 = unsafe_byte s (j + 3) in
      let c = (((b0 land 0x07) lsl 18) lor
               ((b1 land 0x3F) lsl 12) lor
               ((b2 land 0x3F) lsl 6) lor
               (b3 land 0x3F))
      in
      if b3 lsr 6 != 0b10 || b2 lsr 6 != 0b10 then malformed s j l else
      begin match b0 with
      | 0xF0 -> if b1 < 0x90 || 0xBF < b1 then malformed s j l else uchar c
      | 0xF4 -> if b1 < 0x80 || 0x8F < b1 then malformed s j l else uchar c
      | _ -> if b1 lsr 6 != 0b10 then malformed s j l else uchar c
      end
  | _ -> assert false

let r_utf_16 s j0 j1 =                       (* May return a high surrogate. *)
  (* assert (0 <= j0 && 0 <= j1 && max j0 j1 < String.length s); *)
  let b0 = unsafe_byte s j0 in let b1 = unsafe_byte s j1 in
  let u = (b0 lsl 8) lor b1 in
  if u < 0xD800 || u > 0xDFFF then `Uchar (Uchar.unsafe_of_int u) else
  if u > 0xDBFF then malformed s (min j0 j1) 2 else `Hi u

let r_utf_16_lo hi s j0 j1 =          (* Combines [hi] with a low surrogate. *)
  (* assert (0 <= j0 && 0 <= j1 && max j0 j1 < String.length s); *)
  let b0 = unsafe_byte s j0 in
  let b1 = unsafe_byte s j1 in
  let lo = (b0 lsl 8) lor b1 in
  if lo < 0xDC00 || lo > 0xDFFF
  then malformed_pair (j0 < j1 (* true => be *)) hi s (min j0 j1) 2
  else `Uchar (Uchar.unsafe_of_int ((((hi land 0x3FF) lsl 10) lor
                                     (lo land 0x3FF)) + 0x10000))

let r_encoding s j l =                  (* guess encoding with max. 3 bytes. *)
  (* assert (0 <= j && 0 <= l && j + l <= String.length s) *)
  let some i = if i < l then Some (unsafe_byte s (j + i)) else None in
  match (some 0), (some 1), (some 2) with
  | Some 0xEF, Some 0xBB, Some 0xBF                 -> `UTF_8 `BOM
  | Some 0xFE, Some 0xFF, _                         -> `UTF_16BE `BOM
  | Some 0xFF, Some 0xFE, _                         -> `UTF_16LE `BOM
  | Some 0x00, Some    p, _              when p > 0 -> `UTF_16BE (`ASCII p)
  | Some    p, Some 0x00, _              when p > 0 -> `UTF_16LE (`ASCII p)
  | Some    u,         _, _ when utf_8_len.(u) <> 0 -> `UTF_8 `Decode
  | Some    _, Some    _, _                         -> `UTF_16BE `Decode
  | Some    _, None     , None                      -> `UTF_8 `Decode
  | None     , None     , None                      -> `UTF_8 `End
  | None     , Some    _, _                         -> assert false
  | Some    _, None     , Some _                    -> assert false
  | None     , None     , Some _                    -> assert false

(* Decode *)

type src = [ `Channel of in_channel | `String of string | `Manual ]
type nln = [ `ASCII of Uchar.t | `NLF of Uchar.t | `Readline of Uchar.t ]
type decode = [ `Await | `End | `Malformed of string | `Uchar of Uchar.t]

let pp_decode ppf = function
| `Uchar u -> pp ppf "@[`Uchar U+%04X@]" (Uchar.to_int u)
| `End -> pp ppf "`End"
| `Await -> pp ppf "`Await"
| `Malformed bs ->
    let l = String.length bs in
    pp ppf "@[`Malformed (";
    if l > 0 then pp ppf "%02X" (Char.code (bs.[0]));
    for i = 1 to l - 1 do pp ppf " %02X" (Char.code (bs.[i])) done;
    pp ppf ")@]"

type decoder =
  { src : src;                                              (* input source. *)
    mutable encoding : decoder_encoding;                (* decoded encoding. *)
    nln : nln option;                     (* newline normalization (if any). *)
    nl : Uchar.t;                        (* newline normalization character. *)
    mutable i : Bytes.t;                             (* current input chunk. *)
    mutable i_pos : int;                          (* input current position. *)
    mutable i_max : int;                          (* input maximal position. *)
    t : Bytes.t;       (* four bytes temporary buffer for overlapping reads. *)
    mutable t_len : int;                      (* current byte length of [t]. *)
    mutable t_need : int;                  (* number of bytes needed in [t]. *)
    mutable removed_bom : bool;     (* [true] if an initial BOM was removed. *)
    mutable last_cr : bool;                   (* [true] if last char was CR. *)
    mutable line : int;                                      (* line number. *)
    mutable col : int;                                     (* column number. *)
    mutable byte_count : int;                                 (* byte count. *)
    mutable count : int;                                      (* char count. *)
    mutable pp :        (* decoder post-processor for BOM, position and nln. *)
      decoder -> [ `Malformed of string | `Uchar of Uchar.t ] -> decode;
    mutable k : decoder -> decode }                 (* decoder continuation. *)

(* On decodes that overlap two (or more) [d.i] buffers, we use [t_fill] to copy
   the input data to [d.t] and decode from there. If the [d.i] buffers are not
   too small this is faster than continuation based byte per byte writes.

   End of input (eoi) is signalled by [d.i_pos = 0] and [d.i_max = min_int]
   which implies that [i_rem d < 0] is [true]. *)

let i_rem d = d.i_max - d.i_pos + 1     (* remaining bytes to read in [d.i]. *)
let eoi d =
  d.i <- Bytes.empty; d.i_pos <- 0; d.i_max <- min_int   (* set eoi in [d]. *)

let src d s j l =                                     (* set [d.i] with [s]. *)
  if (j < 0 || l < 0 || j + l > Bytes.length s) then invalid_bounds j l else
  if (l = 0) then eoi d else
  (d.i <- s; d.i_pos <- j; d.i_max <- j + l - 1)

let refill k d = match d.src with  (* get new input in [d.i] and [k]ontinue. *)
| `Manual -> d.k <- k; `Await
| `String _ -> eoi d; k d
| `Channel ic ->
    let rc = input ic d.i 0 (Bytes.length d.i) in
    (src d d.i 0 rc; k d)

let t_need d need = d.t_len <- 0; d.t_need <- need
let rec t_fill k d =      (* get [d.t_need] bytes (or less if eoi) in [i.t]. *)
  let blit d l =
    unsafe_blit d.i d.i_pos d.t d.t_len (* write pos. *) l;
    d.i_pos <- d.i_pos + l; d.t_len <- d.t_len + l;
  in
  let rem = i_rem d in
  if rem < 0 (* eoi *) then k d else
  let need = d.t_need - d.t_len in
  if rem < need then (blit d rem; refill (t_fill k) d) else (blit d need; k d)

let ret k v byte_count d =                     (* return post-processed [v]. *)
  d.k <- k; d.byte_count <- d.byte_count + byte_count; d.pp d v

(* Decoders. *)

let rec decode_us_ascii d =
  let rem = i_rem d in
  if rem <= 0 then (if rem < 0 then `End else refill decode_us_ascii d) else
  let j = d.i_pos in
  d.i_pos <- d.i_pos + 1; ret decode_us_ascii (r_us_ascii d.i j) 1 d

let rec decode_iso_8859_1 d =
  let rem = i_rem d in
  if rem <= 0 then (if rem < 0 then `End else refill decode_iso_8859_1 d) else
  let j = d.i_pos in
  d.i_pos <- d.i_pos + 1; ret decode_iso_8859_1 (r_iso_8859_1 d.i j) 1 d

(* UTF-8 decoder *)

let rec t_decode_utf_8 d =                             (* decode from [d.t]. *)
  if d.t_len < d.t_need
  then ret decode_utf_8 (malformed d.t 0 d.t_len) d.t_len d
  else ret decode_utf_8 (r_utf_8 d.t 0 d.t_len) d.t_len d

and decode_utf_8 d =
  let rem = i_rem d in
  if rem <= 0 then (if rem < 0 then `End else refill decode_utf_8 d) else
  let need = unsafe_array_get utf_8_len (unsafe_byte d.i d.i_pos) in
  if rem < need then (t_need d need; t_fill t_decode_utf_8 d) else
  let j = d.i_pos in
  if need = 0
  then (d.i_pos <- d.i_pos + 1; ret decode_utf_8 (malformed d.i j 1) 1 d)
  else (d.i_pos <- d.i_pos + need; ret decode_utf_8 (r_utf_8 d.i j need) need d)

(* UTF-16BE decoder *)

let rec t_decode_utf_16be_lo hi d =                    (* decode from [d.t]. *)
  let bcount = d.t_len + 2 (* hi count *) in
  if d.t_len < d.t_need
  then ret decode_utf_16be (malformed_pair true hi d.t 0 d.t_len) bcount d
  else ret decode_utf_16be (r_utf_16_lo hi d.t 0 1) bcount d

and t_decode_utf_16be d =                              (* decode from [d.t]. *)
  if d.t_len < d.t_need
  then ret decode_utf_16be (malformed d.t 0 d.t_len) d.t_len d
  else decode_utf_16be_lo (r_utf_16 d.t 0 1) d

and decode_utf_16be_lo v d = match v with
| `Uchar _ | `Malformed _ as v -> ret decode_utf_16be v 2 d
| `Hi hi ->
    let rem = i_rem d in
    if rem < 2 then (t_need d 2; t_fill (t_decode_utf_16be_lo hi) d) else
    let j = d.i_pos in
    d.i_pos <- d.i_pos + 2;
    ret decode_utf_16be (r_utf_16_lo hi d.i j (j + 1)) 4 d

and decode_utf_16be d =
  let rem = i_rem d in
  if rem <= 0 then (if rem < 0 then `End else refill decode_utf_16be d) else
  if rem < 2 then (t_need d 2; t_fill t_decode_utf_16be d) else
  let j = d.i_pos in
  d.i_pos <- d.i_pos + 2; decode_utf_16be_lo (r_utf_16 d.i j (j + 1)) d

(* UTF-16LE decoder, same as UTF-16BE with byte swapped. *)

let rec t_decode_utf_16le_lo hi d =                    (* decode from [d.t]. *)
  let bcount = d.t_len + 2 (* hi count *) in
  if d.t_len < d.t_need
  then ret decode_utf_16le (malformed_pair false hi d.t 0 d.t_len) bcount d
  else ret decode_utf_16le (r_utf_16_lo hi d.t 1 0) bcount d

and t_decode_utf_16le d =                              (* decode from [d.t]. *)
  if d.t_len < d.t_need
  then ret decode_utf_16le (malformed d.t 0 d.t_len) d.t_len d
  else decode_utf_16le_lo (r_utf_16 d.t 1 0) d

and decode_utf_16le_lo v d = match v with
| `Uchar _ | `Malformed _ as v -> ret decode_utf_16le v 2 d
| `Hi hi ->
    let rem = i_rem d in
    if rem < 2 then (t_need d 2; t_fill (t_decode_utf_16le_lo hi) d) else
    let j = d.i_pos in
    d.i_pos <- d.i_pos + 2;
    ret decode_utf_16le (r_utf_16_lo hi d.i (j + 1) j) 4 d

and decode_utf_16le d =
  let rem = i_rem d in
  if rem <= 0 then (if rem < 0 then `End else refill decode_utf_16le d) else
  if rem < 2 then (t_need d 2; t_fill t_decode_utf_16le d) else
  let j = d.i_pos in
  d.i_pos <- d.i_pos + 2; decode_utf_16le_lo (r_utf_16 d.i (j + 1) j) d

(* Encoding guessing. The guess is simple but starting the decoder
   after is tedious, uutf's decoders are not designed to put bytes
   back in the stream. *)

let guessed_utf_8 d =                   (* start decoder after `UTF_8 guess. *)
  let b3 d =                                 (* handles the third read byte. *)
    let b3 = unsafe_byte d.t 2 in
    match utf_8_len.(b3) with
    | 0 -> ret decode_utf_8 (malformed d.t 2 1) 1 d
    | n ->
        d.t_need <- n; d.t_len <- 1; unsafe_set_byte d.t 0 b3;
        t_fill t_decode_utf_8 d
  in
  let b2 d =                                     (* handle second read byte. *)
    let b2 = unsafe_byte d.t 1 in
    let b3 = if d.t_len > 2 then b3 else decode_utf_8 (* decodes `End *) in
    match utf_8_len.(b2) with
    | 0 -> ret b3 (malformed d.t 1 1) 1 d
    | 1 -> ret b3 (r_utf_8 d.t 1 1) 1 d
    | n ->                         (* copy d.t.(1-2) to d.t.(0-1) and decode *)
        d.t_need <- n;
        unsafe_set_byte d.t 0 b2;
        if (d.t_len < 3) then d.t_len <- 1 else
        (d.t_len <- 2; unsafe_set_byte d.t 1 (unsafe_byte d.t 2); );
        t_fill t_decode_utf_8 d
  in
  let b1 = unsafe_byte d.t 0 in                   (* handle first read byte. *)
  let b2 = if d.t_len > 1 then b2 else decode_utf_8 (* decodes `End *) in
  match utf_8_len.(b1) with
  | 0 -> ret b2 (malformed d.t 0 1) 1 d
  | 1 -> ret b2 (r_utf_8 d.t 0 1) 1 d
  | 2 ->
      if d.t_len < 2 then ret decode_utf_8 (malformed d.t 0 1) 1 d else
      if d.t_len < 3 then ret decode_utf_8 (r_utf_8 d.t 0 2) 2 d else
      ret b3 (r_utf_8 d.t 0 2) 2 d
  | 3 ->
      if d.t_len < 3
      then ret decode_utf_8 (malformed d.t 0 d.t_len) d.t_len d
      else ret decode_utf_8 (r_utf_8 d.t 0 3) 3 d
  | 4 ->
      if d.t_len < 3
      then ret decode_utf_8 (malformed d.t 0 d.t_len) d.t_len d
      else (d.t_need <- 4; t_fill t_decode_utf_8 d)
  | n -> assert false

let guessed_utf_16 d be v =     (* start decoder after `UTF_16{BE,LE} guess. *)
  let decode_utf_16, t_decode_utf_16, t_decode_utf_16_lo, j0, j1 =
    if be then decode_utf_16be, t_decode_utf_16be, t_decode_utf_16be_lo, 0, 1
    else decode_utf_16le, t_decode_utf_16le, t_decode_utf_16le_lo, 1, 0
  in
  let b3 k d =
    if d.t_len < 3 then decode_utf_16 d (* decodes `End *) else
    begin                             (* copy d.t.(2) to d.t.(0) and decode. *)
      d.t_need <- 2; d.t_len <- 1;
      unsafe_set_byte d.t 0 (unsafe_byte d.t 2);
      t_fill k d
    end
  in
  match v with
  | `BOM -> ret (b3 t_decode_utf_16) (`Uchar u_bom) 2 d
  | `ASCII u -> ret (b3 t_decode_utf_16) (`Uchar (Uchar.unsafe_of_int u)) 2 d
  | `Decode ->
      match r_utf_16 d.t j0 j1 with
      | `Malformed _ | `Uchar _ as v -> ret (b3 t_decode_utf_16) v 2 d
      | `Hi hi ->
        if d.t_len < 3
        then ret decode_utf_16 (malformed_pair be hi Bytes.empty 0 0) d.t_len d
        else (b3 (t_decode_utf_16_lo hi)) d

let guess_encoding d =                  (* guess encoding and start decoder. *)
  let setup d = match r_encoding d.t 0 d.t_len with
  | `UTF_8 r ->
      d.encoding <- `UTF_8; d.k <- decode_utf_8;
      begin match r with
      | `BOM -> ret decode_utf_8 (`Uchar u_bom) 3 d
      | `Decode -> guessed_utf_8 d
      | `End -> `End
      end
  | `UTF_16BE r ->
      d.encoding <- `UTF_16BE; d.k <- decode_utf_16be; guessed_utf_16 d true r
  | `UTF_16LE r ->
      d.encoding <- `UTF_16LE; d.k <- decode_utf_16le; guessed_utf_16 d false r

  in
  (t_need d 3; t_fill setup d)

(* Character post-processors. Used for BOM handling, newline
   normalization and position tracking. The [pp_remove_bom] is only
   used for the first character to remove a possible initial BOM and
   handle UTF-16 endianness recognition. *)

let nline d = d.col <- 0; d.line <- d.line + 1                   (* inlined. *)
let ncol d = d.col <- d.col + 1                                  (* inlined. *)
let ncount d = d.count <- d.count + 1                            (* inlined. *)
let cr d b = d.last_cr <- b                                      (* inlined. *)

let pp_remove_bom utf16 pp d = function(* removes init. BOM, handles UTF-16. *)
| `Malformed _  as v -> d.removed_bom <- false; d.pp <- pp; d.pp d v
| `Uchar u as v ->
    match Uchar.to_int u with
    | 0xFEFF (* BOM *) ->
        if utf16 then (d.encoding <- `UTF_16BE; d.k <- decode_utf_16be);
        d.removed_bom <- true; d.pp <- pp; d.k d
    | 0xFFFE (* BOM reversed from decode_utf_16be *) when utf16 ->
        d.encoding <- `UTF_16LE; d.k <- decode_utf_16le;
        d.removed_bom <- true; d.pp <- pp; d.k d
    | _ ->
        d.removed_bom <- false; d.pp <- pp; d.pp d v

let pp_nln_none d = function
| `Malformed _ as v -> cr d false; ncount d; ncol d; v
| `Uchar u as v ->
    match Uchar.to_int u with
    | 0x000A (* LF *) ->
        let last_cr = d.last_cr in
        cr d false; ncount d; if last_cr then v else (nline d; v)
    | 0x000D (* CR *) -> cr d true; ncount d; nline d; v
    | (0x0085 | 0x000C | 0x2028 | 0x2029) (* NEL | FF | LS | PS *) ->
        cr d false; ncount d; nline d; v
    | _ ->
        cr d false; ncount d; ncol d; v

let pp_nln_readline d = function
| `Malformed _ as v -> cr d false; ncount d; ncol d; v
| `Uchar u as v ->
    match Uchar.to_int u with
    | 0x000A (* LF *) ->
        let last_cr = d.last_cr in
        cr d false; if last_cr then d.k d else (ncount d; nline d; `Uchar d.nl)
    | 0x000D (* CR *) -> cr d true; ncount d; nline d; `Uchar d.nl
    | (0x0085 | 0x000C | 0x2028 | 0x2029) (* NEL | FF | LS | PS *) ->
        cr d false; ncount d; nline d; `Uchar d.nl
    | _ ->
        cr d false; ncount d; ncol d; v

let pp_nln_nlf d = function
| `Malformed _ as v -> cr d false; ncount d; ncol d; v
| `Uchar u as v ->
    match Uchar.to_int u with
    | 0x000A (* LF *) ->
        let last_cr = d.last_cr in
        cr d false; if last_cr then d.k d else (ncount d; nline d; `Uchar d.nl)
    | 0x000D (* CR *) -> cr d true; ncount d; nline d; `Uchar d.nl
    | 0x0085 (* NEL *) -> cr d false; ncount d; nline d; `Uchar d.nl
    | (0x000C | 0x2028 | 0x2029) (* FF | LS | PS *) ->
        cr d false; ncount d; nline d; v
    | _ ->
        cr d false; ncount d; ncol d; v

let pp_nln_ascii d = function
| `Malformed _ as v -> cr d false; ncount d; ncol d; v
| `Uchar u as v ->
    match Uchar.to_int u with
    | 0x000A (* LF *) ->
        let last_cr = d.last_cr in
        cr d false; if last_cr then d.k d else (ncount d; nline d; `Uchar d.nl)
    | 0x000D (* CR *) -> cr d true; ncount d; nline d; `Uchar d.nl
    | (0x0085 | 0x000C | 0x2028 | 0x2029) (* NEL | FF | LS | PS *) ->
        cr d false; ncount d; nline d; v
    | _ ->
        cr d false; ncount d; ncol d; v

let decode_fun = function
| `UTF_8 -> decode_utf_8
| `UTF_16 -> decode_utf_16be                         (* see [pp_remove_bom]. *)
| `UTF_16BE -> decode_utf_16be
| `UTF_16LE -> decode_utf_16le
| `US_ASCII -> decode_us_ascii
| `ISO_8859_1 -> decode_iso_8859_1

let decoder ?nln ?encoding src =
  let pp, nl = match nln with
  | None -> pp_nln_none, Uchar.unsafe_of_int 0x000A (* not used. *)
  | Some (`ASCII nl) -> pp_nln_ascii, nl
  | Some (`NLF nl) -> pp_nln_nlf, nl
  | Some (`Readline nl) -> pp_nln_readline, nl
  in
  let encoding, k = match encoding with
  | None -> `UTF_8, guess_encoding
  | Some e -> (e :> decoder_encoding), decode_fun e
  in
  let i, i_pos, i_max = match src with
  | `Manual -> Bytes.empty, 1, 0                  (* implies src_rem d = 0. *)
  | `Channel _ -> Bytes.create io_buffer_size, 1, 0                (* idem. *)
  | `String s -> Bytes.unsafe_of_string s, 0, String.length s - 1
  in
  { src = (src :> src); encoding; nln = (nln :> nln option); nl;
    i; i_pos; i_max; t = Bytes.create 4; t_len = 0; t_need = 0;
    removed_bom = false; last_cr = false; line = 1; col = 0;
    byte_count = 0; count = 0;
    pp = pp_remove_bom (encoding = `UTF_16) pp; k }

let decode d = d.k d
let decoder_line d = d.line
let decoder_col d = d.col
let decoder_byte_count d = d.byte_count
let decoder_count d = d.count
let decoder_removed_bom d = d.removed_bom
let decoder_src d = d.src
let decoder_nln d = d.nln
let decoder_encoding d = d.encoding
let set_decoder_encoding d e =
  d.encoding <- (e :> decoder_encoding); d.k <- decode_fun e

(* Encode *)

type dst = [ `Channel of out_channel | `Buffer of Buffer.t | `Manual ]
type encode = [ `Await | `End | `Uchar of Uchar.t ]
type encoder =
  { dst : dst;                                        (* output destination. *)
    encoding : encoding;                                (* encoded encoding. *)
    mutable o : Bytes.t;                            (* current output chunk. *)
    mutable o_pos : int;                   (* next output position to write. *)
    mutable o_max : int;                (* maximal output position to write. *)
    t : Bytes.t;                (* four bytes buffer for overlapping writes. *)
    mutable t_pos : int;                    (* next position to read in [t]. *)
    mutable t_max : int;                 (* maximal position to read in [t]. *)
    mutable k :                                     (* encoder continuation. *)
      encoder -> encode -> [ `Ok | `Partial ] }

(* On encodes that overlap two (or more) [e.o] buffers, we encode the
   character to the temporary buffer [o.t] and continue with
   [tmp_flush] to write this data on the different [e.o] buffers. If
   the [e.o] buffers are not too small this is faster than
   continuation based byte per byte writes. *)

let o_rem e = e.o_max - e.o_pos + 1    (* remaining bytes to write in [e.o]. *)
let dst e s j l =                                     (* set [e.o] with [s]. *)
  if (j < 0 || l < 0 || j + l > Bytes.length s) then invalid_bounds j l;
  e.o <- s; e.o_pos <- j; e.o_max <- j + l - 1

let partial k e = function `Await -> k e | `Uchar _ | `End -> invalid_encode ()
let flush k e = match e.dst with(* get free storage in [d.o] and [k]ontinue. *)
| `Manual -> e.k <- partial k; `Partial
| `Channel oc -> output oc e.o 0 e.o_pos; e.o_pos <- 0; k e
| `Buffer b ->
    let o = Bytes.unsafe_to_string e.o in
    Buffer.add_substring b o 0 e.o_pos; e.o_pos <- 0; k e


let t_range e max = e.t_pos <- 0; e.t_max <- max
let rec t_flush k e =               (* flush [d.t] up to [d.t_max] in [d.i]. *)
  let blit e l =
    unsafe_blit e.t e.t_pos e.o e.o_pos l;
    e.o_pos <- e.o_pos + l; e.t_pos <- e.t_pos + l
  in
  let rem = o_rem e in
  let len = e.t_max - e.t_pos + 1 in
  if rem < len then (blit e rem; flush (t_flush k) e) else (blit e len; k e)

(* Encoders. *)

let rec encode_utf_8 e v =
  let k e = e.k <- encode_utf_8; `Ok in
  match v with
  | `Await -> k e
  | `End -> flush k e
  | `Uchar u as v ->
      let u = Uchar.to_int u in
      let rem = o_rem e in
      if u <= 0x007F then
      if rem < 1 then flush (fun e -> encode_utf_8 e v) e else
      (unsafe_set_byte e.o e.o_pos u; e.o_pos <- e.o_pos + 1; k e)
      else if u <= 0x07FF then
      begin
        let s, j, k =
          if rem < 2 then (t_range e 1; e.t, 0, t_flush k) else
          let j = e.o_pos in (e.o_pos <- e.o_pos + 2; e.o, j, k)
        in
        unsafe_set_byte s j (0xC0 lor (u lsr 6));
        unsafe_set_byte s (j + 1) (0x80 lor (u land 0x3F));
        k e
      end
      else if u <= 0xFFFF then
      begin
        let s, j, k =
          if rem < 3 then (t_range e 2; e.t, 0, t_flush k) else
          let j = e.o_pos in (e.o_pos <- e.o_pos + 3; e.o, j, k)
        in
        unsafe_set_byte s j (0xE0 lor (u lsr 12));
        unsafe_set_byte s (j + 1) (0x80 lor ((u lsr 6) land 0x3F));
        unsafe_set_byte s (j + 2) (0x80 lor (u land 0x3F));
        k e
      end
      else
      begin
        let s, j, k =
          if rem < 4 then (t_range e 3; e.t, 0, t_flush k) else
          let j = e.o_pos in (e.o_pos <- e.o_pos + 4; e.o, j, k)
        in
        unsafe_set_byte s j (0xF0 lor (u lsr 18));
        unsafe_set_byte s (j + 1) (0x80 lor ((u lsr 12) land 0x3F));
        unsafe_set_byte s (j + 2) (0x80 lor ((u lsr 6) land 0x3F));
        unsafe_set_byte s (j + 3) (0x80 lor (u land 0x3F));
        k e
      end

let rec encode_utf_16be e v =
  let k e = e.k <- encode_utf_16be; `Ok in
  match v with
  | `Await -> k e
  | `End -> flush k e
  | `Uchar u ->
      let u = Uchar.to_int u in
      let rem = o_rem e in
      if u < 0x10000 then
      begin
        let s, j, k =
          if rem < 2 then (t_range e 1; e.t, 0, t_flush k) else
          let j = e.o_pos in (e.o_pos <- e.o_pos + 2; e.o, j, k)
        in
        unsafe_set_byte s j (u lsr 8);
        unsafe_set_byte s (j + 1) (u land 0xFF);
        k e
      end else begin
        let s, j, k =
          if rem < 4 then (t_range e 3; e.t, 0, t_flush k) else
          let j = e.o_pos in (e.o_pos <- e.o_pos + 4; e.o, j, k)
        in
        let u' = u - 0x10000 in
        let hi = (0xD800 lor (u' lsr 10)) in
        let lo = (0xDC00 lor (u' land 0x3FF)) in
        unsafe_set_byte s j (hi lsr 8);
        unsafe_set_byte s (j + 1) (hi land 0xFF);
        unsafe_set_byte s (j + 2) (lo lsr 8);
        unsafe_set_byte s (j + 3) (lo land 0xFF);
        k e
      end

let rec encode_utf_16le e v =         (* encode_uft_16be with bytes swapped. *)
  let k e = e.k <- encode_utf_16le; `Ok in
  match v with
  | `Await -> k e
  | `End -> flush k e
  | `Uchar u ->
      let u = Uchar.to_int u in
      let rem = o_rem e in
      if u < 0x10000 then
        begin
          let s, j, k =
            if rem < 2 then (t_range e 1; e.t, 0, t_flush k) else
            let j = e.o_pos in (e.o_pos <- e.o_pos + 2; e.o, j, k)
          in
          unsafe_set_byte s j (u land 0xFF);
          unsafe_set_byte s (j + 1) (u lsr 8);
          k e
        end
      else
      begin
        let s, j, k =
          if rem < 4 then (t_range e 3; e.t, 0, t_flush k) else
          let j = e.o_pos in (e.o_pos <- e.o_pos + 4; e.o, j, k)
        in
        let u' = u - 0x10000 in
        let hi = (0xD800 lor (u' lsr 10)) in
        let lo = (0xDC00 lor (u' land 0x3FF)) in
        unsafe_set_byte s j (hi land 0xFF);
        unsafe_set_byte s (j + 1) (hi lsr 8);
        unsafe_set_byte s (j + 2) (lo land 0xFF);
        unsafe_set_byte s (j + 3) (lo lsr 8);
        k e
      end

let encode_fun = function
| `UTF_8 -> encode_utf_8
| `UTF_16 -> encode_utf_16be
| `UTF_16BE -> encode_utf_16be
| `UTF_16LE -> encode_utf_16le

let encoder encoding dst =
  let o, o_pos, o_max = match dst with
  | `Manual -> Bytes.empty, 1, 0                     (* implies o_rem e = 0. *)
  | `Buffer _
  | `Channel _ -> Bytes.create io_buffer_size, 0, io_buffer_size - 1
  in
  { dst = (dst :> dst); encoding = (encoding :> encoding); o; o_pos; o_max;
    t = Bytes.create 4; t_pos = 1; t_max = 0; k = encode_fun encoding}

let encode e v = e.k e (v :> encode)
let encoder_encoding e = e.encoding
let encoder_dst e = e.dst

(* Manual sources and destinations. *)

module Manual = struct
  let src = src
  let dst = dst
  let dst_rem = o_rem
end

(* Strings folders and Buffer encoders *)

module String = struct
  let encoding_guess s =
    let s = Bytes.unsafe_of_string s in
    match r_encoding s 0 (max (Bytes.length s) 3) with
    | `UTF_8 d -> `UTF_8, (d = `BOM)
    | `UTF_16BE d -> `UTF_16BE, (d = `BOM)
    | `UTF_16LE d -> `UTF_16LE, (d = `BOM)

  type 'a folder =
    'a -> int -> [ `Uchar of Uchar.t | `Malformed of string ] -> 'a

  let fold_utf_8 ?(pos = 0) ?len f acc s =
    let rec loop acc f s i l =
      if i = l then acc else
      let need = unsafe_array_get utf_8_len (unsafe_byte s i) in
      if need = 0 then loop (f acc i (malformed s i 1)) f s (i + 1) l else
      let rem = l - i in
      if rem < need then f acc i (malformed s i rem) else
      loop (f acc i (r_utf_8 s i need)) f s (i + need) l
    in
    let len = match len with
    | None -> String.length s - pos
    | Some l -> l
    in
    loop acc f (Bytes.unsafe_of_string s) pos len

  let fold_utf_16be ?(pos = 0) ?len f acc s =
    let rec loop acc f s i l =
      if i = l then acc else
      let rem = l - i in
      if rem < 2 then f acc i (malformed s i 1) else
      match r_utf_16 s i (i + 1) with
      | `Uchar _ | `Malformed _ as v -> loop (f acc i v) f s (i + 2) l
      | `Hi hi ->
          if rem < 4 then f acc i (malformed s i rem)  else
          loop (f acc i (r_utf_16_lo hi s (i + 2) (i + 3))) f s (i + 4) l
    in
    let len = match len with
    | None -> String.length s - pos
    | Some l -> l
    in
    loop acc f (Bytes.unsafe_of_string s) pos len

  let fold_utf_16le ?(pos = 0) ?len f acc s = (* [fold_utf_16be], bytes swapped. *)
    let rec loop acc f s i l =
      if i = l then acc else
      let rem = l - i in
      if rem < 2 then f acc i (malformed s i 1) else
      match r_utf_16 s (i + 1) i with
      | `Uchar _ | `Malformed _ as v -> loop (f acc i v) f s (i + 2) l
      | `Hi hi ->
          if rem < 4 then f acc i (malformed s i rem)  else
          loop (f acc i (r_utf_16_lo hi s (i + 3) (i + 2))) f s (i + 4) l
    in
    let len = match len with
    | None -> String.length s - pos
    | Some l -> l
    in
    loop acc f (Bytes.unsafe_of_string s) pos len
end

module Buffer = struct
  let add_utf_8 b u =
    let u = Uchar.to_int u in
    let w byte = Buffer.add_char b (unsafe_chr byte) in          (* inlined. *)
    if u <= 0x007F then
    (w u)
    else if u <= 0x07FF then
    (w (0xC0 lor (u lsr 6));
     w (0x80 lor (u land 0x3F)))
    else if u <= 0xFFFF then
    (w (0xE0 lor (u lsr 12));
     w (0x80 lor ((u lsr 6) land 0x3F));
     w (0x80 lor (u land 0x3F)))
    else
    (w (0xF0 lor (u lsr 18));
     w (0x80 lor ((u lsr 12) land 0x3F));
     w (0x80 lor ((u lsr 6) land 0x3F));
     w (0x80 lor (u land 0x3F)))

  let add_utf_16be b u =
    let u = Uchar.to_int u in
    let w byte = Buffer.add_char b (unsafe_chr byte) in          (* inlined. *)
    if u < 0x10000 then (w (u lsr 8); w (u land 0xFF)) else
    let u' = u - 0x10000 in
    let hi = (0xD800 lor (u' lsr 10)) in
    let lo = (0xDC00 lor (u' land 0x3FF)) in
    w (hi lsr 8); w (hi land 0xFF);
    w (lo lsr 8); w (lo land 0xFF)

  let add_utf_16le b u =                            (* swapped add_utf_16be. *)
    let u = Uchar.to_int u in
    let w byte = Buffer.add_char b (unsafe_chr byte) in          (* inlined. *)
    if u < 0x10000 then (w (u land 0xFF); w (u lsr 8)) else
    let u' = u - 0x10000 in
    let hi = (0xD800 lor (u' lsr 10)) in
    let lo = (0xDC00 lor (u' land 0x3FF)) in
    w (hi land 0xFF); w (hi lsr 8);
    w (lo land 0xFF); w (lo lsr 8)
end

(*---------------------------------------------------------------------------
   Copyright (c) 2012 Daniel C. Bünzli

   Permission to use, copy, modify, and/or distribute this software for any
   purpose with or without fee is hereby granted, provided that the above
   copyright notice and this permission notice appear in all copies.

   THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
   WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
   MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
   ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  ---------------------------------------------------------------------------*)

end
module Markup_common
= struct
#1 "markup_common.ml"
(* This file is part of Markup.ml, released under the BSD 2-clause license. See
   doc/LICENSE for details, or visit https://github.com/aantron/markup.ml. *)

(* Aliases for reducing the number of deprecation warings. *)
module String =
struct
  include String
  let lowercase = lowercase
end

module Char =
struct
  include Char
  let lowercase = lowercase
end

type 'a cont = 'a -> unit
type 'a cps = exn cont -> 'a cont -> unit

type location = int * int

let compare_locations (line, column) (line', column') =
  match line - line' with
  | 0 -> column - column'
  | order -> order

type name = string * string

let (|>) x f = f x
let (@@) f x = f x

let xml_ns = "http://www.w3.org/XML/1998/namespace"
let xmlns_ns = "http://www.w3.org/2000/xmlns/"
let xlink_ns = "http://www.w3.org/1999/xlink"
let html_ns = "http://www.w3.org/1999/xhtml"
let svg_ns = "http://www.w3.org/2000/svg"
let mathml_ns = "http://www.w3.org/1998/Math/MathML"

module Token_tag =
struct
  type t =
    {name         : string;
     attributes   : (string * string) list;
     self_closing : bool}
end

type xml_declaration =
  {version    : string;
   encoding   : string option;
   standalone : bool option}

type doctype =
  {doctype_name      : string option;
   public_identifier : string option;
   system_identifier : string option;
   raw_text          : string option;
   force_quirks      : bool}

type signal =
  [ `Start_element of name * (name * string) list
  | `End_element
  | `Text of string list
  | `Xml of xml_declaration
  | `Doctype of doctype
  | `PI of string * string
  | `Comment of string ]

type content_signal =
  [ `Start_element of name * (name * string) list
  | `End_element
  | `Text of string list ]

type general_token =
  [ `Xml of xml_declaration
  | `Doctype of doctype
  | `Start of Token_tag.t
  | `End of Token_tag.t
  | `Chars of string list
  | `Char of int
  | `PI of string * string
  | `Comment of string
  | `EOF ]

let u_rep = Uchar.to_int Uutf.u_rep

let add_utf_8 buffer c =
  Uutf.Buffer.add_utf_8 buffer (Uchar.unsafe_of_int c)

let format_char = Printf.sprintf "U+%04X"

(* Type constraints are necessary to avoid polymorphic comparison, which would
   greatly reduce performance: https://github.com/aantron/markup.ml/pull/15. *)
let is_in_range (lower : int) (upper : int) c = c >= lower && c <= upper

(* HTML 8.2.2.5. *)
let is_control_character = function
  | 0x000B -> true
  | c when is_in_range 0x0001 0x0008 c -> true
  | c when is_in_range 0x000E 0x001F c -> true
  | c when is_in_range 0x007F 0x009F c -> true
  | _ -> false

(* HTML 8.2.2.5. *)
let is_non_character = function
  | c when is_in_range 0xFDD0 0xFDEF c -> true
  | c when (c land 0xFFFF = 0xFFFF) || (c land 0xFFFF = 0xFFFE) -> true
  | _ -> false

let is_digit = is_in_range 0x0030 0x0039

let is_hex_digit = function
  | c when is_digit c -> true
  | c when is_in_range 0x0041 0x0046 c -> true
  | c when is_in_range 0x0061 0x0066 c -> true
  | _ -> false

let is_scalar = function
  | c when (c >= 0x10FFFF) || ((c >= 0xD800) && (c <= 0xDFFF)) -> false
  | _ -> true

let is_uppercase = is_in_range 0x0041 0x005A

let is_lowercase = is_in_range 0x0061 0x007A

let is_alphabetic = function
  | c when is_uppercase c -> true
  | c when is_lowercase c -> true
  | _ -> false

let is_alphanumeric = function
  | c when is_alphabetic c -> true
  | c when is_digit c -> true
  | _ -> false

let is_whitespace c = c = 0x0020 || c = 0x000A || c = 0x0009 || c = 0x000D

let is_whitespace_only s =
  try
    s |> String.iter (fun c ->
      if is_whitespace (int_of_char c) then ()
      else raise Exit);
    true

  with Exit -> false

let to_lowercase = function
  | c when is_uppercase c -> c + 0x20
  | c -> c

let is_printable = is_in_range 0x0020 0x007E

let char c =
  if is_printable c then begin
    let buffer = Buffer.create 4 in
    add_utf_8 buffer c;
    Buffer.contents buffer
  end
  else
    format_char c

let is_valid_html_char c = not (is_control_character c || is_non_character c)

let is_valid_xml_char c =
  is_in_range 0x0020 0xD7FF c
  || c = 0x0009
  || c = 0x000A
  || c = 0x000D
  || is_in_range 0xE000 0xFFFD c
  || is_in_range 0x10000 0x10FFFF c

let signal_to_string = function
  | `Comment s ->
    Printf.sprintf "<!--%s-->" s

  | `Doctype d ->
    let text =
      match d.doctype_name with
      | None ->
        begin match d.raw_text with
        | None -> ""
        | Some s -> " " ^ s
        end
      | Some name ->
        match d.public_identifier, d.system_identifier with
        | None, None -> name
        | Some p, None -> Printf.sprintf " %s PUBLIC \"%s\"" name p
        | None, Some s -> Printf.sprintf " %s SYSTEM \"%s\"" name s
        | Some p, Some s -> Printf.sprintf " %s PUBLIC \"%s\" \"%s\"" name p s
    in
    Printf.sprintf "<!DOCTYPE %s>" text

  | `Start_element (name, attributes) ->
    let name_to_string = function
      | "", local_name -> local_name
      | ns, local_name -> ns ^ ":" ^ local_name
    in
    let attributes =
      attributes
      |> List.map (fun (name, value) ->
        Printf.sprintf " %s=\"%s\"" (name_to_string name) value)
      |> String.concat ""
    in
    Printf.sprintf "<%s%s>" (name_to_string name) attributes

  | `End_element ->
    "</...>"

  | `Text ss ->
    String.concat "" ss

  | `Xml x ->
    let s = Printf.sprintf "<?xml version=\"%s\">" x.version in
    let s =
      match x.encoding with
      | None -> s
      | Some encoding -> Printf.sprintf "%s encoding=\"%s\"" s encoding
    in
    let s =
      match x.standalone with
      | None -> s
      | Some standalone ->
        Printf.sprintf
          "%s standalone=\"%s\"" s (if standalone then "yes" else "no")
    in
    s ^ "?>"

  | `PI (target, s) ->
    Printf.sprintf "<?%s %s?>" target s

let token_to_string = function
  | `Xml x ->
    signal_to_string (`Xml x)

  | `Doctype d ->
    signal_to_string (`Doctype d)

  | `Start t ->
    let name = "", t.Token_tag.name in
    let attributes =
      t.Token_tag.attributes |> List.map (fun (n, v) -> ("", n), v) in
    let s = signal_to_string (`Start_element (name, attributes)) in
    if not t.Token_tag.self_closing then s
    else (String.sub s 0 (String.length s - 1)) ^ "/>"

  | `End t ->
    Printf.sprintf "</%s>" t.Token_tag.name

  | `Chars ss ->
    String.concat "" ss

  | `Char i ->
    char i

  | `PI v ->
    signal_to_string (`PI v)

  | `Comment s ->
    signal_to_string (`Comment s)

  | `EOF ->
    "EOF"

let whitespace_chars = " \t\n\r"

let whitespace_prefix_length s =
  let rec loop index =
    if index = String.length s then index
    else
      if String.contains whitespace_chars s.[index] then loop (index + 1)
      else index
  in
  loop 0

let whitespace_suffix_length s =
  let rec loop rindex =
    if rindex = String.length s then rindex
    else
      if String.contains whitespace_chars s.[String.length s - rindex - 1] then
        loop (rindex + 1)
      else rindex
  in
  loop 0

let trim_string_left s =
  let prefix_length = whitespace_prefix_length s in
  String.sub s prefix_length (String.length s - prefix_length)

let trim_string_right s =
  let suffix_length = whitespace_suffix_length s in
  String.sub s 0 (String.length s - suffix_length)

(* String.trim not available for OCaml < 4.00. *)
let trim_string s = s |> trim_string_left |> trim_string_right

(* Specialization of List.mem at string list, to avoid polymorphic
   comparison. *)
let list_mem_string (s : string) l = List.exists (fun s' -> s' = s) l

end
module Markup_error
= struct
#1 "markup_error.ml"
(* This file is part of Markup.ml, released under the BSD 2-clause license. See
   doc/LICENSE for details, or visit https://github.com/aantron/markup.ml. *)

open Markup_common

type t =
  [ `Decoding_error of string * string
  | `Bad_token of string * string * string
  | `Unexpected_eoi of string
  | `Bad_document of string
  | `Unmatched_start_tag of string
  | `Unmatched_end_tag of string
  | `Bad_namespace of string
  | `Misnested_tag of string * string
  | `Bad_content of string ]

let explode_string s =
  let rec iterate index acc =
    if index >= String.length s then List.rev acc
    else iterate (index + 1) (s.[index]::acc)
  in
  iterate 0 []

let to_string ?location error =
  let fmt = Printf.sprintf in

  let message =
    match error with
    | `Decoding_error (bytes, encoding) ->
      begin match String.length bytes with
      | 0 ->
        fmt "bad bytes for encoding '%s'" encoding
      | 1 ->
        fmt "bad byte '0x%02X' for encoding '%s'" (Char.code bytes.[0]) encoding
      | _ ->
        fmt "bad bytes '%s' for encoding '%s'"
          (explode_string bytes
           |> List.map Char.code
           |> List.map (fmt "0x%02X")
           |> String.concat " ")
          encoding
      end

    | `Bad_token (s, production, reason) ->
      fmt "bad token '%s' in %s: %s" s production reason

    | `Unexpected_eoi in_ ->
      fmt "unexpected end of input in %s" in_

    | `Bad_document reason ->
      fmt "bad document: %s" reason

    | `Unmatched_start_tag s ->
      fmt "unmatched start tag '%s'" s

    | `Unmatched_end_tag s ->
      fmt "unmatched end tag '%s'" s

    | `Bad_namespace s ->
      fmt "unknown namespace '%s'" s

    | `Misnested_tag (s, in_) ->
      fmt "misnested tag: '%s' in '%s'" s in_

    | `Bad_content s ->
      fmt "bad content in '%s'" s
  in

  match location with
  | None -> message
  | Some (line, column) -> fmt "line %i, column %i: %s" line column message

type 'a handler = 'a -> t -> unit cps
type parse_handler = location handler
type write_handler = (signal * int) handler

let ignore_errors _ _ _ resume = resume ()

let report_if report condition location detail throw k =
  if condition then report location (detail ()) throw k
  else k ()

end
module Markup_kstream : sig 
#1 "markup_kstream.mli"
(* This file is part of Markup.ml, released under the BSD 2-clause license. See
   doc/LICENSE for details, or visit https://github.com/aantron/markup.ml. *)

(* CPS-friendly streams with elimination form

   next : 'a t -> (exn -> unit) -> (unit -> unit) -> ('a -> unit) -> unit

   where next stream throw e k calls e () if the stream is empty, f v if the
   next value in the stream is v, and throw exn if retrieving the next value
   raises exception exn.

   The *_expected and *_n functions can pass Failure and Invalid_argument,
   respectively, to their exception continuations. Occurence of these exceptions
   indicates programming errors, since the functions are not part of the
   interface of Markup.ml, and the internal code should be calling them only
   when it is statically provable that the functions will succeed. *)

open Markup_common

type 'a t

val make : (exn cont -> unit cont -> 'a cont -> unit) -> 'a t
val construct : 'a t cps -> 'a t
val empty : unit -> 'a t

val next : 'a t -> exn cont -> unit cont -> 'a cont -> unit
val next_option : 'a t -> 'a option cps
val next_expected : 'a t -> 'a cps
val next_n : int -> 'a t -> 'a list cps

val push : 'a t -> 'a -> unit
val push_option : 'a t -> 'a option -> unit
val push_list : 'a t -> 'a list -> unit

val peek : 'a t -> exn cont -> unit cont -> 'a cont -> unit
val peek_option : 'a t -> 'a option cps
val peek_expected : 'a t -> 'a cps
val peek_n : int -> 'a t -> 'a list cps

val tap : ('a -> unit) -> 'a t -> (unit -> unit)
val checkpoint : 'a t -> 'a t * (unit -> unit)

val transform : ('a -> 'b -> ('c list * 'a option) cps) -> 'a -> 'b t -> 'c t
val map : ('a -> 'b cps) -> 'a t -> 'b t
val fold : ('a -> 'b -> 'a cps) -> 'a -> 'b t -> 'a cps
val iter : ('a -> unit cps) -> 'a t -> unit cps
val filter_map : ('a -> 'b option cps) -> 'a t -> 'b t
val filter : ('a -> bool cps) -> 'a t -> 'a t
val of_list : 'a list -> 'a t
val to_list : 'a t -> 'a list cps
val enumerate : 'a t -> (int * 'a) t

end = struct
#1 "markup_kstream.ml"
(* This file is part of Markup.ml, released under the BSD 2-clause license. See
   doc/LICENSE for details, or visit https://github.com/aantron/markup.ml. *)

open Markup_common

type 'a t = {mutable f : exn cont -> unit cont -> 'a cont -> unit}

let make f = {f}

let construct c =
  let s = ref None in
  (fun throw e k ->
    match !s with
    | None -> c throw (fun s' -> s := Some s'; s'.f throw e k)
    | Some s' -> s'.f throw e k)
  |> make

let empty () = (fun _ e _ -> e ()) |> make

let next {f} throw e k = f throw e k

let next_option {f} throw k = f throw (fun () -> k None) (fun v -> k (Some v))

let next_expected {f} throw k =
  f throw (fun () -> throw (Failure "stream empty")) k

let next_n n s throw k =
  if n < 0 then throw (Invalid_argument "n is negative")
  else
    let rec iterate acc = function
      | 0 -> k (List.rev acc)
      | n ->
        next s throw
          (fun () -> iterate acc 0) (fun v -> iterate (v::acc) (n - 1))
    in

    iterate [] n

let push ({f} as s) v = s.f <- fun _ _ k -> s.f <- f; k v

let push_option s = function
  | None -> ()
  | Some v -> push s v

let push_list ({f} as s) = function
  | [] -> ()
  | vs ->
    let remainder = ref vs in
    s.f <- fun throw e k ->
      match !remainder with
      | [] -> s.f <- f; f throw e k
      | v::vs -> remainder := vs; k v

let peek s throw e k = next s throw e (fun v -> push s v; k v)

let peek_option s throw k =
  peek s throw (fun () -> k None) (fun v -> k (Some v))

let peek_expected s throw k =
  peek s throw (fun () -> throw (Failure "stream empty")) k

let peek_n n s throw k = next_n n s throw (fun vs -> push_list s vs; k vs)

let tap g ({f} as s) =
  (s.f <- fun throw e k -> f throw e (fun v -> g v; k v));
  fun () -> s.f <- f

let checkpoint s =
  let buffer = ref [] in
  let s' =
    (fun throw e k ->
      s.f throw e (fun v -> buffer := v::!buffer; k v))
    |> make
  in
  let restore () = push_list s (List.rev !buffer) in
  s', restore

let transform f init s =
  let current_acc = ref (Some init) in
  let to_emit = ref [] in
  let rec operate throw e k =
    match !to_emit with
    | v::more -> to_emit := more; k v
    | [] ->
      match !current_acc with
      | None -> e ()
      | Some acc ->
        next s throw e (fun v ->
          f acc v throw (fun (vs, acc') ->
            to_emit := vs;
            current_acc := acc';
            operate throw e k))
  in
  make operate

let map f s = (fun throw e k -> next s throw e (fun v -> f v throw k)) |> make

let rec fold f v s throw k =
  next s throw
    (fun () -> k v)
    (fun v' -> f v v' throw (fun v'' -> fold f v'' s throw k))

let iter f s throw k = fold (fun () v throw k -> f v throw k) () s throw k

let filter_map f s =
  let rec emit throw e k =
    next s throw e (fun v ->
      f v throw (function
        | None -> emit throw e k
        | Some v -> k v))
  in
  make emit

let filter f s =
  s |> filter_map (fun v throw k ->
    f v throw (function
      | true -> k (Some v)
      | false -> k None))

let of_list l =
  let l = ref l in
  (fun _ e k ->
    match !l with
    | [] -> e ()
    | v::l' -> l := l'; k v)
  |> make

let to_list s throw k =
  fold (fun l v _ k -> k (v::l)) [] s throw (fun l -> k (List.rev l))

let enumerate s =
  let index = ref 0 in
  s |> map (fun v _ k -> index := !index + 1; k ((!index - 1), v))

end
module Markup_namespace : sig 
#1 "markup_namespace.mli"
(* This file is part of Markup.ml, released under the BSD 2-clause license. See
   doc/LICENSE for details, or visit https://github.com/aantron/markup.ml. *)

open Markup_common

module Parsing :
sig
  type context

  val init : (string -> string option) -> context
  val push :
      unit Markup_error.handler ->
      context ->
      string -> (string * string) list ->
        (name * (name * string) list) cps
  val pop : context -> unit
  val expand_element :
    unit Markup_error.handler -> context -> string -> name cps

  val parse : string -> string * string
end

module Writing :
sig
  type context

  val init : (string -> string option) -> context
  val push :
    unit Markup_error.handler ->
    context ->
    name -> (name * string) list ->
      (string * (string * string) list) cps
  val pop : context -> unit
end

end = struct
#1 "markup_namespace.ml"
(* This file is part of Markup.ml, released under the BSD 2-clause license. See
   doc/LICENSE for details, or visit https://github.com/aantron/markup.ml. *)

open Markup_common

let list_map_cps : ('a -> 'b cps) -> 'a list -> 'b list cps =
    fun f l throw k ->

  let rec loop accumulator = function
    | [] -> k (List.rev accumulator)
    | x::l -> f x throw (fun x' -> loop (x'::accumulator) l)
  in
  loop [] l

module Parsing =
struct
  type context_entry =
    {f        : string -> string option;
     previous : context_entry}

  type context = context_entry ref

  let parse qualified_name =
    try
      let colon_index = String.index qualified_name ':' in
      let prefix = String.sub qualified_name 0 colon_index in
      let suffix =
        String.sub qualified_name
          (colon_index + 1)
          (String.length qualified_name - colon_index - 1)
      in
      prefix, suffix

    with Not_found -> ("", qualified_name)

  let init top_level =
    let f = function
      | "xml" -> Some xml_ns
      | "xmlns" -> Some xmlns_ns
      | s -> top_level s
    in
    let rec entry = {f; previous = entry} in
    ref entry

  let expand_element report context raw_element_name throw k =
    let ns, name = parse raw_element_name in
    match !context.f ns with
    | Some uri -> k (uri, name)
    | None ->
      match ns with
      | "" -> k ("", name)
      | prefix ->
        report () (`Bad_namespace prefix) throw (fun () -> k (prefix, name))

  let push report context raw_element_name raw_attributes throw k =
    let parsed_attributes =
      raw_attributes |> List.map (fun (name, value) -> parse name, value) in

    let f =
      parsed_attributes |> List.fold_left (fun f -> function
        | ("xmlns", prefix), uri ->
          (fun p -> if p = prefix then Some uri else f p)
        | ("", "xmlns"), uri ->
          (fun p -> if p = "" then Some uri else f p)
        | _ -> f)
        !context.f
    in

    let entry = {f; previous = !context} in
    context := entry;

    expand_element report context raw_element_name throw
      (fun expanded_element_name ->
    list_map_cps begin fun (name, value) _ k ->
      match name with
      | "", "xmlns" -> k ((xmlns_ns, "xmlns"), value)
      | "", name -> k (("", name), value)
      | ns, name ->
        match f ns with
        | Some uri -> k ((uri, name), value)
        | None ->
          report () (`Bad_namespace ns) throw (fun () -> k ((ns, name), value))
    end parsed_attributes throw (fun expanded_attributes ->
    k (expanded_element_name, expanded_attributes)))

  let pop ({contents = {previous}} as context) =
    context := previous
end

module StringMap = Map.Make (String)

module Writing =
struct
  type context_entry =
    {namespace_to_prefix : string list StringMap.t;
     prefix_to_namespace : string StringMap.t;
     previous            : context_entry}

  type context = context_entry ref * (string -> string option)

  let init top_level =
    let namespace_to_prefix =
      StringMap.empty
      |> StringMap.add "" [""]
      |> StringMap.add xml_ns ["xml"]
      |> StringMap.add xmlns_ns ["xmlns"]
    in

    let prefix_to_namespace =
      StringMap.empty
      |> StringMap.add "" ""
      |> StringMap.add "xml" xml_ns
      |> StringMap.add "xmlns" xmlns_ns
    in

    let rec entry =
      {namespace_to_prefix; prefix_to_namespace; previous = entry} in

    ref entry, top_level

  let lookup report allow_default context namespace throw k =
    let candidate_prefixes =
      try StringMap.find namespace !(fst context).namespace_to_prefix
      with Not_found -> []
    in

    let prefix =
      try
        Some (candidate_prefixes |> List.find (fun prefix ->
          (allow_default || prefix <> "") &&
           begin
            try StringMap.find prefix !(fst context).prefix_to_namespace =
              namespace
            with Not_found -> false
           end))
      with Not_found -> None
    in

    let prefix =
      match prefix with
      | Some _ -> prefix
      | None ->
        match snd context namespace with
        | None -> None
        | Some prefix ->
          if not allow_default && prefix = "" ||
              StringMap.mem prefix !(fst context).prefix_to_namespace then
            None
          else Some prefix
    in

    match prefix with
    | None -> report () (`Bad_namespace namespace) throw (fun () -> k "")
    | Some prefix -> k prefix

  let format prefix name =
    match prefix with
    | "" -> name
    | prefix -> prefix ^ ":" ^ name

  let unexpand_element report context (namespace, name) throw k =
    lookup report true context namespace throw (fun prefix ->
    k (format prefix name))

  let unexpand_attribute report context ((namespace, name), value) throw k =
    match namespace with
    | "" -> k (name, value)
    | uri ->
      if uri = xmlns_ns && name = "xmlns" then k ("xmlns", value)
      else
        lookup report false context namespace throw (fun prefix ->
          k (format prefix name, value))

  let extend k v map =
    let vs =
      try StringMap.find k map
      with Not_found -> []
    in
    StringMap.add k (v::vs) map

  let push report context element_name attributes throw k =
    let namespace_to_prefix, prefix_to_namespace =
      attributes |> List.fold_left (fun (ns_to_prefix, prefix_to_ns) -> function
        | (ns, "xmlns"), uri when ns = xmlns_ns ->
          extend uri "" ns_to_prefix,
          StringMap.add "" uri prefix_to_ns
        | (ns, prefix), uri when ns = xmlns_ns ->
          extend uri prefix ns_to_prefix,
          StringMap.add prefix uri prefix_to_ns
        | _ -> ns_to_prefix, prefix_to_ns)
        (!(fst context).namespace_to_prefix, !(fst context).prefix_to_namespace)
    in

    let entry =
      {namespace_to_prefix; prefix_to_namespace; previous = !(fst context)} in
    (fst context) := entry;

    unexpand_element report context element_name throw (fun element_name ->
    list_map_cps (unexpand_attribute report context) attributes throw
      (fun attributes ->
    k (element_name, attributes)))

  let pop ({contents = {previous}}, _ as context) =
    (fst context) := previous
end

end
module Markup_text
= struct
#1 "markup_text.ml"
open Markup_common

type t =
  {mutable strings  : string list;
   buffer           : Buffer.t;
   mutable location : location option}

(* This is changed for unit testing. *)
let length_limit = ref (Sys.max_string_length / 2)

let prepare () = {strings = []; buffer = Buffer.create 256; location = None}

let note_location text location =
  begin match text.location with
  | None -> text.location <- Some location
  | Some _ -> ()
  end

let adding text location =
  note_location text location;

  if Buffer.length text.buffer >= !length_limit then begin
    text.strings <- (Buffer.contents text.buffer)::text.strings;
    Buffer.clear text.buffer
  end

let add text location c =
  adding text location;
  add_utf_8 text.buffer c

(* This is only used for strings that are expected to be very small, at the
   moment. *)
let add_string text location s =
  adding text location;
  Buffer.add_string text.buffer s

let emit text =
  match text.location with
  | None -> None
  | Some location ->
    text.location <- None;
    if Buffer.length text.buffer = 0 then None
    else begin
      let strings = (Buffer.contents text.buffer)::text.strings |> List.rev in
      text.strings <- [];
      Buffer.clear text.buffer;
      Some (location, strings)
    end

end
module Markup_xml_tokenizer : sig 
#1 "markup_xml_tokenizer.mli"
(* This file is part of Markup.ml, released under the BSD 2-clause license. See
   doc/LICENSE for details, or visit https://github.com/aantron/markup.ml. *)

open Markup_common

type token =
  [ `Xml of xml_declaration
  | `Doctype of doctype
  | `Start of Token_tag.t
  | `End of Token_tag.t
  | `Chars of string list
  | `PI of string * string
  | `Comment of string
  | `EOF ]

val tokenize :
  Markup_error.parse_handler ->
  (string -> string option) ->
  (location * int) Markup_kstream.t * (unit -> location) ->
    (location * token) Markup_kstream.t

end = struct
#1 "markup_xml_tokenizer.ml"
(* This file is part of Markup.ml, released under the BSD 2-clause license. See
   doc/LICENSE for details, or visit https://github.com/aantron/markup.ml. *)

open Markup_common
module Error = Markup_error
module Common = Markup_common
module Kstream = Markup_kstream
module Text = Markup_text

type token =
  [ `Xml of xml_declaration
  | `Doctype of doctype
  | `Start of Token_tag.t
  | `End of Token_tag.t
  | `Chars of string list
  | `PI of string * string
  | `Comment of string
  | `EOF ]

let is_name_start_char c =
  is_in_range 0x0041 0x005A c
  || is_in_range 0x0061 0x007A c
  || c = 0x003A
  || c = 0x005F
  || is_in_range 0x00C0 0x00D6 c
  || is_in_range 0x00D8 0x00F6 c
  || is_in_range 0x00F8 0x02FF c
  || is_in_range 0x0370 0x037D c
  || is_in_range 0x037F 0x1FFF c
  || is_in_range 0x200C 0x200D c
  || is_in_range 0x2070 0x218F c
  || is_in_range 0x2C00 0x2FEF c
  || is_in_range 0x3001 0xD7EF c
  || is_in_range 0xF900 0xFDCF c
  || is_in_range 0xFDF0 0xFFFD c
  || is_in_range 0x10000 0xEFFFF c

let is_name_char c =
  is_name_start_char c
  || is_in_range 0x0030 0x0039 c
  || c = 0x002D
  || c = 0x002E
  || c = 0x00B7
  || is_in_range 0x0300 0x036F c
  || is_in_range 0x203F 0x2040 c

let resolve_builtin_reference = function
  | "quot" -> Some "\""
  | "amp" -> Some "&"
  | "apos" -> Some "'"
  | "lt" -> Some "<"
  | "gt" -> Some ">"
  | _ -> None

open Kstream
open Common.Token_tag

let tokenize report resolve_reference (input, get_location) =
  let resolve_reference s =
    match resolve_builtin_reference s with
    | Some _ as v -> v
    | None -> resolve_reference s
  in

  let report_if = Error.report_if report in

  let throw = ref (fun _ -> ()) in
  let ended = ref (fun _ -> ()) in
  let output = ref (fun _ -> ()) in

  let parse_reference l' k =
    let input, restore = checkpoint input in
    let unresolved () = restore (); k None in
    let k s = k (Some s) in

    let unexpected_eoi () =
      report (get_location ()) (`Unexpected_eoi "reference") !throw (fun () ->
      unresolved ())
    in

    let character_reference filter notation_prefix reference_prefix =
      let buffer = Buffer.create 32 in
      let rec read () =
        next input !throw unexpected_eoi begin function
          | _, 0x003B ->
            if Buffer.length buffer = 0 then
              report l' (`Bad_token
                (Printf.sprintf "&#%s;" reference_prefix, "reference",
                 "empty character reference")) !throw unresolved

            else
              let s = Buffer.contents buffer in
              let maybe_n =
                try Some (int_of_string (notation_prefix ^ s))
                with Failure _ -> None
              in

              begin match maybe_n with
              | None ->
                report l' (`Bad_token
                  (Printf.sprintf "&#%s%s;" reference_prefix s, "reference",
                   "number out of range")) !throw unresolved

              | Some n -> k (char n)
              end

          | _, c when filter c ->
            add_utf_8 buffer c;
            read ()

          | l, c ->
            report l (`Bad_token (char c, "reference", "expected digit")) !throw
              unresolved
        end
      in
      read ()
    in

    next input !throw unexpected_eoi begin function
      | _, 0x003B ->
        report l'
          (`Bad_token ("&;", "reference", "empty reference")) !throw unresolved

      | _, 0x0023 ->
        next input !throw unexpected_eoi begin function
          | _, 0x0078 ->
            character_reference is_hex_digit "0x" "x"

          | _, c as v when is_digit c || c = 0x003B ->
            push input v;
            character_reference is_digit "" ""

          | l, c ->
            report l (`Bad_token (char c, "reference", "expected digit")) !throw
              unresolved
        end

      | _, c when is_name_start_char c ->
        let buffer = Buffer.create 32 in
        add_utf_8 buffer c;
        let rec read () =
          next input !throw unexpected_eoi begin function
            | _, 0x003B ->
              let s = Buffer.contents buffer in
              begin match resolve_reference s with
              | Some s -> k s
              | None ->
                report l' (`Bad_token (s, "reference", "unknown entity")) !throw
                  unresolved
              end

            | _, c when is_name_char c ->
              add_utf_8 buffer c;
              read ()

            | l, c ->
              report l
                (`Bad_token (char c, "reference", "invalid name character"))
                !throw unresolved
          end
        in
        read ()

      | l, c ->
        report l (`Bad_token (char c, "reference", "invalid start character"))
          !throw unresolved
    end
  in

  let extra_whitespace where l c k =
    report l (`Bad_token (char c, where, "whitespace not allowed here"))
      !throw k
  in

  let rec consume_whitespace k =
    next input !throw k (function
      | _, c when is_whitespace c -> consume_whitespace k
      | v -> push input v; k ())
  in

  let parse_attribute with_references terminators l k' =
    let name_buffer = Buffer.create 32 in
    let value_buffer = Buffer.create 256 in
    let quote_opened = ref false in
    let quote_closed = ref false in

    let finish () =
      if Buffer.length name_buffer = 0 then k' None
      else
        let emit () = 
          k' (Some (Buffer.contents name_buffer, Buffer.contents value_buffer))
        in

        if !quote_opened then
          if not !quote_closed then
            report (get_location ()) (`Unexpected_eoi "attribute value") !throw
              emit
          else
            emit ()
        else
          if Buffer.length value_buffer = 0 then
            report l (`Bad_token
              (Buffer.contents name_buffer, "attribute", "has no value")) !throw
              emit
          else
            emit ()
    in

    let next' f =
      next input !throw finish begin function
        | _, c as v when List.mem c terminators ->
          push input v;
          finish ();

        | v -> f v
      end
    in

    let rec name_start_state () =
      next' begin function
        | l, c ->
          report_if (not @@ is_name_start_char c) l (fun () ->
            `Bad_token (char c, "attribute", "invalid start character"))
            !throw (fun () ->
          add_utf_8 name_buffer c;
          name_state ())
      end

    and name_state () =
      next' begin function
        | _, 0x003D ->
          value_state ()

        | l, c when is_whitespace c ->
          extra_whitespace "attribute" l c (fun () ->
          consume_whitespace equals_state)

        | l, c ->
          report_if (not @@ is_name_start_char c) l (fun () ->
            `Bad_token (char c, "attribute", "invalid name character"))
            !throw (fun () ->
          add_utf_8 name_buffer c;
          name_state ())
      end

    and equals_state () =
      next' begin function
        | _, 0x003D ->
          value_state ()

        | v ->
          push input v;
          finish ()
      end

    and value_state () =
      next' begin function
        | l, c when is_whitespace c ->
          extra_whitespace "attribute" l c (fun () ->
          consume_whitespace value_state)

        | _, (0x0022 | 0x0027 as c) ->
          quote_opened := true;
          quoted_value_state c

        | l, c as v ->
          push input v;
          report l (`Bad_token (char c, "attribute", "unquoted value"))
            !throw unquoted_value_state
      end

    and handle_ampersand l state =
      parse_reference l begin function
        | Some s ->
          Buffer.add_string value_buffer s;
          state ()

        | None ->
          report l
            (`Bad_token ("&", "attribute", "replace with '&amp;'"))
            !throw (fun () ->
          add_utf_8 value_buffer 0x0026;
          state ())
      end

    and handle_lt l state =
      report l (`Bad_token ("<", "attribute", "replace with '&lt;'")) !throw
        (fun () ->
      add_utf_8 value_buffer 0x003C;
      state ())

    and quoted_value_state quote =
      next input !throw finish begin function
        | _, c when c = quote ->
          quote_closed := true;
          finish ()

        | l, 0x0026 when with_references ->
          handle_ampersand l (fun () ->
          quoted_value_state quote)

        | l, 0x003C ->
          handle_lt l (fun () ->
          quoted_value_state quote)

        | _, c ->
          add_utf_8 value_buffer c;
          quoted_value_state quote
      end

    and unquoted_value_state () =
      next' begin function
        | _, c as v when is_whitespace c ->
          push input v;
          finish ()

        | l, 0x0026 when with_references ->
          handle_ampersand l unquoted_value_state

        | l, 0x003C ->
          handle_lt l unquoted_value_state

        | _, c ->
          add_utf_8 value_buffer c;
          unquoted_value_state ()
      end

    in

    name_start_state ()
  in

  let parse_declaration_or_processing_instruction l k =
    let pi = "processing instruction" in
    let xml = "xml declaration" in

    let target_buffer = Buffer.create 32 in
    let text_buffer = Buffer.create 512 in
    let attributes = ref [] in

    let next' context finish f =
      let rec initial_state () =
        next input !throw (fun () ->
          report (get_location ()) (`Unexpected_eoi context) !throw finish)
        begin function
          | l, 0x003F ->
            question_mark_state l

          | v ->
            f v
        end

      and question_mark_state l =
        next input !throw (fun () ->
          report (get_location ()) (`Unexpected_eoi context) !throw finish)
        begin function
          | _, 0x003E ->
            finish ()

          | v ->
            push input v;
            f (l, 0x003F)
        end

      in
      initial_state ()
    in

    let rec target_start_state () =
      next' pi finish_pi begin function
        | l, c when is_whitespace c ->
          extra_whitespace pi l c (fun () ->
          consume_whitespace target_start_state)

        | l, c ->
          report_if (not @@ is_name_start_char c) l (fun () ->
            `Bad_token (char c, pi, "invalid start character")) !throw
            (fun () ->
          add_utf_8 target_buffer c;
          target_state ())
      end

    and target_state () =
      next' pi finish_pi begin function
        | _, c when is_whitespace c ->
          if String.lowercase (Buffer.contents target_buffer) = "xml" then
            xml_declaration_state ()
          else
            text_state ()

        | l, c ->
          report_if (not @@ is_name_char c) l (fun () ->
            `Bad_token (char c, pi, "invalid name character")) !throw
            (fun () ->
          add_utf_8 target_buffer c;
          target_state ())
      end

    and text_state () =
      next' pi finish_pi (fun (_, c) ->
        add_utf_8 text_buffer c;
        text_state ())

    and xml_declaration_state () =
      next' xml finish_xml begin function
        | _, c when is_whitespace c ->
          xml_declaration_state ()

        | _, 0x003F ->
          xml_declaration_state ()

        | l, _ as v ->
          push input v;
          parse_attribute false [0x003F] l (function
            | None -> xml_declaration_state ()
            | Some (name, value) ->
              attributes := (l, name, value)::!attributes;
              xml_declaration_state ())
      end

    and finish_pi () =
      if Buffer.length target_buffer = 0 then
        report l (`Bad_token ("<?...", pi, "empty")) !throw (fun () ->
        k None)
      else
        if String.lowercase (Buffer.contents target_buffer) = "xml" then
          finish_xml ()
        else
          k (Some
            (`PI (Buffer.contents target_buffer, Buffer.contents text_buffer)))

    and finish_xml () =
      let split f l =
        let rec scan prefix = function
          | x::suffix when f x -> Some (List.rev prefix, x, suffix)
          | x::suffix -> scan (x::prefix) suffix
          | [] -> None
        in
        scan [] l
      in

      let matches s (_, name, _) = String.lowercase name = s in

      let version_valid s =
        String.length s = 3 &&
        s.[0] = '1' && s.[1] = '.' && is_digit (Char.code s.[2])
      in

      let rec check_name attributes =
        let target = Buffer.contents target_buffer in
        report_if (target <> "xml") l (fun () ->
          `Bad_token (target, xml, "must be 'xml'")) !throw (fun () ->
        version_state attributes)

      and version_state attributes =
        match split (matches "version") attributes with
        | None ->
          report l (`Bad_token ("<?xml...", xml, "missing version")) !throw
            (fun () ->
          encoding_state "1.0" attributes)

        | Some (prefix, (l, name, value), suffix) ->
          report_if (name <> "version") l (fun () ->
            `Bad_token (name, xml, "must be 'version'")) !throw (fun () ->
          report_if (List.length prefix <> 0) l (fun () ->
            `Bad_token (name, xml, "must be first")) !throw (fun () ->
          report_if (not @@ version_valid value) l (fun () ->
            `Bad_token (value, xml, "must match 1.x")) !throw (fun () ->
          encoding_state value (prefix @ suffix))))

      and encoding_state version attributes =
        match split (matches "encoding") attributes with
        | None ->
          standalone_state version None 0 attributes

        | Some (prefix, (l, name, value), suffix) ->
          report_if (name <> "encoding") l (fun () ->
            `Bad_token (name, xml, "must be 'encoding'")) !throw (fun () ->
          standalone_state
            version (Some value) (List.length prefix) (prefix @ suffix))

      and standalone_state version encoding encoding_index attributes =
        match split (matches "standalone") attributes with
        | None ->
          final_state version encoding None attributes

        | Some (prefix, (l, name, value), suffix) ->
          report_if (name <> "standalone") l (fun () ->
            `Bad_token (name, xml, "must be 'standalone'")) !throw (fun () ->
          report_if (List.length prefix < encoding_index) l (fun () ->
            `Bad_token (name, xml, "must come after 'encoding'")) !throw
            (fun () ->

          (fun k ->
            match value with
            | "yes" -> k (Some true)
            | "no" -> k (Some false)
            | _ ->
              report l
                (`Bad_token (value, xml, "must be 'yes' or 'no'")) !throw
                (fun () ->
              match String.lowercase value with
              | "yes" -> k (Some true)
              | "no" -> k (Some false)
              | _ -> k None))
          (fun v ->
            final_state version encoding v (prefix @ suffix))))

      and final_state version encoding standalone attributes =
        (fun k ->
          match attributes with
          | (l, name, _)::_ ->
            report l (`Bad_token (name, xml, "not allowed here")) !throw k
          | [] -> k ())
        (fun () ->
          k (Some (`Xml {version; encoding; standalone})))

      in
      check_name (List.rev !attributes)
    in

    target_start_state ()
  in

  let text = Text.prepare () in
  let note_character_location = Text.note_location text in
  let add_character = Text.add text in
  let add_string = Text.add_string text in

  let rec current_state = ref initial_state

  and emit' l t s = current_state := s; !output (l, t)

  and emit_chars state =
    match Text.emit text with
    | None -> state ()
    | Some (l, strings) ->
      emit' l (`Chars strings) state

  and emit l t state =
    emit_chars (fun () ->
    emit' l t state)

  and emit_eoi ?during () =
    let l = get_location () in
    emit_chars (fun () ->
      (fun k' ->
        match during with
        | None -> k' ()
        | Some production ->
          report l (`Unexpected_eoi production) !throw k')
      (fun () ->
        emit' l `EOF (fun () -> !ended ())))

  and emit_start l name self_closing attributes state =
    let tag = {name = name; self_closing; attributes = List.rev attributes} in
    emit l (`Start tag) state

  and emit_end l name state =
    let tag = {name = name; self_closing = false; attributes = []} in
    emit l (`End tag) state

  and emit_doctype l buffer s =
    let doctype =
      {doctype_name      = None;
       public_identifier = None;
       system_identifier = None;
       raw_text          = Some (Buffer.contents buffer);
       force_quirks      = false}
    in
    emit l (`Doctype doctype) s

  and lt_in_text l k =
    report l (`Bad_token ("<", "text", "replace with '&lt;'")) !throw k

  and initial_state () =
    next input !throw (fun () -> emit_eoi ()) begin function
      | l, (0x005D as c) ->
        add_character l c;
        one_bracket_state l

      | l, 0x003C ->
        begin_markup_state l

      | l, (0x0026 as c) ->
        parse_reference l (function
          | None ->
            report l (`Bad_token (char c, "text", "replace with '&amp;'"))
              !throw (fun () ->
            add_character l c;
            initial_state ())

          | Some s ->
            add_string l s;
            initial_state ())

      | l, c ->
        add_character l c;
        initial_state ()
    end

  and one_bracket_state l' =
    next_option input !throw begin function
      | Some (l, (0x005D as c)) ->
        add_character l c;
        two_brackets_state l' l

      | v ->
        push_option input v;
        initial_state ()
    end

  and two_brackets_state l' l'' =
    next_option input !throw begin function
      | Some (l, (0x003E as c)) ->
        report l' (`Bad_token ("]]>", "text", "must end a CDATA section"))
          !throw (fun () ->
        add_character l c;
        initial_state ())

      | Some (l, (0x005D as c)) ->
        add_character l c;
        two_brackets_state l'' l

      | v ->
        push_option input v;
        initial_state ()
    end

  and begin_markup_state l' =
    let recover v =
      lt_in_text l' (fun () ->
      add_character l' 0x003C;
      push_option input v;
      initial_state ())
    in

    next input !throw (fun () ->
      report (get_location ()) (`Unexpected_eoi "tag") !throw
      (fun () -> recover None))
    begin function
      | _, 0x0021 ->
        comment_cdata_or_doctype_state l'

      | _, 0x003F ->
        parse_declaration_or_processing_instruction l' (function
          | None -> initial_state ()
          | Some token -> emit l' token initial_state)

      | _, 0x002F ->
        end_tag_state l'

      | _, c when is_name_start_char c ->
        let tag_name_buffer = Buffer.create 32 in
        add_utf_8 tag_name_buffer c;
        start_tag_state l' tag_name_buffer

      | l, c as v ->
        report l (`Bad_token (char c, "tag", "invalid start character"))
          !throw (fun () ->
        recover (Some v))
    end

  and start_tag_state l' buffer =
    let recover v =
      lt_in_text l' (fun () ->
      add_character l' 0x003C;
      add_string l' (Buffer.contents buffer);
      push_option input v;
      initial_state ())
    in

    next input !throw (fun () ->
      report (get_location ()) (`Unexpected_eoi "tag") !throw (fun () ->
      recover None))
    begin function
      | _, 0x003E ->
        emit_start l' (Buffer.contents buffer) false [] initial_state

      | l, 0x002F ->
        close_empty_element_state l' l (Buffer.contents buffer) []

      | _, c when is_whitespace c ->
        attributes_state l' (Buffer.contents buffer) []

      | _, c when is_name_char c ->
        add_utf_8 buffer c;
        start_tag_state l' buffer

      | l, c as v ->
        report l (`Bad_token (char c, "tag", "invalid name character"))
          !throw (fun () ->
        recover (Some v))
    end

  and attributes_state l' tag_name attributes =
    next input !throw begin fun () ->
      emit_start l' tag_name false attributes (fun () ->
      emit_eoi ~during:"tag" ())
    end
    begin function
      | _, c when is_whitespace c ->
        attributes_state l' tag_name attributes

      | _, 0x003E ->
        emit_start l' tag_name false attributes initial_state

      | l, 0x002F ->
        close_empty_element_state l' l tag_name attributes

      | l, _ as v ->
        push input v;
        parse_attribute true [0x003E; 0x002F] l (function
          | None -> attributes_state l' tag_name attributes
          | Some (name, value) ->
            attributes_state l' tag_name ((name, value)::attributes))
    end

  and close_empty_element_state l' l'' name attributes =
    next input !throw begin fun () ->
      emit_start l' name true attributes (fun () ->
      emit_eoi ~during:"tag" ())
    end
    begin function
      | _, 0x003E ->
        emit_start l' name true attributes initial_state

      | v ->
        report l'' (`Bad_token (char 0x002F, "tag", "should be part of '/>'"))
          !throw (fun () ->
        push input v;
        attributes_state l' name attributes)
    end

  and end_tag_state l' =
    let recover v =
      lt_in_text l' (fun () ->
      add_character l' 0x003C;
      add_character l' 0x002F;
      push_option input v;
      initial_state ())
    in

    next input !throw (fun () ->
      report (get_location ()) (`Unexpected_eoi "tag") !throw (fun () ->
      recover None))
    begin function
      | _, c when is_name_start_char c ->
        let name_buffer = Buffer.create 32 in
        add_utf_8 name_buffer c;
        end_tag_name_state l' name_buffer

      | l, c as v ->
        report l (`Bad_token (char c, "tag", "invalid start character"))
          !throw (fun () ->
        recover (Some v))
    end

  and end_tag_name_state l' buffer =
    let recover v =
      lt_in_text l' (fun () ->
      add_character l' 0x003C;
      add_character l' 0x002F;
      add_string l' (Buffer.contents buffer);
      push_option input v;
      initial_state ())
    in

    next input !throw (fun () ->
      report (get_location ()) (`Unexpected_eoi "tag") !throw (fun () ->
      recover None))
    begin function
      | _, 0x003E ->
        emit_end l' (Buffer.contents buffer) initial_state

      | _, c when is_whitespace c ->
        end_tag_whitespace_state false l' (Buffer.contents buffer)

      | _, c when is_name_char c ->
        add_utf_8 buffer c;
        end_tag_name_state l' buffer

      | l, c as v ->
        report l (`Bad_token (char c, "tag", "invalid name character"))
          !throw (fun () ->
        recover (Some v))
    end

  and end_tag_whitespace_state reported l' name =
    next input !throw begin fun () ->
      emit_end l' name (fun () ->
      emit_eoi ~during:"tag" ())
    end
    begin function
      | _, 0x003E ->
        emit_end l' name initial_state

      | _, c when is_whitespace c ->
        end_tag_whitespace_state reported l' name

      | l, c ->
        if not reported then
          report l (`Bad_token (char c, "tag", "attribute in end tag"))
            !throw (fun () ->
          end_tag_whitespace_state true l' name)
        else
          end_tag_whitespace_state reported l' name
    end

  and bad_comment_start s l k' =
    report l (`Bad_token (s, "comment", "should start with '<!--'"))
      !throw (fun () ->
    lt_in_text l k')

  and comment_cdata_or_doctype_state l' =
    next_option input !throw begin function
      | Some (_, 0x002D) ->
        comment_start_state l'

      | Some (_, 0x005B) ->
        cdata_start_state l'

      | Some (_, 0x0044) ->
        doctype_start_state l'

      | v ->
        bad_comment_start "<!" l' (fun () ->
        add_character l' 0x003C;
        add_character l' 0x0021;
        push_option input v;
        initial_state ())
    end

  and comment_start_state l' =
    next_option input !throw begin function
      | Some (_, 0x002D) ->
        comment_state l' (Buffer.create 256)

      | v ->
        bad_comment_start "<!-" l' (fun () ->
        add_character l' 0x003C;
        add_character l' 0x0021;
        add_character l' 0x002D;
        push_option input v;
        initial_state ())
    end

  and unterminated_comment l buffer =
    emit l (`Comment (Buffer.contents buffer)) (fun () ->
    emit_eoi ~during:"comment" ())

  and comment_state l' buffer =
    next input !throw (fun () -> unterminated_comment l' buffer)
    begin function
      | l, 0x002D ->
        comment_one_dash_state l' l buffer

      | _, c ->
        add_utf_8 buffer c;
        comment_state l' buffer
    end

  and comment_one_dash_state l' l'' buffer =
    next input !throw (fun () -> unterminated_comment l' buffer)
    begin function
      | _, 0x002D ->
        comment_two_dashes_state false l' l'' buffer

      | _, c ->
        add_utf_8 buffer 0x002D;
        add_utf_8 buffer c;
        comment_state l' buffer
    end

  and comment_two_dashes_state reported l' l'' buffer =
    let recover k' =
      if reported then k' ()
      else
        report l''
          (`Bad_token ("--", "comment", "should be followed by '>'")) !throw k'
    in

    next input !throw (fun () -> unterminated_comment l' buffer)
    begin function
      | _, 0x003E ->
        emit l' (`Comment (Buffer.contents buffer)) initial_state

      | _, 0x002D ->
        recover (fun () ->
        add_utf_8 buffer 0x002D;
        comment_two_dashes_state true l' l'' buffer)

      | _, c ->
        recover (fun () ->
        add_utf_8 buffer 0x002D;
        add_utf_8 buffer 0x002D;
        add_utf_8 buffer c;
        comment_state l' buffer)
    end

  and cdata_start_state l' =
    next_n 6 input !throw begin function
      | [_, 0x43; _, 0x44; _, 0x41; _, 0x54; _, 0x41; _, 0x005B] ->
        note_character_location l';
        cdata_state l'

      | cs ->
        report l' (`Bad_token ("<![", "cdata", "should start with '<![CDATA['"))
          !throw (fun () ->
        lt_in_text l' (fun () ->
        push_list input cs;
        add_character l' 0x003C;
        add_character l' 0x0021;
        add_character l' 0x005B;
        initial_state ()))
    end

  and cdata_state l' =
    next input !throw (fun () -> emit_eoi ~during:"cdata" ())
    begin function
      | l, 0x005D ->
        cdata_one_bracket_state l' l

      | l, c ->
        add_character l c;
        cdata_state l'
    end

  and cdata_one_bracket_state l' l'' =
    next input !throw (fun () -> emit_eoi ~during:"cdata" ())
    begin function
      | l, 0x005D ->
        cdata_two_brackets_state l' l'' l

      | l, c ->
        add_character l'' 0x005D;
        add_character l c;
        cdata_state l'
    end

  and cdata_two_brackets_state l' l'' l''' =
    next input !throw (fun () -> emit_eoi ~during:"cdata" ())
    begin function
      | _, 0x003E ->
        initial_state ()

      | l, 0x005D ->
        add_character l'' 0x005D;
        cdata_two_brackets_state l' l''' l

      | l, c ->
        add_character l'' 0x005D;
        add_character l''' 0x005D;
        add_character l c;
        cdata_state l'
    end

  and doctype_start_state l' =
    next_n 7 input !throw begin function
      | [_, 0x4F; _, 0x43; _, 0x54; _, 0x59; _, 0x50; _, 0x45; _, c]
          when is_whitespace c ->
        doctype_state l' (Buffer.create 512)

      | cs ->
        report l'
          (`Bad_token ("<!D", "doctype", "should start with '<!DOCTYPE '"))
          !throw (fun () ->
        lt_in_text l' (fun () ->
        push_list input cs;
        add_character l' 0x003C;
        add_character l' 0x0021;
        add_character l' 0x0044;
        initial_state ()))
    end

  and unterminated_doctype l buffer =
    emit_doctype l buffer (fun () ->
    emit_eoi ~during:"doctype" ())

  and doctype_state l' buffer =
    next input !throw (fun () -> unterminated_doctype l' buffer)
    begin function
      | _, 0x003E ->
        emit_doctype l' buffer initial_state

      | _, (0x0022 | 0x0027 as c) ->
        add_utf_8 buffer c;
        doctype_quoted_state (fun () -> doctype_state l' buffer) c l' buffer

      | _, (0x003C as c) ->
        add_utf_8 buffer c;
        doctype_item_state (fun () -> doctype_state l' buffer) l' buffer

      | _, c ->
        add_utf_8 buffer c;
        doctype_state l' buffer
    end

  and doctype_quoted_state state quote l' buffer =
    next input !throw (fun () -> unterminated_doctype l' buffer)
    begin function
      | _, c when c = quote ->
        add_utf_8 buffer c;
        state ()

      | _, c ->
        add_utf_8 buffer c;
        doctype_quoted_state state quote l' buffer
    end

  and doctype_item_state state l' buffer =
    next input !throw (fun () -> unterminated_doctype l' buffer)
    begin function
      | _, (0x0021 as c) ->
        add_utf_8 buffer c;
        doctype_declaration_state state l' buffer

      | l, (0x003F as c) ->
        add_utf_8 buffer c;
        let undo = tap (fun (_, c) -> add_utf_8 buffer c) input in
        parse_declaration_or_processing_instruction l (fun _ ->
        undo ();
        state ())

      | _, c ->
        add_utf_8 buffer c;
        state ()
    end

  and doctype_declaration_state state l' buffer =
    next input !throw (fun () -> unterminated_doctype l' buffer)
    begin function
      | _, (0x003E as c) ->
        add_utf_8 buffer c;
        state ()

      | _, (0x0022 | 0x0027 as c) ->
        add_utf_8 buffer c;
        doctype_quoted_state
          (fun () -> doctype_declaration_state state l' buffer) c l' buffer

      | _, c ->
        add_utf_8 buffer c;
        doctype_declaration_state state l' buffer
    end

  in

  (fun throw_ e k ->
    throw := throw_;
    ended := e;
    output := k;
    !current_state ())
  |> make

end
module Markup__xml_parser : sig 
#1 "markup__xml_parser.mli"
(* This file is part of Markup.ml, released under the BSD 2-clause license. See
   doc/LICENSE for details, or visit https://github.com/aantron/markup.ml. *)

open Markup_common

val parse :
  [< `Document | `Fragment ] option ->
  (string -> string option) ->
  Markup_error.parse_handler ->
  (location * Markup_xml_tokenizer.token) Markup_kstream.t ->
    (location * signal) Markup_kstream.t

end = struct
#1 "markup__xml_parser.ml"
(* This file is part of Markup.ml, released under the BSD 2-clause license. See
   doc/LICENSE for details, or visit https://github.com/aantron/markup.ml. *)

open Markup_common
open Markup_kstream
open Token_tag
module Namespace = Markup_namespace

let is_whitespace_only strings = List.for_all is_whitespace_only strings

let parse context namespace report tokens =
  let open_elements = ref [] in
  let namespaces = Namespace.Parsing.init namespace in
  let is_fragment = ref false in
  let fragment_allowed = ref true in

  let throw = ref (fun _ -> ()) in
  let ended = ref (fun _ -> ()) in
  let output = ref (fun _ -> ()) in

  let rec current_state = ref (fun () ->
    match context with
    | None -> initial_state []
    | Some `Document ->
      fragment_allowed := false;
      document_state ()
    | Some `Fragment ->
      is_fragment := false;
      content_state ())

  and emit l signal state = current_state := state; !output (l, signal)

  and push_and_emit l {name = raw_name; attributes} state =
    Namespace.Parsing.push (fun () -> report l) namespaces raw_name attributes
      !throw (fun (expanded_name, attributes) ->

    let rec deduplicate acc attributes k =
      match attributes with
      | [] -> k (List.rev acc)
      | ((n, _) as attr)::more ->
        if acc |> List.exists (fun (n', _) -> n' = n) then
          report l (`Bad_token (snd n, "tag", "duplicate attribute")) !throw
            (fun () -> deduplicate acc more k)
        else
          deduplicate (attr::acc) more k
    in

    deduplicate [] attributes (fun attributes ->
    open_elements := (l, expanded_name, raw_name)::!open_elements;
    emit l (`Start_element (expanded_name, attributes)) state))

  and pop l state =
    match !open_elements with
    | [] -> state ()
    | _::more ->
      Namespace.Parsing.pop namespaces;
      open_elements := more;
      emit l `End_element state

  and emit_end () =
    current_state := (fun () -> !ended ());
    !ended ()

  and initial_state leading =
    next_expected tokens !throw begin function
      | _, (`Xml _ | `Doctype _ | `Start _ | `End _) as v ->
        push tokens v;
        push_list tokens (List.rev leading);
        document_state ()

      | _, `Chars s as v when is_whitespace_only s ->
        initial_state (v::leading)

      | _, (`Comment _ | `PI _) as v ->
        initial_state (v::leading)

      | _, (`Chars _ | `EOF) as v ->
        is_fragment := true;
        push tokens v;
        push_list tokens (List.rev leading);
        content_state ()
    end

  and document_state () =
    next_expected tokens !throw begin function
      | l, `Xml declaration ->
        fragment_allowed := false;
        emit l (`Xml declaration) doctype_state

      | v ->
        push tokens v;
        doctype_state ()
    end

  and doctype_state () =
    next_expected tokens !throw begin function
      | l, `Doctype d ->
        fragment_allowed := false;
        emit l (`Doctype d) root_state

      | _, `Chars s when is_whitespace_only s ->
        doctype_state ()

      | l, `Comment s ->
        emit l (`Comment s) doctype_state

      | l, `PI s ->
        emit l (`PI s) doctype_state

      | l, `Xml _ ->
        report l (`Bad_document "XML declaration must be first") !throw
          doctype_state

      | l, `Chars _ ->
        report l (`Bad_document "text at top level") !throw doctype_state

      | v ->
        push tokens v;
        root_state ()
    end

  and root_state () =
    next_expected tokens !throw begin function
      | l, `Start t ->
        if t.self_closing then
          push_and_emit l t (fun () ->
          pop l after_root_state)
        else
          push_and_emit l t content_state

      | _, `Chars s when is_whitespace_only s ->
        root_state ()

      | l, `Comment s ->
        emit l (`Comment s) root_state

      | l, `PI s ->
        emit l (`PI s) root_state

      | l, `Xml _ ->
        report l (`Bad_document "XML declaration must be first") !throw
          root_state

      | l, `EOF ->
        report l (`Unexpected_eoi "document before root element") !throw
          emit_end

      | l, _ ->
        report l (`Bad_document "expected root element") !throw root_state
    end

  and after_root_state () =
    next_expected tokens !throw begin function
      | _, `Chars s when is_whitespace_only s ->
        after_root_state ()

      | l, `Comment s ->
        emit l (`Comment s) after_root_state

      | l, `PI s ->
        emit l (`PI s) after_root_state

      | _, `EOF ->
        emit_end ()

      | _, (`Chars _ | `Start _ | `End _) as v when !fragment_allowed ->
        is_fragment := true;
        push tokens v;
        content_state ()

      | l, _ as v ->
        report l (`Bad_document "not allowed after root element") !throw
          (fun () ->
        is_fragment := true;
        push tokens v;
        content_state ())
    end

  and content_state () =
    next_expected tokens !throw begin function
      | l, `Start t ->
        if t.self_closing then
          push_and_emit l t (fun () ->
          pop l content_state)
        else
          push_and_emit l t content_state

      | l, `End {name = raw_name} ->
        Namespace.Parsing.expand_element (fun () -> report l) namespaces
          raw_name !throw (fun expanded_name ->

        let is_on_stack =
          !open_elements
          |> List.exists (fun (_, name, _) -> name = expanded_name)
        in

        if not is_on_stack then
          report l (`Unmatched_end_tag raw_name) !throw content_state
        else
          let rec pop_until_match () =
            match !open_elements with
            | (_, name, _)::_ when name = expanded_name ->
              pop l (fun () ->
              match !open_elements with
              | [] when not !is_fragment -> after_root_state ()
              | _ -> content_state ())

            | (l', _, name)::_ ->
              report l' (`Unmatched_start_tag name) !throw (fun () ->
              pop l pop_until_match)

            | _ -> failwith "impossible"
          in
          pop_until_match ())

      | l, `Chars s ->
        emit l (`Text s) content_state

      | l, `PI s ->
        emit l (`PI s) content_state

      | l, `Comment s ->
        emit l (`Comment s) content_state

      | l, `EOF ->
        let rec pop_stack () =
          match !open_elements with
          | [] -> emit_end ()
          | (l', _, raw_name)::_ ->
            report l' (`Unmatched_start_tag raw_name) !throw (fun () ->
            pop l pop_stack)
        in
        pop_stack ()

      | l, `Xml _ ->
        report l (`Bad_document "XML declaration should be at top level") !throw
          content_state

      | l, `Doctype _ ->
        report l (`Bad_document "doctype should be at top level") !throw
          content_state
    end

  in

  (fun throw_ e k ->
    throw := throw_;
    ended := e;
    output := k;
    !current_state ())
  |> make

end
module Markup_encoding
= struct
#1 "markup_encoding.ml"
(* This file is part of Markup.ml, released under the BSD 2-clause license. See
   doc/LICENSE for details, or visit https://github.com/aantron/markup.ml. *)

open Markup_common
open Markup_kstream
module Kstream = Markup_kstream
module Error = Markup_error

type t = ?report:Error.parse_handler -> char Kstream.t -> int Kstream.t

let wrap f = fun ?(report = Error.ignore_errors) s -> f report s

let bytes_empty = Bytes.create 0

(* Decoders based on the Uutf library. *)
let uutf_decoder encoding name =
  (fun report bytes ->
    let decoder = Uutf.decoder ~encoding `Manual in

    (fun throw empty k ->
      let rec run () =
        match Uutf.decode decoder with
        | `End -> empty ()
        | `Uchar c -> k (Uchar.to_int c)
        | `Malformed s ->
          let location = Uutf.decoder_line decoder, Uutf.decoder_col decoder in
          report location (`Decoding_error (s, name)) throw (fun () ->
          k u_rep)
        | `Await ->
          next bytes throw
            (fun () -> Uutf.Manual.src decoder bytes_empty 0 0; run ())
            (fun c -> Uutf.Manual.src decoder (Bytes.make 1 c) 0 1; run ())
      in
      run ())
    |> make)
  |> wrap

let utf_8 : t = uutf_decoder `UTF_8 "utf-8"
let utf_16be : t = uutf_decoder `UTF_16BE "utf-16be"
let utf_16le : t = uutf_decoder `UTF_16LE "utf-16le"
let iso_8859_1 : t = uutf_decoder `ISO_8859_1 "iso-8859-1"
let us_ascii : t = uutf_decoder `US_ASCII "us-ascii"

(* Chooses UTF-16LE unless the BE BOM is present, as in
   http://www.w3.org/TR/encoding/ *)
let utf_16 : t =
  (fun report bytes ->
    let constructor =
      fun throw k ->
        peek_n 2 bytes throw (function
        | ['\xFE'; '\xFF'] -> k (utf_16be ~report bytes)
        | _ -> k (utf_16le ~report bytes))
    in
    construct constructor)
  |> wrap

let ucs_4_decoder arrange name =
  (fun report bytes ->
    let first = ref true in
    let line = ref 1 in
    let column = ref 1 in

    let char k c =
      column := !column + 1;
      k c
    in

    let newline k c =
      column := 1;
      line := !line + 1;
      k c
    in

    (fun throw empty k ->
      let rec run () =
        next_n 4 bytes throw begin function
          | [b1; b2; b3; b4] ->
            let low, b2', b3', high = arrange (b1, b2, b3, b4) in
            let low, b2', b3', high =
              Char.code low, Char.code b2', Char.code b3', Char.code high in

            if high land 0x80 <> 0 then
              let s = Printf.sprintf "%c%c%c%c" b1 b2 b3 b4 in
              report (!line, !column) (`Decoding_error (s, name)) throw
                (fun () ->
              char k u_rep)
            else
              let scalar =
                (high lsl 24) lor (b3' lsl 16) lor (b2' lsl 8) lor low in

              let skip =
                if !first then begin
                  first := false;
                  scalar = Uchar.to_int Uutf.u_bom
                end
                else
                  false
              in

              if skip then run ()
              else
                if scalar = 0x000A then
                  newline k scalar
                else
                  char k scalar

          | [] -> empty ()

          | l ->
            let buffer = Buffer.create 4 in
            l |> List.iter (Buffer.add_char buffer);
            report (!line, !column)
              (`Decoding_error (Buffer.contents buffer, name)) throw (fun () ->
            char k u_rep)
        end
      in
      run ())
    |> make)
  |> wrap

let ucs_4be : t =
  ucs_4_decoder (fun (b1, b2, b3, b4) -> b4, b3, b2, b1) "ucs-4be"
let ucs_4le : t =
  ucs_4_decoder (fun bs -> bs) "ucs-4le"
let ucs_4be_transposed : t =
  ucs_4_decoder (fun (b1, b2, b3, b4) -> b3, b4, b1, b2) "ucs-4be-transposed"
let ucs_4le_transposed : t =
  ucs_4_decoder (fun (b1, b2, b3, b4) -> b2, b1, b4, b3) "ucs-4le-transposed"

let code_page table =
  if Array.length table < 256 then
    raise (Invalid_argument
      "Markup.Encoding.code_page: array does not have 256 entries");

  (fun _ bytes ->
    (fun throw empty k ->
      next bytes throw empty (fun c -> k table.(Char.code c)))
    |> make)
  |> wrap

let windows_1251_table = [|
    (* ASCII *)
    0x0000; 0x0001; 0x0002; 0x0003; 0x0004; 0x0005; 0x0006; 0x0007;
    0x0008; 0x0009; 0x000A; 0x000B; 0x000C; 0x000D; 0x000E; 0x000F;
    0x0010; 0x0011; 0x0012; 0x0013; 0x0014; 0x0015; 0x0016; 0x0017;
    0x0018; 0x0019; 0x001A; 0x001B; 0x001C; 0x001D; 0x001E; 0x001F;
    0x0020; 0x0021; 0x0022; 0x0023; 0x0024; 0x0025; 0x0026; 0x0027;
    0x0028; 0x0029; 0x002A; 0x002B; 0x002C; 0x002D; 0x002E; 0x002F;
    0x0030; 0x0031; 0x0032; 0x0033; 0x0034; 0x0035; 0x0036; 0x0037;
    0x0038; 0x0039; 0x003A; 0x003B; 0x003C; 0x003D; 0x003E; 0x003F;
    0x0040; 0x0041; 0x0042; 0x0043; 0x0044; 0x0045; 0x0046; 0x0047;
    0x0048; 0x0049; 0x004A; 0x004B; 0x004C; 0x004D; 0x004E; 0x004F;
    0x0050; 0x0051; 0x0052; 0x0053; 0x0054; 0x0055; 0x0056; 0x0057;
    0x0058; 0x0059; 0x005A; 0x005B; 0x005C; 0x005D; 0x005E; 0x005F;
    0x0060; 0x0061; 0x0062; 0x0063; 0x0064; 0x0065; 0x0066; 0x0067;
    0x0068; 0x0069; 0x006A; 0x006B; 0x006C; 0x006D; 0x006E; 0x006F;
    0x0070; 0x0071; 0x0072; 0x0073; 0x0074; 0x0075; 0x0076; 0x0077;
    0x0078; 0x0079; 0x007A; 0x007B; 0x007C; 0x007D; 0x007E; 0x007F;
    (* 0x8_ *)
    0x0402; 0x0403; 0x201A; 0x0453; 0x201E; 0x2026; 0x2020; 0x2021;
    0x20AC; 0x2030; 0x0409; 0x2039; 0x040A; 0x040C; 0x040B; 0x040F;
    (* 0x9_ *)
    0x0452; 0x2018; 0x2019; 0x201C; 0x201D; 0x2022; 0x2013; 0x2014;
    0xFFFD; 0x2122; 0x0459; 0x203A; 0x045A; 0x045C; 0x045B; 0x045F;
    (* 0xA_ *)
    0x00A0; 0x040E; 0x045E; 0x0408; 0x00A4; 0x0490; 0x00A6; 0x00A7;
    0x0401; 0x00A9; 0x0404; 0x00AB; 0x00AC; 0x00AD; 0x00AE; 0x0407;
    (* 0xB_ *)
    0x00B0; 0x00B1; 0x0406; 0x0456; 0x0491; 0x00B5; 0x00B6; 0x00B7;
    0x0451; 0x2116; 0x0454; 0x00BB; 0x0458; 0x0405; 0x0455; 0x0457;
    (* 0xC_ *)
    0x0410; 0x0411; 0x0412; 0x0413; 0x0414; 0x0415; 0x0416; 0x0417;
    0x0418; 0x0419; 0x041A; 0x041B; 0x041C; 0x041D; 0x041E; 0x041F;
    (* 0xD_ *)
    0x0410; 0x0421; 0x0422; 0x0423; 0x0424; 0x0425; 0x0426; 0x0427;
    0x0428; 0x0429; 0x042A; 0x042B; 0x042C; 0x042D; 0x042E; 0x042F;
    (* 0xE_ *)
    0x0430; 0x0431; 0x0432; 0x0433; 0x0434; 0x0435; 0x0436; 0x0437;
    0x0438; 0x0439; 0x043A; 0x043B; 0x043C; 0x043D; 0x043E; 0x043F;
    (* 0xF_ *)
    0x0440; 0x0441; 0x0442; 0x0443; 0x0444; 0x0445; 0x0446; 0x0447;
    0x0448; 0x0449; 0x044A; 0x044B; 0x044C; 0x044D; 0x044E; 0x044F
  |]

let windows_1251 : t = code_page windows_1251_table

let windows_1252_table = [|
    (* ASCII *)
    0x0000; 0x0001; 0x0002; 0x0003; 0x0004; 0x0005; 0x0006; 0x0007;
    0x0008; 0x0009; 0x000A; 0x000B; 0x000C; 0x000D; 0x000E; 0x000F;
    0x0010; 0x0011; 0x0012; 0x0013; 0x0014; 0x0015; 0x0016; 0x0017;
    0x0018; 0x0019; 0x001A; 0x001B; 0x001C; 0x001D; 0x001E; 0x001F;
    0x0020; 0x0021; 0x0022; 0x0023; 0x0024; 0x0025; 0x0026; 0x0027;
    0x0028; 0x0029; 0x002A; 0x002B; 0x002C; 0x002D; 0x002E; 0x002F;
    0x0030; 0x0031; 0x0032; 0x0033; 0x0034; 0x0035; 0x0036; 0x0037;
    0x0038; 0x0039; 0x003A; 0x003B; 0x003C; 0x003D; 0x003E; 0x003F;
    0x0040; 0x0041; 0x0042; 0x0043; 0x0044; 0x0045; 0x0046; 0x0047;
    0x0048; 0x0049; 0x004A; 0x004B; 0x004C; 0x004D; 0x004E; 0x004F;
    0x0050; 0x0051; 0x0052; 0x0053; 0x0054; 0x0055; 0x0056; 0x0057;
    0x0058; 0x0059; 0x005A; 0x005B; 0x005C; 0x005D; 0x005E; 0x005F;
    0x0060; 0x0061; 0x0062; 0x0063; 0x0064; 0x0065; 0x0066; 0x0067;
    0x0068; 0x0069; 0x006A; 0x006B; 0x006C; 0x006D; 0x006E; 0x006F;
    0x0070; 0x0071; 0x0072; 0x0073; 0x0074; 0x0075; 0x0076; 0x0077;
    0x0078; 0x0079; 0x007A; 0x007B; 0x007C; 0x007D; 0x007E; 0x007F;
    (* 0x8_ *)
    0x20AC; 0x0081; 0x201A; 0x0192; 0x201E; 0x2026; 0x2020; 0x2021;
    0x02C6; 0x2030; 0x0160; 0x2039; 0x0152; 0x008D; 0x017D; 0x008F;
    (* 0x9_ *)
    0x0090; 0x2018; 0x2019; 0x201C; 0x201D; 0x2022; 0x2013; 0x2014;
    0x02DC; 0x2122; 0x0161; 0x203A; 0x0153; 0x009D; 0x017E; 0x0178;
    (* ISO-8859-1 *)
    0x00A0; 0x00A1; 0x00A2; 0x00A3; 0x00A4; 0x00A5; 0x00A6; 0x00A7;
    0x00A8; 0x00A9; 0x00AA; 0x00AB; 0x00AC; 0x00AD; 0x00AE; 0x00AF;
    0x00B0; 0x00B1; 0x00B2; 0x00B3; 0x00B4; 0x00B5; 0x00B6; 0x00B7;
    0x00B8; 0x00B9; 0x00BA; 0x00BB; 0x00BC; 0x00BD; 0x00BE; 0x00BF;
    0x00C0; 0x00C1; 0x00C2; 0x00C3; 0x00C4; 0x00C5; 0x00C6; 0x00C7;
    0x00C8; 0x00C9; 0x00CA; 0x00CB; 0x00CC; 0x00CD; 0x00CE; 0x00CF;
    0x00D0; 0x00D1; 0x00D2; 0x00D3; 0x00D4; 0x00D5; 0x00D6; 0x00D7;
    0x00D8; 0x00D9; 0x00DA; 0x00DB; 0x00DC; 0x00DD; 0x00DE; 0x00DF;
    0x00E0; 0x00E1; 0x00E2; 0x00E3; 0x00E4; 0x00E5; 0x00E6; 0x00E7;
    0x00E8; 0x00E9; 0x00EA; 0x00EB; 0x00EC; 0x00ED; 0x00EE; 0x00EF;
    0x00F0; 0x00F1; 0x00F2; 0x00F3; 0x00F4; 0x00F5; 0x00F6; 0x00F7;
    0x00F8; 0x00F9; 0x00FA; 0x00FB; 0x00FC; 0x00FD; 0x00FE; 0x00FF
  |]

let windows_1252 : t = code_page windows_1252_table

let ebcdic_37_table = [|
    (* 0x0_ *)
    0x0000; 0x0001; 0x0002; 0x0003; 0x009C; 0x0009; 0x0086; 0x007F;
    0x0097; 0x008D; 0x008E; 0x000B; 0x000C; 0x000D; 0x000E; 0x000F;
    (* 0x1_ *)
    0x0010; 0x0011; 0x0012; 0x0013; 0x009D; 0x0085; 0x0008; 0x0087;
    0x0018; 0x0019; 0x0092; 0x008F; 0x001C; 0x001D; 0x001E; 0x001F;
    (* 0x2_ *)
    0x0080; 0x0081; 0x0082; 0x0083; 0x0084; 0x000A; 0x0017; 0x001B;
    0x0088; 0x0089; 0x008A; 0x008B; 0x008C; 0x0005; 0x0006; 0x0007;
    (* 0x3_ *)
    0x0090; 0x0091; 0x0016; 0x0093; 0x0094; 0x0095; 0x0096; 0x0004;
    0x0098; 0x0099; 0x009A; 0x009B; 0x0014; 0x0015; 0x009E; 0x001A;
    (* 0x4_ *)
    0x0020; 0x00A0; 0x00E2; 0x00E4; 0x00E0; 0x00E1; 0x00E3; 0x00E5;
    0x00E7; 0x00F1; 0x00A2; 0x002E; 0x003C; 0x0028; 0x002B; 0x007C;
    (* 0x5_ *)
    0x0026; 0x00E9; 0x00EA; 0x00EB; 0x00E8; 0x00ED; 0x00EE; 0x00EF;
    0x00EC; 0x00DF; 0x0021; 0x0024; 0x002A; 0x0029; 0x003B; 0x00AC;
    (* 0x6_ *)
    0x002D; 0x002F; 0x00C2; 0x00C4; 0x00C0; 0x00C1; 0x00C3; 0x00C5;
    0x00C7; 0x00D1; 0x00A6; 0x002C; 0x0025; 0x005F; 0x003E; 0x003F;
    (* 0x7_ *)
    0x00F8; 0x00C9; 0x00CA; 0x00CB; 0x00C8; 0x00CD; 0x00CE; 0x00CF;
    0x00CC; 0x0060; 0x003A; 0x0023; 0x0040; 0x0027; 0x003D; 0x0022;
    (* 0x8_ *)
    0x00D8; 0x0061; 0x0062; 0x0063; 0x0064; 0x0065; 0x0066; 0x0067;
    0x0068; 0x0069; 0x00AB; 0x00BB; 0x00F0; 0x00FD; 0x00FE; 0x00B1;
    (* 0x9_ *)
    0x00B0; 0x006A; 0x006B; 0x006C; 0x006D; 0x006E; 0x006F; 0x0070;
    0x0071; 0x0072; 0x00AA; 0x00BA; 0x00E6; 0x00B8; 0x00C6; 0x00A4;
    (* 0xA_ *)
    0x00B5; 0x007E; 0x0073; 0x0074; 0x0075; 0x0076; 0x0077; 0x0078;
    0x0079; 0x007A; 0x00A1; 0x00BF; 0x00D0; 0x00DD; 0x00DE; 0x00AE;
    (* 0xB_ *)
    0x005E; 0x00A3; 0x00A5; 0x00B7; 0x00A9; 0x00A7; 0x00B6; 0x00BC;
    0x00BD; 0x00BE; 0x005B; 0x005D; 0x00AF; 0x00A8; 0x00B4; 0x00D7;
    (* 0xC_ *)
    0x007B; 0x0041; 0x0042; 0x0043; 0x0044; 0x0045; 0x0046; 0x0047;
    0x0048; 0x0049; 0x00AD; 0x00F4; 0x00F6; 0x00F2; 0x00F3; 0x00F5;
    (* 0xD_ *)
    0x007D; 0x004A; 0x004B; 0x004C; 0x004D; 0x004E; 0x004F; 0x0050;
    0x0051; 0x0052; 0x00B9; 0x00FB; 0x00FC; 0x00F9; 0x00FA; 0x00FF;
    (* 0xE_ *)
    0x005C; 0x00F7; 0x0053; 0x0054; 0x0055; 0x0056; 0x0057; 0x0058;
    0x0059; 0x005A; 0x00B2; 0x00D4; 0x00D6; 0x00D2; 0x00D3; 0x00D5;
    (* 0xF_ *)
    0x0030; 0x0031; 0x0032; 0x0033; 0x0034; 0x0035; 0x0036; 0x0037;
    0x0038; 0x0039; 0x00B3; 0x00DB; 0x00DC; 0x00D9; 0x00DA; 0x009F
  |]

let ebcdic : t = code_page ebcdic_37_table

end
module Markup_input : sig 
#1 "markup_input.mli"
(* This file is part of Markup.ml, released under the BSD 2-clause license. See
   doc/LICENSE for details, or visit https://github.com/aantron/markup.ml. *)

open Markup_common

val preprocess :
  (int -> bool) -> Markup_error.parse_handler -> int Markup_kstream.t ->
    (location * int) Markup_kstream.t * (unit -> location)

end = struct
#1 "markup_input.ml"
(* This file is part of Markup.ml, released under the BSD 2-clause license. See
   doc/LICENSE for details, or visit https://github.com/aantron/markup.ml. *)

open Markup_common
open Markup_kstream

let preprocess is_valid_char report source =
  let first_char = ref true in
  let line = ref 1 in
  let column = ref 1 in

  let get_location () = !line, !column in

  let stream =
    (fun throw empty k ->
      let newline () =
        let location = !line, !column in
        line := !line + 1;
        column := 1;
        k (location, 0x0A)
      in

      let symbol c =
        let location = !line, !column in
        column := !column + 1;
        k (location, c)
      in

      let rec iterate () =
        next source throw empty (function
          | 0xFEFF when !first_char -> first_char := false; iterate ()

          | 0x0D ->
            next source throw newline (function
              | 0x0A -> newline ()
              | c -> push source c; newline ())

          | 0x0A -> newline ()

          | c when not (is_valid_char c) ->
            report (!line, !column)
              (`Bad_token (format_char c, "input", "out of range"))
              throw (fun () ->
            symbol c)

          | c -> symbol c)
      in
      iterate ())
    |> make
  in

  stream, get_location

end
module Markup_stream_io
= struct
#1 "markup_stream_io.ml"
(* This file is part of Markup.ml, released under the BSD 2-clause license. See
   doc/LICENSE for details, or visit https://github.com/aantron/markup.ml. *)

open Markup_common
open Markup_kstream

let state_fold f initial =
  let state = ref initial in
  (fun throw e k ->
    f !state throw e (fun (c, new_state) ->
      state := new_state; k c))
  |> make

let string s =
  state_fold (fun i _ e k ->
    if i >= String.length s then e () else k (s.[i], i + 1)) 0

let buffer b =
  state_fold (fun i _ e k ->
    if i >= Buffer.length b then e () else k (Buffer.nth b i, i + 1)) 0

(* Optimized away by Flambda. *)
type result = Count of int | Exn of exn

let channel c =
  let ended = ref false in
  let buffer_length = 4096 in
  let buffer = Bytes.create buffer_length in
  let position = ref 0 in
  let buffered = ref 0 in

  (fun throw e k ->
    let position' = !position in
    if position' < !buffered then begin
      position := position' + 1;
      k (Bytes.get buffer position')
    end
    else
      let result =
        try Count (Pervasives.input c buffer 0 buffer_length)
        with exn -> Exn exn
      in
      match result with
      | Count 0 ->
        ended := true;
        e ()
      | Count n ->
        position := 1;
        buffered := n;
        k (Bytes.get buffer 0)
      | Exn exn ->
        if !ended then e ()
        else throw exn)
  |> make

let file f =
  let c = Pervasives.open_in f in
  let s = channel c in

  let s' =
    (fun throw e k ->
      next s
        (fun exn -> close_in_noerr c; throw exn)
        (fun () -> close_in_noerr c; e ())
        k)
    |> make
  in

  s', fun () -> close_in_noerr c

let to_buffer s throw k =
  let buffer = Buffer.create 4096 in
  iter (fun b _ k -> Buffer.add_char buffer b; k ()) s throw (fun () ->
  k buffer)

let to_string s throw k =
  to_buffer s throw (fun buffer -> k (Buffer.contents buffer))

let to_channel c s throw k =
  let write b throw k =
    let exn =
      try output_char c b; None
      with exn -> Some exn
    in
    match exn with
    | None -> k ()
    | Some exn -> throw exn
  in
  iter write s throw k

let to_file f s throw k =
  let c = Pervasives.open_out f in
  to_channel c s
    (fun exn -> close_out_noerr c; throw exn)
    (fun () -> close_out_noerr c; k ())

end
module Markup_detect : sig 
#1 "markup_detect.mli"
(* This file is part of Markup.ml, released under the BSD 2-clause license. See
   doc/LICENSE for details, or visit https://github.com/aantron/markup.ml. *)

open Markup_common

val select_html : ?limit:int -> char Markup_kstream.t -> Markup_encoding.t cps
val select_xml : char Markup_kstream.t -> Markup_encoding.t cps

(* The following values are exposed for testing. They are not used outside the
   module. *)

val normalize_name : bool -> string -> string
val guess_from_bom_html : char Markup_kstream.t -> string option cps
val guess_from_bom_xml : char Markup_kstream.t -> string option cps
val guess_family_xml : char Markup_kstream.t -> string option cps
val meta_tag_prescan :
  ?supported:(string -> bool cont -> unit) ->
  ?limit:int ->
  char Markup_kstream.t -> string option cps
val read_xml_encoding_declaration :
  char Markup_kstream.t -> Markup_encoding.t -> string option cps

end = struct
#1 "markup_detect.ml"
(* This file is part of Markup.ml, released under the BSD 2-clause license. See
   doc/LICENSE for details, or visit https://github.com/aantron/markup.ml. *)

open Markup_common
open Markup_kstream
open Markup_encoding
module Common = Markup_common
module Kstream = Markup_kstream
module Stream_io = Markup_stream_io
module Encoding = Markup_encoding
module Input = Markup_input
module Xml_tokenizer = Markup_xml_tokenizer

let name_to_encoding = function
  | "utf-8" -> Some utf_8
  | "utf-16be" -> Some utf_16be
  | "utf-16le" -> Some utf_16le
  | "iso-8859-1" -> Some iso_8859_1
  | "us-ascii" -> Some us_ascii
  | "windows-1251" -> Some windows_1251
  | "windows-1252" -> Some windows_1252
  | "ucs-4be" -> Some ucs_4be
  | "ucs-4le" -> Some ucs_4le
  | _ -> None

(* 8.2.2.2. *)
let guess_from_bom_html source throw k =
  peek_n 3 source throw (function
    | '\xFE'::'\xFF'::_ -> k (Some "utf-16be")
    | '\xFF'::'\xFE'::_ -> k (Some "utf-16le")
    | ['\xEF'; '\xBB'; '\xBF'] -> k (Some "utf-8")
    | _ -> k None)

(* Appendix F.1. *)
let guess_from_bom_xml source throw k =
  peek_n 4 source throw (function
    | ['\x00'; '\x00'; '\xFE'; '\xFF'] -> k (Some "ucs-4be")
    | ['\xFF'; '\xFE'; '\x00'; '\x00'] -> k (Some "ucs-4le")
    | ['\x00'; '\x00'; '\xFF'; '\xFE'] -> k (Some "ucs-4be-transposed")
    | ['\xFE'; '\xFF'; '\x00'; '\x00'] -> k (Some "ucs-4le-transposed")
    | '\xFE'::'\xFF'::_ -> k (Some "utf-16be")
    | '\xFF'::'\xFE'::_ -> k (Some "utf-16le")
    | '\xEF'::'\xBB'::'\xBF'::_ -> k (Some "utf-8")
    | _ -> k None)

(* Appendix F.1. *)
let guess_family_xml source throw k =
  peek_n 4 source throw (function
    | ['\x00'; '\x00'; '\x00'; '\x3C'] -> k (Some "ucs-4be")
    | ['\x3C'; '\x00'; '\x00'; '\x00'] -> k (Some "ucs-4le")
    | ['\x00'; '\x00'; '\x3C'; '\x00'] -> k (Some "ucs-4be-transposed")
    | ['\x00'; '\x3C'; '\x00'; '\x00'] -> k (Some "ucs-4le-transposed")
    | ['\x00'; '\x3C'; '\x00'; '\x3F'] -> k (Some "utf-16be")
    | ['\x3C'; '\x00'; '\x3F'; '\x00'] -> k (Some "utf-16le")
    | ['\x3C'; '\x3F'; '\x78'; '\x6D'] -> k (Some "utf-8")
    | ['\x4C'; '\x6F'; '\xA7'; '\x94'] -> k (Some "ebcdic")
    | _ -> k None)

(* 5.2 in the Encoding Candidate Recommendation. *)
let normalize_name for_html s =
  match String.lowercase (trim_string s) with
  | "unicode-1-1-utf-8" | "utf-8" | "utf8" ->
    "utf-8"
  
  | "866" | "cp866" | "csibm866" | "ibm866" ->
    "ibm866"
  
  | "csisolatin2" | "iso-8859-2" | "iso-ir-101" | "iso8859-2" | "iso88592"
  | "iso_8859-2" | "iso_8859-2:1987" | "l2" | "latin2" ->
    "iso-8859-2"
  
  | "csisolatin3" | "iso-8859-3" | "iso-ir-109" | "iso8859-3" | "iso88593"
  | "iso_8859-3" | "iso_8859-3:1988" | "l3" | "latin3" ->
    "iso-8859-3"
  
  | "csisolatin4" | "iso-8859-4" | "iso-ir-110" | "iso8859-4" | "iso88594"
  | "iso_8859-4" | "iso_8859-4:1988" | "l4" | "latin4" ->
    "iso-8859-4"

  | "csisolatincyrillic" | "cyrillic" | "iso-8859-5" | "iso-ir-144"
  | "iso8859-5" | "iso88595" | "iso_8859-5" | "iso_8859-5:1988" ->
    "iso-8859-5"

  | "arabic" | "asmo-708" | "csiso88596e" | "csiso88596i" | "csisolatinarabic"
  | "ecma-114" | "iso-8859-6" | "iso-8859-6-e" | "iso-8859-6-i" | "iso-ir-127"
  | "iso8859-6" | "iso88596" | "iso_8859-6" | "iso_8859-6:1987" ->
    "iso-8859-6"

  | "csisolatingreek" | "ecma-118" | "elot_928" | "greek" | "greek8"
  | "iso-8859-7" | "iso-ir-126" | "iso8859-7" | "iso88597" | "iso_8859-7"
  | "iso_8859-7:1987" | "sun_eu_greek" ->
    "iso-8859-7"

  | "csiso88598e" | "csisolatinhebrew" | "hebrew" | "iso-8859-8"
  | "iso-8859-8-e" | "iso-ir-138" | "iso8859-8" | "iso88598" | "iso_8859-8"
  | "iso_8859-8:1988" | "visual" ->
    "iso-8859-8"

  | "csiso88598i" | "iso-8859-8-i" | "logical" ->
    "iso-8859-8-i"

  | "csisolatin6" | "iso-8859-10" | "iso-ir-157" | "iso8859-10" | "iso885910"
  | "l6" | "latin6" ->
    "iso-8859-10"

  | "iso-8859-13" | "iso8859-13" | "iso885913" ->
    "iso-8859-13"

  | "iso-8859-14" | "iso8859-14" | "iso885914" ->
    "iso-8859-14"

  | "csisolatin9" | "iso-8859-15" | "iso8859-15" | "iso885915" | "iso_8859-15"
  | "l9" ->
    "iso-8859-15"

  | "iso-8859-16" ->
    "iso-8859-16"

  | "cskoi8r" | "koi" | "koi8" | "koi8-r" | "koi8_r" ->
    "koi8-r"

  | "koi8-ru" | "koi8-u" ->
    "koi8-u"

  | "csmacintosh" | "mac" | "macintosh" | "x-mac-roman" ->
    "macintosh"

  | "dos-874" | "iso-8859-11" | "iso8859-11" | "iso885911" | "tis-620"
  | "windows-874" ->
    "windows-874"

  | "cp1250" | "windows-1250" | "x-cp1250" ->
    "windows-1250"

  | "cp1251" | "windows-1251" | "x-cp1251" ->
    "windows-1251"

  | "ansi_x3.4-1968" | "ascii" | "us-ascii" ->
    if for_html then "windows-1252" else "us-ascii"

  | "cp819" | "csisolatin1" | "ibm819" | "iso-8859-1" | "iso-ir-100"
  | "iso8859-1" | "iso88591" | "iso_8859-1" | "iso_8859-1:1987" | "l1"
  | "latin1" ->
    if for_html then "windows-1252" else "iso-8859-1"

  | "cp1252" | "windows-1252" | "x-cp1252" ->
    "windows-1252"

  | "cp1253" | "windows-1253" | "x-cp1253" ->
    "windows-1253"

  | "cp1254" | "csisolatin5" | "iso-8859-9" | "iso-ir-148" | "iso8859-9"
  | "iso88599" | "iso_8859-9" | "iso_8859-9:1989" | "l5" | "latin5"
  | "windows-1254" | "x-cp1254" ->
    "windows-1254"

  | "cp1255" | "windows-1255" | "x-cp1255" ->
    "windows-1255"

  | "cp1256" | "windows-1256" | "x-cp1256" ->
    "windows-1256"

  | "cp1257" | "windows-1257" | "x-cp1257" ->
    "windows-1257"

  | "cp1258" | "windows-1258" | "x-cp1258" ->
    "windows-1258"

  | "x-mac-cyrillic" | "x-mac-ukrainian" ->
    "x-mac-cyrillic"

  | "chinese" | "csgb2312" | "csiso58gb231280" | "gb2312" | "gb_2312"
  | "gb_2312-80" | "gbk" | "iso-ir-58" | "x-gbk" ->
    "gbk"

  | "gb18030" ->
    "gb18030"

  | "big5" | "big5-hkscs" | "cn-big5" | "csbig5" | "x-x-big5" ->
    "big5"

  | "cseucpkdfmtjapanese" | "euc-jp" | "x-euc-jp" ->
    "euc-jp"

  | "csiso2022jp" | "iso-2022-jp" ->
    "iso-2022-jp"

  | "csshiftjis" | "ms932" | "ms_kanji" | "shift-jis" | "shift_jis" | "sjis"
  | "windows-31j" | "x-sjis" ->
    "shift_jis"

  | "cseuckr" | "csksc56011987" | "euc-kr" | "iso-ir-149" | "korean"
  | "ks_c_5601-1987" | "ks_c_5601-1989" | "ksc5601" | "ksc_5601"
  | "windows-949" ->
    "euc-kr"

  | "csiso2022kr" | "hz-gb-2312" | "iso-2022-cn" | "iso-2022-cn-ext"
  | "iso-2022-kr" ->
    "replacement"

  | "utf-16be" ->
    "utf-16be"

  | "utf-16" | "utf-16le" ->
    "utf-16le"

  | "x-user-defined" ->
    "x-user-defined"

  | s -> s

(* 8.2.2.2. *)
let meta_tag_prescan =
  let is_uppercase c = c >= 'A' && c <= 'Z' in
  let is_lowercase c = c >= 'a' && c <= 'z' in
  let is_letter c = is_uppercase c || is_lowercase c in
  let is_whitespace c = String.contains "\t\n\r\x0C " c in

  let rec skip_whitespace source throw k =
    next source throw k (function
      | c when is_whitespace c -> skip_whitespace source throw k
      | c -> push source c; k ())
  in

  let read_quoted_value quote source throw k =
    let buffer = Buffer.create 32 in

    let rec iterate () =
      next source throw (fun () -> k "") (function
        | c when c = quote -> k (Buffer.contents buffer)
        | c -> add_utf_8 buffer (Char.code (Char.lowercase c)); iterate ())
    in
    iterate ()
  in

  let read_unquoted_value terminator source throw k =
    let buffer = Buffer.create 32 in

    let rec iterate () =
      next source throw (fun () -> k (Buffer.contents buffer)) (function
        | c when is_whitespace c || c = terminator ->
          push source c;
          k (Buffer.contents buffer)
        | c ->
          add_utf_8 buffer (Char.code (Char.lowercase c));
          iterate ())
    in
    iterate ()
  in

  (* 2.6.5. *)
  let extract_encoding source throw k =
    let rec scan () =
      next source throw (fun () -> k None) begin function
        | 'c' ->
          next_n 6 source throw begin fun l ->
            match List.map Char.lowercase l with
            | ['h'; 'a'; 'r'; 's'; 'e'; 't'] ->
              skip_whitespace source throw (fun () ->
              next source throw (fun () -> k None) begin function
                | '=' ->
                  skip_whitespace source throw (fun () ->
                  next source throw (fun () -> k None) (fun c ->
                  let continue_with =
                    match c with
                    | '"' | '\'' as c -> read_quoted_value c source throw
                    | _ -> push source c; read_unquoted_value ';' source throw
                  in
                  continue_with (function
                    | "" -> k None
                    | s -> k (Some s))))

                | c ->
                  push source c;
                  scan ()
              end)
            | _ -> scan ()
          end
        | _ -> scan ()
      end
    in
    scan ()
  in

  let everything = fun _ k -> k true in

  fun ?(supported = everything) ?(limit = 1024) source throw k ->
    let source, restore = checkpoint source in
    let finish result = restore (); k result in

    let source =
      let count = ref 0 in
      (fun throw empty k ->
        if !count >= limit then empty ()
        else next source throw empty (fun c -> count := !count + 1; k c))
      |> make
    in

    let get_attribute k' =
      let rec skip_leading k =
        next source throw (fun () -> k' None) (function
          | c when is_whitespace c || c = '/' -> skip_leading k
          | c -> push source c; k ())
      in

      let read_name k =
        let buffer = Buffer.create 32 in

        let rec iterate () =
          next_option source throw begin function
            | Some ('=' as c) when Buffer.length buffer > 0 ->
              push source c;
              k (Buffer.contents buffer)

            | Some '/' | Some '>' | None as c ->
              push_option source c;
              if Buffer.length buffer = 0 then k' None
              else k' (Some (Buffer.contents buffer, ""))

            | Some c when is_whitespace c ->
              k (Buffer.contents buffer)

            | Some c ->
              add_utf_8 buffer (Char.code (Char.lowercase c));
              iterate ()
          end
        in
        iterate ()
      in

      skip_leading (fun () ->
      read_name (fun name ->
      skip_whitespace source throw (fun () ->
      next_option source throw begin function
        | Some '=' ->
          skip_whitespace source throw (fun () ->
          next_option source throw (fun maybe_c ->
          let continue_with =
            match maybe_c with
            | Some ('\'' | '"' as c) ->
              read_quoted_value c source throw
            | Some c ->
              push source c;
              read_unquoted_value '>' source throw
            | None ->
              read_unquoted_value '>' source throw
          in
          continue_with (fun value -> k' (Some (name, value)))))

        | c ->
          push_option source c;
          k' (Some (name, ""))
      end)))
    in

    let read_attributes k =
      let rec iterate names got_pragma need_pragma charset =
        get_attribute begin function
          | None -> k got_pragma need_pragma charset
          | Some (name, value) ->
            if list_mem_string name names then
              iterate names got_pragma need_pragma charset
            else
              let names = name::names in
              match name with
              | "http-equiv" ->
                if value = "content-type" then
                  iterate names true need_pragma charset
                else
                  iterate names got_pragma need_pragma charset

              | "content" ->
                if charset <> None then
                  iterate names got_pragma need_pragma charset
                else
                  extract_encoding (Stream_io.string value) throw begin function
                    | None -> iterate names got_pragma need_pragma charset
                    | Some encoding ->
                      iterate names got_pragma (Some true) (Some encoding)
                  end

              | "charset" ->
                if value = "" then
                  iterate names got_pragma need_pragma charset
                else
                  iterate names got_pragma (Some false) (Some value)

              | _ -> iterate names got_pragma need_pragma charset
        end
      in
      iterate [] false None None
    in

    let process_attributes got_pragma need_pragma charset k =
      match need_pragma with
      | None -> k None
      | Some need_pragma ->
        if need_pragma && (not got_pragma) then k None
        else
          match charset with
          | None -> k None
          | Some charset ->
            let charset =
              match normalize_name true charset with
              | "utf-16be" | "utf-16le" | "utf-16" -> "utf-8"
              | s -> s
            in
            supported charset (function
              | true -> k (Some charset)
              | false -> k None)
    in

    let process_meta_tag k =
      read_attributes (fun got_pragma need_pragma charset ->
      process_attributes got_pragma need_pragma charset (function
        | None -> k ()
        | v -> finish v))
    in

    let rec close_comment k =
      next source throw (fun () -> finish None) (function
        | '-' ->
          next_n 2 source throw (function
            | ['-'; '>'] -> k ()
            | l -> push_list source l; close_comment k)
        | _ -> close_comment k)
    in

    let close_tag k =
      let rec skip () =
        next source throw (fun () -> finish None) (function
          | c when is_whitespace c || c = '>' ->
            push source c;
            let rec drain_attributes () =
              get_attribute (function
                | None -> k ()
                | Some _ -> drain_attributes ())
            in
            drain_attributes ()

          | _ -> skip ())
      in
      skip ()
    in

    let rec close_tag_like k =
      next source throw (fun () -> finish None) (function
        | '>' -> k ()
        | _ -> close_tag_like k)
    in

    let rec scan () =
      next source throw (fun () -> finish None) begin function
        | '<' ->
          peek source throw (fun () -> finish None) begin function
            | '!' ->
              peek_n 3 source throw (function
                | ['!'; '-'; '-'] -> close_comment scan
                | _ -> close_tag_like scan)

            | '/' ->
              peek_n 2 source throw (function
                | ['/'; c] when is_letter c -> close_tag scan
                | _ -> close_tag_like scan)

            | '?' ->
              close_tag_like scan

            | 'm' ->
              peek_n 5 source throw (fun l ->
                match List.map Char.lowercase l with
                | ['m'; 'e'; 't'; 'a'; c] when is_whitespace c || c = '/' ->
                  next_n 4 source throw (fun _ ->
                  process_meta_tag scan)

                | _ ->
                  close_tag scan)

            | c when is_letter c ->
              close_tag scan

            | _ ->
              scan ()
          end

        | _ -> scan ()
      end
    in
    scan ()

let read_xml_encoding_declaration bytes (family : Encoding.t) throw k =
  let bytes, restore = Kstream.checkpoint bytes in
  let k v = restore (); k v in

  let tokens =
    bytes
    |> family
    |> Input.preprocess is_valid_xml_char Error.ignore_errors
    |> Xml_tokenizer.tokenize Error.ignore_errors (fun _ -> None)
  in

  let rec prescan () =
    Kstream.next tokens throw (fun () -> k None) begin function
      | _, `Xml {Common.encoding} -> k encoding
      | _, `Comment _ -> prescan ()
      | _, `Chars s when List.for_all is_whitespace_only s -> prescan ()
      | _ -> k None
    end
  in

  prescan ()

let name_to_encoding_or_utf_8 encoding =
  match name_to_encoding encoding with
  | Some e -> e
  | None -> utf_8

let select_html ?limit bytes throw k =
  guess_from_bom_html bytes throw (function
    | Some encoding -> k (name_to_encoding_or_utf_8 encoding)
    | None ->
      meta_tag_prescan ?limit bytes throw (function
        | Some encoding -> k (name_to_encoding_or_utf_8 encoding)
        | None -> k utf_8))

let select_xml bytes throw k =
  guess_from_bom_xml bytes throw (function
    | Some encoding -> k (name_to_encoding_or_utf_8 encoding)
    | None ->
      (fun k' ->
        guess_family_xml bytes throw (function
          | None -> k' "utf-8" utf_8
          | Some family -> k' family (name_to_encoding_or_utf_8 family)))
      (fun name family ->
        read_xml_encoding_declaration bytes family throw (function
          | None -> k (name_to_encoding_or_utf_8 name)
          | Some encoding ->
            match name, normalize_name false encoding with
            | "utf-8", "iso-8859-1" -> k iso_8859_1
            | "utf-8", "us-ascii" -> k us_ascii
            | "utf-8", "windows-1251" -> k windows_1251
            | "utf-8", "windows-1252" -> k windows_1252
            | _ -> k (name_to_encoding_or_utf_8 name))))

end
module Markup_entities
= struct
#1 "markup_entities.ml"
(* This file is part of Markup.ml, released under the BSD 2-clause license. See
   doc/LICENSE for details, or visit https://github.com/aantron/markup.ml. *)

(* Copyright © 2014 W3C® (MIT, ERCIM, Keio, Beihang). This software or document
   includes material copied from or derived from W3C Recommendation HTML5
   [https://www.w3.org/TR/2014/REC-html5-20141028/]. *)

(* Generated automatically from entities.json. *)

let entities : (string * [ `One of int | `Two of int * int ]) array = [|
  "Aacute", `One 0x000C1;
  "Aacut", `One 0x000C1;
  "aacute", `One 0x000E1;
  "aacut", `One 0x000E1;
  "Abreve", `One 0x00102;
  "abreve", `One 0x00103;
  "ac", `One 0x0223E;
  "acd", `One 0x0223F;
  "acE", `Two (0x0223E, 0x00333);
  "Acirc", `One 0x000C2;
  "Acir", `One 0x000C2;
  "acirc", `One 0x000E2;
  "acir", `One 0x000E2;
  "acute", `One 0x000B4;
  "acut", `One 0x000B4;
  "Acy", `One 0x00410;
  "acy", `One 0x00430;
  "AElig", `One 0x000C6;
  "AEli", `One 0x000C6;
  "aelig", `One 0x000E6;
  "aeli", `One 0x000E6;
  "af", `One 0x02061;
  "Afr", `One 0x1D504;
  "afr", `One 0x1D51E;
  "Agrave", `One 0x000C0;
  "Agrav", `One 0x000C0;
  "agrave", `One 0x000E0;
  "agrav", `One 0x000E0;
  "alefsym", `One 0x02135;
  "aleph", `One 0x02135;
  "Alpha", `One 0x00391;
  "alpha", `One 0x003B1;
  "Amacr", `One 0x00100;
  "amacr", `One 0x00101;
  "amalg", `One 0x02A3F;
  "AMP", `One 0x00026;
  "AM", `One 0x00026;
  "amp", `One 0x00026;
  "am", `One 0x00026;
  "And", `One 0x02A53;
  "and", `One 0x02227;
  "andand", `One 0x02A55;
  "andd", `One 0x02A5C;
  "andslope", `One 0x02A58;
  "andv", `One 0x02A5A;
  "ang", `One 0x02220;
  "ange", `One 0x029A4;
  "angle", `One 0x02220;
  "angmsd", `One 0x02221;
  "angmsdaa", `One 0x029A8;
  "angmsdab", `One 0x029A9;
  "angmsdac", `One 0x029AA;
  "angmsdad", `One 0x029AB;
  "angmsdae", `One 0x029AC;
  "angmsdaf", `One 0x029AD;
  "angmsdag", `One 0x029AE;
  "angmsdah", `One 0x029AF;
  "angrt", `One 0x0221F;
  "angrtvb", `One 0x022BE;
  "angrtvbd", `One 0x0299D;
  "angsph", `One 0x02222;
  "angst", `One 0x000C5;
  "angzarr", `One 0x0237C;
  "Aogon", `One 0x00104;
  "aogon", `One 0x00105;
  "Aopf", `One 0x1D538;
  "aopf", `One 0x1D552;
  "ap", `One 0x02248;
  "apacir", `One 0x02A6F;
  "apE", `One 0x02A70;
  "ape", `One 0x0224A;
  "apid", `One 0x0224B;
  "apos", `One 0x00027;
  "ApplyFunction", `One 0x02061;
  "approx", `One 0x02248;
  "approxeq", `One 0x0224A;
  "Aring", `One 0x000C5;
  "Arin", `One 0x000C5;
  "aring", `One 0x000E5;
  "arin", `One 0x000E5;
  "Ascr", `One 0x1D49C;
  "ascr", `One 0x1D4B6;
  "Assign", `One 0x02254;
  "ast", `One 0x0002A;
  "asymp", `One 0x02248;
  "asympeq", `One 0x0224D;
  "Atilde", `One 0x000C3;
  "Atild", `One 0x000C3;
  "atilde", `One 0x000E3;
  "atild", `One 0x000E3;
  "Auml", `One 0x000C4;
  "Aum", `One 0x000C4;
  "auml", `One 0x000E4;
  "aum", `One 0x000E4;
  "awconint", `One 0x02233;
  "awint", `One 0x02A11;
  "backcong", `One 0x0224C;
  "backepsilon", `One 0x003F6;
  "backprime", `One 0x02035;
  "backsim", `One 0x0223D;
  "backsimeq", `One 0x022CD;
  "Backslash", `One 0x02216;
  "Barv", `One 0x02AE7;
  "barvee", `One 0x022BD;
  "Barwed", `One 0x02306;
  "barwed", `One 0x02305;
  "barwedge", `One 0x02305;
  "bbrk", `One 0x023B5;
  "bbrktbrk", `One 0x023B6;
  "bcong", `One 0x0224C;
  "Bcy", `One 0x00411;
  "bcy", `One 0x00431;
  "bdquo", `One 0x0201E;
  "becaus", `One 0x02235;
  "Because", `One 0x02235;
  "because", `One 0x02235;
  "bemptyv", `One 0x029B0;
  "bepsi", `One 0x003F6;
  "bernou", `One 0x0212C;
  "Bernoullis", `One 0x0212C;
  "Beta", `One 0x00392;
  "beta", `One 0x003B2;
  "beth", `One 0x02136;
  "between", `One 0x0226C;
  "Bfr", `One 0x1D505;
  "bfr", `One 0x1D51F;
  "bigcap", `One 0x022C2;
  "bigcirc", `One 0x025EF;
  "bigcup", `One 0x022C3;
  "bigodot", `One 0x02A00;
  "bigoplus", `One 0x02A01;
  "bigotimes", `One 0x02A02;
  "bigsqcup", `One 0x02A06;
  "bigstar", `One 0x02605;
  "bigtriangledown", `One 0x025BD;
  "bigtriangleup", `One 0x025B3;
  "biguplus", `One 0x02A04;
  "bigvee", `One 0x022C1;
  "bigwedge", `One 0x022C0;
  "bkarow", `One 0x0290D;
  "blacklozenge", `One 0x029EB;
  "blacksquare", `One 0x025AA;
  "blacktriangle", `One 0x025B4;
  "blacktriangledown", `One 0x025BE;
  "blacktriangleleft", `One 0x025C2;
  "blacktriangleright", `One 0x025B8;
  "blank", `One 0x02423;
  "blk12", `One 0x02592;
  "blk14", `One 0x02591;
  "blk34", `One 0x02593;
  "block", `One 0x02588;
  "bne", `Two (0x0003D, 0x020E5);
  "bnequiv", `Two (0x02261, 0x020E5);
  "bNot", `One 0x02AED;
  "bnot", `One 0x02310;
  "Bopf", `One 0x1D539;
  "bopf", `One 0x1D553;
  "bot", `One 0x022A5;
  "bottom", `One 0x022A5;
  "bowtie", `One 0x022C8;
  "boxbox", `One 0x029C9;
  "boxDL", `One 0x02557;
  "boxDl", `One 0x02556;
  "boxdL", `One 0x02555;
  "boxdl", `One 0x02510;
  "boxDR", `One 0x02554;
  "boxDr", `One 0x02553;
  "boxdR", `One 0x02552;
  "boxdr", `One 0x0250C;
  "boxH", `One 0x02550;
  "boxh", `One 0x02500;
  "boxHD", `One 0x02566;
  "boxHd", `One 0x02564;
  "boxhD", `One 0x02565;
  "boxhd", `One 0x0252C;
  "boxHU", `One 0x02569;
  "boxHu", `One 0x02567;
  "boxhU", `One 0x02568;
  "boxhu", `One 0x02534;
  "boxminus", `One 0x0229F;
  "boxplus", `One 0x0229E;
  "boxtimes", `One 0x022A0;
  "boxUL", `One 0x0255D;
  "boxUl", `One 0x0255C;
  "boxuL", `One 0x0255B;
  "boxul", `One 0x02518;
  "boxUR", `One 0x0255A;
  "boxUr", `One 0x02559;
  "boxuR", `One 0x02558;
  "boxur", `One 0x02514;
  "boxV", `One 0x02551;
  "boxv", `One 0x02502;
  "boxVH", `One 0x0256C;
  "boxVh", `One 0x0256B;
  "boxvH", `One 0x0256A;
  "boxvh", `One 0x0253C;
  "boxVL", `One 0x02563;
  "boxVl", `One 0x02562;
  "boxvL", `One 0x02561;
  "boxvl", `One 0x02524;
  "boxVR", `One 0x02560;
  "boxVr", `One 0x0255F;
  "boxvR", `One 0x0255E;
  "boxvr", `One 0x0251C;
  "bprime", `One 0x02035;
  "Breve", `One 0x002D8;
  "breve", `One 0x002D8;
  "brvbar", `One 0x000A6;
  "brvba", `One 0x000A6;
  "Bscr", `One 0x0212C;
  "bscr", `One 0x1D4B7;
  "bsemi", `One 0x0204F;
  "bsim", `One 0x0223D;
  "bsime", `One 0x022CD;
  "bsol", `One 0x0005C;
  "bsolb", `One 0x029C5;
  "bsolhsub", `One 0x027C8;
  "bull", `One 0x02022;
  "bullet", `One 0x02022;
  "bump", `One 0x0224E;
  "bumpE", `One 0x02AAE;
  "bumpe", `One 0x0224F;
  "Bumpeq", `One 0x0224E;
  "bumpeq", `One 0x0224F;
  "Cacute", `One 0x00106;
  "cacute", `One 0x00107;
  "Cap", `One 0x022D2;
  "cap", `One 0x02229;
  "capand", `One 0x02A44;
  "capbrcup", `One 0x02A49;
  "capcap", `One 0x02A4B;
  "capcup", `One 0x02A47;
  "capdot", `One 0x02A40;
  "CapitalDifferentialD", `One 0x02145;
  "caps", `Two (0x02229, 0x0FE00);
  "caret", `One 0x02041;
  "caron", `One 0x002C7;
  "Cayleys", `One 0x0212D;
  "ccaps", `One 0x02A4D;
  "Ccaron", `One 0x0010C;
  "ccaron", `One 0x0010D;
  "Ccedil", `One 0x000C7;
  "Ccedi", `One 0x000C7;
  "ccedil", `One 0x000E7;
  "ccedi", `One 0x000E7;
  "Ccirc", `One 0x00108;
  "ccirc", `One 0x00109;
  "Cconint", `One 0x02230;
  "ccups", `One 0x02A4C;
  "ccupssm", `One 0x02A50;
  "Cdot", `One 0x0010A;
  "cdot", `One 0x0010B;
  "cedil", `One 0x000B8;
  "cedi", `One 0x000B8;
  "Cedilla", `One 0x000B8;
  "cemptyv", `One 0x029B2;
  "cent", `One 0x000A2;
  "cen", `One 0x000A2;
  "CenterDot", `One 0x000B7;
  "centerdot", `One 0x000B7;
  "Cfr", `One 0x0212D;
  "cfr", `One 0x1D520;
  "CHcy", `One 0x00427;
  "chcy", `One 0x00447;
  "check", `One 0x02713;
  "checkmark", `One 0x02713;
  "Chi", `One 0x003A7;
  "chi", `One 0x003C7;
  "cir", `One 0x025CB;
  "circ", `One 0x002C6;
  "circeq", `One 0x02257;
  "circlearrowleft", `One 0x021BA;
  "circlearrowright", `One 0x021BB;
  "circledast", `One 0x0229B;
  "circledcirc", `One 0x0229A;
  "circleddash", `One 0x0229D;
  "CircleDot", `One 0x02299;
  "circledR", `One 0x000AE;
  "circledS", `One 0x024C8;
  "CircleMinus", `One 0x02296;
  "CirclePlus", `One 0x02295;
  "CircleTimes", `One 0x02297;
  "cirE", `One 0x029C3;
  "cire", `One 0x02257;
  "cirfnint", `One 0x02A10;
  "cirmid", `One 0x02AEF;
  "cirscir", `One 0x029C2;
  "ClockwiseContourIntegral", `One 0x02232;
  "CloseCurlyDoubleQuote", `One 0x0201D;
  "CloseCurlyQuote", `One 0x02019;
  "clubs", `One 0x02663;
  "clubsuit", `One 0x02663;
  "Colon", `One 0x02237;
  "colon", `One 0x0003A;
  "Colone", `One 0x02A74;
  "colone", `One 0x02254;
  "coloneq", `One 0x02254;
  "comma", `One 0x0002C;
  "commat", `One 0x00040;
  "comp", `One 0x02201;
  "compfn", `One 0x02218;
  "complement", `One 0x02201;
  "complexes", `One 0x02102;
  "cong", `One 0x02245;
  "congdot", `One 0x02A6D;
  "Congruent", `One 0x02261;
  "Conint", `One 0x0222F;
  "conint", `One 0x0222E;
  "ContourIntegral", `One 0x0222E;
  "Copf", `One 0x02102;
  "copf", `One 0x1D554;
  "coprod", `One 0x02210;
  "Coproduct", `One 0x02210;
  "COPY", `One 0x000A9;
  "COP", `One 0x000A9;
  "copy", `One 0x000A9;
  "cop", `One 0x000A9;
  "copysr", `One 0x02117;
  "CounterClockwiseContourIntegral", `One 0x02233;
  "crarr", `One 0x021B5;
  "Cross", `One 0x02A2F;
  "cross", `One 0x02717;
  "Cscr", `One 0x1D49E;
  "cscr", `One 0x1D4B8;
  "csub", `One 0x02ACF;
  "csube", `One 0x02AD1;
  "csup", `One 0x02AD0;
  "csupe", `One 0x02AD2;
  "ctdot", `One 0x022EF;
  "cudarrl", `One 0x02938;
  "cudarrr", `One 0x02935;
  "cuepr", `One 0x022DE;
  "cuesc", `One 0x022DF;
  "cularr", `One 0x021B6;
  "cularrp", `One 0x0293D;
  "Cup", `One 0x022D3;
  "cup", `One 0x0222A;
  "cupbrcap", `One 0x02A48;
  "CupCap", `One 0x0224D;
  "cupcap", `One 0x02A46;
  "cupcup", `One 0x02A4A;
  "cupdot", `One 0x0228D;
  "cupor", `One 0x02A45;
  "cups", `Two (0x0222A, 0x0FE00);
  "curarr", `One 0x021B7;
  "curarrm", `One 0x0293C;
  "curlyeqprec", `One 0x022DE;
  "curlyeqsucc", `One 0x022DF;
  "curlyvee", `One 0x022CE;
  "curlywedge", `One 0x022CF;
  "curren", `One 0x000A4;
  "curre", `One 0x000A4;
  "curvearrowleft", `One 0x021B6;
  "curvearrowright", `One 0x021B7;
  "cuvee", `One 0x022CE;
  "cuwed", `One 0x022CF;
  "cwconint", `One 0x02232;
  "cwint", `One 0x02231;
  "cylcty", `One 0x0232D;
  "Dagger", `One 0x02021;
  "dagger", `One 0x02020;
  "daleth", `One 0x02138;
  "Darr", `One 0x021A1;
  "dArr", `One 0x021D3;
  "darr", `One 0x02193;
  "dash", `One 0x02010;
  "Dashv", `One 0x02AE4;
  "dashv", `One 0x022A3;
  "dbkarow", `One 0x0290F;
  "dblac", `One 0x002DD;
  "Dcaron", `One 0x0010E;
  "dcaron", `One 0x0010F;
  "Dcy", `One 0x00414;
  "dcy", `One 0x00434;
  "DD", `One 0x02145;
  "dd", `One 0x02146;
  "ddagger", `One 0x02021;
  "ddarr", `One 0x021CA;
  "DDotrahd", `One 0x02911;
  "ddotseq", `One 0x02A77;
  "deg", `One 0x000B0;
  "de", `One 0x000B0;
  "Del", `One 0x02207;
  "Delta", `One 0x00394;
  "delta", `One 0x003B4;
  "demptyv", `One 0x029B1;
  "dfisht", `One 0x0297F;
  "Dfr", `One 0x1D507;
  "dfr", `One 0x1D521;
  "dHar", `One 0x02965;
  "dharl", `One 0x021C3;
  "dharr", `One 0x021C2;
  "DiacriticalAcute", `One 0x000B4;
  "DiacriticalDot", `One 0x002D9;
  "DiacriticalDoubleAcute", `One 0x002DD;
  "DiacriticalGrave", `One 0x00060;
  "DiacriticalTilde", `One 0x002DC;
  "diam", `One 0x022C4;
  "Diamond", `One 0x022C4;
  "diamond", `One 0x022C4;
  "diamondsuit", `One 0x02666;
  "diams", `One 0x02666;
  "die", `One 0x000A8;
  "DifferentialD", `One 0x02146;
  "digamma", `One 0x003DD;
  "disin", `One 0x022F2;
  "div", `One 0x000F7;
  "divide", `One 0x000F7;
  "divid", `One 0x000F7;
  "divideontimes", `One 0x022C7;
  "divonx", `One 0x022C7;
  "DJcy", `One 0x00402;
  "djcy", `One 0x00452;
  "dlcorn", `One 0x0231E;
  "dlcrop", `One 0x0230D;
  "dollar", `One 0x00024;
  "Dopf", `One 0x1D53B;
  "dopf", `One 0x1D555;
  "Dot", `One 0x000A8;
  "dot", `One 0x002D9;
  "DotDot", `One 0x020DC;
  "doteq", `One 0x02250;
  "doteqdot", `One 0x02251;
  "DotEqual", `One 0x02250;
  "dotminus", `One 0x02238;
  "dotplus", `One 0x02214;
  "dotsquare", `One 0x022A1;
  "doublebarwedge", `One 0x02306;
  "DoubleContourIntegral", `One 0x0222F;
  "DoubleDot", `One 0x000A8;
  "DoubleDownArrow", `One 0x021D3;
  "DoubleLeftArrow", `One 0x021D0;
  "DoubleLeftRightArrow", `One 0x021D4;
  "DoubleLeftTee", `One 0x02AE4;
  "DoubleLongLeftArrow", `One 0x027F8;
  "DoubleLongLeftRightArrow", `One 0x027FA;
  "DoubleLongRightArrow", `One 0x027F9;
  "DoubleRightArrow", `One 0x021D2;
  "DoubleRightTee", `One 0x022A8;
  "DoubleUpArrow", `One 0x021D1;
  "DoubleUpDownArrow", `One 0x021D5;
  "DoubleVerticalBar", `One 0x02225;
  "DownArrow", `One 0x02193;
  "Downarrow", `One 0x021D3;
  "downarrow", `One 0x02193;
  "DownArrowBar", `One 0x02913;
  "DownArrowUpArrow", `One 0x021F5;
  "DownBreve", `One 0x00311;
  "downdownarrows", `One 0x021CA;
  "downharpoonleft", `One 0x021C3;
  "downharpoonright", `One 0x021C2;
  "DownLeftRightVector", `One 0x02950;
  "DownLeftTeeVector", `One 0x0295E;
  "DownLeftVector", `One 0x021BD;
  "DownLeftVectorBar", `One 0x02956;
  "DownRightTeeVector", `One 0x0295F;
  "DownRightVector", `One 0x021C1;
  "DownRightVectorBar", `One 0x02957;
  "DownTee", `One 0x022A4;
  "DownTeeArrow", `One 0x021A7;
  "drbkarow", `One 0x02910;
  "drcorn", `One 0x0231F;
  "drcrop", `One 0x0230C;
  "Dscr", `One 0x1D49F;
  "dscr", `One 0x1D4B9;
  "DScy", `One 0x00405;
  "dscy", `One 0x00455;
  "dsol", `One 0x029F6;
  "Dstrok", `One 0x00110;
  "dstrok", `One 0x00111;
  "dtdot", `One 0x022F1;
  "dtri", `One 0x025BF;
  "dtrif", `One 0x025BE;
  "duarr", `One 0x021F5;
  "duhar", `One 0x0296F;
  "dwangle", `One 0x029A6;
  "DZcy", `One 0x0040F;
  "dzcy", `One 0x0045F;
  "dzigrarr", `One 0x027FF;
  "Eacute", `One 0x000C9;
  "Eacut", `One 0x000C9;
  "eacute", `One 0x000E9;
  "eacut", `One 0x000E9;
  "easter", `One 0x02A6E;
  "Ecaron", `One 0x0011A;
  "ecaron", `One 0x0011B;
  "ecir", `One 0x02256;
  "Ecirc", `One 0x000CA;
  "Ecir", `One 0x000CA;
  "ecirc", `One 0x000EA;
  "ecir", `One 0x000EA;
  "ecolon", `One 0x02255;
  "Ecy", `One 0x0042D;
  "ecy", `One 0x0044D;
  "eDDot", `One 0x02A77;
  "Edot", `One 0x00116;
  "eDot", `One 0x02251;
  "edot", `One 0x00117;
  "ee", `One 0x02147;
  "efDot", `One 0x02252;
  "Efr", `One 0x1D508;
  "efr", `One 0x1D522;
  "eg", `One 0x02A9A;
  "Egrave", `One 0x000C8;
  "Egrav", `One 0x000C8;
  "egrave", `One 0x000E8;
  "egrav", `One 0x000E8;
  "egs", `One 0x02A96;
  "egsdot", `One 0x02A98;
  "el", `One 0x02A99;
  "Element", `One 0x02208;
  "elinters", `One 0x023E7;
  "ell", `One 0x02113;
  "els", `One 0x02A95;
  "elsdot", `One 0x02A97;
  "Emacr", `One 0x00112;
  "emacr", `One 0x00113;
  "empty", `One 0x02205;
  "emptyset", `One 0x02205;
  "EmptySmallSquare", `One 0x025FB;
  "emptyv", `One 0x02205;
  "EmptyVerySmallSquare", `One 0x025AB;
  "emsp", `One 0x02003;
  "emsp13", `One 0x02004;
  "emsp14", `One 0x02005;
  "ENG", `One 0x0014A;
  "eng", `One 0x0014B;
  "ensp", `One 0x02002;
  "Eogon", `One 0x00118;
  "eogon", `One 0x00119;
  "Eopf", `One 0x1D53C;
  "eopf", `One 0x1D556;
  "epar", `One 0x022D5;
  "eparsl", `One 0x029E3;
  "eplus", `One 0x02A71;
  "epsi", `One 0x003B5;
  "Epsilon", `One 0x00395;
  "epsilon", `One 0x003B5;
  "epsiv", `One 0x003F5;
  "eqcirc", `One 0x02256;
  "eqcolon", `One 0x02255;
  "eqsim", `One 0x02242;
  "eqslantgtr", `One 0x02A96;
  "eqslantless", `One 0x02A95;
  "Equal", `One 0x02A75;
  "equals", `One 0x0003D;
  "EqualTilde", `One 0x02242;
  "equest", `One 0x0225F;
  "Equilibrium", `One 0x021CC;
  "equiv", `One 0x02261;
  "equivDD", `One 0x02A78;
  "eqvparsl", `One 0x029E5;
  "erarr", `One 0x02971;
  "erDot", `One 0x02253;
  "Escr", `One 0x02130;
  "escr", `One 0x0212F;
  "esdot", `One 0x02250;
  "Esim", `One 0x02A73;
  "esim", `One 0x02242;
  "Eta", `One 0x00397;
  "eta", `One 0x003B7;
  "ETH", `One 0x000D0;
  "ET", `One 0x000D0;
  "eth", `One 0x000F0;
  "et", `One 0x000F0;
  "Euml", `One 0x000CB;
  "Eum", `One 0x000CB;
  "euml", `One 0x000EB;
  "eum", `One 0x000EB;
  "euro", `One 0x020AC;
  "excl", `One 0x00021;
  "exist", `One 0x02203;
  "Exists", `One 0x02203;
  "expectation", `One 0x02130;
  "ExponentialE", `One 0x02147;
  "exponentiale", `One 0x02147;
  "fallingdotseq", `One 0x02252;
  "Fcy", `One 0x00424;
  "fcy", `One 0x00444;
  "female", `One 0x02640;
  "ffilig", `One 0x0FB03;
  "fflig", `One 0x0FB00;
  "ffllig", `One 0x0FB04;
  "Ffr", `One 0x1D509;
  "ffr", `One 0x1D523;
  "filig", `One 0x0FB01;
  "FilledSmallSquare", `One 0x025FC;
  "FilledVerySmallSquare", `One 0x025AA;
  "fjlig", `Two (0x00066, 0x0006A);
  "flat", `One 0x0266D;
  "fllig", `One 0x0FB02;
  "fltns", `One 0x025B1;
  "fnof", `One 0x00192;
  "Fopf", `One 0x1D53D;
  "fopf", `One 0x1D557;
  "ForAll", `One 0x02200;
  "forall", `One 0x02200;
  "fork", `One 0x022D4;
  "forkv", `One 0x02AD9;
  "Fouriertrf", `One 0x02131;
  "fpartint", `One 0x02A0D;
  "frac12", `One 0x000BD;
  "frac1", `One 0x000BD;
  "frac13", `One 0x02153;
  "frac14", `One 0x000BC;
  "frac1", `One 0x000BC;
  "frac15", `One 0x02155;
  "frac16", `One 0x02159;
  "frac18", `One 0x0215B;
  "frac23", `One 0x02154;
  "frac25", `One 0x02156;
  "frac34", `One 0x000BE;
  "frac3", `One 0x000BE;
  "frac35", `One 0x02157;
  "frac38", `One 0x0215C;
  "frac45", `One 0x02158;
  "frac56", `One 0x0215A;
  "frac58", `One 0x0215D;
  "frac78", `One 0x0215E;
  "frasl", `One 0x02044;
  "frown", `One 0x02322;
  "Fscr", `One 0x02131;
  "fscr", `One 0x1D4BB;
  "gacute", `One 0x001F5;
  "Gamma", `One 0x00393;
  "gamma", `One 0x003B3;
  "Gammad", `One 0x003DC;
  "gammad", `One 0x003DD;
  "gap", `One 0x02A86;
  "Gbreve", `One 0x0011E;
  "gbreve", `One 0x0011F;
  "Gcedil", `One 0x00122;
  "Gcirc", `One 0x0011C;
  "gcirc", `One 0x0011D;
  "Gcy", `One 0x00413;
  "gcy", `One 0x00433;
  "Gdot", `One 0x00120;
  "gdot", `One 0x00121;
  "gE", `One 0x02267;
  "ge", `One 0x02265;
  "gEl", `One 0x02A8C;
  "gel", `One 0x022DB;
  "geq", `One 0x02265;
  "geqq", `One 0x02267;
  "geqslant", `One 0x02A7E;
  "ges", `One 0x02A7E;
  "gescc", `One 0x02AA9;
  "gesdot", `One 0x02A80;
  "gesdoto", `One 0x02A82;
  "gesdotol", `One 0x02A84;
  "gesl", `Two (0x022DB, 0x0FE00);
  "gesles", `One 0x02A94;
  "Gfr", `One 0x1D50A;
  "gfr", `One 0x1D524;
  "Gg", `One 0x022D9;
  "gg", `One 0x0226B;
  "ggg", `One 0x022D9;
  "gimel", `One 0x02137;
  "GJcy", `One 0x00403;
  "gjcy", `One 0x00453;
  "gl", `One 0x02277;
  "gla", `One 0x02AA5;
  "glE", `One 0x02A92;
  "glj", `One 0x02AA4;
  "gnap", `One 0x02A8A;
  "gnapprox", `One 0x02A8A;
  "gnE", `One 0x02269;
  "gne", `One 0x02A88;
  "gneq", `One 0x02A88;
  "gneqq", `One 0x02269;
  "gnsim", `One 0x022E7;
  "Gopf", `One 0x1D53E;
  "gopf", `One 0x1D558;
  "grave", `One 0x00060;
  "GreaterEqual", `One 0x02265;
  "GreaterEqualLess", `One 0x022DB;
  "GreaterFullEqual", `One 0x02267;
  "GreaterGreater", `One 0x02AA2;
  "GreaterLess", `One 0x02277;
  "GreaterSlantEqual", `One 0x02A7E;
  "GreaterTilde", `One 0x02273;
  "Gscr", `One 0x1D4A2;
  "gscr", `One 0x0210A;
  "gsim", `One 0x02273;
  "gsime", `One 0x02A8E;
  "gsiml", `One 0x02A90;
  "GT", `One 0x0003E;
  "G", `One 0x0003E;
  "Gt", `One 0x0226B;
  "gt", `One 0x0003E;
  "g", `One 0x0003E;
  "gtcc", `One 0x02AA7;
  "gtcir", `One 0x02A7A;
  "gtdot", `One 0x022D7;
  "gtlPar", `One 0x02995;
  "gtquest", `One 0x02A7C;
  "gtrapprox", `One 0x02A86;
  "gtrarr", `One 0x02978;
  "gtrdot", `One 0x022D7;
  "gtreqless", `One 0x022DB;
  "gtreqqless", `One 0x02A8C;
  "gtrless", `One 0x02277;
  "gtrsim", `One 0x02273;
  "gvertneqq", `Two (0x02269, 0x0FE00);
  "gvnE", `Two (0x02269, 0x0FE00);
  "Hacek", `One 0x002C7;
  "hairsp", `One 0x0200A;
  "half", `One 0x000BD;
  "hamilt", `One 0x0210B;
  "HARDcy", `One 0x0042A;
  "hardcy", `One 0x0044A;
  "hArr", `One 0x021D4;
  "harr", `One 0x02194;
  "harrcir", `One 0x02948;
  "harrw", `One 0x021AD;
  "Hat", `One 0x0005E;
  "hbar", `One 0x0210F;
  "Hcirc", `One 0x00124;
  "hcirc", `One 0x00125;
  "hearts", `One 0x02665;
  "heartsuit", `One 0x02665;
  "hellip", `One 0x02026;
  "hercon", `One 0x022B9;
  "Hfr", `One 0x0210C;
  "hfr", `One 0x1D525;
  "HilbertSpace", `One 0x0210B;
  "hksearow", `One 0x02925;
  "hkswarow", `One 0x02926;
  "hoarr", `One 0x021FF;
  "homtht", `One 0x0223B;
  "hookleftarrow", `One 0x021A9;
  "hookrightarrow", `One 0x021AA;
  "Hopf", `One 0x0210D;
  "hopf", `One 0x1D559;
  "horbar", `One 0x02015;
  "HorizontalLine", `One 0x02500;
  "Hscr", `One 0x0210B;
  "hscr", `One 0x1D4BD;
  "hslash", `One 0x0210F;
  "Hstrok", `One 0x00126;
  "hstrok", `One 0x00127;
  "HumpDownHump", `One 0x0224E;
  "HumpEqual", `One 0x0224F;
  "hybull", `One 0x02043;
  "hyphen", `One 0x02010;
  "Iacute", `One 0x000CD;
  "Iacut", `One 0x000CD;
  "iacute", `One 0x000ED;
  "iacut", `One 0x000ED;
  "ic", `One 0x02063;
  "Icirc", `One 0x000CE;
  "Icir", `One 0x000CE;
  "icirc", `One 0x000EE;
  "icir", `One 0x000EE;
  "Icy", `One 0x00418;
  "icy", `One 0x00438;
  "Idot", `One 0x00130;
  "IEcy", `One 0x00415;
  "iecy", `One 0x00435;
  "iexcl", `One 0x000A1;
  "iexc", `One 0x000A1;
  "iff", `One 0x021D4;
  "Ifr", `One 0x02111;
  "ifr", `One 0x1D526;
  "Igrave", `One 0x000CC;
  "Igrav", `One 0x000CC;
  "igrave", `One 0x000EC;
  "igrav", `One 0x000EC;
  "ii", `One 0x02148;
  "iiiint", `One 0x02A0C;
  "iiint", `One 0x0222D;
  "iinfin", `One 0x029DC;
  "iiota", `One 0x02129;
  "IJlig", `One 0x00132;
  "ijlig", `One 0x00133;
  "Im", `One 0x02111;
  "Imacr", `One 0x0012A;
  "imacr", `One 0x0012B;
  "image", `One 0x02111;
  "ImaginaryI", `One 0x02148;
  "imagline", `One 0x02110;
  "imagpart", `One 0x02111;
  "imath", `One 0x00131;
  "imof", `One 0x022B7;
  "imped", `One 0x001B5;
  "Implies", `One 0x021D2;
  "in", `One 0x02208;
  "incare", `One 0x02105;
  "infin", `One 0x0221E;
  "infintie", `One 0x029DD;
  "inodot", `One 0x00131;
  "Int", `One 0x0222C;
  "int", `One 0x0222B;
  "intcal", `One 0x022BA;
  "integers", `One 0x02124;
  "Integral", `One 0x0222B;
  "intercal", `One 0x022BA;
  "Intersection", `One 0x022C2;
  "intlarhk", `One 0x02A17;
  "intprod", `One 0x02A3C;
  "InvisibleComma", `One 0x02063;
  "InvisibleTimes", `One 0x02062;
  "IOcy", `One 0x00401;
  "iocy", `One 0x00451;
  "Iogon", `One 0x0012E;
  "iogon", `One 0x0012F;
  "Iopf", `One 0x1D540;
  "iopf", `One 0x1D55A;
  "Iota", `One 0x00399;
  "iota", `One 0x003B9;
  "iprod", `One 0x02A3C;
  "iquest", `One 0x000BF;
  "iques", `One 0x000BF;
  "Iscr", `One 0x02110;
  "iscr", `One 0x1D4BE;
  "isin", `One 0x02208;
  "isindot", `One 0x022F5;
  "isinE", `One 0x022F9;
  "isins", `One 0x022F4;
  "isinsv", `One 0x022F3;
  "isinv", `One 0x02208;
  "it", `One 0x02062;
  "Itilde", `One 0x00128;
  "itilde", `One 0x00129;
  "Iukcy", `One 0x00406;
  "iukcy", `One 0x00456;
  "Iuml", `One 0x000CF;
  "Ium", `One 0x000CF;
  "iuml", `One 0x000EF;
  "ium", `One 0x000EF;
  "Jcirc", `One 0x00134;
  "jcirc", `One 0x00135;
  "Jcy", `One 0x00419;
  "jcy", `One 0x00439;
  "Jfr", `One 0x1D50D;
  "jfr", `One 0x1D527;
  "jmath", `One 0x00237;
  "Jopf", `One 0x1D541;
  "jopf", `One 0x1D55B;
  "Jscr", `One 0x1D4A5;
  "jscr", `One 0x1D4BF;
  "Jsercy", `One 0x00408;
  "jsercy", `One 0x00458;
  "Jukcy", `One 0x00404;
  "jukcy", `One 0x00454;
  "Kappa", `One 0x0039A;
  "kappa", `One 0x003BA;
  "kappav", `One 0x003F0;
  "Kcedil", `One 0x00136;
  "kcedil", `One 0x00137;
  "Kcy", `One 0x0041A;
  "kcy", `One 0x0043A;
  "Kfr", `One 0x1D50E;
  "kfr", `One 0x1D528;
  "kgreen", `One 0x00138;
  "KHcy", `One 0x00425;
  "khcy", `One 0x00445;
  "KJcy", `One 0x0040C;
  "kjcy", `One 0x0045C;
  "Kopf", `One 0x1D542;
  "kopf", `One 0x1D55C;
  "Kscr", `One 0x1D4A6;
  "kscr", `One 0x1D4C0;
  "lAarr", `One 0x021DA;
  "Lacute", `One 0x00139;
  "lacute", `One 0x0013A;
  "laemptyv", `One 0x029B4;
  "lagran", `One 0x02112;
  "Lambda", `One 0x0039B;
  "lambda", `One 0x003BB;
  "Lang", `One 0x027EA;
  "lang", `One 0x027E8;
  "langd", `One 0x02991;
  "langle", `One 0x027E8;
  "lap", `One 0x02A85;
  "Laplacetrf", `One 0x02112;
  "laquo", `One 0x000AB;
  "laqu", `One 0x000AB;
  "Larr", `One 0x0219E;
  "lArr", `One 0x021D0;
  "larr", `One 0x02190;
  "larrb", `One 0x021E4;
  "larrbfs", `One 0x0291F;
  "larrfs", `One 0x0291D;
  "larrhk", `One 0x021A9;
  "larrlp", `One 0x021AB;
  "larrpl", `One 0x02939;
  "larrsim", `One 0x02973;
  "larrtl", `One 0x021A2;
  "lat", `One 0x02AAB;
  "lAtail", `One 0x0291B;
  "latail", `One 0x02919;
  "late", `One 0x02AAD;
  "lates", `Two (0x02AAD, 0x0FE00);
  "lBarr", `One 0x0290E;
  "lbarr", `One 0x0290C;
  "lbbrk", `One 0x02772;
  "lbrace", `One 0x0007B;
  "lbrack", `One 0x0005B;
  "lbrke", `One 0x0298B;
  "lbrksld", `One 0x0298F;
  "lbrkslu", `One 0x0298D;
  "Lcaron", `One 0x0013D;
  "lcaron", `One 0x0013E;
  "Lcedil", `One 0x0013B;
  "lcedil", `One 0x0013C;
  "lceil", `One 0x02308;
  "lcub", `One 0x0007B;
  "Lcy", `One 0x0041B;
  "lcy", `One 0x0043B;
  "ldca", `One 0x02936;
  "ldquo", `One 0x0201C;
  "ldquor", `One 0x0201E;
  "ldrdhar", `One 0x02967;
  "ldrushar", `One 0x0294B;
  "ldsh", `One 0x021B2;
  "lE", `One 0x02266;
  "le", `One 0x02264;
  "LeftAngleBracket", `One 0x027E8;
  "LeftArrow", `One 0x02190;
  "Leftarrow", `One 0x021D0;
  "leftarrow", `One 0x02190;
  "LeftArrowBar", `One 0x021E4;
  "LeftArrowRightArrow", `One 0x021C6;
  "leftarrowtail", `One 0x021A2;
  "LeftCeiling", `One 0x02308;
  "LeftDoubleBracket", `One 0x027E6;
  "LeftDownTeeVector", `One 0x02961;
  "LeftDownVector", `One 0x021C3;
  "LeftDownVectorBar", `One 0x02959;
  "LeftFloor", `One 0x0230A;
  "leftharpoondown", `One 0x021BD;
  "leftharpoonup", `One 0x021BC;
  "leftleftarrows", `One 0x021C7;
  "LeftRightArrow", `One 0x02194;
  "Leftrightarrow", `One 0x021D4;
  "leftrightarrow", `One 0x02194;
  "leftrightarrows", `One 0x021C6;
  "leftrightharpoons", `One 0x021CB;
  "leftrightsquigarrow", `One 0x021AD;
  "LeftRightVector", `One 0x0294E;
  "LeftTee", `One 0x022A3;
  "LeftTeeArrow", `One 0x021A4;
  "LeftTeeVector", `One 0x0295A;
  "leftthreetimes", `One 0x022CB;
  "LeftTriangle", `One 0x022B2;
  "LeftTriangleBar", `One 0x029CF;
  "LeftTriangleEqual", `One 0x022B4;
  "LeftUpDownVector", `One 0x02951;
  "LeftUpTeeVector", `One 0x02960;
  "LeftUpVector", `One 0x021BF;
  "LeftUpVectorBar", `One 0x02958;
  "LeftVector", `One 0x021BC;
  "LeftVectorBar", `One 0x02952;
  "lEg", `One 0x02A8B;
  "leg", `One 0x022DA;
  "leq", `One 0x02264;
  "leqq", `One 0x02266;
  "leqslant", `One 0x02A7D;
  "les", `One 0x02A7D;
  "lescc", `One 0x02AA8;
  "lesdot", `One 0x02A7F;
  "lesdoto", `One 0x02A81;
  "lesdotor", `One 0x02A83;
  "lesg", `Two (0x022DA, 0x0FE00);
  "lesges", `One 0x02A93;
  "lessapprox", `One 0x02A85;
  "lessdot", `One 0x022D6;
  "lesseqgtr", `One 0x022DA;
  "lesseqqgtr", `One 0x02A8B;
  "LessEqualGreater", `One 0x022DA;
  "LessFullEqual", `One 0x02266;
  "LessGreater", `One 0x02276;
  "lessgtr", `One 0x02276;
  "LessLess", `One 0x02AA1;
  "lesssim", `One 0x02272;
  "LessSlantEqual", `One 0x02A7D;
  "LessTilde", `One 0x02272;
  "lfisht", `One 0x0297C;
  "lfloor", `One 0x0230A;
  "Lfr", `One 0x1D50F;
  "lfr", `One 0x1D529;
  "lg", `One 0x02276;
  "lgE", `One 0x02A91;
  "lHar", `One 0x02962;
  "lhard", `One 0x021BD;
  "lharu", `One 0x021BC;
  "lharul", `One 0x0296A;
  "lhblk", `One 0x02584;
  "LJcy", `One 0x00409;
  "ljcy", `One 0x00459;
  "Ll", `One 0x022D8;
  "ll", `One 0x0226A;
  "llarr", `One 0x021C7;
  "llcorner", `One 0x0231E;
  "Lleftarrow", `One 0x021DA;
  "llhard", `One 0x0296B;
  "lltri", `One 0x025FA;
  "Lmidot", `One 0x0013F;
  "lmidot", `One 0x00140;
  "lmoust", `One 0x023B0;
  "lmoustache", `One 0x023B0;
  "lnap", `One 0x02A89;
  "lnapprox", `One 0x02A89;
  "lnE", `One 0x02268;
  "lne", `One 0x02A87;
  "lneq", `One 0x02A87;
  "lneqq", `One 0x02268;
  "lnsim", `One 0x022E6;
  "loang", `One 0x027EC;
  "loarr", `One 0x021FD;
  "lobrk", `One 0x027E6;
  "LongLeftArrow", `One 0x027F5;
  "Longleftarrow", `One 0x027F8;
  "longleftarrow", `One 0x027F5;
  "LongLeftRightArrow", `One 0x027F7;
  "Longleftrightarrow", `One 0x027FA;
  "longleftrightarrow", `One 0x027F7;
  "longmapsto", `One 0x027FC;
  "LongRightArrow", `One 0x027F6;
  "Longrightarrow", `One 0x027F9;
  "longrightarrow", `One 0x027F6;
  "looparrowleft", `One 0x021AB;
  "looparrowright", `One 0x021AC;
  "lopar", `One 0x02985;
  "Lopf", `One 0x1D543;
  "lopf", `One 0x1D55D;
  "loplus", `One 0x02A2D;
  "lotimes", `One 0x02A34;
  "lowast", `One 0x02217;
  "lowbar", `One 0x0005F;
  "LowerLeftArrow", `One 0x02199;
  "LowerRightArrow", `One 0x02198;
  "loz", `One 0x025CA;
  "lozenge", `One 0x025CA;
  "lozf", `One 0x029EB;
  "lpar", `One 0x00028;
  "lparlt", `One 0x02993;
  "lrarr", `One 0x021C6;
  "lrcorner", `One 0x0231F;
  "lrhar", `One 0x021CB;
  "lrhard", `One 0x0296D;
  "lrm", `One 0x0200E;
  "lrtri", `One 0x022BF;
  "lsaquo", `One 0x02039;
  "Lscr", `One 0x02112;
  "lscr", `One 0x1D4C1;
  "Lsh", `One 0x021B0;
  "lsh", `One 0x021B0;
  "lsim", `One 0x02272;
  "lsime", `One 0x02A8D;
  "lsimg", `One 0x02A8F;
  "lsqb", `One 0x0005B;
  "lsquo", `One 0x02018;
  "lsquor", `One 0x0201A;
  "Lstrok", `One 0x00141;
  "lstrok", `One 0x00142;
  "LT", `One 0x0003C;
  "L", `One 0x0003C;
  "Lt", `One 0x0226A;
  "lt", `One 0x0003C;
  "l", `One 0x0003C;
  "ltcc", `One 0x02AA6;
  "ltcir", `One 0x02A79;
  "ltdot", `One 0x022D6;
  "lthree", `One 0x022CB;
  "ltimes", `One 0x022C9;
  "ltlarr", `One 0x02976;
  "ltquest", `One 0x02A7B;
  "ltri", `One 0x025C3;
  "ltrie", `One 0x022B4;
  "ltrif", `One 0x025C2;
  "ltrPar", `One 0x02996;
  "lurdshar", `One 0x0294A;
  "luruhar", `One 0x02966;
  "lvertneqq", `Two (0x02268, 0x0FE00);
  "lvnE", `Two (0x02268, 0x0FE00);
  "macr", `One 0x000AF;
  "mac", `One 0x000AF;
  "male", `One 0x02642;
  "malt", `One 0x02720;
  "maltese", `One 0x02720;
  "Map", `One 0x02905;
  "map", `One 0x021A6;
  "mapsto", `One 0x021A6;
  "mapstodown", `One 0x021A7;
  "mapstoleft", `One 0x021A4;
  "mapstoup", `One 0x021A5;
  "marker", `One 0x025AE;
  "mcomma", `One 0x02A29;
  "Mcy", `One 0x0041C;
  "mcy", `One 0x0043C;
  "mdash", `One 0x02014;
  "mDDot", `One 0x0223A;
  "measuredangle", `One 0x02221;
  "MediumSpace", `One 0x0205F;
  "Mellintrf", `One 0x02133;
  "Mfr", `One 0x1D510;
  "mfr", `One 0x1D52A;
  "mho", `One 0x02127;
  "micro", `One 0x000B5;
  "micr", `One 0x000B5;
  "mid", `One 0x02223;
  "midast", `One 0x0002A;
  "midcir", `One 0x02AF0;
  "middot", `One 0x000B7;
  "middo", `One 0x000B7;
  "minus", `One 0x02212;
  "minusb", `One 0x0229F;
  "minusd", `One 0x02238;
  "minusdu", `One 0x02A2A;
  "MinusPlus", `One 0x02213;
  "mlcp", `One 0x02ADB;
  "mldr", `One 0x02026;
  "mnplus", `One 0x02213;
  "models", `One 0x022A7;
  "Mopf", `One 0x1D544;
  "mopf", `One 0x1D55E;
  "mp", `One 0x02213;
  "Mscr", `One 0x02133;
  "mscr", `One 0x1D4C2;
  "mstpos", `One 0x0223E;
  "Mu", `One 0x0039C;
  "mu", `One 0x003BC;
  "multimap", `One 0x022B8;
  "mumap", `One 0x022B8;
  "nabla", `One 0x02207;
  "Nacute", `One 0x00143;
  "nacute", `One 0x00144;
  "nang", `Two (0x02220, 0x020D2);
  "nap", `One 0x02249;
  "napE", `Two (0x02A70, 0x00338);
  "napid", `Two (0x0224B, 0x00338);
  "napos", `One 0x00149;
  "napprox", `One 0x02249;
  "natur", `One 0x0266E;
  "natural", `One 0x0266E;
  "naturals", `One 0x02115;
  "nbsp", `One 0x000A0;
  "nbs", `One 0x000A0;
  "nbump", `Two (0x0224E, 0x00338);
  "nbumpe", `Two (0x0224F, 0x00338);
  "ncap", `One 0x02A43;
  "Ncaron", `One 0x00147;
  "ncaron", `One 0x00148;
  "Ncedil", `One 0x00145;
  "ncedil", `One 0x00146;
  "ncong", `One 0x02247;
  "ncongdot", `Two (0x02A6D, 0x00338);
  "ncup", `One 0x02A42;
  "Ncy", `One 0x0041D;
  "ncy", `One 0x0043D;
  "ndash", `One 0x02013;
  "ne", `One 0x02260;
  "nearhk", `One 0x02924;
  "neArr", `One 0x021D7;
  "nearr", `One 0x02197;
  "nearrow", `One 0x02197;
  "nedot", `Two (0x02250, 0x00338);
  "NegativeMediumSpace", `One 0x0200B;
  "NegativeThickSpace", `One 0x0200B;
  "NegativeThinSpace", `One 0x0200B;
  "NegativeVeryThinSpace", `One 0x0200B;
  "nequiv", `One 0x02262;
  "nesear", `One 0x02928;
  "nesim", `Two (0x02242, 0x00338);
  "NestedGreaterGreater", `One 0x0226B;
  "NestedLessLess", `One 0x0226A;
  "NewLine", `One 0x0000A;
  "nexist", `One 0x02204;
  "nexists", `One 0x02204;
  "Nfr", `One 0x1D511;
  "nfr", `One 0x1D52B;
  "ngE", `Two (0x02267, 0x00338);
  "nge", `One 0x02271;
  "ngeq", `One 0x02271;
  "ngeqq", `Two (0x02267, 0x00338);
  "ngeqslant", `Two (0x02A7E, 0x00338);
  "nges", `Two (0x02A7E, 0x00338);
  "nGg", `Two (0x022D9, 0x00338);
  "ngsim", `One 0x02275;
  "nGt", `Two (0x0226B, 0x020D2);
  "ngt", `One 0x0226F;
  "ngtr", `One 0x0226F;
  "nGtv", `Two (0x0226B, 0x00338);
  "nhArr", `One 0x021CE;
  "nharr", `One 0x021AE;
  "nhpar", `One 0x02AF2;
  "ni", `One 0x0220B;
  "nis", `One 0x022FC;
  "nisd", `One 0x022FA;
  "niv", `One 0x0220B;
  "NJcy", `One 0x0040A;
  "njcy", `One 0x0045A;
  "nlArr", `One 0x021CD;
  "nlarr", `One 0x0219A;
  "nldr", `One 0x02025;
  "nlE", `Two (0x02266, 0x00338);
  "nle", `One 0x02270;
  "nLeftarrow", `One 0x021CD;
  "nleftarrow", `One 0x0219A;
  "nLeftrightarrow", `One 0x021CE;
  "nleftrightarrow", `One 0x021AE;
  "nleq", `One 0x02270;
  "nleqq", `Two (0x02266, 0x00338);
  "nleqslant", `Two (0x02A7D, 0x00338);
  "nles", `Two (0x02A7D, 0x00338);
  "nless", `One 0x0226E;
  "nLl", `Two (0x022D8, 0x00338);
  "nlsim", `One 0x02274;
  "nLt", `Two (0x0226A, 0x020D2);
  "nlt", `One 0x0226E;
  "nltri", `One 0x022EA;
  "nltrie", `One 0x022EC;
  "nLtv", `Two (0x0226A, 0x00338);
  "nmid", `One 0x02224;
  "NoBreak", `One 0x02060;
  "NonBreakingSpace", `One 0x000A0;
  "Nopf", `One 0x02115;
  "nopf", `One 0x1D55F;
  "Not", `One 0x02AEC;
  "not", `One 0x000AC;
  "no", `One 0x000AC;
  "NotCongruent", `One 0x02262;
  "NotCupCap", `One 0x0226D;
  "NotDoubleVerticalBar", `One 0x02226;
  "NotElement", `One 0x02209;
  "NotEqual", `One 0x02260;
  "NotEqualTilde", `Two (0x02242, 0x00338);
  "NotExists", `One 0x02204;
  "NotGreater", `One 0x0226F;
  "NotGreaterEqual", `One 0x02271;
  "NotGreaterFullEqual", `Two (0x02267, 0x00338);
  "NotGreaterGreater", `Two (0x0226B, 0x00338);
  "NotGreaterLess", `One 0x02279;
  "NotGreaterSlantEqual", `Two (0x02A7E, 0x00338);
  "NotGreaterTilde", `One 0x02275;
  "NotHumpDownHump", `Two (0x0224E, 0x00338);
  "NotHumpEqual", `Two (0x0224F, 0x00338);
  "notin", `One 0x02209;
  "notindot", `Two (0x022F5, 0x00338);
  "notinE", `Two (0x022F9, 0x00338);
  "notinva", `One 0x02209;
  "notinvb", `One 0x022F7;
  "notinvc", `One 0x022F6;
  "NotLeftTriangle", `One 0x022EA;
  "NotLeftTriangleBar", `Two (0x029CF, 0x00338);
  "NotLeftTriangleEqual", `One 0x022EC;
  "NotLess", `One 0x0226E;
  "NotLessEqual", `One 0x02270;
  "NotLessGreater", `One 0x02278;
  "NotLessLess", `Two (0x0226A, 0x00338);
  "NotLessSlantEqual", `Two (0x02A7D, 0x00338);
  "NotLessTilde", `One 0x02274;
  "NotNestedGreaterGreater", `Two (0x02AA2, 0x00338);
  "NotNestedLessLess", `Two (0x02AA1, 0x00338);
  "notni", `One 0x0220C;
  "notniva", `One 0x0220C;
  "notnivb", `One 0x022FE;
  "notnivc", `One 0x022FD;
  "NotPrecedes", `One 0x02280;
  "NotPrecedesEqual", `Two (0x02AAF, 0x00338);
  "NotPrecedesSlantEqual", `One 0x022E0;
  "NotReverseElement", `One 0x0220C;
  "NotRightTriangle", `One 0x022EB;
  "NotRightTriangleBar", `Two (0x029D0, 0x00338);
  "NotRightTriangleEqual", `One 0x022ED;
  "NotSquareSubset", `Two (0x0228F, 0x00338);
  "NotSquareSubsetEqual", `One 0x022E2;
  "NotSquareSuperset", `Two (0x02290, 0x00338);
  "NotSquareSupersetEqual", `One 0x022E3;
  "NotSubset", `Two (0x02282, 0x020D2);
  "NotSubsetEqual", `One 0x02288;
  "NotSucceeds", `One 0x02281;
  "NotSucceedsEqual", `Two (0x02AB0, 0x00338);
  "NotSucceedsSlantEqual", `One 0x022E1;
  "NotSucceedsTilde", `Two (0x0227F, 0x00338);
  "NotSuperset", `Two (0x02283, 0x020D2);
  "NotSupersetEqual", `One 0x02289;
  "NotTilde", `One 0x02241;
  "NotTildeEqual", `One 0x02244;
  "NotTildeFullEqual", `One 0x02247;
  "NotTildeTilde", `One 0x02249;
  "NotVerticalBar", `One 0x02224;
  "npar", `One 0x02226;
  "nparallel", `One 0x02226;
  "nparsl", `Two (0x02AFD, 0x020E5);
  "npart", `Two (0x02202, 0x00338);
  "npolint", `One 0x02A14;
  "npr", `One 0x02280;
  "nprcue", `One 0x022E0;
  "npre", `Two (0x02AAF, 0x00338);
  "nprec", `One 0x02280;
  "npreceq", `Two (0x02AAF, 0x00338);
  "nrArr", `One 0x021CF;
  "nrarr", `One 0x0219B;
  "nrarrc", `Two (0x02933, 0x00338);
  "nrarrw", `Two (0x0219D, 0x00338);
  "nRightarrow", `One 0x021CF;
  "nrightarrow", `One 0x0219B;
  "nrtri", `One 0x022EB;
  "nrtrie", `One 0x022ED;
  "nsc", `One 0x02281;
  "nsccue", `One 0x022E1;
  "nsce", `Two (0x02AB0, 0x00338);
  "Nscr", `One 0x1D4A9;
  "nscr", `One 0x1D4C3;
  "nshortmid", `One 0x02224;
  "nshortparallel", `One 0x02226;
  "nsim", `One 0x02241;
  "nsime", `One 0x02244;
  "nsimeq", `One 0x02244;
  "nsmid", `One 0x02224;
  "nspar", `One 0x02226;
  "nsqsube", `One 0x022E2;
  "nsqsupe", `One 0x022E3;
  "nsub", `One 0x02284;
  "nsubE", `Two (0x02AC5, 0x00338);
  "nsube", `One 0x02288;
  "nsubset", `Two (0x02282, 0x020D2);
  "nsubseteq", `One 0x02288;
  "nsubseteqq", `Two (0x02AC5, 0x00338);
  "nsucc", `One 0x02281;
  "nsucceq", `Two (0x02AB0, 0x00338);
  "nsup", `One 0x02285;
  "nsupE", `Two (0x02AC6, 0x00338);
  "nsupe", `One 0x02289;
  "nsupset", `Two (0x02283, 0x020D2);
  "nsupseteq", `One 0x02289;
  "nsupseteqq", `Two (0x02AC6, 0x00338);
  "ntgl", `One 0x02279;
  "Ntilde", `One 0x000D1;
  "Ntild", `One 0x000D1;
  "ntilde", `One 0x000F1;
  "ntild", `One 0x000F1;
  "ntlg", `One 0x02278;
  "ntriangleleft", `One 0x022EA;
  "ntrianglelefteq", `One 0x022EC;
  "ntriangleright", `One 0x022EB;
  "ntrianglerighteq", `One 0x022ED;
  "Nu", `One 0x0039D;
  "nu", `One 0x003BD;
  "num", `One 0x00023;
  "numero", `One 0x02116;
  "numsp", `One 0x02007;
  "nvap", `Two (0x0224D, 0x020D2);
  "nVDash", `One 0x022AF;
  "nVdash", `One 0x022AE;
  "nvDash", `One 0x022AD;
  "nvdash", `One 0x022AC;
  "nvge", `Two (0x02265, 0x020D2);
  "nvgt", `Two (0x0003E, 0x020D2);
  "nvHarr", `One 0x02904;
  "nvinfin", `One 0x029DE;
  "nvlArr", `One 0x02902;
  "nvle", `Two (0x02264, 0x020D2);
  "nvlt", `Two (0x0003C, 0x020D2);
  "nvltrie", `Two (0x022B4, 0x020D2);
  "nvrArr", `One 0x02903;
  "nvrtrie", `Two (0x022B5, 0x020D2);
  "nvsim", `Two (0x0223C, 0x020D2);
  "nwarhk", `One 0x02923;
  "nwArr", `One 0x021D6;
  "nwarr", `One 0x02196;
  "nwarrow", `One 0x02196;
  "nwnear", `One 0x02927;
  "Oacute", `One 0x000D3;
  "Oacut", `One 0x000D3;
  "oacute", `One 0x000F3;
  "oacut", `One 0x000F3;
  "oast", `One 0x0229B;
  "ocir", `One 0x0229A;
  "Ocirc", `One 0x000D4;
  "Ocir", `One 0x000D4;
  "ocirc", `One 0x000F4;
  "ocir", `One 0x000F4;
  "Ocy", `One 0x0041E;
  "ocy", `One 0x0043E;
  "odash", `One 0x0229D;
  "Odblac", `One 0x00150;
  "odblac", `One 0x00151;
  "odiv", `One 0x02A38;
  "odot", `One 0x02299;
  "odsold", `One 0x029BC;
  "OElig", `One 0x00152;
  "oelig", `One 0x00153;
  "ofcir", `One 0x029BF;
  "Ofr", `One 0x1D512;
  "ofr", `One 0x1D52C;
  "ogon", `One 0x002DB;
  "Ograve", `One 0x000D2;
  "Ograv", `One 0x000D2;
  "ograve", `One 0x000F2;
  "ograv", `One 0x000F2;
  "ogt", `One 0x029C1;
  "ohbar", `One 0x029B5;
  "ohm", `One 0x003A9;
  "oint", `One 0x0222E;
  "olarr", `One 0x021BA;
  "olcir", `One 0x029BE;
  "olcross", `One 0x029BB;
  "oline", `One 0x0203E;
  "olt", `One 0x029C0;
  "Omacr", `One 0x0014C;
  "omacr", `One 0x0014D;
  "Omega", `One 0x003A9;
  "omega", `One 0x003C9;
  "Omicron", `One 0x0039F;
  "omicron", `One 0x003BF;
  "omid", `One 0x029B6;
  "ominus", `One 0x02296;
  "Oopf", `One 0x1D546;
  "oopf", `One 0x1D560;
  "opar", `One 0x029B7;
  "OpenCurlyDoubleQuote", `One 0x0201C;
  "OpenCurlyQuote", `One 0x02018;
  "operp", `One 0x029B9;
  "oplus", `One 0x02295;
  "Or", `One 0x02A54;
  "or", `One 0x02228;
  "orarr", `One 0x021BB;
  "ord", `One 0x02A5D;
  "order", `One 0x02134;
  "orderof", `One 0x02134;
  "ordf", `One 0x000AA;
  "ord", `One 0x000AA;
  "ordm", `One 0x000BA;
  "ord", `One 0x000BA;
  "origof", `One 0x022B6;
  "oror", `One 0x02A56;
  "orslope", `One 0x02A57;
  "orv", `One 0x02A5B;
  "oS", `One 0x024C8;
  "Oscr", `One 0x1D4AA;
  "oscr", `One 0x02134;
  "Oslash", `One 0x000D8;
  "Oslas", `One 0x000D8;
  "oslash", `One 0x000F8;
  "oslas", `One 0x000F8;
  "osol", `One 0x02298;
  "Otilde", `One 0x000D5;
  "Otild", `One 0x000D5;
  "otilde", `One 0x000F5;
  "otild", `One 0x000F5;
  "Otimes", `One 0x02A37;
  "otimes", `One 0x02297;
  "otimesas", `One 0x02A36;
  "Ouml", `One 0x000D6;
  "Oum", `One 0x000D6;
  "ouml", `One 0x000F6;
  "oum", `One 0x000F6;
  "ovbar", `One 0x0233D;
  "OverBar", `One 0x0203E;
  "OverBrace", `One 0x023DE;
  "OverBracket", `One 0x023B4;
  "OverParenthesis", `One 0x023DC;
  "par", `One 0x02225;
  "para", `One 0x000B6;
  "par", `One 0x000B6;
  "parallel", `One 0x02225;
  "parsim", `One 0x02AF3;
  "parsl", `One 0x02AFD;
  "part", `One 0x02202;
  "PartialD", `One 0x02202;
  "Pcy", `One 0x0041F;
  "pcy", `One 0x0043F;
  "percnt", `One 0x00025;
  "period", `One 0x0002E;
  "permil", `One 0x02030;
  "perp", `One 0x022A5;
  "pertenk", `One 0x02031;
  "Pfr", `One 0x1D513;
  "pfr", `One 0x1D52D;
  "Phi", `One 0x003A6;
  "phi", `One 0x003C6;
  "phiv", `One 0x003D5;
  "phmmat", `One 0x02133;
  "phone", `One 0x0260E;
  "Pi", `One 0x003A0;
  "pi", `One 0x003C0;
  "pitchfork", `One 0x022D4;
  "piv", `One 0x003D6;
  "planck", `One 0x0210F;
  "planckh", `One 0x0210E;
  "plankv", `One 0x0210F;
  "plus", `One 0x0002B;
  "plusacir", `One 0x02A23;
  "plusb", `One 0x0229E;
  "pluscir", `One 0x02A22;
  "plusdo", `One 0x02214;
  "plusdu", `One 0x02A25;
  "pluse", `One 0x02A72;
  "PlusMinus", `One 0x000B1;
  "plusmn", `One 0x000B1;
  "plusm", `One 0x000B1;
  "plussim", `One 0x02A26;
  "plustwo", `One 0x02A27;
  "pm", `One 0x000B1;
  "Poincareplane", `One 0x0210C;
  "pointint", `One 0x02A15;
  "Popf", `One 0x02119;
  "popf", `One 0x1D561;
  "pound", `One 0x000A3;
  "poun", `One 0x000A3;
  "Pr", `One 0x02ABB;
  "pr", `One 0x0227A;
  "prap", `One 0x02AB7;
  "prcue", `One 0x0227C;
  "prE", `One 0x02AB3;
  "pre", `One 0x02AAF;
  "prec", `One 0x0227A;
  "precapprox", `One 0x02AB7;
  "preccurlyeq", `One 0x0227C;
  "Precedes", `One 0x0227A;
  "PrecedesEqual", `One 0x02AAF;
  "PrecedesSlantEqual", `One 0x0227C;
  "PrecedesTilde", `One 0x0227E;
  "preceq", `One 0x02AAF;
  "precnapprox", `One 0x02AB9;
  "precneqq", `One 0x02AB5;
  "precnsim", `One 0x022E8;
  "precsim", `One 0x0227E;
  "Prime", `One 0x02033;
  "prime", `One 0x02032;
  "primes", `One 0x02119;
  "prnap", `One 0x02AB9;
  "prnE", `One 0x02AB5;
  "prnsim", `One 0x022E8;
  "prod", `One 0x0220F;
  "Product", `One 0x0220F;
  "profalar", `One 0x0232E;
  "profline", `One 0x02312;
  "profsurf", `One 0x02313;
  "prop", `One 0x0221D;
  "Proportion", `One 0x02237;
  "Proportional", `One 0x0221D;
  "propto", `One 0x0221D;
  "prsim", `One 0x0227E;
  "prurel", `One 0x022B0;
  "Pscr", `One 0x1D4AB;
  "pscr", `One 0x1D4C5;
  "Psi", `One 0x003A8;
  "psi", `One 0x003C8;
  "puncsp", `One 0x02008;
  "Qfr", `One 0x1D514;
  "qfr", `One 0x1D52E;
  "qint", `One 0x02A0C;
  "Qopf", `One 0x0211A;
  "qopf", `One 0x1D562;
  "qprime", `One 0x02057;
  "Qscr", `One 0x1D4AC;
  "qscr", `One 0x1D4C6;
  "quaternions", `One 0x0210D;
  "quatint", `One 0x02A16;
  "quest", `One 0x0003F;
  "questeq", `One 0x0225F;
  "QUOT", `One 0x00022;
  "QUO", `One 0x00022;
  "quot", `One 0x00022;
  "quo", `One 0x00022;
  "rAarr", `One 0x021DB;
  "race", `Two (0x0223D, 0x00331);
  "Racute", `One 0x00154;
  "racute", `One 0x00155;
  "radic", `One 0x0221A;
  "raemptyv", `One 0x029B3;
  "Rang", `One 0x027EB;
  "rang", `One 0x027E9;
  "rangd", `One 0x02992;
  "range", `One 0x029A5;
  "rangle", `One 0x027E9;
  "raquo", `One 0x000BB;
  "raqu", `One 0x000BB;
  "Rarr", `One 0x021A0;
  "rArr", `One 0x021D2;
  "rarr", `One 0x02192;
  "rarrap", `One 0x02975;
  "rarrb", `One 0x021E5;
  "rarrbfs", `One 0x02920;
  "rarrc", `One 0x02933;
  "rarrfs", `One 0x0291E;
  "rarrhk", `One 0x021AA;
  "rarrlp", `One 0x021AC;
  "rarrpl", `One 0x02945;
  "rarrsim", `One 0x02974;
  "Rarrtl", `One 0x02916;
  "rarrtl", `One 0x021A3;
  "rarrw", `One 0x0219D;
  "rAtail", `One 0x0291C;
  "ratail", `One 0x0291A;
  "ratio", `One 0x02236;
  "rationals", `One 0x0211A;
  "RBarr", `One 0x02910;
  "rBarr", `One 0x0290F;
  "rbarr", `One 0x0290D;
  "rbbrk", `One 0x02773;
  "rbrace", `One 0x0007D;
  "rbrack", `One 0x0005D;
  "rbrke", `One 0x0298C;
  "rbrksld", `One 0x0298E;
  "rbrkslu", `One 0x02990;
  "Rcaron", `One 0x00158;
  "rcaron", `One 0x00159;
  "Rcedil", `One 0x00156;
  "rcedil", `One 0x00157;
  "rceil", `One 0x02309;
  "rcub", `One 0x0007D;
  "Rcy", `One 0x00420;
  "rcy", `One 0x00440;
  "rdca", `One 0x02937;
  "rdldhar", `One 0x02969;
  "rdquo", `One 0x0201D;
  "rdquor", `One 0x0201D;
  "rdsh", `One 0x021B3;
  "Re", `One 0x0211C;
  "real", `One 0x0211C;
  "realine", `One 0x0211B;
  "realpart", `One 0x0211C;
  "reals", `One 0x0211D;
  "rect", `One 0x025AD;
  "REG", `One 0x000AE;
  "RE", `One 0x000AE;
  "reg", `One 0x000AE;
  "re", `One 0x000AE;
  "ReverseElement", `One 0x0220B;
  "ReverseEquilibrium", `One 0x021CB;
  "ReverseUpEquilibrium", `One 0x0296F;
  "rfisht", `One 0x0297D;
  "rfloor", `One 0x0230B;
  "Rfr", `One 0x0211C;
  "rfr", `One 0x1D52F;
  "rHar", `One 0x02964;
  "rhard", `One 0x021C1;
  "rharu", `One 0x021C0;
  "rharul", `One 0x0296C;
  "Rho", `One 0x003A1;
  "rho", `One 0x003C1;
  "rhov", `One 0x003F1;
  "RightAngleBracket", `One 0x027E9;
  "RightArrow", `One 0x02192;
  "Rightarrow", `One 0x021D2;
  "rightarrow", `One 0x02192;
  "RightArrowBar", `One 0x021E5;
  "RightArrowLeftArrow", `One 0x021C4;
  "rightarrowtail", `One 0x021A3;
  "RightCeiling", `One 0x02309;
  "RightDoubleBracket", `One 0x027E7;
  "RightDownTeeVector", `One 0x0295D;
  "RightDownVector", `One 0x021C2;
  "RightDownVectorBar", `One 0x02955;
  "RightFloor", `One 0x0230B;
  "rightharpoondown", `One 0x021C1;
  "rightharpoonup", `One 0x021C0;
  "rightleftarrows", `One 0x021C4;
  "rightleftharpoons", `One 0x021CC;
  "rightrightarrows", `One 0x021C9;
  "rightsquigarrow", `One 0x0219D;
  "RightTee", `One 0x022A2;
  "RightTeeArrow", `One 0x021A6;
  "RightTeeVector", `One 0x0295B;
  "rightthreetimes", `One 0x022CC;
  "RightTriangle", `One 0x022B3;
  "RightTriangleBar", `One 0x029D0;
  "RightTriangleEqual", `One 0x022B5;
  "RightUpDownVector", `One 0x0294F;
  "RightUpTeeVector", `One 0x0295C;
  "RightUpVector", `One 0x021BE;
  "RightUpVectorBar", `One 0x02954;
  "RightVector", `One 0x021C0;
  "RightVectorBar", `One 0x02953;
  "ring", `One 0x002DA;
  "risingdotseq", `One 0x02253;
  "rlarr", `One 0x021C4;
  "rlhar", `One 0x021CC;
  "rlm", `One 0x0200F;
  "rmoust", `One 0x023B1;
  "rmoustache", `One 0x023B1;
  "rnmid", `One 0x02AEE;
  "roang", `One 0x027ED;
  "roarr", `One 0x021FE;
  "robrk", `One 0x027E7;
  "ropar", `One 0x02986;
  "Ropf", `One 0x0211D;
  "ropf", `One 0x1D563;
  "roplus", `One 0x02A2E;
  "rotimes", `One 0x02A35;
  "RoundImplies", `One 0x02970;
  "rpar", `One 0x00029;
  "rpargt", `One 0x02994;
  "rppolint", `One 0x02A12;
  "rrarr", `One 0x021C9;
  "Rrightarrow", `One 0x021DB;
  "rsaquo", `One 0x0203A;
  "Rscr", `One 0x0211B;
  "rscr", `One 0x1D4C7;
  "Rsh", `One 0x021B1;
  "rsh", `One 0x021B1;
  "rsqb", `One 0x0005D;
  "rsquo", `One 0x02019;
  "rsquor", `One 0x02019;
  "rthree", `One 0x022CC;
  "rtimes", `One 0x022CA;
  "rtri", `One 0x025B9;
  "rtrie", `One 0x022B5;
  "rtrif", `One 0x025B8;
  "rtriltri", `One 0x029CE;
  "RuleDelayed", `One 0x029F4;
  "ruluhar", `One 0x02968;
  "rx", `One 0x0211E;
  "Sacute", `One 0x0015A;
  "sacute", `One 0x0015B;
  "sbquo", `One 0x0201A;
  "Sc", `One 0x02ABC;
  "sc", `One 0x0227B;
  "scap", `One 0x02AB8;
  "Scaron", `One 0x00160;
  "scaron", `One 0x00161;
  "sccue", `One 0x0227D;
  "scE", `One 0x02AB4;
  "sce", `One 0x02AB0;
  "Scedil", `One 0x0015E;
  "scedil", `One 0x0015F;
  "Scirc", `One 0x0015C;
  "scirc", `One 0x0015D;
  "scnap", `One 0x02ABA;
  "scnE", `One 0x02AB6;
  "scnsim", `One 0x022E9;
  "scpolint", `One 0x02A13;
  "scsim", `One 0x0227F;
  "Scy", `One 0x00421;
  "scy", `One 0x00441;
  "sdot", `One 0x022C5;
  "sdotb", `One 0x022A1;
  "sdote", `One 0x02A66;
  "searhk", `One 0x02925;
  "seArr", `One 0x021D8;
  "searr", `One 0x02198;
  "searrow", `One 0x02198;
  "sect", `One 0x000A7;
  "sec", `One 0x000A7;
  "semi", `One 0x0003B;
  "seswar", `One 0x02929;
  "setminus", `One 0x02216;
  "setmn", `One 0x02216;
  "sext", `One 0x02736;
  "Sfr", `One 0x1D516;
  "sfr", `One 0x1D530;
  "sfrown", `One 0x02322;
  "sharp", `One 0x0266F;
  "SHCHcy", `One 0x00429;
  "shchcy", `One 0x00449;
  "SHcy", `One 0x00428;
  "shcy", `One 0x00448;
  "ShortDownArrow", `One 0x02193;
  "ShortLeftArrow", `One 0x02190;
  "shortmid", `One 0x02223;
  "shortparallel", `One 0x02225;
  "ShortRightArrow", `One 0x02192;
  "ShortUpArrow", `One 0x02191;
  "shy", `One 0x000AD;
  "sh", `One 0x000AD;
  "Sigma", `One 0x003A3;
  "sigma", `One 0x003C3;
  "sigmaf", `One 0x003C2;
  "sigmav", `One 0x003C2;
  "sim", `One 0x0223C;
  "simdot", `One 0x02A6A;
  "sime", `One 0x02243;
  "simeq", `One 0x02243;
  "simg", `One 0x02A9E;
  "simgE", `One 0x02AA0;
  "siml", `One 0x02A9D;
  "simlE", `One 0x02A9F;
  "simne", `One 0x02246;
  "simplus", `One 0x02A24;
  "simrarr", `One 0x02972;
  "slarr", `One 0x02190;
  "SmallCircle", `One 0x02218;
  "smallsetminus", `One 0x02216;
  "smashp", `One 0x02A33;
  "smeparsl", `One 0x029E4;
  "smid", `One 0x02223;
  "smile", `One 0x02323;
  "smt", `One 0x02AAA;
  "smte", `One 0x02AAC;
  "smtes", `Two (0x02AAC, 0x0FE00);
  "SOFTcy", `One 0x0042C;
  "softcy", `One 0x0044C;
  "sol", `One 0x0002F;
  "solb", `One 0x029C4;
  "solbar", `One 0x0233F;
  "Sopf", `One 0x1D54A;
  "sopf", `One 0x1D564;
  "spades", `One 0x02660;
  "spadesuit", `One 0x02660;
  "spar", `One 0x02225;
  "sqcap", `One 0x02293;
  "sqcaps", `Two (0x02293, 0x0FE00);
  "sqcup", `One 0x02294;
  "sqcups", `Two (0x02294, 0x0FE00);
  "Sqrt", `One 0x0221A;
  "sqsub", `One 0x0228F;
  "sqsube", `One 0x02291;
  "sqsubset", `One 0x0228F;
  "sqsubseteq", `One 0x02291;
  "sqsup", `One 0x02290;
  "sqsupe", `One 0x02292;
  "sqsupset", `One 0x02290;
  "sqsupseteq", `One 0x02292;
  "squ", `One 0x025A1;
  "Square", `One 0x025A1;
  "square", `One 0x025A1;
  "SquareIntersection", `One 0x02293;
  "SquareSubset", `One 0x0228F;
  "SquareSubsetEqual", `One 0x02291;
  "SquareSuperset", `One 0x02290;
  "SquareSupersetEqual", `One 0x02292;
  "SquareUnion", `One 0x02294;
  "squarf", `One 0x025AA;
  "squf", `One 0x025AA;
  "srarr", `One 0x02192;
  "Sscr", `One 0x1D4AE;
  "sscr", `One 0x1D4C8;
  "ssetmn", `One 0x02216;
  "ssmile", `One 0x02323;
  "sstarf", `One 0x022C6;
  "Star", `One 0x022C6;
  "star", `One 0x02606;
  "starf", `One 0x02605;
  "straightepsilon", `One 0x003F5;
  "straightphi", `One 0x003D5;
  "strns", `One 0x000AF;
  "Sub", `One 0x022D0;
  "sub", `One 0x02282;
  "subdot", `One 0x02ABD;
  "subE", `One 0x02AC5;
  "sube", `One 0x02286;
  "subedot", `One 0x02AC3;
  "submult", `One 0x02AC1;
  "subnE", `One 0x02ACB;
  "subne", `One 0x0228A;
  "subplus", `One 0x02ABF;
  "subrarr", `One 0x02979;
  "Subset", `One 0x022D0;
  "subset", `One 0x02282;
  "subseteq", `One 0x02286;
  "subseteqq", `One 0x02AC5;
  "SubsetEqual", `One 0x02286;
  "subsetneq", `One 0x0228A;
  "subsetneqq", `One 0x02ACB;
  "subsim", `One 0x02AC7;
  "subsub", `One 0x02AD5;
  "subsup", `One 0x02AD3;
  "succ", `One 0x0227B;
  "succapprox", `One 0x02AB8;
  "succcurlyeq", `One 0x0227D;
  "Succeeds", `One 0x0227B;
  "SucceedsEqual", `One 0x02AB0;
  "SucceedsSlantEqual", `One 0x0227D;
  "SucceedsTilde", `One 0x0227F;
  "succeq", `One 0x02AB0;
  "succnapprox", `One 0x02ABA;
  "succneqq", `One 0x02AB6;
  "succnsim", `One 0x022E9;
  "succsim", `One 0x0227F;
  "SuchThat", `One 0x0220B;
  "Sum", `One 0x02211;
  "sum", `One 0x02211;
  "sung", `One 0x0266A;
  "Sup", `One 0x022D1;
  "sup", `One 0x02283;
  "sup1", `One 0x000B9;
  "sup", `One 0x000B9;
  "sup2", `One 0x000B2;
  "sup", `One 0x000B2;
  "sup3", `One 0x000B3;
  "sup", `One 0x000B3;
  "supdot", `One 0x02ABE;
  "supdsub", `One 0x02AD8;
  "supE", `One 0x02AC6;
  "supe", `One 0x02287;
  "supedot", `One 0x02AC4;
  "Superset", `One 0x02283;
  "SupersetEqual", `One 0x02287;
  "suphsol", `One 0x027C9;
  "suphsub", `One 0x02AD7;
  "suplarr", `One 0x0297B;
  "supmult", `One 0x02AC2;
  "supnE", `One 0x02ACC;
  "supne", `One 0x0228B;
  "supplus", `One 0x02AC0;
  "Supset", `One 0x022D1;
  "supset", `One 0x02283;
  "supseteq", `One 0x02287;
  "supseteqq", `One 0x02AC6;
  "supsetneq", `One 0x0228B;
  "supsetneqq", `One 0x02ACC;
  "supsim", `One 0x02AC8;
  "supsub", `One 0x02AD4;
  "supsup", `One 0x02AD6;
  "swarhk", `One 0x02926;
  "swArr", `One 0x021D9;
  "swarr", `One 0x02199;
  "swarrow", `One 0x02199;
  "swnwar", `One 0x0292A;
  "szlig", `One 0x000DF;
  "szli", `One 0x000DF;
  "Tab", `One 0x00009;
  "target", `One 0x02316;
  "Tau", `One 0x003A4;
  "tau", `One 0x003C4;
  "tbrk", `One 0x023B4;
  "Tcaron", `One 0x00164;
  "tcaron", `One 0x00165;
  "Tcedil", `One 0x00162;
  "tcedil", `One 0x00163;
  "Tcy", `One 0x00422;
  "tcy", `One 0x00442;
  "tdot", `One 0x020DB;
  "telrec", `One 0x02315;
  "Tfr", `One 0x1D517;
  "tfr", `One 0x1D531;
  "there4", `One 0x02234;
  "Therefore", `One 0x02234;
  "therefore", `One 0x02234;
  "Theta", `One 0x00398;
  "theta", `One 0x003B8;
  "thetasym", `One 0x003D1;
  "thetav", `One 0x003D1;
  "thickapprox", `One 0x02248;
  "thicksim", `One 0x0223C;
  "ThickSpace", `Two (0x0205F, 0x0200A);
  "thinsp", `One 0x02009;
  "ThinSpace", `One 0x02009;
  "thkap", `One 0x02248;
  "thksim", `One 0x0223C;
  "THORN", `One 0x000DE;
  "THOR", `One 0x000DE;
  "thorn", `One 0x000FE;
  "thor", `One 0x000FE;
  "Tilde", `One 0x0223C;
  "tilde", `One 0x002DC;
  "TildeEqual", `One 0x02243;
  "TildeFullEqual", `One 0x02245;
  "TildeTilde", `One 0x02248;
  "times", `One 0x000D7;
  "time", `One 0x000D7;
  "timesb", `One 0x022A0;
  "timesbar", `One 0x02A31;
  "timesd", `One 0x02A30;
  "tint", `One 0x0222D;
  "toea", `One 0x02928;
  "top", `One 0x022A4;
  "topbot", `One 0x02336;
  "topcir", `One 0x02AF1;
  "Topf", `One 0x1D54B;
  "topf", `One 0x1D565;
  "topfork", `One 0x02ADA;
  "tosa", `One 0x02929;
  "tprime", `One 0x02034;
  "TRADE", `One 0x02122;
  "trade", `One 0x02122;
  "triangle", `One 0x025B5;
  "triangledown", `One 0x025BF;
  "triangleleft", `One 0x025C3;
  "trianglelefteq", `One 0x022B4;
  "triangleq", `One 0x0225C;
  "triangleright", `One 0x025B9;
  "trianglerighteq", `One 0x022B5;
  "tridot", `One 0x025EC;
  "trie", `One 0x0225C;
  "triminus", `One 0x02A3A;
  "TripleDot", `One 0x020DB;
  "triplus", `One 0x02A39;
  "trisb", `One 0x029CD;
  "tritime", `One 0x02A3B;
  "trpezium", `One 0x023E2;
  "Tscr", `One 0x1D4AF;
  "tscr", `One 0x1D4C9;
  "TScy", `One 0x00426;
  "tscy", `One 0x00446;
  "TSHcy", `One 0x0040B;
  "tshcy", `One 0x0045B;
  "Tstrok", `One 0x00166;
  "tstrok", `One 0x00167;
  "twixt", `One 0x0226C;
  "twoheadleftarrow", `One 0x0219E;
  "twoheadrightarrow", `One 0x021A0;
  "Uacute", `One 0x000DA;
  "Uacut", `One 0x000DA;
  "uacute", `One 0x000FA;
  "uacut", `One 0x000FA;
  "Uarr", `One 0x0219F;
  "uArr", `One 0x021D1;
  "uarr", `One 0x02191;
  "Uarrocir", `One 0x02949;
  "Ubrcy", `One 0x0040E;
  "ubrcy", `One 0x0045E;
  "Ubreve", `One 0x0016C;
  "ubreve", `One 0x0016D;
  "Ucirc", `One 0x000DB;
  "Ucir", `One 0x000DB;
  "ucirc", `One 0x000FB;
  "ucir", `One 0x000FB;
  "Ucy", `One 0x00423;
  "ucy", `One 0x00443;
  "udarr", `One 0x021C5;
  "Udblac", `One 0x00170;
  "udblac", `One 0x00171;
  "udhar", `One 0x0296E;
  "ufisht", `One 0x0297E;
  "Ufr", `One 0x1D518;
  "ufr", `One 0x1D532;
  "Ugrave", `One 0x000D9;
  "Ugrav", `One 0x000D9;
  "ugrave", `One 0x000F9;
  "ugrav", `One 0x000F9;
  "uHar", `One 0x02963;
  "uharl", `One 0x021BF;
  "uharr", `One 0x021BE;
  "uhblk", `One 0x02580;
  "ulcorn", `One 0x0231C;
  "ulcorner", `One 0x0231C;
  "ulcrop", `One 0x0230F;
  "ultri", `One 0x025F8;
  "Umacr", `One 0x0016A;
  "umacr", `One 0x0016B;
  "uml", `One 0x000A8;
  "um", `One 0x000A8;
  "UnderBar", `One 0x0005F;
  "UnderBrace", `One 0x023DF;
  "UnderBracket", `One 0x023B5;
  "UnderParenthesis", `One 0x023DD;
  "Union", `One 0x022C3;
  "UnionPlus", `One 0x0228E;
  "Uogon", `One 0x00172;
  "uogon", `One 0x00173;
  "Uopf", `One 0x1D54C;
  "uopf", `One 0x1D566;
  "UpArrow", `One 0x02191;
  "Uparrow", `One 0x021D1;
  "uparrow", `One 0x02191;
  "UpArrowBar", `One 0x02912;
  "UpArrowDownArrow", `One 0x021C5;
  "UpDownArrow", `One 0x02195;
  "Updownarrow", `One 0x021D5;
  "updownarrow", `One 0x02195;
  "UpEquilibrium", `One 0x0296E;
  "upharpoonleft", `One 0x021BF;
  "upharpoonright", `One 0x021BE;
  "uplus", `One 0x0228E;
  "UpperLeftArrow", `One 0x02196;
  "UpperRightArrow", `One 0x02197;
  "Upsi", `One 0x003D2;
  "upsi", `One 0x003C5;
  "upsih", `One 0x003D2;
  "Upsilon", `One 0x003A5;
  "upsilon", `One 0x003C5;
  "UpTee", `One 0x022A5;
  "UpTeeArrow", `One 0x021A5;
  "upuparrows", `One 0x021C8;
  "urcorn", `One 0x0231D;
  "urcorner", `One 0x0231D;
  "urcrop", `One 0x0230E;
  "Uring", `One 0x0016E;
  "uring", `One 0x0016F;
  "urtri", `One 0x025F9;
  "Uscr", `One 0x1D4B0;
  "uscr", `One 0x1D4CA;
  "utdot", `One 0x022F0;
  "Utilde", `One 0x00168;
  "utilde", `One 0x00169;
  "utri", `One 0x025B5;
  "utrif", `One 0x025B4;
  "uuarr", `One 0x021C8;
  "Uuml", `One 0x000DC;
  "Uum", `One 0x000DC;
  "uuml", `One 0x000FC;
  "uum", `One 0x000FC;
  "uwangle", `One 0x029A7;
  "vangrt", `One 0x0299C;
  "varepsilon", `One 0x003F5;
  "varkappa", `One 0x003F0;
  "varnothing", `One 0x02205;
  "varphi", `One 0x003D5;
  "varpi", `One 0x003D6;
  "varpropto", `One 0x0221D;
  "vArr", `One 0x021D5;
  "varr", `One 0x02195;
  "varrho", `One 0x003F1;
  "varsigma", `One 0x003C2;
  "varsubsetneq", `Two (0x0228A, 0x0FE00);
  "varsubsetneqq", `Two (0x02ACB, 0x0FE00);
  "varsupsetneq", `Two (0x0228B, 0x0FE00);
  "varsupsetneqq", `Two (0x02ACC, 0x0FE00);
  "vartheta", `One 0x003D1;
  "vartriangleleft", `One 0x022B2;
  "vartriangleright", `One 0x022B3;
  "Vbar", `One 0x02AEB;
  "vBar", `One 0x02AE8;
  "vBarv", `One 0x02AE9;
  "Vcy", `One 0x00412;
  "vcy", `One 0x00432;
  "VDash", `One 0x022AB;
  "Vdash", `One 0x022A9;
  "vDash", `One 0x022A8;
  "vdash", `One 0x022A2;
  "Vdashl", `One 0x02AE6;
  "Vee", `One 0x022C1;
  "vee", `One 0x02228;
  "veebar", `One 0x022BB;
  "veeeq", `One 0x0225A;
  "vellip", `One 0x022EE;
  "Verbar", `One 0x02016;
  "verbar", `One 0x0007C;
  "Vert", `One 0x02016;
  "vert", `One 0x0007C;
  "VerticalBar", `One 0x02223;
  "VerticalLine", `One 0x0007C;
  "VerticalSeparator", `One 0x02758;
  "VerticalTilde", `One 0x02240;
  "VeryThinSpace", `One 0x0200A;
  "Vfr", `One 0x1D519;
  "vfr", `One 0x1D533;
  "vltri", `One 0x022B2;
  "vnsub", `Two (0x02282, 0x020D2);
  "vnsup", `Two (0x02283, 0x020D2);
  "Vopf", `One 0x1D54D;
  "vopf", `One 0x1D567;
  "vprop", `One 0x0221D;
  "vrtri", `One 0x022B3;
  "Vscr", `One 0x1D4B1;
  "vscr", `One 0x1D4CB;
  "vsubnE", `Two (0x02ACB, 0x0FE00);
  "vsubne", `Two (0x0228A, 0x0FE00);
  "vsupnE", `Two (0x02ACC, 0x0FE00);
  "vsupne", `Two (0x0228B, 0x0FE00);
  "Vvdash", `One 0x022AA;
  "vzigzag", `One 0x0299A;
  "Wcirc", `One 0x00174;
  "wcirc", `One 0x00175;
  "wedbar", `One 0x02A5F;
  "Wedge", `One 0x022C0;
  "wedge", `One 0x02227;
  "wedgeq", `One 0x02259;
  "weierp", `One 0x02118;
  "Wfr", `One 0x1D51A;
  "wfr", `One 0x1D534;
  "Wopf", `One 0x1D54E;
  "wopf", `One 0x1D568;
  "wp", `One 0x02118;
  "wr", `One 0x02240;
  "wreath", `One 0x02240;
  "Wscr", `One 0x1D4B2;
  "wscr", `One 0x1D4CC;
  "xcap", `One 0x022C2;
  "xcirc", `One 0x025EF;
  "xcup", `One 0x022C3;
  "xdtri", `One 0x025BD;
  "Xfr", `One 0x1D51B;
  "xfr", `One 0x1D535;
  "xhArr", `One 0x027FA;
  "xharr", `One 0x027F7;
  "Xi", `One 0x0039E;
  "xi", `One 0x003BE;
  "xlArr", `One 0x027F8;
  "xlarr", `One 0x027F5;
  "xmap", `One 0x027FC;
  "xnis", `One 0x022FB;
  "xodot", `One 0x02A00;
  "Xopf", `One 0x1D54F;
  "xopf", `One 0x1D569;
  "xoplus", `One 0x02A01;
  "xotime", `One 0x02A02;
  "xrArr", `One 0x027F9;
  "xrarr", `One 0x027F6;
  "Xscr", `One 0x1D4B3;
  "xscr", `One 0x1D4CD;
  "xsqcup", `One 0x02A06;
  "xuplus", `One 0x02A04;
  "xutri", `One 0x025B3;
  "xvee", `One 0x022C1;
  "xwedge", `One 0x022C0;
  "Yacute", `One 0x000DD;
  "Yacut", `One 0x000DD;
  "yacute", `One 0x000FD;
  "yacut", `One 0x000FD;
  "YAcy", `One 0x0042F;
  "yacy", `One 0x0044F;
  "Ycirc", `One 0x00176;
  "ycirc", `One 0x00177;
  "Ycy", `One 0x0042B;
  "ycy", `One 0x0044B;
  "yen", `One 0x000A5;
  "ye", `One 0x000A5;
  "Yfr", `One 0x1D51C;
  "yfr", `One 0x1D536;
  "YIcy", `One 0x00407;
  "yicy", `One 0x00457;
  "Yopf", `One 0x1D550;
  "yopf", `One 0x1D56A;
  "Yscr", `One 0x1D4B4;
  "yscr", `One 0x1D4CE;
  "YUcy", `One 0x0042E;
  "yucy", `One 0x0044E;
  "Yuml", `One 0x00178;
  "yuml", `One 0x000FF;
  "yum", `One 0x000FF;
  "Zacute", `One 0x00179;
  "zacute", `One 0x0017A;
  "Zcaron", `One 0x0017D;
  "zcaron", `One 0x0017E;
  "Zcy", `One 0x00417;
  "zcy", `One 0x00437;
  "Zdot", `One 0x0017B;
  "zdot", `One 0x0017C;
  "zeetrf", `One 0x02128;
  "ZeroWidthSpace", `One 0x0200B;
  "Zeta", `One 0x00396;
  "zeta", `One 0x003B6;
  "Zfr", `One 0x02128;
  "zfr", `One 0x1D537;
  "ZHcy", `One 0x00416;
  "zhcy", `One 0x00436;
  "zigrarr", `One 0x021DD;
  "Zopf", `One 0x02124;
  "zopf", `One 0x1D56B;
  "Zscr", `One 0x1D4B5;
  "zscr", `One 0x1D4CF;
  "zwj", `One 0x0200D;
  "zwnj", `One 0x0200C
|]

end
module Markup_trie
= struct
#1 "markup_trie.ml"
(* This file is part of Markup.ml, released under the BSD 2-clause license. See
   doc/LICENSE for details, or visit https://github.com/aantron/markup.ml. *)

(* Tries. These aren't fully functional nor fully mutable. To accumulate a trie,
   it is necessary to retain the latest result of [add]. However, previous tries
   become invalid after [add]. *)

type 'a trie =
  | Empty
  | Leaf of 'a
  | Node of 'a option * 'a trie array

let lower_limit = Char.code '0'
let upper_limit = Char.code 'z'
let array_size = upper_limit - lower_limit + 1

let create () =
  Empty

let edge_index c =
  Char.code c - lower_limit

let add key value trie =
  let rec traverse index trie =
    if index >= String.length key then
      match trie with
      | Empty | Leaf _ -> Leaf value
      | Node (_, children) -> Node (Some value, children)

    else
      let edge_index = edge_index key.[index] in
      let value', children, current_child =
        match trie with
        | Empty -> None, None, Empty
        | Leaf v -> Some v, None, Empty
        | Node (v, children) -> v, Some children, children.(edge_index)
      in
      let child = traverse (index + 1) current_child in
      let children =
        match children with
        | None ->
          Array.init array_size (fun i ->
            if i = edge_index then child else Empty)
        | Some children ->
          children.(edge_index) <- child;
          children
      in
      Node (value', children)
  in

  traverse 0 trie

type 'a match_ =
  | No
  | Yes of 'a
  | Prefix
  | Multiple of 'a

let matches = function
  | Empty -> No
  | Leaf v -> Yes v
  | Node (None, _) -> Prefix
  | Node (Some v, _) -> Multiple v

let advance c = function
  | Empty | Leaf _ -> Empty
  | Node (_, children) ->
    if c < lower_limit || c > upper_limit then Empty
    else children.(c - lower_limit)

let guess_memory_usage trie =
  let rec accumulate words = function
    | Empty -> words + 1
    | Leaf _ -> words + 2
    | Node (_, children) ->
      let words = words + 4 + Array.length children in
      Array.fold_left accumulate words children
  in
  accumulate 0 trie

end
module Markup_html_tokenizer : sig 
#1 "markup_html_tokenizer.mli"
(* This file is part of Markup.ml, released under the BSD 2-clause license. See
   doc/LICENSE for details, or visit https://github.com/aantron/markup.ml. *)

open Markup_common

type token =
  [ `Doctype of doctype
  | `Start of Token_tag.t
  | `End of Token_tag.t
  | `Char of int
  | `Comment of string
  | `EOF ]

type state = [ `Data | `RCDATA | `RAWTEXT | `Script_data | `PLAINTEXT ]

val tokenize :
  Markup_error.parse_handler ->
  (location * int) Markup_kstream.t * (unit -> location) ->
    (location * token) Markup_kstream.t *
    (state -> unit) *
    ((unit -> bool) -> unit)

end = struct
#1 "markup_html_tokenizer.ml"
(* This file is part of Markup.ml, released under the BSD 2-clause license. See
   doc/LICENSE for details, or visit https://github.com/aantron/markup.ml. *)

open Markup_common
open Token_tag
module Common = Markup_common
module Trie = Markup_trie
module Kstream = Markup_kstream

type token =
  [ `Doctype of doctype
  | `Start of Token_tag.t
  | `End of Token_tag.t
  | `Char of int
  | `Comment of string
  | `EOF ]

type state = [ `Data | `RCDATA | `RAWTEXT | `Script_data | `PLAINTEXT ]

let replace_windows_1252_entity = function
  | 0x80 -> 0x20AC
  | 0x82 -> 0x201A
  | 0x83 -> 0x0192
  | 0x84 -> 0x201E
  | 0x85 -> 0x2026
  | 0x86 -> 0x2020
  | 0x87 -> 0x2021
  | 0x88 -> 0x02C6
  | 0x89 -> 0x2030
  | 0x8A -> 0x0160
  | 0x8B -> 0x2039
  | 0x8C -> 0x0152
  | 0x8E -> 0x017D
  | 0x91 -> 0x2018
  | 0x92 -> 0x2019
  | 0x93 -> 0x201C
  | 0x94 -> 0x201D
  | 0x95 -> 0x2022
  | 0x96 -> 0x2013
  | 0x97 -> 0x2014
  | 0x98 -> 0x02DC
  | 0x99 -> 0x2122
  | 0x9A -> 0x0161
  | 0x9B -> 0x203A
  | 0x9C -> 0x0153
  | 0x9E -> 0x017E
  | 0x9F -> 0x0178
  | c -> c

let named_entity_trie =
  lazy begin
    let trie = Trie.create () in
    Array.fold_left (fun trie (name, characters) ->
      Trie.add name characters trie)
      trie
      Markup_entities.entities
  end

type doctype_buffers =
  {mutable doctype_name      : Buffer.t option;
   mutable public_identifier : Buffer.t option;
   mutable system_identifier : Buffer.t option;
   mutable force_quirks      : bool}

module Doctype_buffers =
struct
  type t = doctype_buffers =
    {mutable doctype_name      : Buffer.t option;
     mutable public_identifier : Buffer.t option;
     mutable system_identifier : Buffer.t option;
     mutable force_quirks      : bool}
end

let add_doctype_char buffer c =
  let buffer =
    match buffer with
    | None -> Buffer.create 32
    | Some buffer -> buffer
  in
  add_utf_8 buffer c;
  Some buffer

type tag_buffers =
  {mutable start        : bool;
   tag_name             : Buffer.t;
   mutable self_closing : bool;
   mutable attributes   : (string * string) list}

module Tag_buffers =
struct
  type t = tag_buffers =
    {mutable start        : bool;
     tag_name             : Buffer.t;
     mutable self_closing : bool;
     mutable attributes   : (string * string) list}
end

let sequence_to_lowercase = List.map (fun (l, c) -> l, to_lowercase c)

open Kstream

let tokenize report (input, get_location) =
  let foreign = ref (fun () -> false) in

  let last_start_tag_name : string option ref = ref None in

  let is_appropriate_end_tag name_buffer =
    match !last_start_tag_name with
    | None -> false
    | Some name -> Buffer.contents name_buffer = name
  in

  let throw = ref (fun _ -> ()) in
  let ended = ref (fun _ -> ()) in
  let output = ref (fun _ -> ()) in

  let rec current_state = ref data_state

  and emit t s = current_state := s; !output t

  and emit_character l c s = emit (l, `Char c) s

  and emit_characters cs s =
    match cs with
    | [] -> s ()
    | (l, c)::cs -> emit_character l c (fun () -> emit_characters cs s)

  and emit_eof () =
    emit (get_location (), `EOF) (fun () -> !ended ())

  and emit_tag l tag' =
    let rec rev_deduplicate accumulator seen attributes k =
      match attributes with
      | [] -> k accumulator
      | (n, v)::more ->
        if list_mem_string n seen then
          report l (`Bad_token (n, "tag", "duplicate attribute")) !throw
            (fun () ->
          rev_deduplicate accumulator seen more k)
        else rev_deduplicate ((n, v)::accumulator) (n::seen) more k
    in

    rev_deduplicate [] [] (List.rev tag'.Tag_buffers.attributes)
      (fun attributes ->

    let tag =
      {Token_tag.name = Buffer.contents tag'.tag_name;
       self_closing   = tag'.self_closing;
       attributes     = List.rev attributes}
    in

    (fun k ->
      if tag'.start then begin
        last_start_tag_name := Some tag.name;
        k (`Start tag)
      end
      else
        (fun k ->
          match attributes with
          | (n, _)::_ ->
            report l (`Bad_token (n, "tag", "end tag with attributes")) !throw k
          | _ -> k ())
        @@ (fun k () ->
          if tag.Token_tag.self_closing then
            report l (`Bad_token ("/>", "tag",
                                  "end tag cannot be self-closing")) !throw k
          else k ())
        @@ (fun () -> k (`End tag)))

    (fun token ->
      emit (l, token) data_state))

  and emit_comment l buffer =
    emit (l, `Comment (Buffer.contents buffer)) data_state

  and emit_doctype ?(quirks = false) l doctype =
    if quirks then doctype.Doctype_buffers.force_quirks <- true;

    let if_not_missing = function
      | None -> None
      | Some buffer -> Some (Buffer.contents buffer)
    in

    let doctype =
      {Common.doctype_name = if_not_missing doctype.doctype_name;
       public_identifier   = if_not_missing doctype.public_identifier;
       system_identifier   = if_not_missing doctype.system_identifier;
       raw_text            = None;
       force_quirks        = doctype.force_quirks}
    in

    emit (l, `Doctype doctype) data_state

  (* Implementation of 8.2.4.69 Tokenizing character references. *)
  and consume_character_reference in_attribute additional location k =
    peek_option input !throw (function
      | Some (_, (0x0009 | 0x000A | 0x000C | 0x0020 | 0x003C | 0x0026))
      | None ->
        k None

      | Some (_, c) when Some c = additional -> k None

      | Some (_, 0x0023 as pound) ->
        let consume_digits filter k =
          let buffer = Buffer.create 8 in

          let rec iterate () =
            next_option input !throw (function
              | Some (_, c) when filter c ->
                Buffer.add_char buffer (Char.chr c); iterate ()
              | v ->
                push_option input v;
                if Buffer.length buffer = 0 then k None
                else k (Some (Buffer.contents buffer)))
          in
          iterate ()
        in

        let finish_digits prefix text s =
          let consume_semicolon k =
            next_option input !throw begin function
              | Some (_, 0x003B) -> k ";"

              | v ->
                push_option input v;
                report location
                  (`Bad_token (prefix ^ text, "character reference",
                               "missing ';' at end")) !throw (fun () ->
                k "")
            end
          in

          let convert s semicolon k' =
            let maybe_n =
              try Some (int_of_string s)
              with Failure _ -> None
            in

            match maybe_n with
            | Some n -> k' n
            | None ->
              report location
                (`Bad_token (prefix ^ text ^ semicolon, "character reference",
                             "out of range")) !throw (fun () ->
              k (Some (`One u_rep)))
          in

          consume_semicolon begin fun semicolon ->
            convert s semicolon begin fun n' ->
              let n = replace_windows_1252_entity n' in

              if n <> n' then
                report location
                  (`Bad_token (prefix ^ text ^ semicolon, "character reference",
                               "Windows-1252 character")) !throw (fun () ->
                k (Some (`One n)))

              else
                match n with
                | n when not @@ is_scalar n || n = 0 ->
                  report location
                    (`Bad_token (prefix ^ text ^ semicolon,
                                 "character reference", "out of range"))
                    !throw (fun () ->
                  k (Some (`One u_rep)))

                | n when is_control_character n || is_non_character n ->
                  report location
                    (`Bad_token (prefix ^ text ^ semicolon,
                                 "character reference",
                                 "invalid HTML character")) !throw (fun () ->
                  k (Some (`One n)))

                | n -> k (Some (`One n))
              end
            end
        in

        next_expected input !throw (fun _ ->
          peek_option input !throw (function
            | Some (_, (0x0078 | 0x0058 as c) as x) ->
              let prefix = Printf.sprintf "&#%c" (Char.chr c) in

              next_expected input !throw (fun _ ->
                consume_digits is_hex_digit (function
                  | None ->
                    push_list input [pound; x];

                    report location (`Bad_token
                      (prefix, "character reference", "expected digits"))
                      !throw (fun () ->
                    k None)

                  | Some s -> finish_digits prefix s ("0x" ^ s)))

            | _ ->
              let prefix = "&#" in

              consume_digits is_digit (function
                | None ->
                  push input pound;

                  report location (`Bad_token
                    (prefix, "character reference", "expected digits"))
                    !throw (fun () ->
                  k None)

                | Some s -> finish_digits prefix s s)))

      | _ ->
        let is_entity_like k =
          let finish replace text =
            push_list input (List.rev replace); k text in

          let buffer = Buffer.create 16 in

          let rec iterate replace =
            next_option input !throw (function
              | None -> finish replace None
              | Some ((_, c) as v) when is_alphanumeric c ->
                Buffer.add_char buffer (Char.chr c); iterate (v::replace)
              | Some ((_, 0x003B) as v) ->
                finish (v::replace) (Some (Buffer.contents buffer))
              | Some v -> finish (v::replace) None)
          in
          iterate []
        in

        let finish best matched replace =
          push_list input (List.rev replace);
          match best with
          | None ->
            is_entity_like (function
              | None -> k None
              | Some s ->
                report location
                  (`Bad_token ("&" ^ s ^ ";", "entity reference",
                               "no such entity")) !throw (fun () ->
                k None))
          | Some (text, code_points) ->
            next_option input !throw (function
              | Some (_, 0x003B) -> k (Some code_points)
              | maybe_v ->
                let unterminated () =
                  push_option input maybe_v;

                  report location
                    (`Bad_token ("&" ^ text, "entity reference",
                     "missing ';' at end")) !throw (fun () ->
                  k (Some code_points))
                in

                if not in_attribute then unterminated ()
                else
                  match maybe_v with
                  | Some ((_, c) as v) when is_alphanumeric c ->
                    push_list input (List.rev (v::matched));
                    k None
                  | Some ((_, 0x003D) as v) ->
                    push_list input (List.rev (v::matched));

                    report location
                      (`Bad_token ("&" ^ text ^ "=", "attribute",
                        "unterminated entity reference followed by '='"))
                      !throw(fun () ->
                    k None)
                  | _ -> unterminated ())
        in

        let rec match_named best matched replace trie text =
          next_option input !throw (function
            | None ->
              finish best matched replace
            | Some ((_, c) as v) ->
              let trie = Trie.advance c trie in
              add_utf_8 text c;
              match Trie.matches trie with
              | Trie.No ->
                finish best matched (v::replace)
              | Trie.Prefix ->
                match_named best matched (v::replace) trie text
              | Trie.Multiple m ->
                let w = Buffer.contents text in
                match_named (Some (w, m)) (v::(replace @ matched)) [] trie text
              | Trie.Yes m ->
                let w = Buffer.contents text in
                finish (Some (w, m)) (v::matched) [])
        in
        match_named
          None [] [] (Lazy.force named_entity_trie) (Buffer.create 16))

  (* 8.2.4.1. *)
  and data_state () =
    next_option input !throw begin function
      | Some (l, 0x0026) ->
        character_reference_state data_state l

      | Some (l, 0x003C) ->
        tag_open_state l

      | Some (l, 0) ->
        report l (`Bad_token ("U+0000", "content", "null")) !throw (fun () ->
        emit (l, `Char 0) data_state)

      | None ->
        emit_eof ()

      | Some (l, c) ->
        emit (l, `Char c) data_state
    end

  (* 8.2.4.2, 8.2.4.4. *)
  and character_reference_state state l =
    consume_character_reference false None l begin function
      | None ->
        emit (l, `Char 0x0026) state

      | Some (`One c) ->
        emit (l, `Char c) state

      | Some (`Two (c, c')) ->
        emit (l, `Char c) (fun () ->
        emit (l, `Char c') state)
    end

  (* 8.2.4.3. *)
  and rcdata_state () =
    next_option input !throw begin function
      | Some (l, 0x0026) ->
        character_reference_state rcdata_state l

      | Some (l, 0x003C as v) ->
        text_less_than_sign_state rcdata_state l [v]

      | Some (l, 0) ->
        report l (`Bad_token ("U+0000", "content", "null")) !throw (fun () ->
        emit (l, `Char u_rep) rcdata_state)

      | None ->
        emit_eof ()

      | Some (l, c) ->
        emit (l, `Char c) rcdata_state
    end

  (* 8.2.4.5. *)
  and rawtext_state () =
    next_option input !throw begin function
      | Some (l, 0x003C as v) ->
        text_less_than_sign_state rawtext_state l [v]

      | Some (l, 0) ->
        report l (`Bad_token ("U+0000", "content", "null")) !throw (fun () ->
        emit (l, `Char u_rep) rawtext_state)

      | None ->
        emit_eof ()

      | Some (l, c) ->
        emit (l, `Char c) rawtext_state
    end

  (* 8.2.4.6. *)
  and script_data_state () =
    next_option input !throw begin function
      | Some (l, 0x003C as v) ->
        script_data_less_than_sign_state l [v]

      | Some (l, 0) ->
        report l (`Bad_token ("U+0000", "content", "null")) !throw (fun () ->
        emit_character l u_rep script_data_state)

      | None ->
        emit_eof ()

      | Some (l, c) ->
        emit_character l c script_data_state
    end

  (* 8.2.4.7. *)
  and plaintext_state () =
    next_option input !throw begin function
      | Some (l, 0) ->
        report l (`Bad_token ("U+0000", "content", "null")) !throw (fun () ->
        emit (l, `Char u_rep) plaintext_state)

      | None ->
        emit_eof ()

      | Some (l, c) ->
        emit (l, `Char c) plaintext_state
    end

  (* 8.2.4.8. *)
  and tag_open_state l' =
    let tag =
      {start        = true;
       tag_name     = Buffer.create 16;
       self_closing = false;
       attributes   = []}
    in

    next_option input !throw begin function
      | Some (_, 0x0021) ->
        markup_declaration_open_state l'

      | Some (_, 0x002F) ->
        end_tag_open_state l' tag

      | Some (_, c) when is_alphabetic c ->
        add_utf_8 tag.tag_name (to_lowercase c);
        tag_name_state l' tag

      | Some (_, 0x003F) ->
        report l'
          (`Bad_token ("<?", "content",
                       "HTML does not have processing instructions"))
          !throw (fun () ->
        bogus_comment_state l')

      | Some ((l, c) as v) ->
        report l
          (`Bad_token (char c, "tag",
                       "invalid start character")) !throw (fun () ->
        push input v;
        emit_character l' 0x003C data_state)

      | None ->
        report (get_location ()) (`Unexpected_eoi "tag") !throw (fun () ->
        emit_character l' 0x003C data_state)
    end

  (* 8.2.4.9. *)
  and end_tag_open_state l' tag =
    tag.start <- false;

    next_option input !throw begin function
      | Some (_, c) when is_alphabetic c ->
        add_utf_8 tag.tag_name (to_lowercase c);
        tag_name_state l' tag

      | Some (_, 0x003E) ->
        report l' (`Bad_token ("</>", "tag", "no tag name")) !throw data_state

      | None ->
        report (get_location ()) (`Unexpected_eoi "tag") !throw (fun () ->
        let line, column = l' in
        emit (l', `Char 0x003C) (fun () ->
        emit ((line, column + 1), `Char 0x002F) data_state))

      | Some (l, c) ->
        report l
          (`Bad_token (char c, "tag",
                       "invalid start character")) !throw (fun () ->
        bogus_comment_state l')
    end

  (* 8.2.4.10. *)
  and tag_name_state l' tag =
    next_option input !throw begin function
      | Some (_, (0x0009 | 0x000A | 0x000C | 0x0020)) ->
        before_attribute_name_state l' tag

      | Some (_, 0x002F) ->
        self_closing_start_tag_state l' tag

      | Some (_, 0x003E) ->
        emit_tag l' tag

      | Some (l, 0) ->
        report l (`Bad_token ("U+0000", "tag name", "null")) !throw (fun () ->
        add_utf_8 tag.tag_name u_rep;
        tag_name_state l' tag)

      | None ->
        report (get_location ()) (`Unexpected_eoi "tag") !throw data_state

      | Some (_, c) ->
        add_utf_8 tag.tag_name (to_lowercase c);
        tag_name_state l' tag
    end

  (* 8.2.4.11, 8.2.4.14. *)
  and text_less_than_sign_state state l' cs =
    next_option input !throw begin function
      | Some (_, 0x002F as v) ->
        text_end_tag_open_state state l' (v::cs)

      | maybe_v ->
        push_option input maybe_v;
        emit_characters cs state
    end

  (* 8.2.4.12, 8.2.4.15, 8.2.4.18, 8.2.4.26. *)
  and text_end_tag_open_state state l' cs =
    next_option input !throw begin function
      | Some (_, c as v) when is_alphabetic c ->
        let name_buffer = Buffer.create 32 in
        add_utf_8 name_buffer (to_lowercase c);
        text_end_tag_name_state state l' (v::cs) name_buffer

      | maybe_v ->
        push_option input maybe_v;
        emit_characters (List.rev cs) state
    end

  (* 8.2.4.13, 8.2.4.16, 8.2.4.19, 8.2.4.27. *)
  and text_end_tag_name_state state l' cs name_buffer =
    let create_tag () =
      {start        = false;
       tag_name     = name_buffer;
       self_closing = false;
       attributes   = []}
    in

    next_option input !throw begin function
      | Some (_, (0x0009 | 0x000A | 0x000C | 0x0020))
          when is_appropriate_end_tag name_buffer ->
        before_attribute_name_state l' (create_tag ())

      | Some (_, 0x002F) when is_appropriate_end_tag name_buffer ->
        self_closing_start_tag_state l' (create_tag ())

      | Some (_, 0x003E) when is_appropriate_end_tag name_buffer ->
        emit_tag l' (create_tag ())

      | Some ((_, c) as v) when is_alphabetic c ->
        add_utf_8 name_buffer (to_lowercase c);
        text_end_tag_name_state state l' (v::cs) name_buffer

      | maybe_v ->
        push_option input maybe_v;
        emit_characters (List.rev cs) state
    end

  (* 8.2.4.17. *)
  and script_data_less_than_sign_state l' cs =
    next_option input !throw begin function
      | Some (_, 0x002F as v) ->
        text_end_tag_open_state script_data_state l' (v::cs)

      | Some (_, 0x0021 as v) ->
        emit_characters (List.rev (v::cs)) (fun () ->
        script_data_escape_start_state l')

      | maybe_v ->
        push_option input maybe_v; emit_characters cs script_data_state
    end

  (* 8.2.4.20. *)
  and script_data_escape_start_state l' =
    next_option input !throw begin function
      | Some (l, 0x002D) ->
        emit_character l 0x002D (fun () ->
        script_data_escape_start_dash_state l')

      | maybe_v ->
        push_option input maybe_v;
        script_data_state ()
    end

  (* 8.2.4.21. *)
  and script_data_escape_start_dash_state l' =
    next_option input !throw begin function
      | Some (l, 0x002D) ->
        emit_character l 0x002D (fun () ->
        script_data_escaped_dash_dash_state l')

      | maybe_v ->
        push_option input maybe_v;
        script_data_state ()
    end

  (* 8.2.4.22. *)
  and script_data_escaped_state l' =
    next_option input !throw begin function
      | Some (l, 0x002D) ->
        emit_character l 0x002D (fun () ->
        script_data_escaped_dash_state l')

      | Some ((l, 0x003C) as v) ->
        script_data_escaped_less_than_sign_state l' l [v]

      | Some (l, 0) ->
        report l (`Bad_token ("U+0000", "script", "null")) !throw (fun () ->
        emit_character l u_rep (fun () ->
        script_data_escaped_state l'))

      | None ->
        report (get_location ()) (`Unexpected_eoi "script") !throw data_state

      | Some (l, c) ->
        emit_character l c (fun () ->
        script_data_escaped_state l')
    end

  (* 8.2.4.23. *)
  and script_data_escaped_dash_state l' =
    next_option input !throw begin function
      | Some (l, 0x002D) ->
        emit_character l 0x002D (fun () ->
        script_data_escaped_dash_dash_state l')

      | Some (l, 0x003C as v) ->
        script_data_escaped_less_than_sign_state l' l [v]

      | Some (l, 0) ->
        report l (`Bad_token ("U+0000", "script", "null")) !throw (fun () ->
        emit_character l u_rep (fun () ->
        script_data_escaped_state l'))

      | None ->
        report (get_location ()) (`Unexpected_eoi "script") !throw data_state

      | Some (l, c) ->
        emit_character l c (fun () ->
        script_data_escaped_state l')
    end

  (* 8.2.4.24. *)
  and script_data_escaped_dash_dash_state l' =
    next_option input !throw begin function
      | Some (l, 0x002D) ->
        emit_character l 0x002D (fun () ->
        script_data_escaped_dash_dash_state l')

      | Some (l, 0x003C as v) ->
        script_data_escaped_less_than_sign_state l' l [v]

      | Some (l, 0x003E) ->
        emit_character l 0x003E script_data_state

      | Some (l, 0) ->
        report l (`Bad_token ("U+0000", "script", "null")) !throw (fun () ->
        emit_character l u_rep (fun () ->
        script_data_escaped_state l'))

      | None ->
        report (get_location ()) (`Unexpected_eoi "script") !throw data_state

      | Some (l, c) ->
        emit_character l c (fun () ->
        script_data_escaped_state l')
    end

  (* 8.2.4.25. *)
  and script_data_escaped_less_than_sign_state l' l'' cs =
    next_option input !throw begin function
      | Some (_, 0x002F as v) ->
        text_end_tag_open_state (fun () ->
        script_data_escaped_state l') l'' (v::cs)

      | Some (_, c as v) when is_alphabetic c ->
        let tag_buffer = Buffer.create 32 in
        add_utf_8 tag_buffer (to_lowercase c);
        emit_characters (List.rev (v::cs)) (fun () ->
        script_data_double_escape_start_state l' tag_buffer)

      | maybe_v ->
        push_option input maybe_v;
        emit_characters cs (fun () ->
        script_data_escaped_state l')
    end

  (* 8.2.4.28. *)
  and script_data_double_escape_start_state l' tag_buffer =
    next_option input !throw begin function
      | Some (l, (0x0009 | 0x000A | 0x000C | 0x0020 | 0x002F | 0x003E as c)) ->
        emit_character l c (fun () ->
        if Buffer.contents tag_buffer = "script" then
          script_data_double_escaped_state l'
        else script_data_escaped_state l')

      | Some (l, c) when is_alphabetic c ->
        add_utf_8 tag_buffer (to_lowercase c);
        emit_character l c (fun () ->
        script_data_double_escape_start_state l' tag_buffer)

      | maybe_v ->
        push_option input maybe_v;
        script_data_escaped_state l'
    end

  (* 8.2.4.29. *)
  and script_data_double_escaped_state l' =
    next_option input !throw begin function
      | Some (l, 0x002D) ->
        emit_character l 0x002D (fun () ->
        script_data_double_escaped_dash_state l')

      | Some (l, 0x003C) ->
        emit_character l 0x003C (fun () ->
        script_data_double_escaped_less_than_sign_state l')

      | Some (l, 0) ->
        report l (`Bad_token ("U+0000", "script", "null")) !throw (fun () ->
        emit_character l u_rep (fun () ->
        script_data_double_escaped_state l'))

      | None ->
        report (get_location ()) (`Unexpected_eoi "script") !throw data_state

      | Some (l, c) ->
        emit_character l c (fun () ->
        script_data_double_escaped_state l')
    end

  (* 8.2.4.30. *)
  and script_data_double_escaped_dash_state l' =
    next_option input !throw begin function
      | Some (l, 0x002D) ->
        emit_character l 0x002D (fun () ->
        script_data_double_escaped_dash_dash_state l')

      | Some (l, 0x003C) ->
        emit_character l 0x003C (fun () ->
        script_data_double_escaped_less_than_sign_state l')

      | Some (l, 0) ->
        report l (`Bad_token ("U+0000", "script", "null")) !throw (fun () ->
        emit_character l u_rep (fun () ->
        script_data_double_escaped_state l'))

      | None ->
        report (get_location ()) (`Unexpected_eoi "script") !throw data_state

      | Some (l, c) ->
        emit_character l c (fun () ->
        script_data_double_escaped_state l')
    end

  (* 8.2.4.31. *)
  and script_data_double_escaped_dash_dash_state l' =
    next_option input !throw begin function
      | Some (l, 0x002D) ->
        emit_character l 0x002D (fun () ->
        script_data_double_escaped_dash_dash_state l')

      | Some (l, 0x003C) ->
        emit_character l 0x003C (fun () ->
        script_data_double_escaped_less_than_sign_state l')

      | Some (l, 0x003E) ->
        emit_character l 0x003E script_data_state

      | Some (l, 0) ->
        report l (`Bad_token ("U+0000", "script", "null")) !throw (fun () ->
        emit_character l u_rep (fun () ->
        script_data_double_escaped_state l'))

      | None ->
        report (get_location ()) (`Unexpected_eoi "script") !throw data_state

      | Some (l, c) ->
        emit_character l c (fun () ->
        script_data_double_escaped_state l')
    end

  (* 8.2.4.32. *)
  and script_data_double_escaped_less_than_sign_state l' =
    next_option input !throw begin function
      | Some (l, 0x002F) ->
        let tag_buffer = Buffer.create 32 in
        emit_character l 0x002F (fun () ->
        script_data_double_escape_end_state l' tag_buffer)

      | maybe_v ->
        push_option input maybe_v;
        script_data_double_escaped_state l'
    end

  (* 8.2.4.33. *)
  and script_data_double_escape_end_state l' tag_buffer =
    next_option input !throw begin function
      | Some (l, (0x0009 | 0x000A | 0x000C | 0x0020 | 0x002F | 0x003E as c)) ->
        emit_character l c (fun () ->
        if Buffer.contents tag_buffer = "script" then
          script_data_escaped_state l'
        else script_data_double_escaped_state l')

      | Some (l, c) when is_alphabetic c ->
        add_utf_8 tag_buffer (to_lowercase c);
        emit_character l c (fun () ->
        script_data_double_escape_end_state l' tag_buffer)

      | maybe_v ->
        push_option input maybe_v;
        script_data_double_escaped_state l'
    end

  (* 8.2.4.34. *)
  and before_attribute_name_state l' tag =
    let start_attribute c =
      let name_buffer = Buffer.create 32 in
      add_utf_8 name_buffer c;
      attribute_name_state l' tag name_buffer
    in

    next_option input !throw begin function
      | Some (_, (0x0009 | 0x000A | 0x000C | 0x0020)) ->
        before_attribute_name_state l' tag

      | Some (_, 0x002F) ->
        self_closing_start_tag_state l' tag

      | Some (_, 0x003E) ->
        emit_tag l' tag

      | None ->
        report (get_location ()) (`Unexpected_eoi "tag") !throw data_state

      | Some (l, 0) ->
        report l (`Bad_token ("U+0000", "attribute name", "null")) !throw
          (fun () ->
        start_attribute u_rep)

      | Some (l, (0x0022 | 0x0027 | 0x003C | 0x003D as c)) ->
        report l (`Bad_token (char c, "attribute name",
                              "invalid start character")) !throw (fun () ->
        start_attribute c)

      | Some (_, c) ->
        start_attribute (to_lowercase c)
    end

  (* 8.2.4.35. *)
  and attribute_name_state l' tag name_buffer =
    next_option input !throw begin function
      | Some (_, (0x0009 | 0x000A | 0x000C | 0x0020)) ->
        after_attribute_name_state l' tag (Buffer.contents name_buffer)

      | Some (_, 0x002F) ->
        tag.attributes <- (Buffer.contents name_buffer, "")::tag.attributes;
        self_closing_start_tag_state l' tag

      | Some (_, 0x003D) ->
        before_attribute_value_state l' tag (Buffer.contents name_buffer)

      | Some (_, 0x003E) ->
        tag.attributes <- (Buffer.contents name_buffer, "")::tag.attributes;
        emit_tag l' tag

      | Some (l, 0) ->
        report l (`Bad_token ("U+0000", "attribute name", "null")) !throw
          (fun () ->
        add_utf_8 name_buffer u_rep;
        attribute_name_state l' tag name_buffer)

      | Some (l, (0x0022 | 0x0027 | 0x003C as c)) ->
        report l (`Bad_token (char c, "attribute name",
                              "invalid name character")) !throw (fun () ->
        add_utf_8 name_buffer c;
        attribute_name_state l' tag name_buffer)

      | None ->
        report (get_location ()) (`Unexpected_eoi "tag") !throw data_state

      | Some (_, c) ->
        add_utf_8 name_buffer (to_lowercase c);
        attribute_name_state l' tag name_buffer
    end

  (* 8.2.4.36. *)
  and after_attribute_name_state l' tag name =
    let start_next_attribute c =
      tag.attributes <- (name, "")::tag.attributes;
      let name_buffer = Buffer.create 32 in
      add_utf_8 name_buffer c;
      attribute_name_state l' tag name_buffer
    in

    next_option input !throw begin function
      | Some (_, (0x0009 | 0x000A | 0x000C | 0x0020)) ->
        after_attribute_name_state l' tag name

      | Some (_, 0x002F) ->
        tag.attributes <- (name, "")::tag.attributes;
        self_closing_start_tag_state l' tag

      | Some (_, 0x003D) ->
        before_attribute_value_state l' tag name

      | Some (_, 0x003E) ->
        tag.attributes <- (name, "")::tag.attributes;
        emit_tag l' tag

      | Some (l, 0) ->
        report l (`Bad_token ("U+0000", "attribute name", "null")) !throw
          (fun () ->
        start_next_attribute u_rep)

      | Some (l, (0x0022 | 0x0027 | 0x003C as c)) ->
        report l (`Bad_token (char c, "attribute name",
                              "invalid start character")) !throw (fun () ->
        start_next_attribute c)

      | None ->
        report (get_location ()) (`Unexpected_eoi "tag") !throw data_state

      | Some (_, c) ->
        start_next_attribute (to_lowercase c)
    end

  (* 8.2.4.37. *)
  and before_attribute_value_state l' tag name =
    let start_value state maybe_c =
      let value_buffer = Buffer.create 32 in
      begin match maybe_c with
      | None -> ()
      | Some c -> add_utf_8 value_buffer c
      end;
      state l' tag name value_buffer
    in

    next_option input !throw begin function
      | Some (_, (0x0009 | 0x000A | 0x000C | 0x0020)) ->
        before_attribute_value_state l' tag name

      | Some (_, (0x0022 | 0x0027 as c)) ->
        start_value (attribute_value_quoted_state c) None

      | Some (_, 0x0026 as v) ->
        push input v;
        start_value attribute_value_unquoted_state None

      | Some (l, 0) ->
        report l (`Bad_token ("U+0000", "attribute value", "null")) !throw
          (fun () ->
        start_value attribute_value_unquoted_state (Some u_rep))

      | Some (l, 0x003E) ->
        report l (`Bad_token (">", "tag", "expected attribute value after '='"))
          !throw (fun () ->
        tag.attributes <- (name, "")::tag.attributes;
        emit_tag l' tag)

      | Some (l, (0x003C | 0x003D | 0x0060 as c)) ->
        report l (`Bad_token (char c, "attribute value",
                              "invalid start character")) !throw (fun () ->
        start_value attribute_value_unquoted_state (Some c))

      | None ->
        report (get_location ()) (`Unexpected_eoi "tag") !throw data_state

      | Some (_, c) ->
        start_value attribute_value_unquoted_state (Some c)
    end

  (* 8.2.4.38 and 8.2.4.39. *)
  and attribute_value_quoted_state quote l' tag name value_buffer =
    next_option input !throw begin function
      | Some (_, c) when c = quote ->
        tag.attributes <-
          (name, Buffer.contents value_buffer)::tag.attributes;
        after_attribute_value_quoted_state l' tag

      | Some (l, 0x0026) ->
        character_reference_in_attribute quote l value_buffer (fun () ->
        attribute_value_quoted_state quote l' tag name value_buffer)

      | Some (l, 0) ->
        report l (`Bad_token ("U+0000", "attribute value", "null")) !throw
          (fun () ->
        add_utf_8 value_buffer u_rep;
        attribute_value_quoted_state quote l' tag name value_buffer)

      | None ->
        report (get_location ()) (`Unexpected_eoi "attribute value") !throw
          data_state

      | Some (_, c) ->
        add_utf_8 value_buffer c;
        attribute_value_quoted_state quote l' tag name value_buffer
    end

  (* 8.2.4.40. *)
  and attribute_value_unquoted_state l' tag name value_buffer =
    next_option input !throw begin function
      | Some (_, (0x0009 | 0x000A | 0x000C | 0x0020)) ->
        tag.attributes <-
          (name, Buffer.contents value_buffer)::tag.attributes;
        before_attribute_name_state l' tag

      | Some (l, 0x0026) ->
        character_reference_in_attribute 0x003E l value_buffer (fun () ->
        attribute_value_unquoted_state l' tag name value_buffer)

      | Some (_, 0x003E) ->
        tag.attributes <-
          (name, Buffer.contents value_buffer)::tag.attributes;
        emit_tag l' tag

      | Some (l, 0) ->
        report l (`Bad_token ("U+0000", "attribute value", "null")) !throw
          (fun () ->
        add_utf_8 value_buffer u_rep;
        attribute_value_unquoted_state l' tag name value_buffer)

      | Some (l, (0x0022 | 0x0027 | 0x003C | 0x003D | 0x0060 as c)) ->
        report l (`Bad_token (char c, "attribute value",
                              "invalid character")) !throw (fun () ->
        add_utf_8 value_buffer c;
        attribute_value_unquoted_state l' tag name value_buffer)

      | None ->
        report (get_location ()) (`Unexpected_eoi "tag") !throw data_state

      | Some (_, c) ->
        add_utf_8 value_buffer c;
        attribute_value_unquoted_state l' tag name value_buffer
    end

  (* 8.2.4.41. *)
  and character_reference_in_attribute allowed l value_buffer k =
    consume_character_reference true (Some allowed) l begin function
      | None ->
        add_utf_8 value_buffer 0x0026;
        k ()

      | Some (`One c) ->
        add_utf_8 value_buffer c;
        k ()

      | Some (`Two (c, c')) ->
        add_utf_8 value_buffer c;
        add_utf_8 value_buffer c';
        k ()
    end

  (* 8.2.4.42. *)
  and after_attribute_value_quoted_state l' tag =
    next_option input !throw begin function
      | Some (_, (0x0009 | 0x000A | 0x000C | 0x0020)) ->
        before_attribute_name_state l' tag

      | Some (_, 0x002F) ->
        self_closing_start_tag_state l' tag

      | Some (_, 0x003E) ->
        emit_tag l' tag

      | None ->
        report (get_location ()) (`Unexpected_eoi "tag") !throw data_state

      | Some (l, c as v) ->
        push input v;
        report l (`Bad_token (char c, "tag",
                              "expected whitespace before attribute"))
          !throw (fun () ->
        before_attribute_name_state l' tag)
    end

  (* 8.2.4.43. *)
  and self_closing_start_tag_state l' tag =
    next_option input !throw begin function
      | Some (_, 0x003E) ->
        tag.self_closing <- true;
        emit_tag l' tag

      | None ->
        report (get_location ()) (`Unexpected_eoi "tag") !throw data_state

      | Some (l, c as v) ->
        push input v;
        report l
          (`Bad_token (char c, "tag", "expected '/>'")) !throw (fun () ->
        before_attribute_name_state l' tag)
    end

  (* 8.2.4.44. *)
  and bogus_comment_state l' =
    let buffer = Buffer.create 256 in
    let rec consume () =
      next_option input !throw begin function
        | Some (_, 0x003E) ->
          emit_comment l' buffer

        | Some (_, 0) ->
          add_utf_8 buffer u_rep;
          consume ()

        | None ->
          emit_comment l' buffer

        | Some (_, c) ->
          add_utf_8 buffer c;
          consume ()
      end
    in
    consume ()

  (* 8.2.4.45. *)
  and markup_declaration_open_state l' =
    peek_n 2 input !throw begin function
      | [_, 0x002D; _, 0x002D] ->
        next_n 2 input !throw (fun _ ->
        comment_start_state l' (Buffer.create 64))

      | _ ->
        peek_n 7 input !throw begin fun l ->
          match sequence_to_lowercase l with
          | [_, 0x64; _, 0x6F; _, 0x63; _, 0x74; _, 0x79; _, 0x70; _, 0x65] ->
            next_n 7 input !throw (fun _ ->
            doctype_state l')

          | _ -> 
            peek_n 7 input !throw (function
              | [_, 0x5B; _, 0x43; _, 0x44; _, 0x41;
                 _, 0x54; _, 0x41; _, 0x5B] ->
                if !foreign () then
                  next_n 7 input !throw (fun _ ->
                  cdata_section_state ())
                else
                  report l'
                    (`Bad_token ("<![CDATA[", "content",
                                 "CDATA sections not allowed in HTML"))
                    !throw (fun () ->
                  bogus_comment_state l')

              | _ ->
                report l'
                  (`Bad_token ("<!", "comment", "should begin with '<!--'"))
                  !throw (fun () ->
                bogus_comment_state l'))
        end
    end

  (* 8.2.4.46. *)
  and comment_start_state l' buffer =
    next_option input !throw begin function
      | Some (_, 0x002D) ->
        comment_start_dash_state l' buffer

      | Some (l, 0) ->
        report l (`Bad_token ("U+0000", "comment", "null")) !throw (fun () ->
        add_utf_8 buffer u_rep;
        comment_state l' buffer)

      | Some (_, 0x003E) ->
        report l' (`Bad_token ("<!-->", "comment", "'-->' overlaps '<!--'"))
          !throw (fun () ->
        emit_comment l' buffer)

      | None ->
        report (get_location ()) (`Unexpected_eoi "comment") !throw (fun () ->
        emit_comment l' buffer)

      | Some (_, c) ->
        add_utf_8 buffer c;
        comment_state l' buffer
    end

  (* 8.2.4.47. *)
  and comment_start_dash_state l' buffer =
    next_option input !throw begin function
      | Some (_, 0x002D) ->
        comment_end_state l' buffer

      | Some (l, 0) ->
        report l (`Bad_token ("U+0000", "comment", "null")) !throw (fun () ->
        Buffer.add_char buffer '-';
        add_utf_8 buffer u_rep;
        comment_state l' buffer)

      | Some (_, 0x003E) ->
        report l' (`Bad_token ("<!--->", "comment", "'-->' overlaps '<!--'"))
          !throw (fun () ->
        emit_comment l' buffer)

      | None ->
        report (get_location ()) (`Unexpected_eoi "comment") !throw (fun () ->
        emit_comment l' buffer)

      | Some (_, c) ->
        Buffer.add_char buffer '-';
        add_utf_8 buffer c;
        comment_state l' buffer
    end

  (* 8.2.4.48. *)
  and comment_state l' buffer =
    next_option input !throw begin function
      | Some (_, 0x002D) ->
        comment_end_dash_state l' buffer

      | Some (l, 0) ->
        report l (`Bad_token ("U+0000", "comment", "null")) !throw (fun () ->
        add_utf_8 buffer u_rep;
        comment_state l' buffer)

      | None ->
        report (get_location ()) (`Unexpected_eoi "comment") !throw (fun () ->
        emit_comment l' buffer)

      | Some (_, c) ->
        add_utf_8 buffer c;
        comment_state l' buffer
    end

  (* 8.2.4.49. *)
  and comment_end_dash_state l' buffer =
    next_option input !throw begin function
      | Some (_, 0x002D) ->
        comment_end_state l' buffer

      | Some (l, 0) ->
        report l (`Bad_token ("U+0000", "comment", "null")) !throw (fun () ->
        Buffer.add_char buffer '-';
        add_utf_8 buffer u_rep;
        comment_state l' buffer)

      | None ->
        report (get_location ()) (`Unexpected_eoi "comment") !throw (fun () ->
        emit_comment l' buffer)

      | Some (_, c) ->
        Buffer.add_char buffer '-';
        add_utf_8 buffer c;
        comment_state l' buffer
    end

  (* 8.2.4.50. *)
  and comment_end_state l' buffer =
    next_option input !throw begin function
      | Some (_, 0x003E) ->
        emit_comment l' buffer

      | Some (l, 0) ->
        report l (`Bad_token ("U+0000", "comment", "null")) !throw (fun () ->
        Buffer.add_string buffer "--";
        add_utf_8 buffer u_rep;
        comment_state l' buffer)

      | Some (l, 0x0021) ->
        report l (`Bad_token ("--!", "comment", "'--' should be in '-->'"))
          !throw (fun () ->
        comment_end_bang_state l' buffer)

      | Some (l, 0x002D) ->
        report l (`Bad_token ("---", "comment", "'--' should be in '-->'"))
          !throw (fun () ->
        Buffer.add_char buffer '-';
        comment_end_state l' buffer)

      | None ->
        report (get_location ()) (`Unexpected_eoi "comment") !throw (fun () ->
        emit_comment l' buffer)

      | Some (l, c) ->
        report l (`Bad_token ("--" ^ (char c), "comment",
                              "'--' should be in '-->'")) !throw (fun () ->
        Buffer.add_string buffer "--";
        add_utf_8 buffer c;
        comment_state l' buffer)
    end

  (* 8.2.4.51. *)
  and comment_end_bang_state l' buffer =
    next_option input !throw begin function
      | Some (_, 0x002D) ->
        Buffer.add_string buffer "--!";
        comment_end_dash_state l' buffer

      | Some (_, 0x003E) ->
        emit_comment l' buffer

      | Some (l, 0) ->
        report l (`Bad_token ("U+0000", "comment", "null")) !throw (fun () ->
        Buffer.add_string buffer "--!";
        add_utf_8 buffer u_rep;
        comment_state l' buffer)

      | None ->
        report (get_location ()) (`Unexpected_eoi "comment") !throw (fun () ->
        emit_comment l' buffer)

      | Some (_, c) ->
        Buffer.add_string buffer "--!";
        add_utf_8 buffer c;
        comment_state l' buffer
    end

  (* 8.2.5.52. *)
  and doctype_state l' =
    let doctype =
      {doctype_name      = None;
       public_identifier = None;
       system_identifier = None;
       force_quirks      = false}
    in

    next_option input !throw begin function
      | Some (_, (0x0009 | 0x000A | 0x000C | 0x0020)) ->
        before_doctype_name_state l' doctype

      | None ->
        report (get_location ()) (`Unexpected_eoi "doctype") !throw (fun () ->
        emit_doctype ~quirks:true l' doctype)

      | Some (l, c as v) ->
        report l (`Bad_token (char c, "doctype",
                              "expected whitespace")) !throw (fun () ->
        push input v;
        before_doctype_name_state l' doctype)
    end

  (* 8.2.5.53. *)
  and before_doctype_name_state l' doctype =
    next_option input !throw begin function
      | Some (_, (0x0009 | 0x000A | 0x000C | 0x0020)) ->
        before_doctype_name_state l' doctype

      | Some (l, 0) ->
        report l (`Bad_token ("U+0000", "doctype", "null")) !throw (fun () ->
        doctype.doctype_name <- add_doctype_char doctype.doctype_name u_rep;
        doctype_name_state l' doctype)

      | Some (l, 0x003E) ->
        report l (`Bad_token (">", "doctype", "expected name")) !throw
          (fun () ->
        emit_doctype ~quirks:true l' doctype)

      | None ->
        report (get_location ()) (`Unexpected_eoi "doctype") !throw (fun () ->
        emit_doctype ~quirks:true l' doctype)

      | Some (_, c) ->
        doctype.doctype_name <-
          add_doctype_char doctype.doctype_name (to_lowercase c);
        doctype_name_state l' doctype
    end

  (* 8.2.5.54. *)
  and doctype_name_state l' doctype =
    next_option input !throw begin function
      | Some (_, (0x0009 | 0x000A | 0x000C | 0x0020)) ->
        after_doctype_name_state l' doctype

      | Some (_, 0x003E) ->
        emit_doctype l' doctype

      | Some (l, 0) ->
        report l (`Bad_token ("U+0000", "doctype", "null")) !throw (fun () ->
        doctype.doctype_name <-
          add_doctype_char doctype.doctype_name u_rep;
        doctype_name_state l' doctype)

      | None ->
        report (get_location ()) (`Unexpected_eoi "doctype") !throw (fun () ->
        emit_doctype ~quirks:true l' doctype)

      | Some (_, c) ->
        doctype.doctype_name <-
          add_doctype_char doctype.doctype_name (to_lowercase c);
        doctype_name_state l' doctype
    end

  (* 8.2.4.55. *)
  and after_doctype_name_state l' doctype =
    next_option input !throw begin function
      | Some (_, (0x0009 | 0x000A | 0x000C | 0x0020)) ->
        after_doctype_name_state l' doctype

      | Some (_, 0x003E) ->
        emit_doctype l' doctype

      | None ->
        report (get_location ()) (`Unexpected_eoi "doctype") !throw (fun () ->
        emit_doctype ~quirks:true l' doctype)

      | Some (l'', c as v) ->
        push input v;
        next_n 6 input !throw begin fun l ->
          match sequence_to_lowercase l with
          | [_, 0x70; _, 0x75; _, 0x62; _, 0x6C; _, 0x69; _, 0x63] ->
            after_doctype_public_keyword_state l' doctype

          | [_, 0x73; _, 0x79; _, 0x73; _, 0x74; _, 0x65; _, 0x6D] ->
            after_doctype_system_keyword_state l' doctype

          | vs ->
            push_list input vs;
            report l'' (`Bad_token (char c, "doctype",
                                    "expected 'PUBLIC' or 'SYSTEM'")) !throw
              (fun () ->
            doctype.force_quirks <- true;
            bogus_doctype_state l' doctype)
        end
    end

  (* Helper. *)
  and begin_public_identifier quote l' doctype =
    doctype.Doctype_buffers.public_identifier <- Some (Buffer.create 32);
    doctype_identifier_quoted_state
      (fun doctype c ->
        doctype.Doctype_buffers.public_identifier <-
          add_doctype_char doctype.Doctype_buffers.public_identifier c)
        quote after_doctype_public_identifier_state l' doctype

  (* Helper. *)
  and begin_system_identifier quote l' doctype =
    doctype.Doctype_buffers.system_identifier <- Some (Buffer.create 32);
    doctype_identifier_quoted_state
      (fun doctype c ->
        doctype.system_identifier <-
          add_doctype_char doctype.system_identifier c)
      quote after_doctype_system_identifier_state l' doctype

  (* 8.2.4.56. *)
  and after_doctype_public_keyword_state l' doctype =
    next_option input !throw begin function
      | Some (_, (0x0009 | 0x000A | 0x000C | 0x0020)) ->
        before_doctype_public_identifier_state l' doctype

      | Some (l, (0x0022 | 0x0027 as c)) ->
        report l (`Bad_token (char c, "doctype",
                              "expected whitespace")) !throw (fun () ->
        begin_public_identifier c l' doctype)

      | Some (l, 0x003E) ->
        report l (`Bad_token (">", "doctype", "expected public identifier"))
          !throw (fun () ->
        emit_doctype ~quirks:true l' doctype)

      | None ->
        report (get_location ()) (`Unexpected_eoi "doctype") !throw (fun () ->
        emit_doctype ~quirks:true l' doctype)

      | Some (l, c) ->
        report l (`Bad_token (char c, "doctype",
                              "expected whitespace")) !throw (fun () ->
        doctype.force_quirks <- true;
        bogus_doctype_state l' doctype)
    end

  (* 8.2.4.57. *)
  and before_doctype_public_identifier_state l' doctype =
    next_option input !throw begin function
      | Some (_, (0x0009 | 0x000A | 0x000C | 0x0020)) ->
        before_doctype_public_identifier_state l' doctype

      | Some (_, (0x0022 | 0x0027 as c)) ->
        begin_public_identifier c l' doctype

      | Some (l, 0x003E) ->
        report l (`Bad_token (">", "doctype", "expected public identifier"))
          !throw (fun () ->
        emit_doctype ~quirks:true l' doctype)

      | None ->
        report (get_location ()) (`Unexpected_eoi "doctype") !throw (fun () ->
        emit_doctype ~quirks:true l' doctype)

      | Some (l, c) ->
        report l (`Bad_token (char c, "doctype",
                              "public identifier must be quoted")) !throw
          (fun () ->
        doctype.force_quirks <- true;
        bogus_doctype_state l' doctype)
    end

  (* 8.2.4.58, 8.2.4.59, 8.2.4.64, 8.2.4.65. *)
  and doctype_identifier_quoted_state add quote next_state l' doctype =
    next_option input !throw begin function
      | Some (_, c) when c = quote ->
        next_state l' doctype

      | Some (l, 0) ->
        report l (`Bad_token ("U+0000", "doctype", "null")) !throw (fun () ->
        add doctype u_rep;
        doctype_identifier_quoted_state add quote next_state l' doctype)

      | Some (l, 0x003E) ->
        report l (`Bad_token (">", "doctype", "'>' in identifier")) !throw
          (fun () ->
        emit_doctype ~quirks:true l' doctype)

      | None ->
        report (get_location ()) (`Unexpected_eoi "doctype") !throw (fun () ->
        emit_doctype ~quirks:true l' doctype)

      | Some (_, c) ->
        add doctype c;
        doctype_identifier_quoted_state add quote next_state l' doctype
    end

  (* 8.2.4.60. *)
  and after_doctype_public_identifier_state l' doctype =
    next_option input !throw begin function
      | Some (_, (0x0009 | 0x000A | 0x000C | 0x0020)) ->
        between_doctype_public_and_system_identifiers l' doctype

      | Some (_, 0x003E) -> emit_doctype l' doctype

      | Some (l, (0x0022 | 0x0027 as c)) ->
        report l (`Bad_token (char c, "doctype",
                              "expected whitespace")) !throw (fun () ->
        begin_system_identifier c l' doctype)

      | None ->
        report (get_location ()) (`Unexpected_eoi "doctype") !throw (fun () ->
        emit_doctype ~quirks:true l' doctype)

      | Some (l, c) ->
        report l (`Bad_token (char c, "doctype",
                              "system identifier must be quoted")) !throw
          (fun () ->
        doctype.force_quirks <- true;
        bogus_doctype_state l' doctype)
    end

  (* 8.2.4.61. *)
  and between_doctype_public_and_system_identifiers l' doctype =
    next_option input !throw begin function
      | Some (_, (0x0009 | 0x000A | 0x000C | 0x0020)) ->
        between_doctype_public_and_system_identifiers l' doctype

      | Some (_, 0x003E) ->
        emit_doctype l' doctype

      | Some (_, (0x0022 | 0x0027 as c)) ->
        begin_system_identifier c l' doctype

      | None ->
        report (get_location ()) (`Unexpected_eoi "doctype") !throw (fun () ->
        emit_doctype ~quirks:true l' doctype)

      | Some (l, c) ->
        report l (`Bad_token (char c, "doctype",
                              "system identifier must be quoted")) !throw
          (fun () ->
        doctype.force_quirks <- true;
        bogus_doctype_state l' doctype)
    end

  (* 8.2.4.62. *)
  and after_doctype_system_keyword_state l' doctype =
    next_option input !throw begin function
      | Some (_, (0x0009 | 0x000A | 0x000C | 0x0020)) ->
        before_doctype_system_identifier_state l' doctype

      | Some (l, (0x0022 | 0x0027 as c)) ->
        report l (`Bad_token (char c, "doctype",
                              "expected whitespace")) !throw (fun () ->
        begin_system_identifier c l' doctype)

      | Some (l, 0x003E) ->
        report l (`Bad_token (">", "doctype", "expected system identifier"))
          !throw (fun () ->
        emit_doctype ~quirks:true l' doctype)

      | None ->
        report (get_location ()) (`Unexpected_eoi "doctype") !throw (fun () ->
        emit_doctype ~quirks:true l' doctype)

      | Some (l, c) ->
        report l (`Bad_token (char c, "doctype",
                              "expected whitespace")) !throw (fun () ->
        doctype.force_quirks <- true;
        bogus_doctype_state l' doctype)
    end

  (* 8.2.4.63. *)
  and before_doctype_system_identifier_state l' doctype =
    next_option input !throw begin function
      | Some (_, (0x0009 | 0x000A | 0x000C | 0x0020)) ->
        before_doctype_system_identifier_state l' doctype

      | Some (_, (0x0022 | 0x0027 as c)) ->
        begin_system_identifier c l' doctype

      | Some (l, 0x003E) ->
        report l (`Bad_token (">", "doctype", "expected system identifier"))
          !throw (fun () ->
        emit_doctype ~quirks:true l' doctype)

      | None ->
        report (get_location ()) (`Unexpected_eoi "doctype") !throw (fun () ->
        emit_doctype ~quirks:true l' doctype)

      | Some (l, c) ->
        report l (`Bad_token (char c, "doctype",
                              "system identifier must be quoted")) !throw
          (fun () ->
        doctype.force_quirks <- true;
        bogus_doctype_state l' doctype)
    end

  (* 8.2.4.66. *)
  and after_doctype_system_identifier_state l' doctype =
    next_option input !throw begin function
      | Some (_, (0x0009 | 0x000A | 0x000C | 0x0020)) ->
        after_doctype_system_identifier_state l' doctype

      | Some (_, 0x003E) ->
        emit_doctype l' doctype

      | None ->
        report (get_location ()) (`Unexpected_eoi "doctype") !throw (fun () ->
        emit_doctype ~quirks:true l' doctype)

      | Some (l, c) ->
        report l (`Bad_token (char c, "doctype",
                              "junk after system identifier")) !throw (fun () ->
        bogus_doctype_state l' doctype)
    end

  (* 8.2.4.67. *)
  and bogus_doctype_state l' doctype =
    next_option input !throw begin function
      | Some (_, 0x003E) ->
        emit_doctype l' doctype

      | None ->
        emit_doctype l' doctype

      | _ ->
        bogus_doctype_state l' doctype
    end

  (* 8.2.4.68. *)
  and cdata_section_state () =
    next_option input !throw begin function
      | None ->
        data_state ()

      | Some (l, 0x005D) ->
        peek_n 2 input !throw begin function
          | [_, 0x005D; _, 0x003E] ->
            next_n 2 input !throw (fun _ ->
            data_state ())

          | _ ->
            emit (l, `Char 0x005D) cdata_section_state
        end

      | Some (l, c) ->
        emit (l, `Char c) cdata_section_state
    end

  in

  let stream =
    (fun throw_ e k ->
      throw := throw_;
      ended := e;
      output := k;
      !current_state ())
    |> make
  in

  let set_state = function
    | `Data -> current_state := data_state
    | `RCDATA -> current_state := rcdata_state
    | `RAWTEXT -> current_state := rawtext_state
    | `Script_data -> current_state := script_data_state
    | `PLAINTEXT -> current_state := plaintext_state
  in

  let set_foreign = (:=) foreign in

  stream, set_state, set_foreign

end
module Markup_html_parser : sig 
#1 "markup_html_parser.mli"
(* This file is part of Markup.ml, released under the BSD 2-clause license. See
   doc/LICENSE for details, or visit https://github.com/aantron/markup.ml. *)

open Markup_common

val parse :
  [< `Document | `Fragment of string ] option ->
  Markup_error.parse_handler ->
  (location * Markup_html_tokenizer.token) Markup_kstream.t *
  (Markup_html_tokenizer.state -> unit) *
  ((unit -> bool) -> unit) ->
    (location * signal) Markup_kstream.t

end = struct
#1 "markup_html_parser.ml"
(* This file is part of Markup.ml, released under the BSD 2-clause license. See
   doc/LICENSE for details, or visit https://github.com/aantron/markup.ml. *)

open Markup_common
open Token_tag
open Markup_kstream
module Error = Markup_error
module Kstream = Markup_kstream
module Text = Markup_text
module Namespace = Markup_namespace
module Html_tokenizer = Markup_html_tokenizer



(* Namespaces for pattern matching. *)
type ns = [ `HTML | `MathML | `SVG | `Other of string ]
type qname = ns * string

module Ns :
sig
  val to_string : ns -> string
end =
struct
  let to_string = function
    | `HTML -> html_ns
    | `MathML -> mathml_ns
    | `SVG -> svg_ns
    | `Other s -> s
end

(* Specialization of List.mem at qname list, to avoid polymorphic
   comparison. *)
let list_mem_qname ((ns, tag) : qname) l =
  let rec loop = function
    | [] -> false
    | (ns', tag')::_ when ns' = ns && tag' = tag -> true
    | _::rest -> loop rest
  in
  loop l



(* Elements. *)
type element =
  {element_name              : qname;
   location                  : location;
   is_html_integration_point : bool;
   suppress                  : bool;
   mutable buffering         : bool;
   mutable is_open           : bool;
   mutable attributes        : (name * string) list;
   mutable end_location      : location;
   mutable children          : annotated_node list;
   mutable parent            : element}

and node =
  | Element of element
  | Text of string list
  | PI of string * string
  | Comment of string

and annotated_node = location * node



(* Element helpers. *)
module Element :
sig
  val create :
    ?is_html_integration_point:bool ->
    ?suppress:bool ->
    qname -> location ->
      element
  val dummy : element

  val is_special : qname -> bool
  val is_not_hidden : Token_tag.t -> bool
end =
struct
  let rec dummy =
    {element_name              = `HTML, "dummy";
     location                  = 1, 1;
     is_html_integration_point = false;
     suppress                  = true;
     buffering                 = false;
     is_open                   = false;
     attributes                = [];
     end_location              = 1, 1;
     children                  = [];
     parent                    = dummy}

  let create
      ?(is_html_integration_point = false) ?(suppress = false) name location =
    {element_name = name;
     location;
     is_html_integration_point;
     suppress;
     buffering    = false;
     is_open      = true;
     attributes   = [];
     end_location = 1, 1;
     children     = [];
     parent       = dummy}

  let is_special name =
    list_mem_qname name
      [`HTML, "address"; `HTML, "applet"; `HTML, "area";
       `HTML, "article"; `HTML, "aside"; `HTML, "base";
       `HTML, "basefont"; `HTML, "bgsound"; `HTML, "blockquote";
       `HTML, "body"; `HTML, "br"; `HTML, "button";
       `HTML, "caption"; `HTML, "center"; `HTML, "col";
       `HTML, "colgroup"; `HTML, "dd"; `HTML, "details";
       `HTML, "dir"; `HTML, "div"; `HTML, "dl";
       `HTML, "dt"; `HTML, "embed"; `HTML, "fieldset";
       `HTML, "figcaption"; `HTML, "figure"; `HTML, "footer";
       `HTML, "form"; `HTML, "frame"; `HTML, "frameset";
       `HTML, "h1"; `HTML, "h2"; `HTML, "h3";
       `HTML, "h4"; `HTML, "h5"; `HTML, "h6";
       `HTML, "head"; `HTML, "header"; `HTML, "hgroup";
       `HTML, "hr"; `HTML, "html"; `HTML, "iframe";
       `HTML, "img"; `HTML, "input"; `HTML, "isindex";
       `HTML, "li"; `HTML, "link"; `HTML, "listing";
       `HTML, "main"; `HTML, "marquee"; `HTML, "meta";
       `HTML, "nav"; `HTML, "noembed"; `HTML, "noframes";
       `HTML, "noscript"; `HTML, "object"; `HTML, "ol";
       `HTML, "p"; `HTML, "param"; `HTML, "plaintext";
       `HTML, "pre"; `HTML, "script"; `HTML, "section";
       `HTML, "select"; `HTML, "source"; `HTML, "style";
       `HTML, "summary"; `HTML, "table"; `HTML, "tbody";
       `HTML, "td"; `HTML, "template"; `HTML, "textarea";
       `HTML, "tfoot"; `HTML, "th"; `HTML, "thead";
       `HTML, "title"; `HTML, "tr"; `HTML, "track";
       `HTML, "ul"; `HTML, "wbr"; `HTML, "xmp";
       `MathML, "mi"; `MathML, "mo"; `MathML, "mn";
       `MathML, "ms"; `MathML, "mtext"; `MathML, "annotation-xml";
       `SVG, "foreignObject"; `SVG, "desc"; `SVG, "title"]

  let is_not_hidden tag =
    tag.Token_tag.attributes |> List.exists (fun (name, value) ->
      name = "type" && value <> "hidden")
end



(* Context detection. *)
type simple_context = [ `Document | `Fragment of string ]
type context = [ `Document | `Fragment of qname ]

module Context :
sig
  type t

  val uninitialized : unit -> t
  val initialize :
    (location * Html_tokenizer.token) Kstream.t ->
    [< simple_context ] option ->
    t ->
      unit cps

  val the_context : t -> context
  val element : t -> element option
  val token : t -> string option
end =
struct
  let detect tokens throw k =
    let tokens, restore = checkpoint tokens in

    let last_name = ref None in
    let next_token k =
      next_expected tokens throw (fun token ->
        begin match token with
        | _, `Start {name} -> last_name := Some name
        | _ -> ()
        end;
        k token)
    in

    let k context = restore (); k (context, !last_name) in

    let rec scan () =
      next_token begin function
        | _, `Doctype _ -> k `Document
        | _, `Char c when not @@ is_whitespace c -> k (`Fragment "body")
        | _, `Char _ -> scan ()
        | _, `EOF -> k (`Fragment "body")
        | _, `Start {name = "html"} -> k `Document
        | _, `Start {name = "head" | "body" | "frameset"} ->
          k (`Fragment "html")
        | _, `Start {name =
            "base" | "basefont" | "bgsound" | "link" | "meta" | "noframes" |
            "noscript" | "script" | "style" | "template" | "title"} ->
          k (`Fragment "head")
        | _, `Start {name = "frame"} -> k (`Fragment "frameset")
        | _, `Start {name = "li"} -> k (`Fragment "ul")
        | _, `Start {name =
            "caption" | "col" | "colgroup" | "tbody" | "tfoot" | "thead"} ->
          k (`Fragment "table")
        | _, `Start {name = "tr"} -> k (`Fragment "tbody")
        | _, `Start {name = "td" | "th"} -> k (`Fragment "tr")
        | _, `Start {name = "optgroup" | "option"} -> k (`Fragment "select")
        | _, `Start {name =
            "altglyph" | "altglyphdef" | "altglyphitem" | "animate" |
            "animatecolor" | "animatemotion" | "animatetransform" | "circle" |
            "clippath" | "color-profile" | "cursor" | "defs" | "desc" |
            "ellipse" | "feblend" | "fecolormatrix" | "fecomponenttransfer" |
            "fecomposite" | "fediffuselighting" | "fedisplacementmap" |
            "fedistantlight" | "feflood" | "fefunca" | "fefuncb" | "fefuncg" |
            "fefuncr" | "fegaussianblur" | "feimage" | "femerge" |
            "femergenode" | "femorphology" | "feoffset" | "fepointlight" |
            "fespecularlighting" | "fespotlight" | "fetile" | "feturbulence" |
            "filter" | "font-face" | "font-face-format" | "font-face-name" |
            "font-face-src" | "font-face-uri" | "foreignobject" | "g" |
            "glyph" | "glyphref" | "hkern" | "image" | "line" |
            "lineargradient" | "marker" | "mask" | "metadata" |
            "missing-glyph" | "mpath" | "path" | "pattern" | "polygon" |
            "polyline" | "radialgradient" | "rect" | "set" | "stop" | "switch" |
            "symbol" | "text" | "textpath" | "tref" | "tspan" | "use"} ->
          k (`Fragment "svg")
        | _, `Start {name =
            "maction" | "maligngroup" | "malignmark" | "menclose" | "merror" |
            "mfenced" | "mfrac" | "mglyph" | "mi" | "mlabeledtr" | "mlongdiv" |
            "mmultiscripts" | "mn" | "mo" | "mover" | "mpadded" | "mphantom" |
            "mroot" | "mrow" | "ms" | "mscarries" | "mscarry" | "msgroup" |
            "msline" | "mspace" | "msqrt" | "msrow" | "mstack" | "mstyle" |
            "msub" | "msup" | "msubsup" | "mtable" | "mtd" | "mtext" | "mtr" |
            "munder" | "munderover" | "semantics" | "annotation" |
            "annotation-xml"} ->
          k (`Fragment "math")
        | _, `Start _ -> k (`Fragment "body")
        | _, (`End _ | `Comment _) -> scan ()
      end
    in

    scan ()

  type t = (context * element option * string option) ref

  let uninitialized () = ref (`Document, None, None)

  let initialize tokens requested_context state throw k =
    (fun k ->
      match requested_context with
      | Some (`Fragment element) ->
        (* HTML element names are case-insensitive, even in foreign content.
           Lowercase the element name given by the user before analysis by the
           parser, to match this convention. [String.lowercase] is acceptable
           here because the API assumes the string [element] is in UTF-8. *)
        k (`Fragment (String.lowercase element), None)
      | Some (`Document as c) -> k (c, None)
      | None -> detect tokens throw k)
    (fun (detected_context, deciding_token) ->

      let context =
        match detected_context with
        | `Document -> `Document
        | `Fragment "math" -> `Fragment (`MathML, "math")
        | `Fragment "svg" -> `Fragment (`SVG, "svg")
        | `Fragment name -> `Fragment (`HTML, name)
      in

      let context_element =
        match context with
        | `Document -> None
        | `Fragment name ->
          let is_html_integration_point =
            match name with
            | `SVG, ("foreignObject" | "desc" | "title") -> true
            | _ -> false
          in

          Some (Element.create
            ~is_html_integration_point ~suppress:true name (1, 1))
      in

      state := context, context_element, deciding_token;

      k ())

  let the_context {contents = (c, _, _)} = c
  let element {contents = (_, e, _)} = e
  let token {contents = (_, _, t)} = t
end



(* Heplers for foreign content. *)
module Foreign :
sig
  val is_mathml_text_integration_point : qname -> bool
  val is_html_integration_point :
    ns -> string -> (string * string) list -> bool

  val adjust_mathml_attributes :
    ((string * string) * string) list -> ((string * string) * string) list
  val adjust_svg_attributes :
    ((string * string) * string) list -> ((string * string) * string) list
  val adjust_svg_tag_name : string -> string
end =
struct
  let is_mathml_text_integration_point qname =
    list_mem_qname qname
      [`MathML, "mi"; `MathML, "mo"; `MathML, "mn"; `MathML, "ms";
       `MathML, "mtext"]

  let is_html_integration_point namespace tag_name attributes =
    match namespace with
    | `HTML | `Other _ -> false
    | `MathML ->
      tag_name = "annotation-xml" &&
      attributes |> List.exists (function
        | "encoding", "text/html" -> true
        | "encoding", "application/xhtml+xml" -> true
        | _ -> false)
    | `SVG ->
      list_mem_string tag_name ["foreignObject"; "desc"; "title"]

  let adjust_mathml_attributes attributes =
    attributes |> List.map (fun ((ns, name), value) ->
      let name =
        if ns = mathml_ns && name = "definitionurl" then "definitionURL"
        else name
      in
      (ns, name), value)

  let adjust_svg_attributes attributes =
    attributes |> List.map (fun ((ns, name), value) ->
      if ns <> svg_ns then (ns, name), value
      else
        let name =
          match name with
          | "attributename" -> "attributeName"
          | "attributetype" -> "attributeType"
          | "basefrequency" -> "baseFrequency"
          | "baseprofile" -> "baseProfile"
          | "calcmode" -> "calcMode"
          | "clippathunits" -> "clipPathUnits"
          | "contentscripttype" -> "contentScriptType"
          | "contentstyletype" -> "contentStyleType"
          | "diffuseconstant" -> "diffuseConstant"
          | "edgemode" -> "edgeMode"
          | "externalresourcesrequired" -> "externalResourcesRequired"
          | "filterres" -> "filterRes"
          | "filterunits" -> "filterUnits"
          | "glyphref" -> "glyphRef"
          | "gradienttransform" -> "gradientTransform"
          | "gradientunits" -> "gradientUnits"
          | "kernelmatrix" -> "kernelMatrix"
          | "kernelunitlength" -> "kernelUnitLength"
          | "keypoints" -> "keyPoints"
          | "keysplines" -> "keySplines"
          | "keytimes" -> "keyTimes"
          | "lengthadjust" -> "lengthAdjust"
          | "limitingconeangle" -> "limitingConeAngle"
          | "markerheight" -> "markerHeight"
          | "markerunits" -> "markerUnits"
          | "markerwidth" -> "markerWidth"
          | "maskcontentunits" -> "maskContentUnits"
          | "maskunits" -> "maskUnits"
          | "numoctaves" -> "numOctaves"
          | "pathlength" -> "pathLength"
          | "patterncontentunits" -> "patternContentUnits"
          | "patterntransform" -> "patternTransform"
          | "patternunits" -> "patternUnits"
          | "pointsatx" -> "pointsAtX"
          | "pointsaty" -> "pointsAtY"
          | "pointsatz" -> "pointsAtZ"
          | "preservealpha" -> "preserveAlpha"
          | "preserveaspectratio" -> "preserveAspectRatio"
          | "primitiveunits" -> "primitiveUnits"
          | "refx" -> "refX"
          | "refy" -> "refY"
          | "repeatcount" -> "repeatCount"
          | "repeatdur" -> "repeatDur"
          | "requiredextensions" -> "requiredExtensions"
          | "requiredfeatures" -> "requiredFeatures"
          | "specularconstant" -> "specularConstant"
          | "specularexponent" -> "specularExponent"
          | "spreadmethod" -> "spreadMethod"
          | "startoffset" -> "startOffset"
          | "stddeviation" -> "stdDeviation"
          | "stitchtiles" -> "stitchTiles"
          | "surfacescale" -> "surfaceScale"
          | "systemlanguage" -> "systemLanguage"
          | "tablevalues" -> "tableValues"
          | "targetx" -> "targetX"
          | "targety" -> "targetY"
          | "textlength" -> "textLength"
          | "viewbox" -> "viewBox"
          | "viewtarget" -> "viewTarget"
          | "xchannelselector" -> "xChannelSelector"
          | "ychannelselector" -> "yChannelSelector"
          | "zoomandpan" -> "zoomAndPan"
          | _ -> name
        in
        (ns, name), value)

  let adjust_svg_tag_name = function
    | "altglyph" -> "altGlyph"
    | "altglyphdef" -> "altGlyphDef"
    | "altglyphitem" -> "altGlyphItem"
    | "animatecolor" -> "animateColor"
    | "animatemotion" -> "animateMotion"
    | "animatetransform" -> "animateTransform"
    | "clippath" -> "clipPath"
    | "feblend" -> "feBlend"
    | "fecolormatrix" -> "feColorMatrix"
    | "fecomponenttransfer" -> "feComponentTransfer"
    | "fecomposite" -> "feComposite"
    | "feconvolvematrix" -> "feConvolveMatrix"
    | "fediffuselighting" -> "feDiffuseLighting"
    | "fedisplacementmap" -> "feDisplacementMap"
    | "fedistantlight" -> "feDistantLight"
    | "fedropshadow" -> "feDropShadow"
    | "feflood" -> "feFlood"
    | "fefunca" -> "feFuncA"
    | "fefuncb" -> "feFuncB"
    | "fefuncg" -> "feFuncG"
    | "fefuncr" -> "feFuncR"
    | "fegaussianblur" -> "feGaussianBlur"
    | "feimage" -> "feImage"
    | "femerge" -> "feMerge"
    | "femergenode" -> "feMergeNode"
    | "femorphology" -> "feMorphology"
    | "feoffset" -> "feOffset"
    | "fepointlight" -> "fePointLight"
    | "fespecularlighting" -> "feSpecularLighting"
    | "fespotlight" -> "feSpotLight"
    | "fetile" -> "feTile"
    | "feturbulence" -> "feTurbulence"
    | "foreignobject" -> "foreignObject"
    | "glyphref" -> "glyphRef"
    | "lineargradient" -> "linearGradient"
    | "radialgradient" -> "radialGradient"
    | "textpath" -> "textPath"
    | s -> s
end



(* Stack of open elements. *)
module Stack :
sig
  type t = element list ref

  val create : unit -> t

  val current_element : t -> element option
  val require_current_element : t -> element
  val adjusted_current_element : Context.t -> t -> element option
  val current_element_is : t -> string list -> bool
  val current_element_is_foreign : Context.t -> t -> bool

  val has : t -> string -> bool

  val in_scope : t -> string -> bool
  val in_button_scope : t -> string -> bool
  val in_list_item_scope : t -> string -> bool
  val in_table_scope : t -> string -> bool
  val in_select_scope : t -> string -> bool
  val one_in_scope : t -> string list -> bool
  val one_in_table_scope : t -> string list -> bool
  val target_in_scope : t -> element -> bool

  val remove : t -> element -> unit
  val replace : t -> old:element -> new_:element -> unit
  val insert_below : t -> anchor:element -> new_:element -> unit
end =
struct
  type t = element list ref

  let create () = ref []

  let current_element open_elements =
    match !open_elements with
    | [] -> None
    | element::_ -> Some element

  let require_current_element open_elements =
    match current_element open_elements with
    | None -> failwith "require_current_element: None"
    | Some element -> element

  let adjusted_current_element context open_elements =
    match !open_elements, Context.element context with
    | [_], Some element -> Some element
    | [], _ -> None
    | element::_, _ -> Some element

  let current_element_is open_elements names =
    match !open_elements with
    | {element_name = `HTML, name}::_ -> list_mem_string name names
    | _ -> false

  let current_element_is_foreign context open_elements =
    match adjusted_current_element context open_elements with
    | Some {element_name = ns, _} when ns <> `HTML -> true
    | _ -> false

  let has open_elements name =
    List.exists
      (fun {element_name = ns, name'} ->
        ns = `HTML && name' = name) !open_elements

  let in_scope_general scope_delimiters open_elements name' =
    let rec scan = function
      | [] -> false
      | {element_name = ns, name'' as name}::more ->
        if ns = `HTML && name'' = name' then true
        else
          if list_mem_qname name scope_delimiters then false
          else scan more
    in
    scan !open_elements

  let scope_delimiters =
    [`HTML, "applet"; `HTML, "caption"; `HTML, "html";
     `HTML, "table"; `HTML, "td"; `HTML, "th";
     `HTML, "marquee"; `HTML, "object"; `HTML, "template";
     `MathML, "mi"; `MathML, "mo"; `MathML, "mn";
     `MathML, "ms"; `MathML, "mtext"; `MathML, "annotation-xml";
     `SVG, "foreignObject"; `SVG, "desc"; `SVG, "title"]

  let in_scope = in_scope_general scope_delimiters

  let in_button_scope = in_scope_general ((`HTML, "button")::scope_delimiters)

  let in_list_item_scope =
    in_scope_general ((`HTML, "ol")::(`HTML, "ul")::scope_delimiters)

  let in_table_scope =
    in_scope_general [`HTML, "html"; `HTML, "table"; `HTML, "template"]

  let in_select_scope open_elements name =
    let rec scan = function
      | [] -> false
      | {element_name = ns, name'}::more ->
        if ns <> `HTML then false
        else
          if name' = name then true
          else
            if name' = "optgroup" || name' = "option" then scan more
            else false
    in
    scan !open_elements

  let one_in_scope open_elements names =
    let rec scan = function
      | [] -> false
      | {element_name = ns, name' as name}::more ->
        if ns = `HTML && list_mem_string name' names then true
        else
          if list_mem_qname name scope_delimiters then false
          else scan more
    in
    scan !open_elements

  let one_in_table_scope open_elements names =
    let rec scan = function
      | [] -> false
      | {element_name = ns, name' as name}::more ->
        if ns = `HTML && list_mem_string name' names then true
        else
          if list_mem_qname name
              [`HTML, "html"; `HTML, "table"; `HTML, "template"] then
            false
          else scan more
    in
    scan !open_elements

  let target_in_scope open_elements node =
    let rec scan = function
      | [] -> false
      | e::more ->
        if e == node then true
        else
          if list_mem_qname node.element_name scope_delimiters then false
          else scan more
    in
    scan !open_elements

  let remove open_elements element =
    open_elements := List.filter ((!=) element) !open_elements;
    element.is_open <- false

  let replace open_elements ~old ~new_ =
    open_elements :=
      List.map (fun e ->
        if e == old then (e.is_open <- false; new_) else e) !open_elements

  let insert_below open_elements ~anchor ~new_ =
    let rec insert prefix = function
      | [] -> List.rev prefix
      | e::more when e == anchor -> (List.rev prefix) @ (new_::e::more)
      | e::more -> insert (e::prefix) more
    in
    open_elements := insert [] !open_elements
end



(* List of active formatting elements. *)
module Active :
sig
  type entry =
    | Marker
    | Element_ of element * location * Token_tag.t

  type t = entry list ref

  val create : unit -> t

  val add_marker : t -> unit
  val clear_until_marker : t -> unit

  val has : t -> element -> bool
  val remove : t -> element -> unit
  val replace : t -> old:element -> new_:element -> unit
  val insert_after : t -> anchor:element -> new_:element -> unit

  val has_before_marker : t -> string -> element option
end =
struct
  type entry =
    | Marker
    | Element_ of element * location * Token_tag.t

  type t = entry list ref

  let create () = ref []

  let add_marker active_formatting_elements =
    active_formatting_elements := Marker::!active_formatting_elements

  let clear_until_marker active_formatting_elements =
    let rec iterate = function
      | Marker::rest -> rest
      | (Element_ _)::rest -> iterate rest
      | [] -> []
    in
    active_formatting_elements := iterate !active_formatting_elements

  let has active_formatting_elements element =
    !active_formatting_elements |> List.exists (function
      | Element_ (e, _, _) when e == element -> true
      | _ -> false)

  let remove active_formatting_elements element =
    active_formatting_elements :=
      !active_formatting_elements |> List.filter (function
        | Element_ (e, _, _) when e == element -> false
        | _ -> true)

  let replace active_formatting_elements ~old ~new_ =
    active_formatting_elements :=
      !active_formatting_elements |> List.map (function
        | Element_ (e, l, t) when e == old -> Element_ (new_, l, t)
        | e -> e)

  let insert_after active_formatting_elements ~anchor ~new_ =
    let rec insert prefix = function
      | [] -> List.rev prefix
      | (Element_ (e, l, t) as v)::more when e == anchor ->
        let new_entry = Element_ (new_, l, t) in
        (List.rev prefix) @ (v::new_entry::more)
      | v::more -> insert (v::prefix) more
    in
    active_formatting_elements := insert [] !active_formatting_elements

  let has_before_marker active_formatting_elements name =
    let rec scan = function
      | [] | Marker::_ -> None
      | Element_ (n, _, _)::_ when n.element_name = (`HTML, name) -> Some n
      | _::more -> scan more
    in
    scan !active_formatting_elements
end



type mode = unit -> unit

(* Stack of template insertion modes. *)
module Template :
sig
  type t = mode list ref

  val create : unit -> t

  val push : t -> mode -> unit
  val pop : t -> unit
end =
struct
  type t = (unit -> unit) list ref

  let create () = ref []

  let push template_insertion_modes mode =
    template_insertion_modes := mode::!template_insertion_modes

  let pop template_insertion_modes =
    match !template_insertion_modes with
    | [] -> ()
    | _::rest -> template_insertion_modes := rest
end



(* Subtree buffers. HTML specifies the "adoption agency algorithm" for
   recovering from certain kinds of errors. This algorithm is (apparently)
   incompatible with streaming parsers that do not maintain a DOM - such as
   Markup.ml. So, when the Markup.ml parser encounters a situation in which it
   may be necessary to later run the adoption agency algorithm, it buffers its
   signal output. Instead of being emitted, the signals are used to construct a
   DOM subtree. If the algorithm is run, it is run on this subtree. Whenever the
   parser can "prove" that the subtree can no longer be involved in the adoption
   agency algorithm, it serializes the subtree into the signal stream. In
   practice, this means that buffering begins when a formatting element is
   encountered, and ends when the parent of the formatting element is popped off
   the open element stack. *)
module Subtree :
sig
  type t

  val create : Stack.t -> t

  val accumulate : t -> location -> signal -> bool

  val enable : t -> unit
  val disable : t -> (location * signal) list

  val adoption_agency_algorithm :
    t -> Active.t -> location -> string -> bool * (location * Error.t) list
end =
struct
  type t =
    {open_elements    : Stack.t;
     mutable enabled  : bool;
     mutable position : element}

  let create open_elements =
    {open_elements;
     enabled  = false;
     position = Element.dummy}

  let accumulate subtree_buffer l s =
    if not subtree_buffer.enabled then true
    else begin
      begin match s with
      | `Start_element (_, attributes) ->
        let parent = subtree_buffer.position in
        let child =
          Stack.require_current_element subtree_buffer.open_elements in

        child.attributes <- attributes;
        child.parent <- parent;
        parent.children <- (l, Element child)::parent.children;

        subtree_buffer.position <- child

      | `End_element ->
        subtree_buffer.position.end_location <- l;
        subtree_buffer.position <-
          Stack.require_current_element subtree_buffer.open_elements

      | `Text ss ->
        subtree_buffer.position.children <-
          (l, Text ss)::subtree_buffer.position.children

      | `PI (t, s) ->
        subtree_buffer.position.children <-
          (l, PI (t, s))::subtree_buffer.position.children

      | `Comment s ->
        subtree_buffer.position.children <-
          (l, Comment s)::subtree_buffer.position.children

      | `Xml _ | `Doctype _ -> ()
      end;

      false
    end

  let enable subtree_buffer =
    if subtree_buffer.enabled then ()
    else
      match Stack.current_element subtree_buffer.open_elements with
      | None -> ()
      | Some element ->
        element.buffering <- true;
        subtree_buffer.position <- element;
        subtree_buffer.enabled <- true

  let disable subtree_buffer =
    let rec traverse acc = function
      | l, Element {element_name; attributes; end_location; children} ->
        let name = Ns.to_string (fst element_name), snd element_name in
        let start_signal = l, `Start_element (name, attributes) in
        let end_signal = end_location, `End_element in
        start_signal::(List.fold_left traverse (end_signal::acc) children)

      | l, Text ss ->
        begin match acc with
        | (_, `Text ss')::rest -> (l, `Text (ss @ ss'))::rest
        | _ -> (l, `Text ss)::acc
        end

      | l, PI (t, s) -> (l, `PI (t, s))::acc
      | l, Comment s -> (l, `Comment s)::acc
    in

    let result =
      List.fold_left traverse []
        (Stack.require_current_element subtree_buffer.open_elements).children
    in

    subtree_buffer.enabled <- false;

    result

  (* Part of 8.2.5.4.7. *)
  let adoption_agency_algorithm
      subtree_buffer active_formatting_elements l subject =

    let open_elements = subtree_buffer.open_elements in

    let above_removed_nodes = ref [] in

    let rec above_in_stack node = function
      | e::e'::_ when e == node -> e'
      | _::more -> above_in_stack node more
      | [] -> failwith "above_in_stack: not found"
    in

    let above_node node =
      if node.is_open then above_in_stack node !open_elements
      else
        try List.find (fun (e, _) -> e == node) !above_removed_nodes |> snd
        with Not_found -> failwith "above_node: not found"
    in

    let remove_node node =
      above_removed_nodes :=
        (node, above_in_stack node !open_elements)::!above_removed_nodes;
      Stack.remove open_elements node
    in

    let reparent node new_parent =
      let old_parent = node.parent in

      let entry, filtered_children =
        let rec remove prefix = function
          | (_, Element e as entry)::rest when e == node ->
            entry, (List.rev prefix) @ rest
          | e::rest -> remove (e::prefix) rest
          | [] -> (node.location, Element node), old_parent.children
        in
        remove [] old_parent.children
      in

      old_parent.children <- filtered_children;
      new_parent.children <- entry::new_parent.children;
      node.parent <- new_parent
    in

    let inner_loop formatting_element furthest_block =
      let rec repeat inner_loop_counter node last_node bookmark =
        let node = above_node node in

        if node == formatting_element then last_node, bookmark
        else begin
          if inner_loop_counter > 3 then
            Active.remove active_formatting_elements node;

          if not @@ Active.has active_formatting_elements node then begin
            remove_node node;
            repeat (inner_loop_counter + 1) node last_node bookmark
          end
          else begin
            let new_node =
              {node with is_open = true; children = []; parent = Element.dummy}
            in

            node.end_location <- l;

            Stack.replace open_elements ~old:node ~new_:new_node;
            Active.replace active_formatting_elements ~old:node ~new_:new_node;

            reparent last_node new_node;

            repeat (inner_loop_counter + 1) new_node new_node
              (if last_node == furthest_block then Some new_node else bookmark)
          end
        end

      in
      repeat 1 furthest_block furthest_block None
    in

    let find_formatting_element () =
      let rec scan = function
        | [] -> None
        | Active.Marker::_ -> None
        | (Active.Element_ ({element_name = `HTML, n} as e, _, _))::_
            when n = subject -> Some e
        | _::rest -> scan rest
      in
      scan !active_formatting_elements
    in

    let find_furthest_block formatting_element =
      let rec scan furthest = function
        | [] -> furthest
        | e::_ when e == formatting_element -> furthest
        | e::more when Element.is_special e.element_name -> scan (Some e) more
        | _::more -> scan furthest more
      in
      scan None !open_elements
    in

    let pop_to_formatting_element formatting_element =
      let rec pop () =
        match !open_elements with
        | [] -> ()
        | e::more ->
          open_elements := more;
          e.is_open <- false;
          e.end_location <- l;
          if e != formatting_element then pop ()
      in
      pop ();
      subtree_buffer.position <- Stack.require_current_element open_elements
    in

    let rec outer_loop outer_loop_counter errors =
      let outer_loop_counter = outer_loop_counter + 1 in

      if outer_loop_counter >= 8 then true, List.rev errors
      else begin
        match find_formatting_element () with
        | None -> false, List.rev errors
        | Some formatting_element ->
          if not formatting_element.is_open then begin
            Active.remove active_formatting_elements formatting_element;
            true, List.rev ((l, `Unmatched_end_tag subject)::errors)
          end
          else begin
            if not @@ Stack.target_in_scope open_elements
                        formatting_element then begin
              true, List.rev ((l, `Unmatched_end_tag subject)::errors)
            end
            else begin
              let errors =
                if Stack.require_current_element open_elements ==
                   formatting_element then
                  errors
                else (l, `Unmatched_end_tag subject)::errors
              in

              match find_furthest_block formatting_element with
              | None ->
                pop_to_formatting_element formatting_element;
                Active.remove active_formatting_elements formatting_element;
                true, List.rev errors

              | Some furthest_block ->
                formatting_element.end_location <- l;

                let common_ancestor =
                  above_in_stack formatting_element !open_elements in

                let last_node, bookmark =
                  inner_loop formatting_element furthest_block in

                reparent last_node common_ancestor;

                let new_node =
                  {formatting_element with
                    is_open = true; children = []; parent = Element.dummy}
                in

                new_node.children <- furthest_block.children;
                furthest_block.children <- [];
                new_node.children |> List.iter (function
                  | _, Element child -> child.parent <- new_node
                  | _ -> ());

                reparent new_node furthest_block;

                begin match bookmark with
                | None ->
                  Active.replace active_formatting_elements
                    ~old:formatting_element ~new_:new_node
                | Some node ->
                  Active.remove active_formatting_elements formatting_element;
                  Active.insert_after
                    active_formatting_elements ~anchor:node ~new_:new_node
                end;

                Stack.remove open_elements formatting_element;
                Stack.insert_below
                  open_elements ~anchor:furthest_block ~new_:new_node;

                outer_loop outer_loop_counter errors
            end
          end
      end
    in

    let current_node = Stack.require_current_element open_elements in
    if current_node.element_name = (`HTML, subject) then begin
      open_elements := List.tl !open_elements;
      current_node.is_open <- false;
      current_node.end_location <- l;
      subtree_buffer.position <- Stack.require_current_element open_elements;
      Active.remove active_formatting_elements current_node;
      true, []
    end
    else outer_loop 0 []
end



let parse requested_context report (tokens, set_tokenizer_state, set_foreign) =
  let context = Context.uninitialized () in

  let throw = ref (fun _ -> ()) in
  let ended = ref (fun _ -> ()) in
  let output = ref (fun _ -> ()) in

  let report_if = Error.report_if report in
  let unmatched_end_tag l name k =
    report l (`Unmatched_end_tag name) !throw k in

  let open_elements = Stack.create () in
  let active_formatting_elements = Active.create () in
  let subtree_buffer = Subtree.create open_elements in
  let text = Text.prepare () in
  let template_insertion_modes = Template.create () in
  let frameset_ok = ref true in
  let head_seen = ref false in
  let form_element_pointer = ref None in

  let add_character = Text.add text in

  set_foreign (fun () ->
    Stack.current_element_is_foreign context open_elements);

  let report_if_stack_has_other_than names k =
    let rec iterate = function
      | [] -> k ()
      | {element_name = ns, name; location}::more ->
        report_if (not (ns = `HTML && list_mem_string name names))
          location (fun () -> `Unmatched_start_tag name) !throw (fun () ->
        iterate more)
    in
    iterate !open_elements
  in

  let rec current_mode = ref initial_mode

  and constructor throw_ k =
    Context.initialize tokens requested_context context throw_ (fun () ->

    let initial_tokenizer_state =
      match Context.the_context context with
      | `Fragment (`HTML, ("title" | "textarea")) -> `RCDATA
      | `Fragment
          (`HTML, ("style" | "xmp" | "iframe" | "noembed" | "noframes")) ->
        `RAWTEXT
      | `Fragment (`HTML, "script") -> `Script_data
      | `Fragment (`HTML, "plaintext") -> `PLAINTEXT
      | _ -> `Data
    in

    set_tokenizer_state initial_tokenizer_state;

    begin match Context.the_context context with
    | `Document -> ()
    | `Fragment _ ->
      let notional_root =
        Element.create ~suppress:true (`HTML, "html") (1, 1) in
      open_elements := [notional_root]
    end;

    begin match Context.the_context context with
    | `Fragment (`HTML, "template") ->
      Template.push template_insertion_modes in_template_mode
    | _ -> ()
    end;

    (* The following is a deviation from conformance. The goal is to avoid
       insertion of a <head> element into a fragment beginning with a <body> or
       <frameset> element. *)
    begin match Context.token context with
    | Some ("body" | "frameset") -> head_seen := true
    | _ -> ()
    end;

    current_mode :=
      begin match Context.the_context context with
      | `Fragment _ -> reset_mode ()
      | `Document -> initial_mode
      end;

    (fun throw_ e k ->
      throw := throw_;
      ended := e;
      output := k;
      !current_mode ())
    |> make
    |> k)

  (* 8.2.3.1. *)
  and reset_mode () =
    let rec iterate last = function
      | [e] when not last && Context.the_context context <> `Document ->
        begin match Context.the_context context with
        | `Document -> assert false (*BISECT-IGNORE*)
        | `Fragment name -> iterate true [{e with element_name = name}]
        end
      | {element_name = _, "select"}::ancestors ->
        let rec iterate' = function
          | [] -> in_select_mode
          | {element_name = _, "template"}::_ -> in_select_mode
          | {element_name = _, "table"}::_ -> in_select_in_table_mode
          | _::ancestors -> iterate' ancestors
        in
        iterate' ancestors
      | {element_name = _, ("tr" | "th")}::_::_ -> in_cell_mode
      | {element_name = _, "tr"}::_ -> in_row_mode
      | {element_name = _, ("tbody" | "thead" | "tfoot")}::_ ->
        in_table_body_mode
      | {element_name = _, "caption"}::_ -> in_caption_mode
      | {element_name = _, "colgroup"}::_ -> in_column_group_mode
      | {element_name = _, "table"}::_ -> in_table_mode
      | {element_name = _, "template"}::_ ->
        begin match !template_insertion_modes with
        | [] -> initial_mode (* This is an internal error, actually. *)
        | mode::_ -> mode
        end
      (* The next case corresponds to item 12 of "Resetting the insertion mode
         appropriately." It is commented out as deliberate deviation from the
         specification, because that makes parsing of fragments intended for
         <head> elements more intuitive. For conformance, the pattern in the
         following case would have to end with ::_::_, not ::_. *)
      (* | [{element_name = _, "head"}] -> in_body_mode *)
      | {element_name = _, "head"}::_ -> in_head_mode
      | {element_name = _, "body"}::_ -> in_body_mode
      | {element_name = _, "frameset"}::_ -> in_frameset_mode
      | {element_name = _, "html"}::_ ->
        if !head_seen then after_head_mode else before_head_mode
      | _::rest -> iterate last rest
      | [] -> in_body_mode
    in
    iterate false !open_elements

  and emit' l s m =
    if Subtree.accumulate subtree_buffer l s then begin
      current_mode := m;
      !output (l, s)
    end
    else m ()

  and emit_list ss m =
    match ss with
    | [] -> m ()
    | (l, s)::more -> emit' l s (fun () -> emit_list more m)

  and emit_text m =
    match Text.emit text with
    | None -> m ()
    | Some (l', strings) ->
      emit' l' (`Text strings) m

  and emit l s m = emit_text (fun () -> emit' l s m)

  and push_and_emit
      ?(formatting = false) ?(acknowledge = false) ?(namespace = `HTML)
      ?(set_form_element_pointer = false) location
      ({Token_tag.name; attributes; self_closing} as tag) mode =

    report_if (self_closing && not acknowledge) location (fun () ->
      `Bad_token ("/>", "tag", "should not be self-closing"))
      !throw (fun () ->

    let namespace_string = Ns.to_string namespace in

    let tag_name =
      match namespace with
      | `SVG -> Foreign.adjust_svg_tag_name name
      | _ -> name
    in

    let is_html_integration_point =
      Foreign.is_html_integration_point namespace tag_name attributes in

    let attributes =
      List.map (fun (n, v) -> Namespace.Parsing.parse n, v) attributes in
    let attributes =
      match namespace with
      | `HTML | `Other _ -> attributes
      | `MathML -> Foreign.adjust_mathml_attributes attributes
      | `SVG -> Foreign.adjust_svg_attributes attributes
    in

    let element_entry =
      Element.create ~is_html_integration_point (namespace, tag_name) location
    in
    open_elements := element_entry::!open_elements;

    if set_form_element_pointer then
      form_element_pointer := Some element_entry;

    if formatting then
      active_formatting_elements :=
        Active.Element_ (element_entry, location, tag)::
          !active_formatting_elements;

    emit location
      (`Start_element ((namespace_string, tag_name), attributes)) mode)

  and push_implicit location name mode =
    push_and_emit location
      {Token_tag.name = name; attributes = []; self_closing = false} mode

  and pop location mode =
    match !open_elements with
    | [] -> mode ()
    | element::more ->
      emit_text (fun () ->
      (fun k ->
        if not element.buffering then k ()
        else emit_list (Subtree.disable subtree_buffer) k)
      (fun () ->
        open_elements := more;
        element.is_open <- false;
        if element.suppress then mode ()
        else emit' location `End_element mode))

  and pop_until condition location mode =
    let rec iterate () =
      match !open_elements with
      | [] -> mode ()
      | element::_ ->
        if condition element then mode ()
        else pop location iterate
    in
    iterate ()

  and close_element ?(ns = `HTML) l name mode =
    pop_until
      (fun {element_name = ns', name'} -> ns' = ns && name' = name) l
      (fun () ->
    pop l mode)

  and pop_until_and_raise_errors names location mode =
    let rec iterate () =
      match !open_elements with
      | [] -> mode ()
      | {element_name = ns, name}::_ ->
        if ns = `HTML && list_mem_string name names then pop location mode
        else
          report location (`Unmatched_start_tag name) !throw (fun () ->
          pop location iterate)
    in
    iterate ()

  and pop_implied ?(except = "") location mode =
    pop_until (fun {element_name = _, name} ->
      name = except ||
        not @@ list_mem_string name
          ["dd"; "dt"; "li"; "option"; "optgroup"; "p"; "rb"; "rp"; "rt";
           "rtc"]) location mode

  and pop_to_table_context location mode =
    pop_until (function
      | {element_name = `HTML, ("table" | "template" | "html")} -> true
      | _ -> false) location mode

  and pop_to_table_body_context location mode =
    pop_until (function
      | {element_name =
          `HTML, ("tbody" | "thead" | "tfoot" | "template" | "html")} -> true
      | _ -> false) location mode

  and pop_to_table_row_context location mode =
    pop_until (function
      | {element_name = `HTML, ("tr" | "template" | "html")} -> true
      | _ -> false) location mode

  and close_element_with_implied name location mode =
    pop_implied ~except:name location (fun () ->
    let check_element k =
      match Stack.current_element open_elements with
      | Some {element_name = `HTML, name'} when name' = name -> k ()
      | Some {element_name = _, name; location} ->
        report location (`Unmatched_start_tag name) !throw k
      | None ->
        unmatched_end_tag location name k
    in
    check_element (fun () ->
    close_element location name mode))

  and close_cell location mode =
    pop_implied location (fun () ->
    (fun mode ->
      match Stack.current_element open_elements with
      | Some {element_name = `HTML, ("td" | "th")} -> mode ()
      | Some {element_name = _, name} ->
        unmatched_end_tag location name mode
      | None ->
        unmatched_end_tag location "" mode)
    @@ (fun () ->
    pop_until (function
      | {element_name = `HTML, ("td" | "th")} -> true
      | _ -> false) location (fun () ->
    pop location mode)))

  and close_current_p_element l mode =
    if Stack.in_button_scope open_elements "p" then
      close_element_with_implied "p" l mode
    else mode ()

  and close_preceding_tag names l mode =
    let rec scan = function
      | [] -> mode ()
      | {element_name = (ns, name) as name'}::more ->
        if ns = `HTML && list_mem_string name names then
          close_element_with_implied name l mode
        else
          if Element.is_special name' &&
            not @@ list_mem_qname name'
              [`HTML, "address"; `HTML, "div"; `HTML, "p"] then
            mode ()
          else
            scan more
    in
    scan !open_elements

  and emit_end l =
    pop_until (fun _ -> false) l (fun () ->
    emit_text (fun () ->
    !ended ()))

  and reconstruct_active_formatting_elements mode =
    let rec get_prefix prefix = function
      | [] -> prefix, []
      | Active.Marker::_ as l -> prefix, l
      | Active.Element_ ({is_open = true}, _, _)::_ as l -> prefix, l
      | Active.Element_ ({is_open = false}, l, tag)::more ->
        get_prefix ((l, tag)::prefix) more
    in
    let to_reopen, remainder = get_prefix [] !active_formatting_elements in
    active_formatting_elements := remainder;

    begin match to_reopen with
    | [] -> ()
    | _::_ -> Subtree.enable subtree_buffer
    end;

    let rec reopen = function
      | [] -> mode ()
      | (l, tag)::more ->
        push_and_emit ~formatting:true l tag (fun () -> reopen more)
    in
    reopen to_reopen

  (* 8.2.5. *)
  and dispatch tokens rules =
    next tokens !throw (fun () -> !ended ()) begin fun ((_, t) as v) ->
      let foreign =
        match Stack.adjusted_current_element context open_elements, t with
        | None, _ -> false
        | Some {element_name = `HTML, _}, _ -> false
        | Some {element_name}, `Start {name}
            when Foreign.is_mathml_text_integration_point element_name
            && name <> "mglyph" && name <> "malignmark" -> false
        | Some {element_name = `MathML, "annotation-xml"},
            `Start {name = "svg"} -> false
        | Some {is_html_integration_point = true}, `Start _ -> false
        | Some {is_html_integration_point = true}, `Char _ -> false
        | _, `EOF -> false
        | _ -> true
      in

      if not foreign then rules v
      else foreign_content !current_mode (fun () -> rules v) v
    end

  (* 8.2.5.4.1. *)
  and initial_mode () =
    dispatch tokens begin function
      | _, `Char (0x0009 | 0x000A | 0x000C | 0x000D | 0x0020) ->
        initial_mode ()

      | l, `Comment s ->
        emit l (`Comment s) initial_mode

      | l, `Doctype d ->
        emit l (`Doctype d) before_html_mode

      | v ->
        push tokens v;
        before_html_mode ()
    end

  (* 8.2.5.4.2. *)
  and before_html_mode () =
    dispatch tokens begin function
      | l, `Doctype _ ->
        report l (`Bad_document "doctype should be first") !throw
          before_html_mode

      | l, `Comment s ->
        emit l (`Comment s) before_html_mode

      | _, `Char (0x0009 | 0x000A | 0x000C | 0x000D | 0x0020) ->
        before_html_mode ()

      | l, `Start ({name = "html"} as t) ->
        push_and_emit l t before_head_mode

      | l, `End {name}
          when not @@ list_mem_string name ["head"; "body"; "html"; "br"] ->
        unmatched_end_tag l name before_html_mode

      | l, _ as v ->
        push tokens v;
        push_implicit l "html" before_head_mode
    end

  (* 8.2.5.4.3. *)
  and before_head_mode () =
    dispatch tokens begin function
      | _, `Char (0x0009 | 0x000A | 0x000C | 0x000D | 0x0020) ->
        before_head_mode ()

      | l, `Comment s ->
        emit l (`Comment s) before_head_mode

      | l, `Doctype _ ->
        report l (`Bad_document "doctype should be first") !throw
          before_head_mode

      | _, `Start {name = "html"} as v ->
        in_body_mode_rules "html" before_head_mode v

      | l, `Start ({name = "head"} as t) ->
        head_seen := true;
        push_and_emit l t in_head_mode

      | l, `End {name}
          when not @@ list_mem_string name ["head"; "body"; "html"; "br"] ->
        report l (`Unmatched_end_tag name) !throw before_head_mode

      | l, _ as v ->
        head_seen := true;
        push tokens v;
        push_implicit l "head" in_head_mode
    end

  (* 8.2.5.4.4. *)
  and in_head_mode () =
    dispatch tokens (fun v -> in_head_mode_rules in_head_mode v)

  (* 8.2.5.4.4. *)
  and in_head_mode_rules mode = function
    | l, `Char (0x0009 | 0x000A | 0x000C | 0x000D | 0x0020 as c) ->
      add_character l c;
      mode ()

    | l, `Comment s ->
      emit l (`Comment s) mode

    | l, `Doctype _ ->
      report l (`Bad_document "doctype should be first") !throw mode

    | _, `Start {name = "html"} as v ->
      in_body_mode_rules "head" in_head_mode v

    | l, `Start ({name =
        "base" | "basefont" | "bgsound" | "link" | "meta"} as t) ->
      push_and_emit ~acknowledge:true l t (fun () ->
      pop l mode)

    | l, `Start ({name = "title"} as t) ->
      push_and_emit l t (fun () ->
      parse_rcdata mode)

    | l, `Start ({name = "noframes" | "style"} as t) ->
      push_and_emit l t (fun () ->
      parse_rawtext mode)

    | l, `Start ({name = "noscript"} as t) ->
      push_and_emit l t in_head_noscript_mode

    | l, `Start ({name = "script"} as t) ->
      push_and_emit l t (fun () ->
      set_tokenizer_state `Script_data;
      text_mode mode)

    | l, `End {name = "head"} ->
      pop l after_head_mode

    | l, `Start ({name = "template"} as t) ->
      Active.add_marker active_formatting_elements;
      frameset_ok := false;
      Template.push template_insertion_modes in_template_mode;
      push_and_emit l t in_template_mode

    | l, `End {name = "template"} ->
      if not @@ Stack.has open_elements "template" then
        report l (`Unmatched_end_tag "template") !throw mode
      else begin
        Active.clear_until_marker active_formatting_elements;
        Template.pop template_insertion_modes;
        close_element_with_implied "template" l (fun () -> reset_mode () ())
      end

    | l, `Start {name = "head"} ->
      report l (`Misnested_tag ("head", "head")) !throw mode

    | l, `End {name} when not @@ list_mem_string name ["body"; "html"; "br"] ->
      report l (`Unmatched_end_tag name) !throw mode

    | l, _ as v ->
      push tokens v;
      pop l after_head_mode

  (* 8.2.5.4.5. *)
  and in_head_noscript_mode () =
    dispatch tokens begin function
      | l, `Doctype _ ->
        report l (`Bad_document "doctype should be first") !throw
          in_head_noscript_mode

      | _, `Start {name = "html"} as v ->
        in_body_mode_rules "noscript" in_head_noscript_mode v

      | l, `End {name = "noscript"} ->
        pop l in_head_mode

      | _, `Char (0x0009 | 0x000A | 0x000C | 0x000D | 0x0020)
      | _, `Comment _
      | _, `Start {name =
          "basefont" | "bgsound" | "link" | "meta" | "noframes" |
          "style"} as v ->
        in_head_mode_rules in_head_noscript_mode v

      | l, `Start {name = "head" | "noscript" as name} ->
        report l (`Misnested_tag (name, "noscript")) !throw
          in_head_noscript_mode

      | l, `End {name} when name <> "br" ->
        report l (`Unmatched_end_tag name) !throw in_head_noscript_mode

      | l, _ as v ->
        report l (`Bad_content "noscript") !throw (fun () ->
        push tokens v;
        pop l in_head_mode)
    end

  (* 8.2.5.4.6. *)
  and after_head_mode () =
    dispatch tokens begin function
      | l, `Char (0x0009 | 0x000A | 0x000C | 0x000D | 0x0020 as c) ->
        add_character l c;
        after_head_mode ()

      | l, `Comment s ->
        emit l (`Comment s) after_head_mode

      | l, `Doctype _ ->
        report l (`Bad_document "doctype should be first") !throw
          after_head_mode

      | _, `Start {name = "html"} as v ->
        in_body_mode_rules "html" after_head_mode v

      | l, `Start ({name = "body"} as t) ->
        frameset_ok := false;
        push_and_emit l t in_body_mode

      | l, `Start ({name = "frameset"} as t) ->
        push_and_emit l t in_frameset_mode

      | l, `Start {name =
          "base" | "basefont" | "bgsound" | "link" | "meta" | "noframes" |
          "script" | "style" | "template" | "title" as name} as v ->
        report l (`Misnested_tag (name, "html")) !throw (fun () ->
        in_head_mode_rules after_head_mode v)

      | _, `End {name = "template"} as v ->
        in_head_mode_rules after_head_mode v

      | l, `Start {name = "head"} ->
        report l (`Bad_document "duplicate head element") !throw
          after_head_mode

      | l, `End {name}
          when not @@ list_mem_string name ["body"; "html"; "br"] ->
        report l (`Unmatched_end_tag name) !throw after_head_mode

      (* This case is not found in the specification. It is a deliberate
         deviation from conformance, so that fragments "<head>...</head>" don't
         get an implicit <body> element generated after the <head> element. *)
      | l, `EOF
          when (Context.the_context context = `Fragment (`HTML, "html")
             || Context.the_context context = `Fragment (`HTML, "head")) ->
        emit_end l

      | l, _ as t ->
        push tokens t;
        push_implicit l "body" in_body_mode
    end

  (* 8.2.5.4.7. *)
  and in_body_mode () =
    dispatch tokens (fun v -> in_body_mode_rules "body" in_body_mode v)

  (* 8.2.5.4.7. *)
  and in_body_mode_rules context_name mode = function
    | l, `Char 0 ->
      report l (`Bad_token ("U+0000", "body", "null")) !throw mode

    | l, `Char (0x0009 | 0x000A | 0x000C | 0x000D | 0x0020 as c) ->
      reconstruct_active_formatting_elements (fun () ->
      add_character l c;
      mode ())

    | l, `Char c ->
      frameset_ok := false;
      reconstruct_active_formatting_elements (fun () ->
      add_character l c;
      mode ())

    | l, `Comment s ->
      emit l (`Comment s) mode

    | l, `Doctype _ ->
      report l (`Bad_document "doctype should be first") !throw mode

    | l, `Start {name = "html"} ->
      report l (`Misnested_tag ("html", context_name)) !throw mode

    | _, `Start {name =
        "base" | "basefont" | "bgsound" | "link" | "meta" | "noframes" |
        "script" | "style" | "template" | "title"}
    | _, `End {name = "template"} as v ->
      in_head_mode_rules mode v

    | l, `Start {name = "body"} ->
      report l (`Misnested_tag ("body", context_name)) !throw mode

    | l, `Start ({name = "frameset"} as t) ->
      report l (`Misnested_tag ("frameset", context_name)) !throw (fun () ->
      match !open_elements with
      | [_] -> mode ()
      | _ ->
        let rec second_is_body = function
          | [{element_name = `HTML, "body"}; _] -> true
          | [] -> false
          | _::more -> second_is_body more
        in
        if not @@ second_is_body !open_elements then mode ()
        else
          if not !frameset_ok then mode ()
          else
            (* There is a deviation here due to the nature of the parser: if a
               body element has been emitted, it can't be suppressed. *)
            pop_until
              (fun _ -> match !open_elements with [_] -> true | _ -> false)
              l (fun () ->
            push_and_emit l t in_frameset_mode))

    | l, `EOF as v ->
      report_if_stack_has_other_than
        ["dd"; "dt"; "li"; "p"; "tbody"; "td"; "tfoot"; "th"; "thead"; "tr";
         "body"; "html"] (fun () ->
      match !template_insertion_modes with
      | [] -> emit_end l
      | _ -> in_template_mode_rules mode v)

    | l, `End {name = "body"} ->
      if not @@ Stack.in_scope open_elements "body" then
        report l (`Unmatched_end_tag "body") !throw mode
      else
        report_if_stack_has_other_than
          ["dd"; "dt"; "li"; "optgroup"; "option"; "p"; "rb"; "rp"; "rt";
           "rtc"; "tbody"; "td"; "tfoot"; "th"; "thead"; "tr"; "body";
           "html"] (fun () ->
        close_element l "body" after_body_mode)

    | l, `End {name = "html"} as v ->
      if not @@ Stack.in_scope open_elements "body" then
        report l (`Unmatched_end_tag "html") !throw mode
      else
        report_if_stack_has_other_than
          ["dd"; "dt"; "li"; "optgroup"; "option"; "p"; "rb"; "rp"; "rt";
           "rtc"; "tbody"; "td"; "tfoot"; "th"; "thead"; "tr"; "body";
           "html"] (fun () ->
        push tokens v;
        close_element l "body" after_body_mode)

    | l, `Start ({name =
        "address" | "article" | "aside" | "blockquote" | "center" |
        "details" | "dialog" | "dir" | "div" | "dl" | "fieldset" |
        "figcaption" | "figure" | "footer" | "header" | "hgroup" | "main" |
        "nav" | "ol" | "p" | "section" | "summary" | "ul"} as t) ->
      close_current_p_element l (fun () ->
      push_and_emit l t mode)

    | l, `Start ({name =
        "h1" | "h2" | "h3" | "h4" | "h5" | "h6" as name} as t) ->
      close_current_p_element l (fun () ->
      (fun mode' ->
        match Stack.current_element open_elements with
        | Some {element_name = `HTML,
            ("h1" | "h2" | "h3" | "h4" | "h5" | "h6" as name')} ->
          report l (`Misnested_tag (name, name')) !throw (fun () ->
          pop l mode')
        | _ -> mode' ()) (fun () ->
      push_and_emit l t mode))

    | l, `Start ({name = "pre" | "listing"} as t) ->
      frameset_ok := false;
      close_current_p_element l (fun () ->
      push_and_emit l t (fun () ->
      next_expected tokens !throw (function
        | _, `Char 0x000A -> mode ()
        | v ->
          push tokens v;
          mode ())))

    | l, `Start ({name = "form"} as t) ->
      if !form_element_pointer <> None &&
         not @@ Stack.has open_elements "template" then
        report l (`Misnested_tag ("form", "form")) !throw mode
      else begin
        close_current_p_element l (fun () ->
        let in_template = Stack.has open_elements "template" in
        push_and_emit ~set_form_element_pointer:(not in_template) l t mode)
      end

    | l, `Start ({name = "li"} as t) ->
      frameset_ok := false;
      close_preceding_tag ["li"] l (fun () ->
      close_current_p_element l (fun () ->
      push_and_emit l t mode))

    | l, `Start ({name = "dd" | "dt"} as t) ->
      frameset_ok := false;
      close_preceding_tag ["dd"; "dt"] l (fun () ->
      close_current_p_element l (fun () ->
      push_and_emit l t mode))

    | l, `Start ({name = "plaintext"} as t) ->
      close_current_p_element l (fun () ->
      set_tokenizer_state `PLAINTEXT;
      push_and_emit l t mode)

    | l, `Start ({name = "button"} as t) ->
      (fun mode' ->
        if Stack.in_scope open_elements "button" then
          report l (`Misnested_tag ("button", "button")) !throw (fun () ->
          close_element_with_implied "button" l mode')
        else mode' ())
      (fun () ->
        frameset_ok := false;
        reconstruct_active_formatting_elements (fun () ->
        push_and_emit l t mode))

    | l, `End {name =
        "address" | "article" | "aside" | "blockquote" | "button" |
        "center" | "details" | "dialog" | "dir" | "div" | "dl" | "fieldset" |
        "figcaption" | "figure" | "footer" | "header" | "hgroup" | "listing" |
        "main" | "nav" | "ol" | "pre" | "section" | "summary" | "ul"
        as name} ->
      if not @@ Stack.in_scope open_elements name then
        report l (`Unmatched_end_tag name) !throw mode
      else
        close_element_with_implied name l mode

    | l, `End {name = "form"} ->
      if not @@ Stack.has open_elements "template" then begin
        let form_element = !form_element_pointer in
        form_element_pointer := None;
        match form_element with
        | Some element when Stack.target_in_scope open_elements element ->
          pop_implied l (fun () ->
          match Stack.current_element open_elements with
          | Some element' when element' == element ->
            pop l mode
          | _ ->
            report element.location (`Unmatched_start_tag "form") !throw
              (fun () ->
            pop_until (fun element' -> element' == element) l (fun () ->
            pop l mode)))
        | _ ->
          report l (`Unmatched_end_tag "form") !throw mode
      end
      else
        if not @@ Stack.in_scope open_elements "form" then
          report l (`Unmatched_end_tag "form") !throw mode
        else
          close_element_with_implied "form" l mode

    | l, `End {name = "p"} ->
      (fun mode' ->
        if not @@ Stack.in_button_scope open_elements "p" then
          report l (`Unmatched_end_tag "p") !throw (fun () ->
          push_implicit l "p" mode')
        else mode' ())
      (fun () -> close_element_with_implied "p" l mode)

    | l, `End {name = "li"} ->
      if not @@ Stack.in_list_item_scope open_elements "li" then
        report l (`Unmatched_end_tag "li") !throw mode
      else
        close_element_with_implied "li" l mode

    | l, `End {name = "dd" | "dt" as name} ->
      if not @@ Stack.in_scope open_elements name then
        report l (`Unmatched_end_tag name) !throw mode
      else
        close_element_with_implied name l mode

    | l, `End {name = "h1" | "h2" | "h3" | "h4" | "h5" | "h6" as name} ->
      if not @@ Stack.one_in_scope open_elements
          ["h1"; "h2"; "h3"; "h4"; "h5"; "h6"] then
        report l (`Unmatched_end_tag name) !throw mode
      else
        pop_implied l (fun () ->
          (fun next ->
            match Stack.current_element open_elements with
            | Some {element_name = `HTML, name'}
                when list_mem_string
                  name' ["h1"; "h2"; "h3"; "h4"; "h5"; "h6"] ->
              next ()
            | _ ->
              report l (`Unmatched_end_tag name) !throw next)
          @@ (fun () ->
            pop_until_and_raise_errors
              ["h1"; "h2"; "h3"; "h4"; "h5"; "h6"] l mode))

    | l, `Start ({name = "a"} as t) ->
      (fun k ->
        match Active.has_before_marker active_formatting_elements "a" with
        | None -> k ()
        | Some existing ->
          report l (`Misnested_tag ("a", "a")) !throw (fun () ->
          adoption_agency_algorithm l "a" (fun () ->
          Stack.remove open_elements existing;
          Active.remove active_formatting_elements existing;
          k ())))
      (fun () ->
        Subtree.enable subtree_buffer;
        reconstruct_active_formatting_elements (fun () ->
        push_and_emit ~formatting:true l t mode))

    | l, `Start ({name =
        "b" | "big" | "code" | "em" | "font" | "i" | "s" | "small" |
        "strike" | "strong" | "tt" | "u"} as t) ->
      Subtree.enable subtree_buffer;
      reconstruct_active_formatting_elements (fun () ->
      push_and_emit ~formatting:true l t mode)

    | l, `Start ({name = "nobr"} as t) ->
      Subtree.enable subtree_buffer;
      reconstruct_active_formatting_elements (fun () ->
      (fun k ->
        if not @@ Stack.in_scope open_elements "nobr" then k ()
        else
          report l (`Misnested_tag ("nobr", "nobr")) !throw (fun () ->
          adoption_agency_algorithm l "nobr" (fun () ->
          reconstruct_active_formatting_elements k)))
      (fun () -> push_and_emit ~formatting:true l t mode))

    | l, `End {name =
        "a" | "b" | "big" | "code" | "em" | "font" | "i" | "nobr" | "s" |
        "small" | "strike" | "strong" | "tt" | "u" as name} ->
      adoption_agency_algorithm l name mode

    | l, `Start ({name = "applet" | "marquee" | "object"} as t) ->
      frameset_ok := false;
      reconstruct_active_formatting_elements (fun () ->
      Active.add_marker active_formatting_elements;
      push_and_emit l t mode)

    | l, `End {name = "applet" | "marquee" | "object" as name} ->
      if not @@ Stack.in_scope open_elements name then
        report l (`Unmatched_end_tag name) !throw mode
      else begin
        Active.clear_until_marker active_formatting_elements;
        close_element_with_implied name l mode
      end

    | l, `Start ({name = "table"} as t) ->
      frameset_ok := false;
      close_current_p_element l (fun () ->
      push_and_emit l t in_table_mode)

    | l, `End {name = "br"} ->
      report l (`Unmatched_end_tag "br") !throw (fun () ->
      in_body_mode_rules context_name mode
        (l, `Start
          {Token_tag.name = "br"; attributes = []; self_closing = false}))

    | l, `Start ({name =
        "area" | "br" | "embed" | "img" | "keygen" | "wbr"} as t) ->
      frameset_ok := false;
      reconstruct_active_formatting_elements (fun () ->
      push_and_emit ~acknowledge:true l t (fun () ->
      pop l mode))

    | l, `Start ({name = "input"} as t) ->
      if Element.is_not_hidden t then frameset_ok := false;
      reconstruct_active_formatting_elements (fun () ->
      push_and_emit ~acknowledge:true l t (fun () ->
      pop l mode))

    | l, `Start ({name = "param" | "source" | "track"} as t) ->
      push_and_emit ~acknowledge:true l t (fun () ->
      pop l mode)

    | l, `Start ({name = "hr"} as t) ->
      frameset_ok := false;
      close_current_p_element l (fun () ->
      push_and_emit ~acknowledge:true l t (fun () ->
      pop l mode))

    | l, `Start ({name = "image"} as t) ->
      report l (`Bad_token ("image", "tag", "should be 'img'")) !throw
        (fun () ->
      push tokens (l, `Start {t with name = "img"});
      mode ())

    | l, `Start ({name = "textarea"} as t) ->
      frameset_ok := false;
      push_and_emit l t (fun () ->
      set_tokenizer_state `RCDATA;
      next_expected tokens !throw (function
        | _, `Char 0x000A -> text_mode mode
        | v ->
          push tokens v;
          text_mode mode))

    | l, `Start {name = "xmp"} ->
      frameset_ok := false;
      close_current_p_element l (fun () ->
      reconstruct_active_formatting_elements (fun () ->
      parse_rawtext mode))

    | l, `Start ({name = "iframe"} as t) ->
      frameset_ok := false;
      push_and_emit l t (fun () ->
      parse_rawtext mode)

    | l, `Start ({name = "noembed"} as t) ->
      push_and_emit l t (fun () ->
      parse_rawtext mode)

    | l, `Start ({name = "select"} as t) ->
      frameset_ok := false;
      select_in_body l t in_select_mode

    | l, `Start ({name = "optgroup" | "option"} as t) ->
      (fun mode' ->
        if Stack.current_element_is open_elements ["option"] then
          pop l mode'
        else mode' ())
      (fun () ->
        reconstruct_active_formatting_elements (fun () ->
        push_and_emit l t mode))

    | l, `Start ({name = "rb" | "rp" | "rtc" as name} as t) ->
      (fun mode' ->
        if Stack.in_scope open_elements "ruby" then
          pop_implied l (fun () ->
          if Stack.current_element_is open_elements ["ruby"] then
            mode' ()
          else
            report l (`Misnested_tag (name, context_name)) !throw mode'))
      (fun () ->
        push_and_emit l t mode)

    | l, `Start ({name = "rt"} as t) ->
      (fun mode' ->
        if Stack.in_scope open_elements "ruby" then
          pop_implied ~except:"rtc" l (fun () ->
          if Stack.current_element_is open_elements ["ruby"; "rtc"] then
            mode' ()
          else
            report l (`Misnested_tag ("rt", context_name)) !throw mode'))
      (fun () ->
        push_and_emit l t mode)

    | l, `Start ({name = "math"} as t) ->
      reconstruct_active_formatting_elements (fun () ->
      push_and_emit ~acknowledge:true ~namespace:`MathML l t (fun () ->
      if t.self_closing then pop l mode
      else mode ()))

    | l, `Start ({name = "svg"} as t) ->
      reconstruct_active_formatting_elements (fun () ->
      push_and_emit ~acknowledge:true ~namespace:`SVG l t (fun () ->
      if t.self_closing then pop l mode
      else mode ()))

    | l, `Start {name =
        "caption" | "col" | "colgroup" | "frame" | "head" | "tbody" | "td" |
        "tfoot" | "th" | "thead" | "tr" as name} ->
      report l (`Misnested_tag (name, context_name)) !throw mode

    | l, `Start t ->
      reconstruct_active_formatting_elements (fun () ->
      push_and_emit l t mode)

    | l, `End {name} ->
      any_other_end_tag_in_body l name mode

  (* Part of 8.2.5.4.7. *)
  and any_other_end_tag_in_body l name mode =
    let rec close = function
      | [] -> mode ()
      | {element_name = (ns, name') as name''}::rest ->
        if ns = `HTML && name' = name then
          pop_implied ~except:name l (fun () ->
          pop l mode)
        else
          if Element.is_special name'' then
            report l (`Unmatched_end_tag name) !throw mode
          else close rest
    in
    close !open_elements

  (* Part of 8.2.5.4.7. *)
  and adoption_agency_algorithm l name mode =
    Subtree.enable subtree_buffer;
    emit_text (fun () ->
    let handled, errors =
      Subtree.adoption_agency_algorithm
        subtree_buffer active_formatting_elements l name
    in
    let rec report_all errors k =
      match errors with
      | [] -> k ()
      | (l, error)::more ->
        report l error !throw (fun () -> report_all more k)
    in
    report_all errors (fun () ->
    if not handled then any_other_end_tag_in_body l name mode
    else mode ()))

  (* Part of 8.2.5.4.7. *)
  and select_in_body l t next_mode =
    frameset_ok := false;
    reconstruct_active_formatting_elements (fun () ->
    push_and_emit l t next_mode)

  (* 8.2.5.4.8. *)
  and text_mode original_mode =
    dispatch tokens begin function
      | l, `Char c ->
        add_character l c;
        text_mode original_mode

      | l, `EOF as v ->
        report l (`Unexpected_eoi "content") !throw (fun () ->
        push tokens v;
        pop l original_mode)

      | l, `End _ ->
        pop l original_mode

      | _ ->
        text_mode original_mode
    end

  (* 8.2.5.2. *)
  and parse_rcdata original_mode =
    set_tokenizer_state `RCDATA;
    text_mode original_mode

  (* 8.2.5.2. *)
  and parse_rawtext original_mode =
    set_tokenizer_state `RAWTEXT;
    text_mode original_mode

  and anything_else_in_table mode (l, _ as v) =
    report l (`Bad_content "table") !throw (fun () ->
    in_body_mode_rules "table" mode v)

  (* 8.2.5.4.9. *)
  and in_table_mode () =
    dispatch tokens (fun v -> in_table_mode_rules in_table_mode v)

  and in_table_mode_rules mode = function
    | _, `Char _ as v
        when Stack.current_element_is open_elements
               ["table"; "tbody"; "tfoot"; "thead"; "tr"] ->
      push tokens v;
      in_table_text_mode true [] mode

    | l, `Comment s ->
      emit l (`Comment s) mode

    | l, `Doctype _ ->
      report l (`Bad_document "doctype should be first") !throw mode

    | l, `Start ({name = "caption"} as t) ->
      pop_to_table_context l (fun () ->
      Active.add_marker active_formatting_elements;
      push_and_emit l t in_caption_mode)

    | l, `Start ({name = "colgroup"} as t) ->
      pop_to_table_context l (fun () ->
      push_and_emit l t in_column_group_mode)

    | l, `Start {name = "col"} as v ->
      pop_to_table_context l (fun () ->
      push tokens v;
      push_implicit l "colgroup" in_column_group_mode)

    | l, `Start ({name = "tbody" | "tfoot" | "thead"} as t) ->
      pop_to_table_context l (fun () ->
      push_and_emit l t in_table_body_mode)

    | l, `Start {name = "td" | "th" | "tr"} as v ->
      pop_to_table_context l (fun () ->
      push tokens v;
      push_implicit l "tbody" in_table_body_mode)

    | l, `Start {name = "table"} as v ->
      report l (`Misnested_tag ("table", "table")) !throw (fun () ->
      if not @@ Stack.has open_elements "table" then mode ()
      else begin
        push tokens v;
        close_element l "table" (fun () -> reset_mode () ())
      end)

    | l, `End {name = "table"} ->
      if not @@ Stack.in_table_scope open_elements "table" then
        report l (`Unmatched_end_tag "table") !throw mode
      else
        close_element l "table" (fun () -> reset_mode () ())

    | l, `End {name =
      "body" | "caption" | "col" | "colgroup" | "html" | "tbody" | "td" |
      "tfoot" | "th" | "thead" | "tr" as name} ->
      report l (`Unmatched_end_tag name) !throw mode

    | _, `Start {name = "style" | "script" | "template"}
    | _, `End {name = "template"} as v ->
      in_head_mode_rules mode v

    | l, `Start ({name = "input"} as t) when Element.is_not_hidden t ->
      report l (`Misnested_tag ("input", "table")) !throw (fun () ->
      push_and_emit ~acknowledge:true l t (fun () ->
      pop l mode))

    | l, `Start ({name = "form"} as t) ->
      report l (`Misnested_tag ("form", "table")) !throw (fun () ->
      push_and_emit l t (fun () ->
      pop l mode))

    | _, `EOF as v ->
      in_body_mode_rules "table" mode v

    | v ->
      anything_else_in_table mode v

  (* 8.2.5.4.10. *)
  and in_table_text_mode only_space cs mode =
    dispatch tokens begin function
      | l, `Char 0 ->
        report l (`Bad_token ("U+0000", "table", "null")) !throw (fun () ->
        in_table_text_mode only_space cs mode)

      | _, `Char (0x0009 | 0x000A | 0x000C | 0x000D | 0x0020) as v ->
        in_table_text_mode only_space (v::cs) mode

      | _, `Char _ as v ->
        in_table_text_mode false (v::cs) mode

      | v ->
        push tokens v;
        if not only_space then
          let rec reprocess = function
            | [] -> mode ()
            | v::more -> anything_else_in_table (fun () -> reprocess more) v
          in
          reprocess (List.rev cs)
        else begin
          List.rev cs |> List.iter (function
            | l, `Char c -> add_character l c
            | _ -> ());
          mode ()
        end
    end

  (* 8.2.5.4.11. *)
  and in_caption_mode () =
    dispatch tokens begin function
      | l, `End {name = "caption"} ->
        if not @@ Stack.in_table_scope open_elements "caption" then
          report l (`Unmatched_end_tag "caption") !throw in_caption_mode
        else begin
          Active.clear_until_marker active_formatting_elements;
          close_element_with_implied "caption" l in_table_mode
        end

      | l, `Start {name =
          "caption" | "col" | "colgroup" | "tbody" | "td" | "tfoot" | "th" |
          "thead" | "tr" as name} as v ->
        report l (`Misnested_tag (name, "caption")) !throw (fun () ->
        if not @@ Stack.in_table_scope open_elements "caption" then
          in_caption_mode ()
        else begin
          Active.clear_until_marker active_formatting_elements;
          push tokens v;
          close_element l "caption" in_table_mode
        end)

      | l, `End {name = "table"} as v ->
        report l (`Unmatched_end_tag "table") !throw (fun () ->
        if not @@ Stack.in_table_scope open_elements "caption" then
          in_caption_mode ()
        else begin
          Active.clear_until_marker active_formatting_elements;
          push tokens v;
          close_element l "caption" in_table_mode
        end)

      | l, `End {name =
          ("body" | "col" | "colgroup" | "html" | "tbody" | "td" | "tfoot" |
           "th" | "thead" | "tr") as name} ->
        report l (`Unmatched_end_tag name) !throw in_caption_mode

      | l, `Start ({name = "select"} as t) ->
        select_in_body l t in_select_in_table_mode

      | v ->
        in_body_mode_rules "caption" in_caption_mode v
    end

  (* 8.2.5.4.12. *)
  and in_column_group_mode () =
    dispatch tokens begin function
      | l, `Char (0x0009 | 0x000A | 0x000C | 0x000D | 0x0020 as c) ->
        add_character l c;
        in_column_group_mode ()

      | l, `Comment s ->
        emit l (`Comment s) in_column_group_mode

      | l, `Doctype _ ->
        report l (`Bad_document "doctype should be first") !throw
          in_column_group_mode

      | _, `Start {name = "html"} as v ->
        in_body_mode_rules "colgroup" in_column_group_mode v

      | l, `Start ({name = "col"} as t) ->
        push_and_emit ~acknowledge:true l t (fun () ->
        pop l in_column_group_mode)

      | l, `End {name = "colgroup"} ->
        if not @@ Stack.current_element_is open_elements ["colgroup"] then
          report l (`Unmatched_end_tag "colgroup") !throw in_column_group_mode
        else
          pop l in_table_mode

      | l, `End {name = "col"} ->
        report l (`Unmatched_end_tag "col") !throw in_column_group_mode

      | _, `Start {name = "template"}
      | _, `End {name = "template"} as v ->
        in_head_mode_rules in_column_group_mode v

      | _, `EOF as v ->
        in_body_mode_rules "colgroup" in_column_group_mode v

      | l, _ as v ->
        if not @@ Stack.current_element_is open_elements ["colgroup"] then
          report l (`Bad_content "colgroup") !throw in_table_mode
        else begin
          push tokens v;
          pop l in_table_mode
        end
    end

  (* 8.2.5.4.13. *)
  and in_table_body_mode () =
    dispatch tokens begin function
      | l, `Start ({name = "tr"} as t) ->
        pop_to_table_body_context l (fun () ->
        push_and_emit l t in_row_mode)

      | l, `Start {name = ("th" | "td") as name} as v ->
        report l (`Misnested_tag (name, "table")) !throw (fun () ->
        pop_to_table_body_context l (fun () ->
        push tokens v;
        push_implicit l "tr" in_row_mode))

      | l, `End {name = "tbody" | "tfoot" | "thead" as name} ->
        if not @@ Stack.in_table_scope open_elements name then
          report l (`Unmatched_end_tag name) !throw in_table_body_mode
        else
          pop_to_table_body_context l (fun () ->
          pop l in_table_mode)

      | l, `Start {name =
          "caption" | "col" | "colgroup" | "tbody" | "tfoot" | "thead"
          as name} as v ->
        if not @@ Stack.one_in_table_scope open_elements
            ["tbody"; "thead"; "tfoot"] then
          report l (`Misnested_tag (name, "table")) !throw in_table_body_mode
        else begin
          push tokens v;
          pop_to_table_body_context l (fun () ->
          pop l in_table_mode)
        end

      | l, `End {name = "table" as name} as v ->
        if not @@ Stack.one_in_table_scope open_elements
            ["tbody"; "thead"; "tfoot"] then
          report l (`Unmatched_end_tag name) !throw in_table_body_mode
        else begin
          push tokens v;
          pop_to_table_body_context l (fun () ->
          pop l in_table_mode)
        end

      | l, `End {name =
          "body" | "caption" | "col" | "colgroup" | "html" | "td" | "th" |
          "tr" as name} ->
        report l (`Unmatched_end_tag name) !throw in_table_body_mode

      | v ->
        in_table_mode_rules in_table_body_mode v
    end

  (* 8.2.5.4.14. *)
  and in_row_mode () =
    dispatch tokens begin function
      | l, `Start ({name = "th" | "td"} as t) ->
        Active.add_marker active_formatting_elements;
        pop_to_table_row_context l (fun () ->
        push_and_emit l t in_cell_mode)

      | l, `End {name = "tr"} ->
        if not @@ Stack.in_table_scope open_elements "tr" then
          report l (`Unmatched_end_tag "tr") !throw in_row_mode
        else
          pop_to_table_row_context l (fun () ->
          pop l in_table_body_mode)

      | l, `Start {name =
          ("caption" | "col" | "colgroup" | "tbody" | "tfoot" | "thead" |
           "tr")}
      | l, `End {name = "table"} as v ->
        if not @@ Stack.in_table_scope open_elements "tr" then
          match snd v with
          | `Start {name} ->
            report l (`Misnested_tag (name, "tr")) !throw in_row_mode
          | `End {name} ->
            report l (`Unmatched_end_tag name) !throw in_row_mode
        else
          pop_to_table_row_context l (fun () ->
          push tokens v;
          pop l in_table_body_mode)

      | l, `End {name = "tbody" | "tfoot" | "thead" as name} as v ->
        if not @@ Stack.in_table_scope open_elements name then
          report l (`Unmatched_end_tag name) !throw in_row_mode
        else
          if not @@ Stack.in_table_scope open_elements "tr" then in_row_mode ()
          else
            pop_to_table_row_context l (fun () ->
            push tokens v;
            pop l in_table_body_mode)

      | l, `End {name =
          "body" | "caption" | "col" | "colgroup" | "html" | "td" | "th"
          as name} ->
        report l (`Unmatched_end_tag name) !throw in_row_mode

      | v ->
        in_table_mode_rules in_row_mode v
    end

  (* 8.2.5.4.15. *)
  and in_cell_mode () =
    dispatch tokens begin function
      | l, `End {name = "td" | "th" as name} ->
        if not @@ Stack.in_table_scope open_elements name then
          report l (`Unmatched_end_tag name) !throw in_cell_mode
        else
          close_element_with_implied name l (fun () ->
          Active.clear_until_marker active_formatting_elements;
          in_row_mode ())

      | l, `Start {name =
          "caption" | "col" | "colgroup" | "tbody" | "td" | "tfoot" | "th" |
          "thead" | "tr" as name} as v ->
        if not @@ Stack.one_in_table_scope open_elements ["td"; "th"] then
          report l (`Misnested_tag (name, "td/th")) !throw in_cell_mode
        else
          close_cell l (fun () ->
          Active.clear_until_marker active_formatting_elements;
          push tokens v;
          in_row_mode ())

      | l, `End {name =
          "body" | "caption" | "col" | "colgroup" | "html" as name} ->
        report l (`Unmatched_end_tag name) !throw in_cell_mode

      | l, `End {name =
          "table" | "tbody" | "tfoot" | "thead" | "tr" as name} as v ->
        if not @@ Stack.in_table_scope open_elements name then
          report l (`Unmatched_end_tag name) !throw in_cell_mode
        else
          close_cell l (fun () ->
          Active.clear_until_marker active_formatting_elements;
          push tokens v;
          in_row_mode ())

      | l, `Start ({name = "select"} as t) ->
        select_in_body l t in_select_in_table_mode

      | v ->
        in_body_mode_rules "td" in_cell_mode v
    end

  (* 8.2.5.4.16. *)
  and in_select_mode () =
    dispatch tokens (fun v -> in_select_mode_rules in_select_mode v)

  and in_select_mode_rules mode = function
    | l, `Char 0 ->
      report l (`Bad_token ("U+0000", "select", "null")) !throw mode

    | l, `Char c ->
      add_character l c;
      mode ()

    | l, `Comment s ->
      emit l (`Comment s) mode

    | l, `Doctype _ ->
      report l (`Bad_document "doctype should be first") !throw mode

    | _, `Start {name = "html"} as v ->
      in_body_mode_rules "select" mode v

    | l, `Start ({name = "option"} as t) ->
      (fun mode' ->
        if Stack.current_element_is open_elements ["option"] then pop l mode'
        else mode' ())
      (fun () -> push_and_emit l t mode)

    | l, `Start ({name = "optgroup"} as t) ->
      (fun mode' ->
        if Stack.current_element_is open_elements ["option"] then pop l mode'
        else mode' ())
      @@ (fun mode' () ->
        if Stack.current_element_is open_elements ["optgroup"] then pop l mode'
        else mode' ())
      @@ (fun () -> push_and_emit l t mode)

    | l, `End {name = "optgroup"} ->
      (fun mode' ->
        match !open_elements with
        | {element_name = `HTML, "option"}::
            {element_name = `HTML, "optgroup"}::_ ->
          pop l mode'
        | _ -> mode' ())
      (fun () ->
        if Stack.current_element_is open_elements ["optgroup"] then
          pop l mode
        else
          report l (`Unmatched_end_tag "optgroup") !throw mode)

    | l, `End {name = "option"} ->
      if Stack.current_element_is open_elements ["option"] then
        pop l mode
      else
        report l (`Unmatched_end_tag "option") !throw mode

    | l, `End {name = "select"} ->
      if not @@ Stack.in_select_scope open_elements "select" then
        report l (`Unmatched_end_tag "select") !throw mode
      else
        close_element l "select" (fun () -> reset_mode () ())

    | l, `Start {name = "select"} ->
      report l (`Misnested_tag ("select", "select")) !throw (fun () ->
      close_element l "select" (fun () -> reset_mode () ()))

    | l, `Start {name = "input" | "keygen" | "textarea" as name} as v ->
      report l (`Misnested_tag (name, "select")) !throw (fun () ->
      if not @@ Stack.in_select_scope open_elements "select" then
        mode ()
      else begin
        push tokens v;
        close_element l "select" (fun () -> reset_mode () ())
      end)

    | _, (`Start {name = "script" | "template"} |
          `End {name = "template"}) as v ->
      in_head_mode_rules mode v

    | _, `EOF as v ->
      in_body_mode_rules "select" mode v

    | l, _ ->
      report l (`Bad_content "select") !throw mode

  (* 8.2.5.4.17. *)
  and in_select_in_table_mode () =
    dispatch tokens begin function
      | l, `Start {name =
          "caption" | "table" | "tbody" | "tfoot" | "thead" | "tr" | "td" |
          "th" as name} as v ->
        report l (`Misnested_tag (name, "table")) !throw (fun () ->
        push tokens v;
        close_element l "select" (fun () -> reset_mode () ()))

      | l, `End {name =
          "caption" | "table" | "tbody" | "tfoot" | "thead" | "tr" | "td" |
          "th" as name} as v ->
        report l (`Unmatched_end_tag "name") !throw (fun () ->
        if not @@ Stack.in_table_scope open_elements name then
          in_select_in_table_mode ()
        else begin
          push tokens v;
          close_element l "select" (fun () -> reset_mode () ())
        end)

      | v ->
        in_select_mode_rules in_select_in_table_mode v
    end

  (* 8.2.5.4.18. *)
  and in_template_mode () =
    dispatch tokens (fun v -> in_table_mode_rules in_template_mode v)

  (* 8.2.5.4.18. *)
  and in_template_mode_rules mode = function
    | _, (`Char _ | `Comment _ | `Doctype _) as v ->
      in_body_mode_rules "template" mode v

    | _, `Start {name =
        "base" | "basefont" | "bgsound" | "link" | "meta" | "noframes" |
        "script" | "style" | "template" | "title"}
    | _, `End {name = "template"} as v ->
      in_head_mode_rules mode v

    | _, `Start {name =
        "caption" | "colgroup" | "tbody" | "tfoot" | "thead"} as v ->
      Template.pop template_insertion_modes;
      Template.push template_insertion_modes in_table_mode;
      push tokens v;
      in_table_mode ()

    | _, `Start {name = "col"} as v ->
      Template.pop template_insertion_modes;
      Template.push template_insertion_modes in_column_group_mode;
      push tokens v;
      in_column_group_mode ()

    | _, `Start {name = "tr"} as v ->
      Template.pop template_insertion_modes;
      Template.push template_insertion_modes in_table_body_mode;
      push tokens v;
      in_table_body_mode ()

    | _, `Start {name = "td" | "th"} as v ->
      Template.pop template_insertion_modes;
      Template.push template_insertion_modes in_row_mode;
      push tokens v;
      in_row_mode ()

    | _, `Start _ as v ->
      Template.pop template_insertion_modes;
      Template.push template_insertion_modes in_body_mode;
      push tokens v;
      in_body_mode ()

    | l, `End {name} ->
      report l (`Unmatched_end_tag name) !throw mode

    | l, `EOF as v ->
      if not @@ Stack.has open_elements "template" then emit_end l
      else begin
        report l (`Unmatched_end_tag "template") !throw (fun () ->
        Active.clear_until_marker active_formatting_elements;
        Template.pop template_insertion_modes;
        push tokens v;
        close_element l "template" (fun () -> reset_mode () ()))
      end

  (* 8.2.5.4.19. *)
  and after_body_mode () =
    dispatch tokens begin function
      | _, `Char (0x0009 | 0x000A | 0x000C | 0x000D | 0x0020) as v ->
        in_body_mode_rules "html" after_body_mode v

      | l, `Comment s ->
        emit l (`Comment s) after_body_mode

      | l, `Doctype _ ->
        report l (`Bad_document "doctype should be first") !throw
          after_body_mode

      | _, `Start {name = "html"} as v ->
        in_body_mode_rules "html" after_body_mode v

      | l, `End {name = "html"} ->
        close_element l "html" after_after_body_mode

      | l, `EOF ->
        emit_end l

      | l, _ as v ->
        report l (`Bad_document "content after body") !throw (fun () ->
        push tokens v;
        in_body_mode ())
    end

  (* 8.2.5.4.20. *)
  and in_frameset_mode () =
    dispatch tokens begin function
      | l, `Char (0x0009 | 0x000A | 0x000C | 0x000D | 0x0020 as c) ->
        add_character l c;
        in_frameset_mode ()

      | l, `Comment s ->
        emit l (`Comment s) in_frameset_mode

      | l, `Doctype _ ->
        report l (`Bad_document "doctype should be first") !throw
          in_frameset_mode

      | _, `Start {name = "html"} as v ->
        in_body_mode_rules "frameset" in_frameset_mode v

      | l, `Start ({name = "frameset"} as t) ->
        push_and_emit l t in_frameset_mode

      | l, `End {name = "frameset"} ->
        (fun mode' ->
          if Stack.current_element_is open_elements ["html"] then
            report l (`Unmatched_end_tag "frameset") !throw mode'
          else
            pop l mode')
        (fun () ->
          if Stack.current_element_is open_elements ["frameset"] then
            in_frameset_mode ()
          else after_frameset_mode ())

      | l, `Start ({name = "frame"} as t) ->
        push_and_emit ~acknowledge:true l t (fun () ->
        pop l in_frameset_mode)

      | _, `Start {name = "noframes"} as v ->
        in_head_mode_rules in_frameset_mode v

      | l, `EOF ->
        (fun mode' ->
          if not @@ Stack.current_element_is open_elements ["html"] then
            report l (`Unexpected_eoi "frameset") !throw mode'
          else mode' ())
        (fun () -> emit_end l)

      | l, _ ->
        report l (`Bad_content "frameset") !throw in_frameset_mode
    end

  (* 8.2.5.4.21. *)
  and after_frameset_mode () =
    dispatch tokens begin function
      | l, `Char (0x0009 | 0x000A | 0x000C | 0x000D | 0x0020 as c) ->
        add_character l c;
        after_frameset_mode ()

      | l, `Comment s ->
        emit l (`Comment s) after_frameset_mode

      | l, `Doctype _ ->
        report l (`Bad_document "doctype should be first") !throw
          after_frameset_mode

      | _, `Start {name = "html"} as v ->
        in_body_mode_rules "html" after_frameset_mode v

      | l, `End {name = "html"} ->
        close_element l "html" after_after_frameset_mode

      | _, `Start {name = "noframes"} as v ->
        in_head_mode_rules after_frameset_mode v

      | l, `EOF ->
        emit_end l

      | l, _ ->
        report l (`Bad_content "html") !throw after_frameset_mode
    end

  (* 8.2.5.4.22. *)
  and after_after_body_mode () =
    dispatch tokens begin function
      | l, `Comment s ->
        emit l (`Comment s) after_after_body_mode

      | _, `Doctype _
      | _, `Char (0x0009 | 0x000A | 0x000C | 0x000D | 0x0020)
      | _, `Start {name = "html"} as v ->
        in_body_mode_rules "html" after_after_body_mode v

      | l, `EOF ->
        emit_end l

      | l, _ ->
        report l (`Bad_content "html") !throw after_after_body_mode
    end

  (* 8.2.5.4.23. *)
  and after_after_frameset_mode () =
    dispatch tokens begin function
      | l, `Comment s ->
        emit l (`Comment s) after_after_frameset_mode

      | _, `Doctype _
      | _, `Char (0x0009 | 0x000A | 0x000C | 0x000D | 0x0020)
      | _, `Start {name = "html"} as v ->
        in_body_mode_rules "html" after_after_frameset_mode v

      | l, `EOF ->
        emit_end l

      | _, `Start {name = "noframes"} as v ->
        in_head_mode_rules after_after_frameset_mode v

      | l, _ ->
        report l (`Bad_content "html") !throw after_after_frameset_mode
    end

  (* 8.2.5.5. *)
  and foreign_start_tag mode l tag =
    let namespace =
      match Stack.adjusted_current_element context open_elements with
      | None -> `HTML
      | Some {element_name = ns, _} -> ns
    in

    push_and_emit ~acknowledge:true ~namespace l tag (fun () ->
    if tag.self_closing then pop l mode
    else mode ())

  and is_html_font_tag tag =
    tag.Token_tag.attributes |> List.exists (function
      | ("color" | "face" | "size"), _ -> true
      | _ -> false)

  and foreign_content mode force_html v =
    match v with
    | l, `Char 0 ->
      report l (`Bad_token ("U+0000", "foreign content", "null")) !throw
        (fun () ->
      add_character l u_rep;
      mode ())

    | l, `Char (0x0009 | 0x000A | 0x000C | 0x000D | 0x0020 as c) ->
      add_character l c;
      mode ()

    | l, `Char c ->
      frameset_ok := false;
      add_character l c;
      mode ()

    | l, `Comment s ->
      emit l (`Comment s) mode

    | l, `Doctype _ ->
      report l (`Bad_document "doctype should be first") !throw mode

    | l, `Start ({name =
        "b" | "big" | "blockquote" | "body" | "br" | "center" | "code" |
        "dd" | "div" | "dl" | "dt" | "em" | "embed" | "font" | "h1" | "h2" |
        "h3" | "h4" | "h5" | "h6" | "head" | "hr" | "i" | "img" | "li" |
        "listing" | "main" | "meta" | "nobr" | "ol" | "p" | "pre" | "ruby" |
        "s" | "small" | "span" | "strong" | "strike" | "sub" | "sup" |
        "table" | "tt" | "u" | "ul" | "var" as name} as t) as v ->
      if name = "font" && not @@ is_html_font_tag t then
        foreign_start_tag mode l t
      else
        report l (`Misnested_tag (name, "xml tag")) !throw (fun () ->
        push tokens v;
        pop l (fun () ->
        pop_until (function
          | {element_name = `HTML, _} -> true
          | {is_html_integration_point = true} -> true
          | {element_name} ->
            Foreign.is_mathml_text_integration_point element_name)
          l mode))

    | l, `Start t ->
      foreign_start_tag mode l t

    | l, `End {name = "script"}
        when
          match Stack.current_element open_elements with
          | Some {element_name = `SVG, "script"} -> true
          | _ -> false ->
      pop l mode

    | l, `End {name} ->
      (fun mode' ->
        match Stack.current_element open_elements with
        | Some {element_name = _, name'} when String.lowercase name' = name ->
          mode' ()
        | _ ->
          report l (`Unmatched_end_tag name) !throw (fun () ->
          mode' ()))
      (fun () ->
        let rec scan = function
          | [] -> mode ()
          | {element_name = ns, name'}::_
              when String.lowercase name' = name ->
            close_element ~ns l name mode
          | {element_name = `HTML, _}::_ -> force_html ()
          | _::rest -> scan rest
        in
        scan !open_elements)

    | _, `EOF -> force_html ()

  in

  construct constructor

end
module Markup_html_writer : sig 
#1 "markup_html_writer.mli"
(* This file is part of Markup.ml, released under the BSD 2-clause license. See
   doc/LICENSE for details, or visit https://github.com/aantron/markup.ml. *)

open Markup_common

val write : [< signal ] Markup_kstream.t -> string Markup_kstream.t

end = struct
#1 "markup_html_writer.ml"
(* This file is part of Markup.ml, released under the BSD 2-clause license. See
   doc/LICENSE for details, or visit https://github.com/aantron/markup.ml. *)

open Markup_common
module Kstream = Markup_kstream

let escape_attribute s =
  let buffer = Buffer.create (String.length s) in
  Uutf.String.fold_utf_8 (fun () _ -> function
    | `Malformed _ -> ()
    | `Uchar c ->
      let c = Uchar.to_int c in
      match c with
      | 0x0026 -> Buffer.add_string buffer "&amp;"
      | 0x00A0 -> Buffer.add_string buffer "&nbsp;"
      | 0x0022 -> Buffer.add_string buffer "&quot;"
      | _ -> add_utf_8 buffer c)
    () s;
  Buffer.contents buffer

let escape_text s =
  let buffer = Buffer.create (String.length s) in
  Uutf.String.fold_utf_8 (fun () _ -> function
    | `Malformed _ -> ()
    | `Uchar c ->
      let c = Uchar.to_int c in
      match c with
      | 0x0026 -> Buffer.add_string buffer "&amp;"
      | 0x00A0 -> Buffer.add_string buffer "&nbsp;"
      | 0x003C -> Buffer.add_string buffer "&lt;"
      | 0x003E -> Buffer.add_string buffer "&gt;"
      | _ -> add_utf_8 buffer c)
    () s;
  Buffer.contents buffer

let void_elements =
  ["area"; "base"; "basefont"; "bgsound"; "br"; "col"; "embed"; "frame"; "hr";
   "img"; "input"; "keygen"; "link"; "meta"; "param"; "source"; "track"; "wbr"]

let prepend_newline_for = ["pre"; "textarea"; "listing"]

let rec starts_with_newline = function
  | [] -> false
  | s::more ->
    if String.length s = 0 then starts_with_newline more
    else s.[0] = '\x0A'

open Kstream

let literal_text_elements =
  ["style"; "script"; "xmp"; "iframe"; "noembed"; "noframes"; "plaintext"]

let write signals =
  let open_elements = ref [] in

  let in_literal_text_element () =
    match !open_elements with
      | element :: _ -> List.mem element literal_text_elements
      | _ -> false in

  let rec queue = ref next_signal

  and emit_list l throw e k =
    match l with
    | [] -> next_signal throw e k
    | s::more ->
      queue := emit_list more;
      k s

  and next_signal throw e k =
    next signals throw e begin function
      | `Start_element ((ns, name') as name, attributes) ->
        let tag_name =
          match name with
          | ns, local_name
              when list_mem_string ns [html_ns; svg_ns; mathml_ns] ->
            local_name
          | ns, local_name when ns = xml_ns -> "xml:" ^ local_name
          | ns, local_name when ns = xmlns_ns -> "xmlns:" ^ local_name
          | ns, local_name when ns = xlink_ns -> "xlink:" ^ local_name
          | _, local_name -> (* An error. *) local_name
        in

        let attributes =
          attributes |> List.map (fun ((ns, local_name) as name, value) ->
            let name =
              match name with
              | "", _ -> local_name
              | _ when ns = xml_ns -> "xml:" ^ local_name
              | _, "xmlns" when ns = xmlns_ns -> "xmlns"
              | _ when ns = xmlns_ns -> "xmlns:" ^ local_name
              | _ when ns = xlink_ns -> "xlink:" ^ local_name
              | _ -> (* An error. *) local_name
            in
            name, value)
        in

        let rec prepend_attributes words = function
          | [] -> words
          | (name, value)::more ->
            prepend_attributes
              (" "::name::"=\""::(escape_attribute value)::"\""::words) more
        in

        let tag =
          "<"::tag_name::(prepend_attributes [">"] (List.rev attributes)) in

        let is_void = ns = html_ns && list_mem_string name' void_elements in

        if is_void then
          peek signals throw (fun () -> emit_list tag throw e k) (function
            | `End_element ->
              next_option signals throw (fun _ ->
              emit_list tag throw e k)
            | `Start_element _ | `Text _ | `Comment _ | `PI _ | `Xml _
            | `Doctype _ ->
              open_elements := tag_name::!open_elements;
              emit_list tag throw e k)
        else begin
          open_elements := tag_name::!open_elements;

          if ns = html_ns && list_mem_string name' prepend_newline_for then
            peek_option signals throw (function
              | Some (`Text ss) when starts_with_newline ss ->
                emit_list (tag @ ["\n"]) throw e k
              | Some (`Text _ | `Start_element _ | `End_element | `Comment _ |
                      `PI _ | `Doctype _ | `Xml _)
              | None -> emit_list tag throw e k)
          else
            emit_list tag throw e k
        end

      | `End_element ->
        begin match !open_elements with
        | [] -> next_signal throw e k
        | name::rest ->
          open_elements := rest;
          emit_list ["</"; name; ">"] throw e k
        end

      | `Text ss ->
        if List.for_all (fun s -> String.length s = 0) ss then
          next_signal throw e k
        else if in_literal_text_element () then
          emit_list ss throw e k
        else
          emit_list (List.map escape_text ss) throw e k

      | `Comment s ->
        emit_list ["<!--"; s; "-->"] throw e k

      | `PI (target, s) ->
        emit_list ["<?"; target; " "; s; ">"] throw e k

      | `Doctype {doctype_name = Some name} ->
        emit_list ["<!DOCTYPE "; name; ">"] throw e k

      | `Doctype _ | `Xml _ ->
        next_signal throw e k
    end

  in

  (fun throw e k -> !queue throw e k) |> make

end
module Markup_utility
= struct
#1 "markup_utility.ml"
(* This file is part of Markup.ml, released under the BSD 2-clause license. See
   doc/LICENSE for details, or visit https://github.com/aantron/markup.ml. *)

open Markup_common
open Markup_kstream
module Entities = Markup_entities

let content s =
  let filter signal _ k =
    match signal with
    | `Start_element _ | `End_element | `Text _ as signal -> k (Some signal)
    | `Comment _ | `PI _ | `Doctype _ | `Xml _ -> k None
  in
  filter_map filter s

let strings_to_bytes strings =
  let current_string = ref "" in
  let index = ref 0 in

  let rec emit throw e k =
    if !index < String.length !current_string then begin
      index := !index + 1;
      k (!current_string.[!index - 1])
    end
    else
      next strings throw e (fun s ->
        current_string := s;
        index := 0;
        emit throw e k)
  in
  make emit

let unwrap_lists ls =
  let current_list = ref [] in

  let rec emit throw e k =
    match !current_list with
    | v::l -> current_list := l; k v
    | [] -> next ls throw e (fun l -> current_list := l; emit throw e k)
  in
  make emit

let trees ?text ?element ?comment ?pi ?xml ?doctype s =
  let rec match_node throw k none =
    next s throw none begin function
      | `Start_element (name, attributes) ->
        match_content [] throw (fun children ->
        match element with
        | None -> match_node throw k none
        | Some element -> k (element name attributes children))

      | `End_element -> none ()

      | `Text ss ->
        begin match text with
        | None -> match_node throw k none
        | Some text -> k (text ss)
        end

      | `Doctype d ->
        begin match doctype with
        | None -> match_node throw k none
        | Some doctype -> k (doctype d)
        end

      | `Xml x ->
        begin match xml with
        | None -> match_node throw k none
        | Some xml -> k (xml x)
        end

      | `PI (t, s) ->
        begin match pi with
        | None -> match_node throw k none
        | Some pi -> k (pi t s)
        end

      | `Comment s ->
        begin match comment with
        | None -> match_node throw k none
        | Some comment -> k (comment s)
        end
    end

  and match_content acc throw k =
    match_node throw
      (fun n -> match_content (n::acc) throw k)
      (fun () -> k (List.rev acc))

  in

  (fun throw e k -> match_node throw k e) |> make

let tree ?text ?element ?comment ?pi ?xml ?doctype s throw k =
  let s' = trees ?text ?element ?comment ?pi ?xml ?doctype s in
  next s' throw (fun () -> k None) (fun t -> k (Some t))

type 'a node =
  [ `Element of name * (name * string) list * 'a list
  | `Text of string
  | `Doctype of doctype
  | `Xml of xml_declaration
  | `PI of string * string
  | `Comment of string ]

let from_tree f node =
  let rec traverse acc node =
    match f node with
    | `Element (name, attributes, children) ->
      children
      |> List.fold_left traverse ((`Start_element (name, attributes))::acc)
      |> fun acc -> `End_element::acc

    | `Text s -> (`Text [s])::acc

    | `Doctype _ | `Xml _ | `PI _ | `Comment _ as node ->
      node::acc
  in

  traverse [] node |> List.rev |> of_list

let elements select s =
  let depth = ref 0 in
  let started = ref 0 in
  let finished = ref 0 in

  let rec scan throw e k =
    next s throw e begin fun signal ->
      match signal with
      | `Start_element (name, attributes)
          when !started = !finished && select name attributes ->

        let index = !started + 1 in
        started := index;
        depth := 0;

        let constructor _ k =
          push s signal;
          (fun throw e k ->
            if !finished >= index then e ()
            else
              next s throw e begin fun signal ->
                match signal with
                | `Start_element _ ->
                  depth := !depth + 1;
                  k signal

                | `End_element ->
                  depth := !depth - 1;
                  if !depth = 0 then
                    finished := index;
                  k signal

                | `Text _ | `Comment _ | `PI _ | `Doctype _ | `Xml _ -> k signal
              end)
          |> make
          |> k
        in

        construct constructor |> k

      | `Start_element _ when !started > !finished ->
        depth := !depth + 1;
        scan throw e k

      | `End_element when !started > !finished ->
        depth := !depth - 1;
        if !depth = 0 then
          finished := !started;
        scan throw e k

      | `Text _ | `Start_element _ | `End_element | `Comment _ | `PI _
      | `Doctype _ | `Xml _ ->
        scan throw e k
    end
  in

  make scan

let text s =
  let filter v _ k =
    match v with
    | `Text ss -> k (Some ss)
    | `Start_element _ | `End_element | `Comment _ | `PI _ | `Doctype _
    | `Xml _ -> k None
  in
  filter_map filter s
  |> unwrap_lists
  |> strings_to_bytes

let trim s =
  let rec trim_string_list trim = function
    | [] -> []
    | s::more ->
      match trim s with
      | "" -> trim_string_list trim more
      | s -> s::more
  in

  s |> filter_map (fun v _ k ->
    match v with
    | `Text ss ->
      ss
      |> trim_string_list trim_string_left
      |> List.rev
      |> trim_string_list trim_string_right
      |> List.rev
      |> (function
        | [] -> k None
        | ss -> k (Some (`Text ss)))
    | _ -> k (Some v))

let normalize_text s =
  let rec match_text acc throw e k =
    next_option s throw begin function
      | Some (`Text ss) ->
        match_text (ss::acc) throw e k

      | v ->
        push_option s v;
        let ss =
          List.rev acc
          |> List.flatten
          |> List.filter (fun s -> String.length s > 0)
        in
        match ss with
        | [] -> match_other throw e k
        | _ -> k (`Text ss)
    end

  and match_other throw e k =
    next s throw e (function
      | `Text ss -> match_text [ss] throw e k
      | signal -> k signal)

  in

  make match_other

let tab_width = 2

let pretty_print s =
  let s = s |> normalize_text |> trim in

  let indent n =
    let n = if n < 0 then 0 else n in
    String.make (n * tab_width) ' '
  in

  let rec current_state = ref (fun throw e k -> row 0 throw e k)

  and row depth throw e k =
    next s throw e begin fun v ->
      match v with
      | `Start_element _ ->
        list [`Text [indent depth]; v; `Text ["\n"]]
          (row (depth + 1)) throw e k

      | `End_element ->
        list [`Text [indent (depth - 1)]; v; `Text ["\n"]]
          (row (depth - 1)) throw e k

      | _ ->
        list [`Text [indent depth]; v; `Text ["\n"]]
          (row depth) throw e k
    end

  and list signals state throw e k =
    match signals with
    | [] -> state throw e k
    | signal::more ->
      current_state := list more state;
      k signal

  in

  (fun throw e k -> !current_state throw e k)
  |> make
  |> normalize_text

let html5 s =
  let remove_markup v _ k =
    match v with
    | `Doctype _ | `Xml _ | `PI _ as v -> k (Some v)
    | `Text _ | `Start_element _ | `End_element | `Comment _ -> k None
  in

  s
  |> filter_map remove_markup
  |> fun s ->
    push s (`Doctype
      {doctype_name      = Some "html";
       public_identifier = None;
       system_identifier = None;
       raw_text          = None;
       force_quirks      = false});
    s

let xhtml ?dtd s =
  let doctype_text =
    match dtd with
    | Some `Strict_1_0 ->
      "html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" " ^
      "\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\""

    | Some `Transitional_1_0 ->
      "html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" " ^
      "\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\""

    | Some `Frameset_1_0 ->
      "html PUBLIC \"-//W3C//DTD XHTML 1.0 Frameset//EN\" " ^
      "\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd\""

    | Some `Strict_1_1 | None ->
      "html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" " ^
      "\"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\""
  in

  let remove_markup v _ k =
    match v with
    | `Doctype _ | `Xml _ as v -> k (Some v)
    | `Text _ | `Start_element _ | `End_element | `Comment _ | `PI _ -> k None
  in

  s
  |> filter_map remove_markup
  |> fun s ->
    push s (`Doctype
      {doctype_name      = None;
       public_identifier = None;
       system_identifier = None;
       raw_text          = Some doctype_text;
       force_quirks      = false});
    push s (`Xml {version = "1.0"; encoding = Some "utf-8"; standalone = None});
    s

let xhtml_entity name =
  let rec lookup index =
    if index >= Array.length Entities.entities then raise Exit
    else
      if fst Entities.entities.(index) <> name then lookup (index + 1)
      else snd Entities.entities.(index)
  in

  try
    let buffer = Buffer.create 8 in

    match lookup 0 with
    | `One c ->
      add_utf_8 buffer c;
      Some (Buffer.contents buffer)
    | `Two (c, c') ->
      add_utf_8 buffer c;
      add_utf_8 buffer c';
      Some (Buffer.contents buffer)

  with Exit -> None

end
module Markup_xml_writer : sig 
#1 "markup_xml_writer.mli"
(* This file is part of Markup.ml, released under the BSD 2-clause license. See
   doc/LICENSE for details, or visit https://github.com/aantron/markup.ml. *)

open Markup_common

val write :
  Markup_error.write_handler ->
  (string -> string option) ->
  [< signal ] Markup_kstream.t ->
    string Markup_kstream.t

end = struct
#1 "markup_xml_writer.ml"
(* This file is part of Markup.ml, released under the BSD 2-clause license. See
   doc/LICENSE for details, or visit https://github.com/aantron/markup.ml. *)

module Common = Markup_common
module Kstream = Markup_kstream
module Namespace = Markup_namespace

let escape s =
  let buffer = Buffer.create (String.length s) in
  String.iter (function
    | '"' -> Buffer.add_string buffer "&quot;"
    | '&' -> Buffer.add_string buffer "&amp;"
    | '\'' -> Buffer.add_string buffer "&apos;"
    | '<' -> Buffer.add_string buffer "&lt;"
    | '>' -> Buffer.add_string buffer "&gt;"
    | c -> Buffer.add_char buffer c)
    s;
  Buffer.contents buffer

let attribute_strings end_ attributes =
  let rec prepend_attributes words = function
    | [] -> words
    | (name, value)::more ->
      prepend_attributes
        (" "::name::"=\""::(escape value)::"\""::words) more
  in

  prepend_attributes [end_] (List.rev attributes)

open Common
open Kstream

let write report prefix signals =
  let signals = enumerate signals in

  let open_elements = ref [] in
  let namespaces = Namespace.Writing.init prefix in

  let rec queue = ref next_signal

  and emit_list l throw e k =
    match l with
    | [] -> next_signal throw e k
    | s::more ->
      queue := emit_list more;
      k s

  and next_signal throw e k =
    next signals throw e begin function
      | i, (`Start_element (name, attributes) as signal) ->
        (fun k' ->
          next signals throw (fun () -> k' false) (fun s ->
            match s with
            | _, `End_element -> k' true
            | _, (`Text _ | `Start_element _ | `Comment _ | `PI _ | `Doctype _ |
                  `Xml _) -> push signals s; k' false))
        (fun self_closing ->
          Namespace.Writing.push (fun () -> report (signal, i))
            namespaces name attributes
            throw (fun (formatted_name, formatted_attributes) ->

          open_elements := formatted_name::!open_elements;

          if self_closing then begin
            Namespace.Writing.pop namespaces;
            open_elements :=
              match !open_elements with
              | [] -> []
              | _::rest -> rest
          end;

          let end_ = if self_closing then "/>" else ">" in

          let tag =
            "<"::formatted_name::(attribute_strings end_ formatted_attributes)
          in

          emit_list tag throw e k))

      | _, `End_element ->
        Namespace.Writing.pop namespaces;
        begin match !open_elements with
        | [] -> next_signal throw e k
        | name::rest ->
          open_elements := rest;
          emit_list ["</"; name; ">"] throw e k
        end

      | _, `Text ss ->
        if List.for_all (fun s -> String.length s = 0) ss then
          next_signal throw e k
        else
          emit_list (List.map escape ss) throw e k

      | _, `Xml {version; encoding; standalone} ->
        let attributes =
          match standalone with
          | None -> []
          | Some true -> ["standalone", "yes"]
          | Some false -> ["standalone", "no"]
        in

        let attributes =
          match encoding with
          | None -> attributes
          | Some encoding -> ("encoding", encoding)::attributes
        in

        let attributes = ("version", version)::attributes in

        let declaration = "<?xml"::(attribute_strings "?>" attributes) in

        emit_list declaration throw e k

      | _, `Doctype {raw_text} ->
        begin match raw_text with
        | None -> next_signal throw e k
        | Some text -> emit_list ["<!DOCTYPE "; text; ">"] throw e k
        end

      | _, `PI (target, s) ->
        emit_list ["<?"; target; " "; s; "?>"] throw e k

      | _, `Comment s ->
        emit_list ["<!--"; s; "-->"] throw e k
    end

  in

  (fun throw e k -> !queue throw e k) |> make

end
module Markup : sig 
#1 "markup.mli"
(* This file is part of Markup.ml, released under the BSD 2-clause license. See
   doc/LICENSE for details, or visit https://github.com/aantron/markup.ml. *)

(** Error-recovering streaming HTML and XML parsers and writers.

    Markup.ml is an HTML and XML parsing and serialization library. It:

    - Is error-recovering, so you can get a best-effort parse of malformed
      input.
    - Reports all errors before recovery, so you can get strict parsing
      instead.
    - Conforms closely to the XML grammar and HTML parser from the respective
      specifications.
    - Accepts document fragments, but can be told to accept only full documents.
    - Detects character encodings automatically.
    - Supports both simple synchronous (this module) and non-blocking usage
      ({!Markup_lwt}).
    - Is streaming and lazy. Partial input is processed as soon as received, but
      only as needed.
    - Does one pass over the input and emits a stream of SAX-style parsing
      signals. A helper ({!tree}) allows that to be easily converted into
      DOM-style trees.

    The usage is straightforward. For example:

{[
open Markup

(* Correct and pretty-print HTML. *)
channel stdin
|> parse_html |> signals |> pretty_print
|> write_html |> to_channel stdout

(* Show up to 10 XML well-formedness errors to the user. Stop after
   the 10th, without reading more input. *)
let report =
  let count = ref 0 in
  fun location error ->
    error |> Error.to_string ~location |> prerr_endline;
    count := !count + 1;
    if !count >= 10 then raise_notrace Exit

string "some xml" |> parse_xml ~report |> signals |> drain

(* Load HTML into a custom document tree data type. *)
type html = Text of string | Element of string * html list

file "some_file"
|> fst
|> parse_html
|> signals
|> tree
  ~text:(fun ss -> Text (String.concat "" ss))
  ~element:(fun (_, name) _ children -> Element (name, children))
]}

    The interface is centered around four functions. In pseudocode:

{[
val parse_html : char stream   -> signal stream
val write_html : signal stream -> char stream
val parse_xml  : char stream   -> signal stream
val write_xml  : signal stream -> char stream
]}

    Most of the remaining functions create streams from, or write streams to,
    strings, files, and channels, or manipulate streams, such as {!next} and the
    combinators {!map} and {!fold}.

    Apart from this module, Markup.ml provides two other top-level modules:

    {!modules:Markup_lwt Markup_lwt_unix}

    Most of the interface of {!Markup_lwt} is specified in signature
    {!ASYNCHRONOUS}, which will be shared with a [Markup_async] module, should
    it be implemented.

    Markup.ml is developed on {{:https://github.com/aantron/markup.ml} GitHub}
    and distributed under the
    {{:https://github.com/aantron/markup.ml/blob/master/LICENSE.md} BSD
    license}. This documentation is for version 0.7.5 of the library.
    Documentation for older versions can be found on the
    {{: https://github.com/aantron/markup.ml/releases} releases page}. *)



(** {2 Streams} *)

type async
type sync
(** Phantom types for use with [('a, 's) stream] in place of ['s]. See
    explanation below. *)

type ('a, 's) stream
(** Streams of elements of type ['a].

    In simple usage, when using only this module [Markup], the additional type
    parameter ['s] is always [sync], and there is no need to consider it
    further.

    However, if you are using {!Markup_lwt}, you may create some [async]
    streams. The difference between the two is that {!next} on a [sync] stream
    retrieves an element before {!next} "returns," while {!next} on an [async]
    stream might not retrieve an element until later. As a result, it is not
    safe to pass an [async] stream where a [sync] stream is required. The
    phantom types are used to make the type checker catch such errors at compile
    time. *)



(** {2 Errors}

    The parsers recover from errors automatically. If that is sufficient, you
    can ignore this section. However, if you want stricter behavior, or need to
    debug parser output, use optional argument [?report] of the parsers, and
    look in module {!Error}. *)

type location = int * int
(** Line and column for parsing errors. Both numbers are one-based. *)

(** Error type and [to_string] function. *)
module Error :
sig
  type t =
    [ `Decoding_error of string * string
    | `Bad_token of string * string * string
    | `Unexpected_eoi of string
    | `Bad_document of string
    | `Unmatched_start_tag of string
    | `Unmatched_end_tag of string
    | `Bad_namespace of string
    | `Misnested_tag of string * string
    | `Bad_content of string ]
  (** Errors reported by the parsers. A few of these are also used by the
      writers.

      - [`Decoding_error (bytes, encoding)] is reported by the decoders in
        module {! Encoding}. For example, if the UTF-8 decoder encounters a bare
        [0xA0] byte, it will report [`Decoding_error ("\xA0", "utf-8")].

      - [`Bad_token (token, where, s)] is reported when there is a "local"
        problem with the syntax of the input stream, such as an invalid
        character or a duplicate attribute. For example, if the XML parser
        detects a [&] that is not part of an entity reference while reading an
        attribute, it will report
        [`Bad_token ("&", "attribute", "replace with '&amp;'")]

      - [`Unexpected_eoi where] is reported by the parsers when the input ends
        before an item, such as a tag, element, or comment, is closed. [where]
        describes the kind of item that wasn't closed.

      - [`Bad_document s] is reported by the parsers when there is a problem
        with the top-level structure of the document. For example, if you are
        parsing an input stream as XML with [~context:`Document], and the parser
        finds an element after the root element, it will report
        [`Bad_document "not allowed after root element"].

      - [`Unmatched_start_tag name] and [`Unmatched_end_tag name] are reported
        when tags aren't properly balanced. Note that not all unbalanced tags
        are parse errors in HTML.

      - [`Bad_namespace s] is reported by parsers when the prefix [s] can't be
        resolved to a namespace, and by the writers when the namespace [s] can't
        be resolved to a prefix (or the default namespace).

      - [`Misnested_tag (what, where)] is reported by the HTML parser when a tag
        appears where it is not allowed. For example, if the input has a
        [<body>] tag inside a [<p>] tag, the parser will report
        [`Misnested_tag ("body", "p")].

      - [`Bad_content where] is reported by the HTML parser if an element has
        content it is not allowed to have. For example, if there is stray text
        at the top level of a [<table>] element, the parser will report
        [`Bad_content "table"].
   *)

  val to_string : ?location:location -> t -> string
  (** Converts an error to human-readable form. If [~location] is specified,
      location information is prepended to the output. *)
end



(** {2 Encodings}

    The parsers detect encodings automatically. If you need to specify an
    encoding, use optional argument [?encoding] of the parsers, and look in
    module {!Encoding}. *)

(** Common Internet encodings such as UTF-8 and UTF-16; also includes some less
    popular encodings that are sometimes necessary for parsing XML encoding
    declarations. *)
module Encoding :
sig
  type t
  (** Decoders. These are notionally maps from byte streams to Unicode scalar
      value streams, i.e. pseudocode type [char stream -> int stream]. *)

  val decode :
    ?report:(location -> Error.t -> unit) -> t ->
    (char, 's) stream -> (int, 's) stream
  (** Applies a decoder to a byte stream. Illegal input byte sequences result in
      calls to the error handler [~report] with error kind [`Decoding_error].
      The illegal bytes are then skipped, and zero or more U+FFFD replacement
      characters are emitted. The default handler ignores errors.

      The locations provided to the error handler by the built-in decoders below
      in this module are fully accurate only if the input byte stream uses LF
      characters as line breaks. *)

  val utf_8 : t
  val utf_16be : t
  val utf_16le : t
  val utf_16 : t
  val iso_8859_1 : t
  val us_ascii : t
  val windows_1251 : t
  val windows_1252 : t
  val ucs_4be : t
  val ucs_4le : t
  val ucs_4be_transposed : t
  val ucs_4le_transposed : t
  val ebcdic : t
  (** Code page 37. *)
end



(** {2 Signals} *)

type name = string * string
(** Expanded name: a namespace URI followed by a local name. *)

type xml_declaration =
  {version    : string;
   encoding   : string option;
   standalone : bool option}
(** Representation of an XML declaration, i.e.
    [<?xml version="1.0" encoding="utf-8"?>]. *)

type doctype =
  {doctype_name      : string option;
   public_identifier : string option;
   system_identifier : string option;
   raw_text          : string option;
   force_quirks      : bool}
(** Representation of a document type declaration. The HTML parser fills in all
    fields besides [raw_text]. The XML parser reads declarations roughly, and
    fills only the [raw_text] field with the text found in the declaration. *)

type signal =
  [ `Start_element of name * (name * string) list
  | `End_element
  | `Text of string list
  | `Doctype of doctype
  | `Xml of xml_declaration
  | `PI of string * string
  | `Comment of string ]
(** Parsing signals. The parsers emit them according to the following grammar:

{[
doc     ::= `Xml? misc* `Doctype? misc* element misc*
misc    ::= `PI | `Comment
element ::= `Start_element content* `End_element
content ::= `Text | element | `PI | `Comment
]}

    As a result, emitted [`Start_element] and [`End_element] signals are always
    balanced, and, if there is an XML declaration, it is the first signal.

    If parsing with [~context:`Document], the signal sequence will match the
    [doc] production until the first error. If parsing with
    [~context:`Fragment], it will match [content*]. If [~context] is not
    specified, the parser will pick one of the two by examining the input.

    As an example, if the XML parser is parsing

{[
<?xml version="1.0"?><root>text<nested>more text</nested></root>
]}

    it will emit the signal sequence

{[
`Xml {version = "1.0"; encoding = None; standalone = None}
`Start_element (("", "root"), [])
`Text ["text"]
`Start_element (("", "nested"), [])
`Text ["more text"]
`End_element
`End_element
]}

    The [`Text] signal carries a [string list] instead of a single [string]
    because on 32-bit platforms, OCaml strings cannot be larger than 16MB. In
    case the parsers encounter a very long sequence of text, one whose length
    exceeds about [Sys.max_string_length / 2], they will emit a [`Text] signal
    with several strings. *)

type content_signal =
  [ `Start_element of name * (name * string) list
  | `End_element
  | `Text of string list ]
(** A restriction of type {!signal} to only elements and text, i.e. no comments,
    processing instructions, or declarations. This can be useful for pattern
    matching in applications that only care about the content and element
    structure of a document. See the helper {!content}. *)

val signal_to_string : [< signal ] -> string
(** Provides a human-readable representation of signals for debugging. *)



(** {2 Parsers} *)

type 's parser
(** An ['s parser] is a thin wrapper around a [(signal, 's) stream] that
    supports access to additional information that is not carried directly in
    the stream, such as source locations. *)

val signals : 's parser -> (signal, 's) stream
(** Converts a parser to its underlying signal stream. *)

val location : _ parser -> location
(** Evaluates to the location of the last signal emitted on the parser's signal
    stream. If no signals have yet been emitted, evaluates to [(1, 1)]. *)



(** {2 XML} *)

val parse_xml :
  ?report:(location -> Error.t -> unit) ->
  ?encoding:Encoding.t ->
  ?namespace:(string -> string option) ->
  ?entity:(string -> string option) ->
  ?context:[< `Document | `Fragment ] ->
  (char, 's) stream -> 's parser
(** Creates a parser that converts an XML byte stream to a signal stream.

    For simple usage, [string "foo" |> parse_xml |> signals].

    If [~report] is provided, [report] is called for every error encountered.
    You may raise an exception in [report], and it will propagate to the code
    reading the signal stream.

    If [~encoding] is {e not} specified, the parser detects the input encoding
    automatically. Otherwise, the given encoding is used.

    [~namespace] is called when the parser is unable to resolve a namespace
    prefix. If it evaluates to [Some s], the parser maps the prefix to [s].
    Otherwise, the parser reports [`Bad_namespace].

    [~entity] is called when the parser is unable to resolve an entity
    reference. If it evaluates to [Some s], the parser inserts [s] into the
    text or attribute being parsed without any further parsing of [s]. [s] is
    assumed to be encoded in UTF-8. If [entity] evaluates to [None] instead,
    the parser reports [`Bad_token]. See {!xhtml_entity} if you are parsing
    XHTML.

    The meaning of [~context] is described at {! signal}, above. *)

val write_xml :
  ?report:((signal * int) -> Error.t -> unit) ->
  ?prefix:(string -> string option) ->
  ([< signal ], 's) stream -> (char, 's) stream
(** Converts an XML signal stream to a byte stream.

    If [~report] is provided, it is called for every error encountered. The
    first argument is a pair of the signal causing the error and its index in
    the signal stream. You may raise an exception in [report], and it will
    propagate to the code reading the byte stream.

    [~prefix] is called when the writer is unable to find a prefix in scope
    for a namespace URI. If it evaluates to [Some s], the writer uses [s] for
    the URI. Otherwise, the writer reports [`Bad_namespace]. *)



(** {2 HTML} *)

val parse_html :
  ?report:(location -> Error.t -> unit) ->
  ?encoding:Encoding.t ->
  ?context:[< `Document | `Fragment of string ] ->
  (char, 's) stream -> 's parser
(** Similar to {!parse_xml}, but parses HTML with embedded SVG and MathML, never
    emits signals [`Xml] or [`PI], and [~context] has a different type on tag
    [`Fragment].

    For HTML fragments, you should specify the enclosing element, e.g.
    [`Fragment "body"]. This is because, when parsing HTML, error recovery and
    the interpretation of text depend on the current element. For example, the
    text

{[
foo</bar>
]}

    parses differently in [title] elements than in [p] elements. In the former,
    it is parsed as [foo</bar>], while in the latter, it is [foo] followed by a
    parse error due to unmatched tag [</bar>]. To get these behaviors, set
    [~context] to [`Fragment "title"] and [`Fragment "p"], respectively.

    If you use [`Fragment "svg"], the fragment is assumed to be SVG markup.
    Likewise, [`Fragment "math"] causes the parser to parse MathML markup.

    If [~context] is omitted, the parser guesses it from the input stream. For
    example, if the first signal would be [`Doctype], the context is set to
    [`Document], but if the first signal would be [`Start_element "td"], the
    context is set to [`Fragment "tr"]. If the first signal would be
    [`Start_element "g"], the context is set to [`Fragment "svg"].

 *)

val write_html : ([< signal ], 's) stream -> (char, 's) stream
(** Similar to {!write_xml}, but emits HTML5 instead of XML. *)



(** {2 Input sources} *)

val string : string -> (char, sync) stream
(** Evaluates to a stream that retrieves successive bytes from the given
    string. *)

val buffer : Buffer.t -> (char, sync) stream
(** Evaluates to a stream that retrieves successive bytes from the given buffer.
    Be careful of changing the buffer while it is being iterated by the
    stream. *)

val channel : Pervasives.in_channel -> (char, sync) stream
(** Evaluates to a stream that retrieves bytes from the given channel. If the
    channel cannot be read, the next read of the stream results in raising
    [Sys_error].

    Note that this input source is synchronous because [Pervasives.in_channel]
    reads are blocking. For non-blocking channels, see {!Markup_lwt_unix}. *)

val file : string -> (char, sync) stream * (unit -> unit)
(** [file path] opens the file at [path], then evaluates to a pair [s, close],
    where reading from stream [s] retrieves successive bytes from the file, and
    calling [close ()] closes the file.

    The file is closed automatically if [s] is read to completion, or if reading
    [s] raises an exception. It is not necessary to call [close ()] in these
    cases.

    If the file cannot be opened, raises [Sys_error] immediately. If the file
    cannot be read, reading the stream raises [Sys_error]. *)

val fn : (unit -> char option) -> (char, sync) stream
(** [fn f] is a stream that retrives bytes by calling [f ()]. If the call
    results in [Some c], the stream emits [c]. If the call results in [None],
    the stream is considered to have ended.

    This is actually an alias for {!stream}, restricted to type [char]. *)



(** {2 Output destinations} *)

val to_string : (char, sync) stream -> string
(** Eagerly retrieves bytes from the given stream and assembles a string. *)

val to_buffer : (char, sync) stream -> Buffer.t
(** Eagerly retrieves bytes from the given stream and places them into a
    buffer. *)

val to_channel : Pervasives.out_channel -> (char, sync) stream -> unit
(** Eagerly retrieves bytes from the given stream and writes them to the given
    channel. If writing fails, raises [Sys_error]. *)

val to_file : string -> (char, sync) stream -> unit
(** Eagerly retrieves bytes from the given stream and writes them to the given
    file. If writing fails, or the file cannot be opened, raises [Sys_error].
    Note that the file is truncated (cleared) before writing. If you wish to
    append to file, open it with the appropriate flags and use [to_channel] on
    the resulting channel. *)



(** {2 Stream operations} *)

val stream : (unit -> 'a option) -> ('a, sync) stream
(** [stream f] creates a stream that repeatedly calls [f ()]. Each time [f ()]
    evaluates to [Some v], the next item in the stream is [v]. The first time
    [f ()] evaluates to [None], the stream ends. *)

val next : ('a, sync) stream -> 'a option
(** Retrieves the next item in the stream, if any, and removes it from the
    stream. *)

val peek : ('a, sync) stream -> 'a option
(** Retrieves the next item in the stream, if any, but does not remove the item
    from the stream. *)

val transform :
  ('a -> 'b -> 'c list * 'a option) -> 'a -> ('b, 's) stream -> ('c, 's) stream
(** [transform f init s] lazily creates a stream by repeatedly applying
    [f acc v], where [acc] is an accumulator whose initial value is [init], and
    [v] is consecutive values of [s]. Each time, [f acc v] evaluates to a pair
    [(vs, maybe_acc')]. The values [vs] are added to the result stream. If
    [maybe_acc'] is [Some acc'], the accumulator is set to [acc']. Otherwise, if
    [maybe_acc'] is [None], the result stream ends. *)

val fold : ('a -> 'b -> 'a) -> 'a -> ('b, sync) stream -> 'a
(** [fold f init s] eagerly folds over the items [v], [v'], [v''], ... of [s],
    i.e. evaluates [f (f (f init v) v') v'']... *)

val map : ('a -> 'b) -> ('a, 's) stream -> ('b, 's) stream
(** [map f s] lazily applies [f] to each item of [s], and produces the resulting
    stream. *)

val filter : ('a -> bool) -> ('a, 's) stream -> ('a, 's) stream
(** [filter f s] is [s] without the items for which [f] evaluates to [false].
    [filter] is lazy. *)

val filter_map : ('a -> 'b option) -> ('a, 's) stream -> ('b, 's) stream
(** [filter_map f s] lazily applies [f] to each item [v] of [s]. If [f v]
    evaluates to [Some v'], the result stream has [v']. If [f v] evaluates to
    [None], no item corresponding to [v] appears in the result stream. *)

val iter : ('a -> unit) -> ('a, sync) stream -> unit
(** [iter f s] eagerly applies [f] to each item of [s], i.e. evaluates
    [f v; f v'; f v'']... *)

val drain : ('a, sync) stream -> unit
(** [drain s] eagerly consumes [s]. This is useful for observing side effects,
    such as parsing errors, when you don't care about the parsing signals
    themselves. It is equivalent to [iter ignore s]. *)

val of_list : 'a list -> ('a, sync) stream
(** Produces a (lazy) stream from the given list. *)

val to_list : ('a, sync) stream -> 'a list
(** Eagerly converts the given stream to a list. *)



(** {2 Utility} *)

val content : ([< signal ], 's) stream -> (content_signal, 's) stream
(** Converts a {!signal} stream into a {!content_signal} stream by filtering out
    all signals besides [`Start_element], [`End_element], and [`Text]. *)

val tree :
  ?text:(string list -> 'a) ->
  ?element:(name -> (name * string) list -> 'a list -> 'a) ->
  ?comment:(string -> 'a) ->
  ?pi:(string -> string -> 'a) ->
  ?xml:(xml_declaration -> 'a) ->
  ?doctype:(doctype -> 'a) ->
  ([< signal ], sync) stream -> 'a option
(** This function's type signature may look intimidating, but it is actually
    easy to use. It is best introduced by example:

{[
type my_dom = Text of string | Element of name * my_dom list

"<p>HTML5 is <em>easy</em> to parse"
|> string
|> parse_html
|> signals
|> tree
  ~text:(fun ss -> Text (String.concat "" ss))
  ~element:(fun (name, _) children -> Element (name, children))
]}

    results in the structure

{[
Element ("p" [
  Text "HTML5 is ";
  Element ("em", [Text "easy"]);
  Text " to parse"])
]}

    Formally, [tree] assembles a tree data structure of type ['a] from a signal
    stream. The stream is parsed according to the following grammar:

{[
stream  ::= node*
node    ::= element | `Text | `Comment | `PI | `Xml | `Doctype
element ::= `Start_element node* `End_element
]}

    Each time [trees] matches a production of [node], it calls the corresponding
    function to convert the node into your tree type ['a]. For example, when
    [trees] matches [`Text ss], it calls [~text ss], if [~text] is supplied.
    Similarly, when [trees] matches [element], it calls
    [~element name attributes children], if [~element] is supplied.

    See {!trees} if the input stream might have multiple top-level trees. This
    function [tree] only retrieves the first one. *)

val trees :
  ?text:(string list -> 'a) ->
  ?element:(name -> (name * string) list -> 'a list -> 'a) ->
  ?comment:(string -> 'a) ->
  ?pi:(string -> string -> 'a) ->
  ?xml:(xml_declaration -> 'a) ->
  ?doctype:(doctype -> 'a) ->
  ([< signal ], 's) stream -> ('a, 's) stream
(** Like {!tree}, but converts all top-level trees, not only the first one. The
    trees are emitted on the resulting stream, in the sequence that they appear
    in the input. *)

type 'a node =
  [ `Element of name * (name * string) list * 'a list
  | `Text of string
  | `Doctype of doctype
  | `Xml of xml_declaration
  | `PI of string * string
  | `Comment of string ]
(** See {!from_tree} below. *)

val from_tree : ('a -> 'a node) -> 'a -> (signal, sync) stream
(** Deconstructs tree data structures of type ['a] into signal streams. The
    function argument is applied to each data structure node. For example,

{[
type my_dom = Text of string | Element of string * my_dom list

let dom =
  Element ("p", [
    Text "HTML5 is ";
    Element ("em", [Text "easy"]);
    Text " to parse"])

dom |> from_tree (function
  | Text s -> `Text s
  | Element (name, children) -> `Element (("", name), [], children))
]}

    results in the signal stream

{[
`Start_element (("", "p"), [])
`Text ["HTML5 is "]
`Start_element (("", "em"), [])
`Text ["easy"]
`End_element
`Text " to parse"
`End_element
]} *)

val elements :
  (name -> (name * string) list -> bool) ->
  ([< signal ] as 'a, 's) stream ->
    (('a, 's) stream, 's) stream
(** [elements f s] scans the signal stream [s] for
    [`Start_element (name, attributes)] signals that satisfy
    [f name attributes]. Each such matching signal is the beginning of a
    substream that ends with the corresponding [`End_element] signal. The result
    of [elements f s] is the stream of these substreams.

    Matches don't nest. If there is a matching element contained in another
    matching element, only the top one results in a substream.

    Code using [elements] does not have to read each substream to completion, or
    at all. However, once the using code has tried to get the next substream, it
    should not try to read a previous one. *)

val text : ([< signal ], 's) stream -> (char, 's) stream
(** Extracts all the text in a signal stream by discarding all markup. For each
    [`Text ss] signal, the result stream has the bytes of the strings [ss], and
    all other signals are ignored. *)

val trim : ([> `Text of string list ] as 'a, 's) stream -> ('a, 's) stream
(** Trims whitespace in a signal stream. For each signal [`Text ss], transforms
    [ss] so that the result strings [ss'] satisfy

{[
String.concat "" ss' = String.trim (String.concat "" ss)
]}

    All signals for which [String.concat "" ss' = ""] are then dropped. *)

val normalize_text :
  ([> `Text of string list ] as 'a, 's) stream -> ('a, 's) stream
(** Concatenates adjacent [`Text] signals, then eliminates all empty strings,
    then all [`Text []] signals. Signals besides [`Text] are unaffected. Note
    that signal streams emitted by the parsers already have normalized text.
    This function is useful when you are inserting text into a signal stream
    after parsing, or generating streams from scratch, and would like to clean
    up the [`Text] signals. *)

val pretty_print : ([> content_signal ] as 'a, 's) stream -> ('a, 's) stream
(** Adjusts the whitespace in the [`Text] signals in the given stream so that
    the output appears nicely-indented when the stream is converted to bytes and
    written. *)

val html5 : ([< signal ], 's) stream -> (signal, 's) stream
(** Converts a signal stream into an HTML5 signal stream by stripping any
    document type declarations, XML declarations, and processing instructions,
    and prefixing the HTML5 doctype declaration. This is useful when converting
    between XHTML and HTML. *)

val xhtml :
  ?dtd:[< `Strict_1_0 | `Transitional_1_0 | `Frameset_1_0 | `Strict_1_1 ] ->
  ([< signal ], 's) stream -> (signal, 's) stream
(** Similar to {!html5}, but does not strip processing instructions, and
    prefixes an XHTML document type declaration and an XML declaration. The
    [~dtd] argument specifies which DTD to refer to in the doctype declaration.
    The default is [`Strict_1_1]. *)

val xhtml_entity : string -> string option
(** Translates XHTML entities. This function is for use with the [~entity]
    argument of {!parse_xml} when parsing XHTML. *)

val strings_to_bytes : (string, 's) stream -> (char, 's) stream
(** [strings_to_bytes s] is the stream of all the bytes of all strings in
    [s]. *)

val compare_locations : location -> location -> int
(** Orders locations according to their appearance in an input stream, i.e.
    first by line, and then, for locations on the same line, by column. *)



(** {2 Namespaces} *)

(** Common namespace URIs. *)
module Ns :
sig
  val html : string
  (** [http://www.w3.org/1999/xhtml]. Use for HTML and XHTML. *)

  val svg : string
  (** [http://www.w3.org/2000/svg]. *)

  val mathml : string
  (** [http://www.w3.org/1998/Math/MathML]. *)

  val xml : string
  (** [http://www.w3.org/XML/1998/namespace]. *)

  val xmlns : string
  (** [http://www.w3.org/2000/xmlns/]. *)

  val xlink : string
  (** [http://www.w3.org/1999/xlink]. *)
end



(** {2 Asynchronous interface} *)

(**/**)

module type IO =
sig
  type 'a t

  val return : 'a -> 'a t
  val of_cps : ((exn -> unit) -> ('a -> unit) -> unit) -> 'a t
  val to_cps : (unit -> 'a t) -> ((exn -> unit) -> ('a -> unit) -> unit)
end

(**/**)

(** Markup.ml interface for monadic I/O libraries such as Lwt and Async. This
    signature is included in the signature of {!Markup_lwt}, with type ['a io]
    replaced by ['a Lwt.t]. To use the functions in this interface, use
    {!Markup_lwt}. A [Markup_async] module has not (yet) been implemented.

    All of the functions here correspond directly to functions in {!Markup} with
    the same name. See that module for details on each function.

    The difference is that functions here can take ['a io] (i.e. ['a Lwt.t])
    threads instead of plain functions as arguments. As a consequence, all of
    them evaluate to either [async] streams, or to threads of type ['a io].

    Note that several functions in {!Markup} can take [async] streams as
    {e arguments}, such as {!Markup.map}, {!Markup.parse_xml}, or
    {!Markup.trim}. Where those functions, like {!Markup.trim}, don't take
    another function as argument, they are not duplicated in this signature.
    {!Markup.map} and {!Markup.parse_xml} {e are} provided here because some of
    their function arguments are replaced by ['a io] threads.

    All functions here accept both [sync] and [async] streams as arguments. *)
module type ASYNCHRONOUS =
sig
  (** {2 Threads} *)

  type 'a io
  (** Thread type. Replaced by ['a Lwt.t] in {!Markup_lwt}. *)

  (** {2 Encodings} *)

  (** Asynchronous counterpart to {!Markup.Encoding}. *)
  module Encoding :
  sig
    (**/**)
    type t = Encoding.t
    (**/**)

    val decode :
      ?report:(location -> Error.t -> unit io) -> Encoding.t ->
      (char, _) stream -> (int, async) stream
  end

  (** {2 XML} *)

  val parse_xml :
    ?report:(location -> Error.t -> unit io) ->
    ?encoding:Encoding.t ->
    ?namespace:(string -> string option) ->
    ?entity:(string -> string option) ->
    ?context:[< `Document | `Fragment ] ->
    (char, _) stream -> async parser

  val write_xml :
    ?report:((signal * int) -> Error.t -> unit io) ->
    ?prefix:(string -> string option) ->
    ([< signal ], _) stream -> (char, async) stream

  (** {2 HTML} *)

  val parse_html :
    ?report:(location -> Error.t -> unit io) ->
    ?encoding:Encoding.t ->
    ?context:[< `Document | `Fragment of string ] ->
    (char, _) stream -> async parser

  val write_html : ([< signal ], _) stream -> (char, async) stream

  (** {2 I/O} *)

  val fn : (unit -> char option io) -> (char, async) stream

  val to_string : (char, _) stream -> string io
  val to_buffer : (char, _) stream -> Buffer.t io

  (** {2 Stream manipulation} *)

  val stream : (unit -> 'a option io) -> ('a, async) stream

  val next : ('a, _) stream -> 'a option io
  val peek : ('a, _) stream -> 'a option io

  val transform :
    ('a -> 'b -> ('c list * 'a option) io) -> 'a -> ('b, _) stream ->
      ('c, async) stream
  val fold : ('a -> 'b -> 'a io) -> 'a -> ('b, _) stream -> 'a io
  val map : ('a -> 'b io) -> ('a, _) stream -> ('b, async) stream
  val filter : ('a -> bool io) -> ('a, _) stream -> ('a, async) stream
  val filter_map : ('a -> 'b option io) -> ('a, _) stream -> ('b, async) stream
  val iter : ('a -> unit io) -> ('a, _) stream -> unit io
  val drain : ('a, _) stream -> unit io

  val to_list : ('a, _) stream -> 'a list io

  val load : ('a, _) stream -> ('a, sync) stream io
  (** [load s] converts a general stream [s] to a synchronous stream by
      buffering it. *)

  (** {2 Utility} *)

  val tree :
    ?text:(string list -> 'a) ->
    ?element:(name -> (name * string) list -> 'a list -> 'a) ->
    ?comment:(string -> 'a) ->
    ?pi:(string -> string -> 'a) ->
    ?xml:(xml_declaration -> 'a) ->
    ?doctype:(doctype -> 'a) ->
    ([< signal ], _) stream -> 'a option io
end

(**/**)

module Asynchronous (IO : IO) : ASYNCHRONOUS with type 'a io := 'a IO.t

val kstream : ('a, _) stream -> 'a Markup_kstream.t
val of_kstream : 'a Markup_kstream.t -> ('a, _) stream

val preprocess_input_stream :
  (int, 's) stream -> (location * int, 's) stream * (unit -> location)

(**/**)



(** {2 Conformance status}

    The HTML parser seeks to implement
    {{:https://www.w3.org/TR/html5/syntax.html} section 8 of the HTML5
    specification}. That section describes a parser, part of a full-blown user
    agent, that is building up a DOM representation of an HTML document.
    Markup.ml is neither inherently part of a user agent, nor does it build up a
    DOM representation. With respect to section 8 of HTML5, Markup.ml is
    concerned with only the syntax. When that section requires that the user
    agent perform an action, Markup.ml emits enough information for a
    hypothetical user agent based on it to be able to decide to perform this
    action. Likewise, Markup.ml seeks to emit enough information for a
    hypothetical user agent to build up a conforming DOM.

    The XML parser seeks to be a non-validating implementation of the
    {{:https://www.w3.org/TR/xml/} XML} and {{:https://www.w3.org/TR/xml-names/}
    Namespaces in XML} specifications.

    This rest of this section lists known deviations from HTML5, XML, and
    Namespaces in XML. Some of these deviations are meant to be corrected in
    future versions of Markup.ml, while others will probably remain. The latter
    satisfy some or all of the following properties:

    - They require non-local adjustment, especially of past nodes. For example,
      adjusting the start signal of the root node mid-way through the signal
      stream is difficult for a one-pass parser.
    - They are minor. Users implementing less than a conforming browser
      typically don't care about them. They typically have to do with obscure
      error recovery. There are no deviations affecting the parsing of
      well-formed input.
    - They can easily be corrected by code written over Markup.ml that builds up
      a DOM or maintains other auxiliary data structures during parsing.

    {3 To be corrected:}

    - XML: There is no attribute value normalization.
    - HTML: {e foster parenting} is not implemented, because it requires
      non-local adjustments.
    - HTML: Quirks mode is not honored. This affects the interaction between
      automatic closing of [p] elements and opening of [table] elements.
    - HTML: The parser has non-standard recovery from unmatched closing [form]
      tags in {{: https://github.com/aantron/markup.ml/commit/0bf4f1b} some
      situations}.
    - HTML: The parser ignores interactions between [form] and [template].
    - HTML: The form translation for [isindex] is completely ignored. [isindex]
      is handled as an unknown element.

    {3 To remain:}

    - HTML: Except when detecting encodings, the parser does not try to read
      [<meta>] tags for encoding declarations. The user of Markup.ml should read
      these, if necessary. They are part of the emitted signal stream.
    - HTML: [noscript] elements are always parsed, as are [script] elements. For
      conforming behavior, if the user of Markup.ml "supports scripts," the user
      should serialize the content of [noscript] to a [`Text] signal using
      [write_html].
    - HTML: Elements such as [title] that belong in [head], but are found
      between [head] and [body], are not moved into [head].
    - HTML: [<html>] tags found in the body do not have their attributes added
      to the [`Start_element "html"] signal emitted at the beginning of the
      document. *)

end = struct
#1 "markup.ml"
(* This file is part of Markup.ml, released under the BSD 2-clause license. See
   doc/LICENSE for details, or visit https://github.com/aantron/markup.ml. *)

module Common = Markup_common
module Kstream = Markup_kstream
module Stream_io = Markup_stream_io
module Input = Markup_input
module Detect = Markup_detect
module Xml_tokenizer = Markup_xml_tokenizer
module Xml_writer = Markup_xml_writer
module Html_tokenizer = Markup_html_tokenizer
module Html_parser = Markup_html_parser
module Html_writer = Markup_html_writer
module Utility = Markup_utility

let (|>) = Common.(|>)



module type IO =
sig
  type 'a t

  val return : 'a -> 'a t
  val of_cps : ((exn -> unit) -> ('a -> unit) -> unit) -> 'a t
  val to_cps : (unit -> 'a t) -> ((exn -> unit) -> ('a -> unit) -> unit)
end

module Synchronous : IO with type 'a t = 'a =
struct
  type 'a t = 'a

  exception Not_synchronous

  let return x = x

  let of_cps f =
    let result = ref None in
    f raise (fun v -> result := Some v);
    match !result with
    | None -> raise Not_synchronous
    | Some v -> v

  (* Used in to_cps to avoid the need for a match .. with | exception ..
     expression, which would break compatibility with OCaml < 4.02. Flambda
     seems to optimizes the allocation of these results away completely. There
     is a small performance penalty when not using Flambda. *)
  type 'a result = Value of 'a | Exn of exn

  let to_cps f =
    fun throw k ->
      let result =
        try Value (f ())
        with exn -> Exn exn
      in
      match result with
      | Value v -> k v
      | Exn exn -> throw exn
end



type async = unit
type sync = unit

type ('data, 'sync) stream = 'data Kstream.t

let kstream s = s
let of_kstream s = s

let of_list = Kstream.of_list



type location = Common.location
let compare_locations = Common.compare_locations

module Error = Markup_error



type name = Common.name

type xml_declaration = Common.xml_declaration =
  {version    : string;
   encoding   : string option;
   standalone : bool option}

type doctype = Common.doctype =
  {doctype_name      : string option;
   public_identifier : string option;
   system_identifier : string option;
   raw_text          : string option;
   force_quirks      : bool}

type signal = Common.signal
type content_signal = Common.content_signal

let signal_to_string = Common.signal_to_string

type 's parser =
  {mutable location : location;
   mutable signals  : (signal, 's) stream}

let signals parser = parser.signals
let location parser = parser.location

let stream_to_parser s =
  let parser = {location = (1, 1); signals = Kstream.empty ()} in
  parser.signals <-
    s |> Kstream.map (fun (l, v) _ k -> parser.location <- l; k v);
  parser

module Cps =
struct
  let parse_xml
      report ?encoding namespace entity context source =
    let with_encoding (encoding : Markup_encoding.t) k =
      source
      |> encoding ~report
      |> Input.preprocess Common.is_valid_xml_char report
      |> Xml_tokenizer.tokenize report entity
      |> Markup__xml_parser.parse context namespace report
      |> k
    in

    let constructor throw k =
      match encoding with
      | Some encoding -> with_encoding encoding k
      | None ->
        Detect.select_xml source throw (fun encoding ->
        with_encoding encoding k)
    in

    Kstream.construct constructor
    |> stream_to_parser

  let write_xml report prefix signals =
    signals
    |> Xml_writer.write report prefix
    |> Utility.strings_to_bytes

  let parse_html report ?encoding context source =
    let with_encoding (encoding : Markup_encoding.t) k =
      source
      |> encoding ~report
      |> Input.preprocess Common.is_valid_html_char report
      |> Html_tokenizer.tokenize report
      |> Html_parser.parse context report
      |> k
    in

    let constructor throw k =
      match encoding with
      | Some encoding -> with_encoding encoding k
      | None ->
        Detect.select_html source throw (fun encoding ->
        with_encoding encoding k)
    in

    Kstream.construct constructor
    |> stream_to_parser

  let write_html signals =
    signals
    |> Html_writer.write
    |> Utility.strings_to_bytes
end



let string = Stream_io.string
let buffer = Stream_io.buffer
let channel = Stream_io.channel
let file = Stream_io.file

let to_channel c bytes = Stream_io.to_channel c bytes |> Synchronous.of_cps
let to_file f bytes = Stream_io.to_file f bytes |> Synchronous.of_cps



let preprocess_input_stream source =
  Input.preprocess (fun _ -> true) Error.ignore_errors source



include Utility



module Ns =
struct
  let html = Common.html_ns
  let svg = Common.svg_ns
  let mathml = Common.mathml_ns
  let xml = Common.xml_ns
  let xmlns = Common.xmlns_ns
  let xlink = Common.xlink_ns
end



module type ASYNCHRONOUS =
sig
  type 'a io

  module Encoding :
  sig
    type t = Markup_encoding.t

    val decode :
      ?report:(location -> Error.t -> unit io) -> t ->
      (char, _) stream -> (int, async) stream
  end

  val parse_xml :
    ?report:(location -> Error.t -> unit io) ->
    ?encoding:Encoding.t ->
    ?namespace:(string -> string option) ->
    ?entity:(string -> string option) ->
    ?context:[< `Document | `Fragment ] ->
    (char, _) stream -> async parser

  val write_xml :
    ?report:((signal * int) -> Error.t -> unit io) ->
    ?prefix:(string -> string option) ->
    ([< signal ], _) stream -> (char, async) stream

  val parse_html :
    ?report:(location -> Error.t -> unit io) ->
    ?encoding:Encoding.t ->
    ?context:[< `Document | `Fragment of string ] ->
    (char, _) stream -> async parser

  val write_html : ([< signal ], _) stream -> (char, async) stream

  val fn : (unit -> char option io) -> (char, async) stream

  val to_string : (char, _) stream -> string io
  val to_buffer : (char, _) stream -> Buffer.t io

  val stream : (unit -> 'a option io) -> ('a, async) stream

  val next : ('a, _) stream -> 'a option io
  val peek : ('a, _) stream -> 'a option io

  val transform :
    ('a -> 'b -> ('c list * 'a option) io) -> 'a -> ('b, _) stream ->
      ('c, async) stream
  val fold : ('a -> 'b -> 'a io) -> 'a -> ('b, _) stream -> 'a io
  val map : ('a -> 'b io) -> ('a, _) stream -> ('b, async) stream
  val filter : ('a -> bool io) -> ('a, _) stream -> ('a, async) stream
  val filter_map : ('a -> 'b option io) -> ('a, _) stream -> ('b, async) stream
  val iter : ('a -> unit io) -> ('a, _) stream -> unit io
  val drain : ('a, _) stream -> unit io

  val to_list : ('a, _) stream -> 'a list io

  val load : ('a, _) stream -> ('a, sync) stream io

  val tree :
    ?text:(string list -> 'a) ->
    ?element:(name -> (name * string) list -> 'a list -> 'a) ->
    ?comment:(string -> 'a) ->
    ?pi:(string -> string -> 'a) ->
    ?xml:(xml_declaration -> 'a) ->
    ?doctype:(doctype -> 'a) ->
    ([< signal ], _) stream -> 'a option io
end

module Asynchronous (IO : IO) =
struct
  let wrap_report report = fun l e -> IO.to_cps (fun () -> report l e)

  module Encoding =
  struct
    include Markup_encoding

    let decode ?(report = fun _ _ -> IO.return ()) (f : Markup_encoding.t) s =
      f ~report:(wrap_report report) s
  end

  let parse_xml
      ?(report = fun _ _ -> IO.return ())
      ?encoding
      ?(namespace = fun _ -> None)
      ?(entity = fun _ -> None)
      ?context
      source =

    Cps.parse_xml
      (wrap_report report) ?encoding namespace entity context source

  let write_xml
      ?(report = fun _ _ -> IO.return ())
      ?(prefix = fun _ -> None)
      signals =

    Cps.write_xml (wrap_report report) prefix signals

  let parse_html
      ?(report = fun _ _ -> IO.return ())
      ?encoding
      ?context
      source =

    Cps.parse_html (wrap_report report) ?encoding context source

  let write_html signals =
    Cps.write_html signals

  let to_string bytes = Stream_io.to_string bytes |> IO.of_cps
  let to_buffer bytes = Stream_io.to_buffer bytes |> IO.of_cps

  let stream f =
    let f = IO.to_cps f in
    (fun throw e k ->
      f throw (function
        | None -> e ()
        | Some v -> k v))
    |> Kstream.make

  let fn = stream

  let next s = Kstream.next_option s |> IO.of_cps
  let peek s = Kstream.peek_option s |> IO.of_cps

  (* Without Flambda, thunks are repeatedly created and passed on IO.to_cps,
     resulting in a performance penalty. Flambda seems to optimize this away,
     however. *)

  let transform f v s =
    Kstream.transform (fun v s -> IO.to_cps (fun () -> f v s)) v s

  let fold f v s =
    Kstream.fold (fun v v' -> IO.to_cps (fun () -> f v v')) v s |> IO.of_cps

  let map f s = Kstream.map (fun v -> IO.to_cps (fun () -> f v)) s

  let filter f s = Kstream.filter (fun v -> IO.to_cps (fun () -> f v)) s

  let filter_map f s = Kstream.filter_map (fun v -> IO.to_cps (fun () -> f v)) s

  let iter f s =
    Kstream.iter (fun v -> IO.to_cps (fun () -> f v)) s |> IO.of_cps

  let drain s = iter (fun _ -> IO.return ()) s

  let to_list s = Kstream.to_list s |> IO.of_cps

  let load s =
    (fun throw k -> Kstream.to_list s throw (fun l -> k (Kstream.of_list l)))
    |> IO.of_cps

  let tree ?text ?element ?comment ?pi ?xml ?doctype s =
    Utility.tree ?text ?element ?comment ?pi ?xml ?doctype s |> IO.of_cps
end

include Asynchronous (Synchronous)

end
module Ast_402
= struct
#1 "ast_402.ml"
# 1 "src/ast_402.ml"
# 1 "src/ast_402.ml"
# 1 "src/ast_402.ml"
# 1 "src/ast_402.ml"
# 1 "src/ast_402.ml"
# 1 "src/ast_402.ml"
# 1 "src/ast_402.ml"
# 1 "src/ast_402.ml"
# 1 "src/ast_402.ml"
# 1 "src/ast_402.ml"
# 1 "src/ast_402.ml"
# 1 "src/ast_402.ml"
# 1 "src/ast_402.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*            Jérémie Dimino and Leo White, Jane Street Europe            *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt            *)
(*                         Alain Frisch, LexiFi                           *)
(*       Daniel de Rauglaudre, projet Cristal, INRIA Rocquencourt         *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

module Location = Location
module Longident = Longident

module Asttypes = struct
  (* Auxiliary a.s.t. types used by parsetree and typedtree. *)

  type constant              = Asttypes.constant    =
      Const_int of int
    | Const_char of char
    | Const_string of string * string option
    | Const_float of string
    | Const_int32 of int32
    | Const_int64 of int64
    | Const_nativeint of nativeint

  type rec_flag              = Asttypes.rec_flag    = Nonrecursive | Recursive

  type direction_flag              = Asttypes.direction_flag    = Upto | Downto

  type private_flag              = Asttypes.private_flag    = Private | Public

  type mutable_flag              = Asttypes.mutable_flag    = Immutable | Mutable

  type virtual_flag              = Asttypes.virtual_flag    = Virtual | Concrete

  type override_flag              = Asttypes.override_flag    = Override | Fresh

  type closed_flag              = Asttypes.closed_flag    = Closed | Open

  type label = string

  type 'a loc = 'a Location.loc = {
    txt : 'a;
    loc : Location.t;
  }


  type variance              = Asttypes.variance    =
    | Covariant
    | Contravariant
    | Invariant
end

module Parsetree = struct
  (** Abstract syntax tree produced by parsing *)

  open Asttypes

  (** {2 Extension points} *)

  type attribute = string loc * payload
         (* [@id ARG]
            [@@id ARG]

            Metadata containers passed around within the AST.
            The compiler ignores unknown attributes.
         *)

  and extension = string loc * payload
        (* [%id ARG]
           [%%id ARG]

           Sub-language placeholder -- rejected by the typechecker.
        *)

  and attributes = attribute list

  and payload              = Parsetree.payload    =
    | PStr of structure
    | PTyp of core_type  (* : T *)
    | PPat of pattern * expression option  (* ? P  or  ? P when E *)

  (** {2 Core language} *)

  (* Type expressions *)

  and core_type              = Parsetree.core_type    =
      {
       ptyp_desc: core_type_desc;
       ptyp_loc: Location.t;
       ptyp_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and core_type_desc              = Parsetree.core_type_desc    =
    | Ptyp_any
          (*  _ *)
    | Ptyp_var of string
          (* 'a *)
    | Ptyp_arrow of label * core_type * core_type
          (* T1 -> T2       (label = "")
             ~l:T1 -> T2    (label = "l")
             ?l:T1 -> T2    (label = "?l")
           *)
    | Ptyp_tuple of core_type list
          (* T1 * ... * Tn

             Invariant: n >= 2
          *)
    | Ptyp_constr of Longident.t loc * core_type list
          (* tconstr
             T tconstr
             (T1, ..., Tn) tconstr
           *)
    | Ptyp_object of (string * attributes * core_type) list * closed_flag
          (* < l1:T1; ...; ln:Tn >     (flag = Closed)
             < l1:T1; ...; ln:Tn; .. > (flag = Open)
           *)
    | Ptyp_class of Longident.t loc * core_type list
          (* #tconstr
             T #tconstr
             (T1, ..., Tn) #tconstr
           *)
    | Ptyp_alias of core_type * string
          (* T as 'a *)
    | Ptyp_variant of row_field list * closed_flag * label list option
          (* [ `A|`B ]         (flag = Closed; labels = None)
             [> `A|`B ]        (flag = Open;   labels = None)
             [< `A|`B ]        (flag = Closed; labels = Some [])
             [< `A|`B > `X `Y ](flag = Closed; labels = Some ["X";"Y"])
           *)
    | Ptyp_poly of string list * core_type
          (* 'a1 ... 'an. T

             Can only appear in the following context:

             - As the core_type of a Ppat_constraint node corresponding
               to a constraint on a let-binding: let x : 'a1 ... 'an. T
               = e ...

             - Under Cfk_virtual for methods (not values).

             - As the core_type of a Pctf_method node.

             - As the core_type of a Pexp_poly node.

             - As the pld_type field of a label_declaration.

             - As a core_type of a Ptyp_object node.
           *)

    | Ptyp_package of package_type
          (* (module S) *)
    | Ptyp_extension of extension
          (* [%id] *)

  and package_type = Longident.t loc * (Longident.t loc * core_type) list
        (*
          (module S)
          (module S with type t1 = T1 and ... and tn = Tn)
         *)

  and row_field              = Parsetree.row_field    =
    | Rtag of label * attributes * bool * core_type list
          (* [`A]                   ( true,  [] )
             [`A of T]              ( false, [T] )
             [`A of T1 & .. & Tn]   ( false, [T1;...Tn] )
             [`A of & T1 & .. & Tn] ( true,  [T1;...Tn] )

            - The 2nd field is true if the tag contains a
              constant (empty) constructor.
            - '&' occurs when several types are used for the same constructor
              (see 4.2 in the manual)

            - TODO: switch to a record representation, and keep location
          *)
    | Rinherit of core_type
          (* [ T ] *)

  (* Patterns *)

  and pattern              = Parsetree.pattern    =
      {
       ppat_desc: pattern_desc;
       ppat_loc: Location.t;
       ppat_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and pattern_desc              = Parsetree.pattern_desc    =
    | Ppat_any
          (* _ *)
    | Ppat_var of string loc
          (* x *)
    | Ppat_alias of pattern * string loc
          (* P as 'a *)
    | Ppat_constant of constant
          (* 1, 'a', "true", 1.0, 1l, 1L, 1n *)
    | Ppat_interval of constant * constant
          (* 'a'..'z'

             Other forms of interval are recognized by the parser
             but rejected by the type-checker. *)
    | Ppat_tuple of pattern list
          (* (P1, ..., Pn)

             Invariant: n >= 2
          *)
    | Ppat_construct of Longident.t loc * pattern option
          (* C                None
             C P              Some P
             C (P1, ..., Pn)  Some (Ppat_tuple [P1; ...; Pn])
           *)
    | Ppat_variant of label * pattern option
          (* `A             (None)
             `A P           (Some P)
           *)
    | Ppat_record of (Longident.t loc * pattern) list * closed_flag
          (* { l1=P1; ...; ln=Pn }     (flag = Closed)
             { l1=P1; ...; ln=Pn; _}   (flag = Open)

             Invariant: n > 0
           *)
    | Ppat_array of pattern list
          (* [| P1; ...; Pn |] *)
    | Ppat_or of pattern * pattern
          (* P1 | P2 *)
    | Ppat_constraint of pattern * core_type
          (* (P : T) *)
    | Ppat_type of Longident.t loc
          (* #tconst *)
    | Ppat_lazy of pattern
          (* lazy P *)
    | Ppat_unpack of string loc
          (* (module P)
             Note: (module P : S) is represented as
             Ppat_constraint(Ppat_unpack, Ptyp_package)
           *)
    | Ppat_exception of pattern
          (* exception P *)
    | Ppat_extension of extension
          (* [%id] *)

  (* Value expressions *)

  and expression              = Parsetree.expression    =
      {
       pexp_desc: expression_desc;
       pexp_loc: Location.t;
       pexp_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and expression_desc              = Parsetree.expression_desc    =
    | Pexp_ident of Longident.t loc
          (* x
             M.x
           *)
    | Pexp_constant of constant
          (* 1, 'a', "true", 1.0, 1l, 1L, 1n *)
    | Pexp_let of rec_flag * value_binding list * expression
          (* let P1 = E1 and ... and Pn = EN in E       (flag = Nonrecursive)
             let rec P1 = E1 and ... and Pn = EN in E   (flag = Recursive)
           *)
    | Pexp_function of case list
          (* function P1 -> E1 | ... | Pn -> En *)
    | Pexp_fun of label * expression option * pattern * expression
          (* fun P -> E1                          (lab = "", None)
             fun ~l:P -> E1                       (lab = "l", None)
             fun ?l:P -> E1                       (lab = "?l", None)
             fun ?l:(P = E0) -> E1                (lab = "?l", Some E0)

             Notes:
             - If E0 is provided, lab must start with '?'.
             - "fun P1 P2 .. Pn -> E1" is represented as nested Pexp_fun.
             - "let f P = E" is represented using Pexp_fun.
           *)
    | Pexp_apply of expression * (label * expression) list
          (* E0 ~l1:E1 ... ~ln:En
             li can be empty (non labeled argument) or start with '?'
             (optional argument).

             Invariant: n > 0
           *)
    | Pexp_match of expression * case list
          (* match E0 with P1 -> E1 | ... | Pn -> En *)
    | Pexp_try of expression * case list
          (* try E0 with P1 -> E1 | ... | Pn -> En *)
    | Pexp_tuple of expression list
          (* (E1, ..., En)

             Invariant: n >= 2
          *)
    | Pexp_construct of Longident.t loc * expression option
          (* C                None
             C E              Some E
             C (E1, ..., En)  Some (Pexp_tuple[E1;...;En])
          *)
    | Pexp_variant of label * expression option
          (* `A             (None)
             `A E           (Some E)
           *)
    | Pexp_record of (Longident.t loc * expression) list * expression option
          (* { l1=P1; ...; ln=Pn }     (None)
             { E0 with l1=P1; ...; ln=Pn }   (Some E0)

             Invariant: n > 0
           *)
    | Pexp_field of expression * Longident.t loc
          (* E.l *)
    | Pexp_setfield of expression * Longident.t loc * expression
          (* E1.l <- E2 *)
    | Pexp_array of expression list
          (* [| E1; ...; En |] *)
    | Pexp_ifthenelse of expression * expression * expression option
          (* if E1 then E2 else E3 *)
    | Pexp_sequence of expression * expression
          (* E1; E2 *)
    | Pexp_while of expression * expression
          (* while E1 do E2 done *)
    | Pexp_for of
        pattern *  expression * expression * direction_flag * expression
          (* for i = E1 to E2 do E3 done      (flag = Upto)
             for i = E1 downto E2 do E3 done  (flag = Downto)
           *)
    | Pexp_constraint of expression * core_type
          (* (E : T) *)
    | Pexp_coerce of expression * core_type option * core_type
          (* (E :> T)        (None, T)
             (E : T0 :> T)   (Some T0, T)
           *)
    | Pexp_send of expression * string
          (*  E # m *)
    | Pexp_new of Longident.t loc
          (* new M.c *)
    | Pexp_setinstvar of string loc * expression
          (* x <- 2 *)
    | Pexp_override of (string loc * expression) list
          (* {< x1 = E1; ...; Xn = En >} *)
    | Pexp_letmodule of string loc * module_expr * expression
          (* let module M = ME in E *)
    | Pexp_assert of expression
          (* assert E
             Note: "assert false" is treated in a special way by the
             type-checker. *)
    | Pexp_lazy of expression
          (* lazy E *)
    | Pexp_poly of expression * core_type option
          (* Used for method bodies.

             Can only be used as the expression under Cfk_concrete
             for methods (not values). *)
    | Pexp_object of class_structure
          (* object ... end *)
    | Pexp_newtype of string * expression
          (* fun (type t) -> E *)
    | Pexp_pack of module_expr
          (* (module ME)

             (module ME : S) is represented as
             Pexp_constraint(Pexp_pack, Ptyp_package S) *)
    | Pexp_open of override_flag * Longident.t loc * expression
          (* let open M in E
             let! open M in E
          *)
    | Pexp_extension of extension
          (* [%id] *)

  and case              = Parsetree.case    =   (* (P -> E) or (P when E0 -> E) *)
      {
       pc_lhs: pattern;
       pc_guard: expression option;
       pc_rhs: expression;
      }

  (* Value descriptions *)

  and value_description              = Parsetree.value_description    =
      {
       pval_name: string loc;
       pval_type: core_type;
       pval_prim: string list;
       pval_attributes: attributes;  (* ... [@@id1] [@@id2] *)
       pval_loc: Location.t;
      }

  (*
    val x: T                            (prim = [])
    external x: T = "s1" ... "sn"       (prim = ["s1";..."sn"])

    Note: when used under Pstr_primitive, prim cannot be empty
  *)

  (* Type declarations *)

  and type_declaration              = Parsetree.type_declaration    =
      {
       ptype_name: string loc;
       ptype_params: (core_type * variance) list;
             (* ('a1,...'an) t; None represents  _*)
       ptype_cstrs: (core_type * core_type * Location.t) list;
             (* ... constraint T1=T1'  ... constraint Tn=Tn' *)
       ptype_kind: type_kind;
       ptype_private: private_flag;   (* = private ... *)
       ptype_manifest: core_type option;  (* = T *)
       ptype_attributes: attributes;   (* ... [@@id1] [@@id2] *)
       ptype_loc: Location.t;
      }

  (*
    type t                     (abstract, no manifest)
    type t = T0                (abstract, manifest=T0)
    type t = C of T | ...      (variant,  no manifest)
    type t = T0 = C of T | ... (variant,  manifest=T0)
    type t = {l: T; ...}       (record,   no manifest)
    type t = T0 = {l : T; ...} (record,   manifest=T0)
    type t = ..                (open,     no manifest)
  *)

  and type_kind              = Parsetree.type_kind    =
    | Ptype_abstract
    | Ptype_variant of constructor_declaration list
          (* Invariant: non-empty list *)
    | Ptype_record of label_declaration list
          (* Invariant: non-empty list *)
    | Ptype_open

  and label_declaration              = Parsetree.label_declaration    =
      {
       pld_name: string loc;
       pld_mutable: mutable_flag;
       pld_type: core_type;
       pld_loc: Location.t;
       pld_attributes: attributes; (* l [@id1] [@id2] : T *)
      }

  (*  { ...; l: T; ... }            (mutable=Immutable)
      { ...; mutable l: T; ... }    (mutable=Mutable)

      Note: T can be a Ptyp_poly.
  *)

  and constructor_declaration              = Parsetree.constructor_declaration    =
      {
       pcd_name: string loc;
       pcd_args: core_type list;
       pcd_res: core_type option;
       pcd_loc: Location.t;
       pcd_attributes: attributes; (* C [@id1] [@id2] of ... *)
      }
  (*
    | C of T1 * ... * Tn     (res = None)
    | C: T0                  (args = [], res = Some T0)
    | C: T1 * ... * Tn -> T0 (res = Some T0)
  *)

  and type_extension              = Parsetree.type_extension    =
      {
       ptyext_path: Longident.t loc;
       ptyext_params: (core_type * variance) list;
       ptyext_constructors: extension_constructor list;
       ptyext_private: private_flag;
       ptyext_attributes: attributes;   (* ... [@@id1] [@@id2] *)
      }
  (*
    type t += ...
  *)

  and extension_constructor              = Parsetree.extension_constructor    =
      {
       pext_name: string loc;
       pext_kind : extension_constructor_kind;
       pext_loc : Location.t;
       pext_attributes: attributes; (* C [@id1] [@id2] of ... *)
      }

  and extension_constructor_kind              = Parsetree.extension_constructor_kind    =
      Pext_decl of core_type list * core_type option
        (*
           | C of T1 * ... * Tn     ([T1; ...; Tn], None)
           | C: T0                  ([], Some T0)
           | C: T1 * ... * Tn -> T0 ([T1; ...; Tn], Some T0)
         *)
    | Pext_rebind of Longident.t loc
        (*
           | C = D
         *)

  (** {2 Class language} *)

  (* Type expressions for the class language *)

  and class_type              = Parsetree.class_type    =
      {
       pcty_desc: class_type_desc;
       pcty_loc: Location.t;
       pcty_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and class_type_desc              = Parsetree.class_type_desc    =
    | Pcty_constr of Longident.t loc * core_type list
          (* c
             ['a1, ..., 'an] c *)
    | Pcty_signature of class_signature
          (* object ... end *)
    | Pcty_arrow of label * core_type * class_type
          (* T -> CT       (label = "")
             ~l:T -> CT    (label = "l")
             ?l:T -> CT    (label = "?l")
           *)
    | Pcty_extension of extension
          (* [%id] *)

  and class_signature              = Parsetree.class_signature    =
      {
       pcsig_self: core_type;
       pcsig_fields: class_type_field list;
      }
  (* object('selfpat) ... end
     object ... end             (self = Ptyp_any)
   *)

  and class_type_field              = Parsetree.class_type_field    =
      {
       pctf_desc: class_type_field_desc;
       pctf_loc: Location.t;
       pctf_attributes: attributes; (* ... [@@id1] [@@id2] *)
      }

  and class_type_field_desc              = Parsetree.class_type_field_desc    =
    | Pctf_inherit of class_type
          (* inherit CT *)
    | Pctf_val of (string * mutable_flag * virtual_flag * core_type)
          (* val x: T *)
    | Pctf_method  of (string * private_flag * virtual_flag * core_type)
          (* method x: T

             Note: T can be a Ptyp_poly.
           *)
    | Pctf_constraint  of (core_type * core_type)
          (* constraint T1 = T2 *)
    | Pctf_attribute of attribute
          (* [@@@id] *)
    | Pctf_extension of extension
          (* [%%id] *)

  and 'a class_infos              = 'a Parsetree.class_infos    =
      {
       pci_virt: virtual_flag;
       pci_params: (core_type * variance) list;
       pci_name: string loc;
       pci_expr: 'a;
       pci_loc: Location.t;
       pci_attributes: attributes;  (* ... [@@id1] [@@id2] *)
      }
  (* class c = ...
     class ['a1,...,'an] c = ...
     class virtual c = ...

     Also used for "class type" declaration.
  *)

  and class_description = class_type class_infos

  and class_type_declaration = class_type class_infos

  (* Value expressions for the class language *)

  and class_expr              = Parsetree.class_expr    =
      {
       pcl_desc: class_expr_desc;
       pcl_loc: Location.t;
       pcl_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and class_expr_desc              = Parsetree.class_expr_desc    =
    | Pcl_constr of Longident.t loc * core_type list
          (* c
             ['a1, ..., 'an] c *)
    | Pcl_structure of class_structure
          (* object ... end *)
    | Pcl_fun of label * expression option * pattern * class_expr
          (* fun P -> CE                          (lab = "", None)
             fun ~l:P -> CE                       (lab = "l", None)
             fun ?l:P -> CE                       (lab = "?l", None)
             fun ?l:(P = E0) -> CE                (lab = "?l", Some E0)
           *)
    | Pcl_apply of class_expr * (label * expression) list
          (* CE ~l1:E1 ... ~ln:En
             li can be empty (non labeled argument) or start with '?'
             (optional argument).

             Invariant: n > 0
           *)
    | Pcl_let of rec_flag * value_binding list * class_expr
          (* let P1 = E1 and ... and Pn = EN in CE      (flag = Nonrecursive)
             let rec P1 = E1 and ... and Pn = EN in CE  (flag = Recursive)
           *)
    | Pcl_constraint of class_expr * class_type
          (* (CE : CT) *)
    | Pcl_extension of extension
          (* [%id] *)

  and class_structure              = Parsetree.class_structure    =
      {
       pcstr_self: pattern;
       pcstr_fields: class_field list;
      }
  (* object(selfpat) ... end
     object ... end           (self = Ppat_any)
   *)

  and class_field              = Parsetree.class_field    =
      {
       pcf_desc: class_field_desc;
       pcf_loc: Location.t;
       pcf_attributes: attributes; (* ... [@@id1] [@@id2] *)
      }

  and class_field_desc              = Parsetree.class_field_desc    =
    | Pcf_inherit of override_flag * class_expr * string option
          (* inherit CE
             inherit CE as x
             inherit! CE
             inherit! CE as x
           *)
    | Pcf_val of (string loc * mutable_flag * class_field_kind)
          (* val x = E
             val virtual x: T
           *)
    | Pcf_method of (string loc * private_flag * class_field_kind)
          (* method x = E            (E can be a Pexp_poly)
             method virtual x: T     (T can be a Ptyp_poly)
           *)
    | Pcf_constraint of (core_type * core_type)
          (* constraint T1 = T2 *)
    | Pcf_initializer of expression
          (* initializer E *)
    | Pcf_attribute of attribute
          (* [@@@id] *)
    | Pcf_extension of extension
          (* [%%id] *)

  and class_field_kind              = Parsetree.class_field_kind    =
    | Cfk_virtual of core_type
    | Cfk_concrete of override_flag * expression

  and class_declaration = class_expr class_infos

  (** {2 Module language} *)

  (* Type expressions for the module language *)

  and module_type              = Parsetree.module_type    =
      {
       pmty_desc: module_type_desc;
       pmty_loc: Location.t;
       pmty_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and module_type_desc              = Parsetree.module_type_desc    =
    | Pmty_ident of Longident.t loc
          (* S *)
    | Pmty_signature of signature
          (* sig ... end *)
    | Pmty_functor of string loc * module_type option * module_type
          (* functor(X : MT1) -> MT2 *)
    | Pmty_with of module_type * with_constraint list
          (* MT with ... *)
    | Pmty_typeof of module_expr
          (* module type of ME *)
    | Pmty_extension of extension
          (* [%id] *)
    | Pmty_alias of Longident.t loc
          (* (module M) *)

  and signature = signature_item list

  and signature_item              = Parsetree.signature_item    =
      {
       psig_desc: signature_item_desc;
       psig_loc: Location.t;
      }

  and signature_item_desc              = Parsetree.signature_item_desc    =
    | Psig_value of value_description
          (*
            val x: T
            external x: T = "s1" ... "sn"
           *)
    | Psig_type of type_declaration list
          (* type t1 = ... and ... and tn = ... *)
    | Psig_typext of type_extension
          (* type t1 += ... *)
    | Psig_exception of extension_constructor
          (* exception C of T *)
    | Psig_module of module_declaration
          (* module X : MT *)
    | Psig_recmodule of module_declaration list
          (* module rec X1 : MT1 and ... and Xn : MTn *)
    | Psig_modtype of module_type_declaration
          (* module type S = MT
             module type S *)
    | Psig_open of open_description
          (* open X *)
    | Psig_include of include_description
          (* include MT *)
    | Psig_class of class_description list
          (* class c1 : ... and ... and cn : ... *)
    | Psig_class_type of class_type_declaration list
          (* class type ct1 = ... and ... and ctn = ... *)
    | Psig_attribute of attribute
          (* [@@@id] *)
    | Psig_extension of extension * attributes
          (* [%%id] *)

  and module_declaration              = Parsetree.module_declaration    =
      {
       pmd_name: string loc;
       pmd_type: module_type;
       pmd_attributes: attributes; (* ... [@@id1] [@@id2] *)
       pmd_loc: Location.t;
      }
  (* S : MT *)

  and module_type_declaration              = Parsetree.module_type_declaration    =
      {
       pmtd_name: string loc;
       pmtd_type: module_type option;
       pmtd_attributes: attributes; (* ... [@@id1] [@@id2] *)
       pmtd_loc: Location.t;
      }
  (* S = MT
     S       (abstract module type declaration, pmtd_type = None)
  *)

  and open_description              = Parsetree.open_description    =
      {
       popen_lid: Longident.t loc;
       popen_override: override_flag;
       popen_loc: Location.t;
       popen_attributes: attributes;
      }
  (* open! X - popen_override = Override (silences the 'used identifier
                                shadowing' warning)
     open  X - popen_override = Fresh
   *)

  and 'a include_infos              = 'a Parsetree.include_infos    =
      {
       pincl_mod: 'a;
       pincl_loc: Location.t;
       pincl_attributes: attributes;
      }

  and include_description = module_type include_infos
  (* include MT *)

  and include_declaration = module_expr include_infos
  (* include ME *)

  and with_constraint              = Parsetree.with_constraint    =
    | Pwith_type of Longident.t loc * type_declaration
          (* with type X.t = ...

             Note: the last component of the longident must match
             the name of the type_declaration. *)
    | Pwith_module of Longident.t loc * Longident.t loc
          (* with module X.Y = Z *)
    | Pwith_typesubst of type_declaration
          (* with type t := ... *)
    | Pwith_modsubst of string loc * Longident.t loc
          (* with module X := Z *)

  (* Value expressions for the module language *)

  and module_expr              = Parsetree.module_expr    =
      {
       pmod_desc: module_expr_desc;
       pmod_loc: Location.t;
       pmod_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and module_expr_desc              = Parsetree.module_expr_desc    =
    | Pmod_ident of Longident.t loc
          (* X *)
    | Pmod_structure of structure
          (* struct ... end *)
    | Pmod_functor of string loc * module_type option * module_expr
          (* functor(X : MT1) -> ME *)
    | Pmod_apply of module_expr * module_expr
          (* ME1(ME2) *)
    | Pmod_constraint of module_expr * module_type
          (* (ME : MT) *)
    | Pmod_unpack of expression
          (* (val E) *)
    | Pmod_extension of extension
          (* [%id] *)

  and structure = structure_item list

  and structure_item              = Parsetree.structure_item    =
      {
       pstr_desc: structure_item_desc;
       pstr_loc: Location.t;
      }

  and structure_item_desc              = Parsetree.structure_item_desc    =
    | Pstr_eval of expression * attributes
          (* E *)
    | Pstr_value of rec_flag * value_binding list
          (* let P1 = E1 and ... and Pn = EN       (flag = Nonrecursive)
             let rec P1 = E1 and ... and Pn = EN   (flag = Recursive)
           *)
    | Pstr_primitive of value_description
          (* external x: T = "s1" ... "sn" *)
    | Pstr_type of type_declaration list
          (* type t1 = ... and ... and tn = ... *)
    | Pstr_typext of type_extension
          (* type t1 += ... *)
    | Pstr_exception of extension_constructor
          (* exception C of T
             exception C = M.X *)
    | Pstr_module of module_binding
          (* module X = ME *)
    | Pstr_recmodule of module_binding list
          (* module rec X1 = ME1 and ... and Xn = MEn *)
    | Pstr_modtype of module_type_declaration
          (* module type S = MT *)
    | Pstr_open of open_description
          (* open X *)
    | Pstr_class of class_declaration list
          (* class c1 = ... and ... and cn = ... *)
    | Pstr_class_type of class_type_declaration list
          (* class type ct1 = ... and ... and ctn = ... *)
    | Pstr_include of include_declaration
          (* include ME *)
    | Pstr_attribute of attribute
          (* [@@@id] *)
    | Pstr_extension of extension * attributes
          (* [%%id] *)

  and value_binding              = Parsetree.value_binding    =
    {
      pvb_pat: pattern;
      pvb_expr: expression;
      pvb_attributes: attributes;
      pvb_loc: Location.t;
    }

  and module_binding              = Parsetree.module_binding    =
      {
       pmb_name: string loc;
       pmb_expr: module_expr;
       pmb_attributes: attributes;
       pmb_loc: Location.t;
      }
  (* X = ME *)

  (** {2 Toplevel} *)

  (* Toplevel phrases *)

  type toplevel_phrase              = Parsetree.toplevel_phrase    =
    | Ptop_def of structure
    | Ptop_dir of string * directive_argument
       (* #use, #load ... *)

  and directive_argument              = Parsetree.directive_argument    =
    | Pdir_none
    | Pdir_string of string
    | Pdir_int of int
    | Pdir_ident of Longident.t
    | Pdir_bool of bool
end

module Docstrings : sig
  (** {3 Docstrings} *)

  (** Documentation comments *)
  type docstring

  (** Create a docstring *)
  val docstring : string -> Location.t -> docstring

  (** Get the text of a docstring *)
  val docstring_body : docstring -> string

  (** Get the location of a docstring *)
  val docstring_loc : docstring -> Location.t

  (** {3 Items}

      The {!docs} type represents documentation attached to an item. *)

  type docs =
    { docs_pre: docstring option;
      docs_post: docstring option; }

  val empty_docs : docs

  val docs_attr : docstring -> Parsetree.attribute

  (** Convert item documentation to attributes and add them to an
      attribute list *)
  val add_docs_attrs : docs -> Parsetree.attributes -> Parsetree.attributes

  (** {3 Fields and constructors}

      The {!info} type represents documentation attached to a field or
      constructor. *)

  type info = docstring option

  val empty_info : info

  val info_attr : docstring -> Parsetree.attribute

  (** Convert field info to attributes and add them to an
      attribute list *)
  val add_info_attrs : info -> Parsetree.attributes -> Parsetree.attributes

  (** {3 Unattached comments}

      The {!text} type represents documentation which is not attached to
      anything. *)

  type text = docstring list

  val empty_text : text

  val text_attr : docstring -> Parsetree.attribute

  (** Convert text to attributes and add them to an attribute list *)
  val add_text_attrs : text -> Parsetree.attributes -> Parsetree.attributes

end = struct
  open Location

  (* Docstrings *)

  type docstring =
    { ds_body: string;
      ds_loc: Location.t; }

  (* Docstring constructors and destructors *)

  let docstring body loc =
    let ds =
      { ds_body = body;
        ds_loc = loc; }
    in
    ds

  let docstring_body ds = ds.ds_body

  let docstring_loc ds = ds.ds_loc

  (* Docstrings attached to items *)

  type docs =
    { docs_pre: docstring option;
      docs_post: docstring option; }

  let empty_docs = { docs_pre = None; docs_post = None }

  let doc_loc = {txt = "ocaml.doc"; loc = Location.none}

  let docs_attr ds =
    let open Asttypes in
    let open Parsetree in
    let exp =
      { pexp_desc = Pexp_constant (Const_string(ds.ds_body, None));
        pexp_loc = ds.ds_loc;
        pexp_attributes = []; }
    in
    let item =
      { pstr_desc = Pstr_eval (exp, []); pstr_loc = exp.pexp_loc }
    in
      (doc_loc, PStr [item])

  let add_docs_attrs docs attrs =
    let attrs =
      match docs.docs_pre with
      | None | Some { ds_body=""; _ } -> attrs
      | Some ds -> docs_attr ds :: attrs
    in
    let attrs =
      match docs.docs_post with
      | None | Some { ds_body=""; _ } -> attrs
      | Some ds -> attrs @ [docs_attr ds]
    in
    attrs

  (* Docstrings attached to constructors or fields *)

  type info = docstring option

  let empty_info = None

  let info_attr = docs_attr

  let add_info_attrs info attrs =
    match info with
    | None | Some {ds_body=""; _} -> attrs
    | Some ds -> attrs @ [info_attr ds]

  (* Docstrings not attached to a specific item *)

  type text = docstring list

  let empty_text = []

  let text_loc = {txt = "ocaml.text"; loc = Location.none}

  let text_attr ds =
    let open Asttypes in
    let open Parsetree in
    let exp =
      { pexp_desc = Pexp_constant (Const_string(ds.ds_body, None));
        pexp_loc = ds.ds_loc;
        pexp_attributes = []; }
    in
    let item =
      { pstr_desc = Pstr_eval (exp, []); pstr_loc = exp.pexp_loc }
    in
      (text_loc, PStr [item])

  let add_text_attrs dsl attrs =
    let fdsl = List.filter (function {ds_body=""; _} -> false| _ ->true) dsl in
    (List.map text_attr fdsl) @ attrs

end

module Ast_helper : sig
  (** Helpers to produce Parsetree fragments *)

  open Parsetree
  open Asttypes
  open Docstrings

  type lid = Longident.t loc
  type str = string loc
  type loc = Location.t
  type attrs = attribute list

  (** {2 Default locations} *)

  val default_loc: loc ref
      (** Default value for all optional location arguments. *)

  val with_default_loc: loc -> (unit -> 'a) -> 'a
      (** Set the [default_loc] within the scope of the execution
          of the provided function. *)

  (** {2 Core language} *)

  (** Type expressions *)
  module Typ :
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> core_type_desc -> core_type
      val attr: core_type -> attribute -> core_type

      val any: ?loc:loc -> ?attrs:attrs -> unit -> core_type
      val var: ?loc:loc -> ?attrs:attrs -> string -> core_type
      val arrow: ?loc:loc -> ?attrs:attrs -> label -> core_type -> core_type
                 -> core_type
      val tuple: ?loc:loc -> ?attrs:attrs -> core_type list -> core_type
      val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> core_type
      val object_: ?loc:loc -> ?attrs:attrs ->
                    (string * attributes * core_type) list -> closed_flag ->
                    core_type
      val class_: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> core_type
      val alias: ?loc:loc -> ?attrs:attrs -> core_type -> string -> core_type
      val variant: ?loc:loc -> ?attrs:attrs -> row_field list -> closed_flag
                   -> label list option -> core_type
      val poly: ?loc:loc -> ?attrs:attrs -> string list -> core_type -> core_type
      val package: ?loc:loc -> ?attrs:attrs -> lid -> (lid * core_type) list
                   -> core_type
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> core_type

      val force_poly: core_type -> core_type
    end

  (** Patterns *)
  module Pat:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> pattern_desc -> pattern
      val attr:pattern -> attribute -> pattern

      val any: ?loc:loc -> ?attrs:attrs -> unit -> pattern
      val var: ?loc:loc -> ?attrs:attrs -> str -> pattern
      val alias: ?loc:loc -> ?attrs:attrs -> pattern -> str -> pattern
      val constant: ?loc:loc -> ?attrs:attrs -> constant -> pattern
      val interval: ?loc:loc -> ?attrs:attrs -> constant -> constant -> pattern
      val tuple: ?loc:loc -> ?attrs:attrs -> pattern list -> pattern
      val construct: ?loc:loc -> ?attrs:attrs -> lid -> pattern option -> pattern
      val variant: ?loc:loc -> ?attrs:attrs -> label -> pattern option -> pattern
      val record: ?loc:loc -> ?attrs:attrs -> (lid * pattern) list -> closed_flag
                  -> pattern
      val array: ?loc:loc -> ?attrs:attrs -> pattern list -> pattern
      val or_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern -> pattern
      val constraint_: ?loc:loc -> ?attrs:attrs -> pattern -> core_type -> pattern
      val type_: ?loc:loc -> ?attrs:attrs -> lid -> pattern
      val lazy_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern
      val unpack: ?loc:loc -> ?attrs:attrs -> str -> pattern
      val exception_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> pattern
    end

  (** Expressions *)
  module Exp:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> expression_desc -> expression
      val attr: expression -> attribute -> expression

      val ident: ?loc:loc -> ?attrs:attrs -> lid -> expression
      val constant: ?loc:loc -> ?attrs:attrs -> constant -> expression
      val let_: ?loc:loc -> ?attrs:attrs -> rec_flag -> value_binding list
                -> expression -> expression
      val fun_: ?loc:loc -> ?attrs:attrs -> label -> expression option -> pattern
                -> expression -> expression
      val function_: ?loc:loc -> ?attrs:attrs -> case list -> expression
      val apply: ?loc:loc -> ?attrs:attrs -> expression
                 -> (label * expression) list -> expression
      val match_: ?loc:loc -> ?attrs:attrs -> expression -> case list
                  -> expression
      val try_: ?loc:loc -> ?attrs:attrs -> expression -> case list -> expression
      val tuple: ?loc:loc -> ?attrs:attrs -> expression list -> expression
      val construct: ?loc:loc -> ?attrs:attrs -> lid -> expression option
                     -> expression
      val variant: ?loc:loc -> ?attrs:attrs -> label -> expression option
                   -> expression
      val record: ?loc:loc -> ?attrs:attrs -> (lid * expression) list
                  -> expression option -> expression
      val field: ?loc:loc -> ?attrs:attrs -> expression -> lid -> expression
      val setfield: ?loc:loc -> ?attrs:attrs -> expression -> lid -> expression
                    -> expression
      val array: ?loc:loc -> ?attrs:attrs -> expression list -> expression
      val ifthenelse: ?loc:loc -> ?attrs:attrs -> expression -> expression
                      -> expression option -> expression
      val sequence: ?loc:loc -> ?attrs:attrs -> expression -> expression
                    -> expression
      val while_: ?loc:loc -> ?attrs:attrs -> expression -> expression
                  -> expression
      val for_: ?loc:loc -> ?attrs:attrs -> pattern -> expression -> expression
                -> direction_flag -> expression -> expression
      val coerce: ?loc:loc -> ?attrs:attrs -> expression -> core_type option
                  -> core_type -> expression
      val constraint_: ?loc:loc -> ?attrs:attrs -> expression -> core_type
                       -> expression
      val send: ?loc:loc -> ?attrs:attrs -> expression -> string -> expression
      val new_: ?loc:loc -> ?attrs:attrs -> lid -> expression
      val setinstvar: ?loc:loc -> ?attrs:attrs -> str -> expression -> expression
      val override: ?loc:loc -> ?attrs:attrs -> (str * expression) list
                    -> expression
      val letmodule: ?loc:loc -> ?attrs:attrs -> str -> module_expr -> expression
                     -> expression
      val assert_: ?loc:loc -> ?attrs:attrs -> expression -> expression
      val lazy_: ?loc:loc -> ?attrs:attrs -> expression -> expression
      val poly: ?loc:loc -> ?attrs:attrs -> expression -> core_type option -> expression
      val object_: ?loc:loc -> ?attrs:attrs -> class_structure -> expression
      val newtype: ?loc:loc -> ?attrs:attrs -> string -> expression -> expression
      val pack: ?loc:loc -> ?attrs:attrs -> module_expr -> expression
      val open_: ?loc:loc -> ?attrs:attrs -> override_flag -> lid -> expression -> expression
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> expression

      val case: pattern -> ?guard:expression -> expression -> case
    end

  (** Value declarations *)
  module Val:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs ->
        ?prim:string list -> str -> core_type -> value_description
    end

  (** Type declarations *)
  module Type:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        ?params:(core_type * variance) list -> ?cstrs:(core_type * core_type * loc) list ->
        ?kind:type_kind -> ?priv:private_flag -> ?manifest:core_type -> str ->
        type_declaration

      val constructor: ?loc:loc -> ?attrs:attrs -> ?info:info ->
        ?args:core_type list -> ?res:core_type -> str -> constructor_declaration
      val field: ?loc:loc -> ?attrs:attrs -> ?info:info ->
        ?mut:mutable_flag -> str -> core_type -> label_declaration
    end

  (** Type extensions *)
  module Te:
    sig
      val mk: ?attrs:attrs -> ?docs:docs ->
        ?params:(core_type * variance) list -> ?priv:private_flag ->
        lid -> extension_constructor list -> type_extension

      val constructor: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->
        str -> extension_constructor_kind -> extension_constructor

      val decl: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->
        ?args:core_type list -> ?res:core_type -> str -> extension_constructor
      val rebind: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->
        str -> lid -> extension_constructor
    end

  (** {2 Module language} *)

  (** Module type expressions *)
  module Mty:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> module_type_desc -> module_type
      val attr: module_type -> attribute -> module_type

      val ident: ?loc:loc -> ?attrs:attrs -> lid -> module_type
      val alias: ?loc:loc -> ?attrs:attrs -> lid -> module_type
      val signature: ?loc:loc -> ?attrs:attrs -> signature -> module_type
      val functor_: ?loc:loc -> ?attrs:attrs ->
        str -> module_type option -> module_type -> module_type
      val with_: ?loc:loc -> ?attrs:attrs -> module_type -> with_constraint list -> module_type
      val typeof_: ?loc:loc -> ?attrs:attrs -> module_expr -> module_type
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> module_type
    end

  (** Module expressions *)
  module Mod:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> module_expr_desc -> module_expr
      val attr: module_expr -> attribute -> module_expr

      val ident: ?loc:loc -> ?attrs:attrs -> lid -> module_expr
      val structure: ?loc:loc -> ?attrs:attrs -> structure -> module_expr
      val functor_: ?loc:loc -> ?attrs:attrs ->
        str -> module_type option -> module_expr -> module_expr
      val apply: ?loc:loc -> ?attrs:attrs -> module_expr -> module_expr -> module_expr
      val constraint_: ?loc:loc -> ?attrs:attrs -> module_expr -> module_type -> module_expr
      val unpack: ?loc:loc -> ?attrs:attrs -> expression -> module_expr
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> module_expr
    end

  (** Signature items *)
  module Sig:
    sig
      val mk: ?loc:loc -> signature_item_desc -> signature_item

      val value: ?loc:loc -> value_description -> signature_item
      val type_: ?loc:loc -> type_declaration list -> signature_item
      val type_extension: ?loc:loc -> type_extension -> signature_item
      val exception_: ?loc:loc -> extension_constructor -> signature_item
      val module_: ?loc:loc -> module_declaration -> signature_item
      val rec_module: ?loc:loc -> module_declaration list -> signature_item
      val modtype: ?loc:loc -> module_type_declaration -> signature_item
      val open_: ?loc:loc -> open_description -> signature_item
      val include_: ?loc:loc -> include_description -> signature_item
      val class_: ?loc:loc -> class_description list -> signature_item
      val class_type: ?loc:loc -> class_type_declaration list -> signature_item
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> signature_item
      val attribute: ?loc:loc -> attribute -> signature_item
      val text: text -> signature_item list
    end

  (** Structure items *)
  module Str:
    sig
      val mk: ?loc:loc -> structure_item_desc -> structure_item

      val eval: ?loc:loc -> ?attrs:attributes -> expression -> structure_item
      val value: ?loc:loc -> rec_flag -> value_binding list -> structure_item
      val primitive: ?loc:loc -> value_description -> structure_item
      val type_: ?loc:loc -> type_declaration list -> structure_item
      val type_extension: ?loc:loc -> type_extension -> structure_item
      val exception_: ?loc:loc -> extension_constructor -> structure_item
      val module_: ?loc:loc -> module_binding -> structure_item
      val rec_module: ?loc:loc -> module_binding list -> structure_item
      val modtype: ?loc:loc -> module_type_declaration -> structure_item
      val open_: ?loc:loc -> open_description -> structure_item
      val class_: ?loc:loc -> class_declaration list -> structure_item
      val class_type: ?loc:loc -> class_type_declaration list -> structure_item
      val include_: ?loc:loc -> include_declaration -> structure_item
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> structure_item
      val attribute: ?loc:loc -> attribute -> structure_item
      val text: text -> structure_item list
    end

  (** Module declarations *)
  module Md:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        str -> module_type -> module_declaration
    end

  (** Module type declarations *)
  module Mtd:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        ?typ:module_type -> str -> module_type_declaration
    end

  (** Module bindings *)
  module Mb:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        str -> module_expr -> module_binding
    end

  (* Opens *)
  module Opn:
    sig
      val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs ->
        ?override:override_flag -> lid -> open_description
    end

  (* Includes *)
  module Incl:
    sig
      val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs -> 'a -> 'a include_infos
    end

  (** Value bindings *)

  module Vb:
    sig
      val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        pattern -> expression -> value_binding
    end


  (** {2 Class language} *)

  (** Class type expressions *)
  module Cty:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> class_type_desc -> class_type
      val attr: class_type -> attribute -> class_type

      val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> class_type
      val signature: ?loc:loc -> ?attrs:attrs -> class_signature -> class_type
      val arrow: ?loc:loc -> ?attrs:attrs -> label -> core_type -> class_type -> class_type
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_type
    end

  (** Class type fields *)
  module Ctf:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs ->
        class_type_field_desc -> class_type_field
      val attr: class_type_field -> attribute -> class_type_field

      val inherit_: ?loc:loc -> ?attrs:attrs -> class_type -> class_type_field
      val val_: ?loc:loc -> ?attrs:attrs -> string -> mutable_flag -> virtual_flag -> core_type -> class_type_field
      val method_: ?loc:loc -> ?attrs:attrs -> string -> private_flag -> virtual_flag -> core_type -> class_type_field
      val constraint_: ?loc:loc -> ?attrs:attrs -> core_type -> core_type -> class_type_field
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_type_field
      val attribute: ?loc:loc -> attribute -> class_type_field
      val text: text -> class_type_field list
    end

  (** Class expressions *)
  module Cl:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> class_expr_desc -> class_expr
      val attr: class_expr -> attribute -> class_expr

      val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> class_expr
      val structure: ?loc:loc -> ?attrs:attrs -> class_structure -> class_expr
      val fun_: ?loc:loc -> ?attrs:attrs -> label -> expression option -> pattern -> class_expr -> class_expr
      val apply: ?loc:loc -> ?attrs:attrs -> class_expr -> (label * expression) list -> class_expr
      val let_: ?loc:loc -> ?attrs:attrs -> rec_flag -> value_binding list -> class_expr -> class_expr
      val constraint_: ?loc:loc -> ?attrs:attrs -> class_expr -> class_type -> class_expr
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_expr
    end

  (** Class fields *)
  module Cf:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> class_field_desc -> class_field
      val attr: class_field -> attribute -> class_field

      val inherit_: ?loc:loc -> ?attrs:attrs -> override_flag -> class_expr -> string option -> class_field
      val val_: ?loc:loc -> ?attrs:attrs -> str -> mutable_flag -> class_field_kind -> class_field
      val method_: ?loc:loc -> ?attrs:attrs -> str -> private_flag -> class_field_kind -> class_field
      val constraint_: ?loc:loc -> ?attrs:attrs -> core_type -> core_type -> class_field
      val initializer_: ?loc:loc -> ?attrs:attrs -> expression -> class_field
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_field
      val attribute: ?loc:loc -> attribute -> class_field
      val text: text -> class_field list

      val virtual_: core_type -> class_field_kind
      val concrete: override_flag -> expression -> class_field_kind

    end

  (** Classes *)
  module Ci:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        ?virt:virtual_flag -> ?params:(core_type * variance) list ->
        str -> 'a -> 'a class_infos
    end

  (** Class signatures *)
  module Csig:
    sig
      val mk: core_type -> class_type_field list -> class_signature
    end

  (** Class structures *)
  module Cstr:
    sig
      val mk: pattern -> class_field list -> class_structure
    end

end = struct
  (** Helpers to produce Parsetree fragments *)

  open Asttypes
  open Parsetree
  open Docstrings

  type lid = Longident.t loc
  type str = string loc
  type loc = Location.t
  type attrs = attribute list

  let default_loc = ref Location.none

  let with_default_loc l f =
    let old = !default_loc in
    default_loc := l;
    try let r = f () in default_loc := old; r
    with exn -> default_loc := old; raise exn

  module Typ = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {ptyp_desc = d; ptyp_loc = loc; ptyp_attributes = attrs}
    let attr d a = {d with ptyp_attributes = d.ptyp_attributes @ [a]}

    let any ?loc ?attrs () = mk ?loc ?attrs Ptyp_any
    let var ?loc ?attrs a = mk ?loc ?attrs (Ptyp_var a)
    let arrow ?loc ?attrs a b c = mk ?loc ?attrs (Ptyp_arrow (a, b, c))
    let tuple ?loc ?attrs a = mk ?loc ?attrs (Ptyp_tuple a)
    let constr ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_constr (a, b))
    let object_ ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_object (a, b))
    let class_ ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_class (a, b))
    let alias ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_alias (a, b))
    let variant ?loc ?attrs a b c = mk ?loc ?attrs (Ptyp_variant (a, b, c))
    let poly ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_poly (a, b))
    let package ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_package (a, b))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Ptyp_extension a)

    let force_poly t =
      match t.ptyp_desc with
      | Ptyp_poly _ -> t
      | _ -> poly ~loc:t.ptyp_loc [] t (* -> ghost? *)
  end

  module Pat = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {ppat_desc = d; ppat_loc = loc; ppat_attributes = attrs}
    let attr d a = {d with ppat_attributes = d.ppat_attributes @ [a]}

    let any ?loc ?attrs () = mk ?loc ?attrs Ppat_any
    let var ?loc ?attrs a = mk ?loc ?attrs (Ppat_var a)
    let alias ?loc ?attrs a b = mk ?loc ?attrs (Ppat_alias (a, b))
    let constant ?loc ?attrs a = mk ?loc ?attrs (Ppat_constant a)
    let interval ?loc ?attrs a b = mk ?loc ?attrs (Ppat_interval (a, b))
    let tuple ?loc ?attrs a = mk ?loc ?attrs (Ppat_tuple a)
    let construct ?loc ?attrs a b = mk ?loc ?attrs (Ppat_construct (a, b))
    let variant ?loc ?attrs a b = mk ?loc ?attrs (Ppat_variant (a, b))
    let record ?loc ?attrs a b = mk ?loc ?attrs (Ppat_record (a, b))
    let array ?loc ?attrs a = mk ?loc ?attrs (Ppat_array a)
    let or_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_or (a, b))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_constraint (a, b))
    let type_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_type a)
    let lazy_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_lazy a)
    let unpack ?loc ?attrs a = mk ?loc ?attrs (Ppat_unpack a)
    let exception_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_exception a)
    let extension ?loc ?attrs a = mk ?loc ?attrs (Ppat_extension a)
  end

  module Exp = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {pexp_desc = d; pexp_loc = loc; pexp_attributes = attrs}
    let attr d a = {d with pexp_attributes = d.pexp_attributes @ [a]}

    let ident ?loc ?attrs a = mk ?loc ?attrs (Pexp_ident a)
    let constant ?loc ?attrs a = mk ?loc ?attrs (Pexp_constant a)
    let let_ ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_let (a, b, c))
    let fun_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pexp_fun (a, b, c, d))
    let function_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_function a)
    let apply ?loc ?attrs a b = mk ?loc ?attrs (Pexp_apply (a, b))
    let match_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_match (a, b))
    let try_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_try (a, b))
    let tuple ?loc ?attrs a = mk ?loc ?attrs (Pexp_tuple a)
    let construct ?loc ?attrs a b = mk ?loc ?attrs (Pexp_construct (a, b))
    let variant ?loc ?attrs a b = mk ?loc ?attrs (Pexp_variant (a, b))
    let record ?loc ?attrs a b = mk ?loc ?attrs (Pexp_record (a, b))
    let field ?loc ?attrs a b = mk ?loc ?attrs (Pexp_field (a, b))
    let setfield ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_setfield (a, b, c))
    let array ?loc ?attrs a = mk ?loc ?attrs (Pexp_array a)
    let ifthenelse ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_ifthenelse (a, b, c))
    let sequence ?loc ?attrs a b = mk ?loc ?attrs (Pexp_sequence (a, b))
    let while_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_while (a, b))
    let for_ ?loc ?attrs a b c d e = mk ?loc ?attrs (Pexp_for (a, b, c, d, e))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_constraint (a, b))
    let coerce ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_coerce (a, b, c))
    let send ?loc ?attrs a b = mk ?loc ?attrs (Pexp_send (a, b))
    let new_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_new a)
    let setinstvar ?loc ?attrs a b = mk ?loc ?attrs (Pexp_setinstvar (a, b))
    let override ?loc ?attrs a = mk ?loc ?attrs (Pexp_override a)
    let letmodule ?loc ?attrs a b c= mk ?loc ?attrs (Pexp_letmodule (a, b, c))
    let assert_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_assert a)
    let lazy_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_lazy a)
    let poly ?loc ?attrs a b = mk ?loc ?attrs (Pexp_poly (a, b))
    let object_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_object a)
    let newtype ?loc ?attrs a b = mk ?loc ?attrs (Pexp_newtype (a, b))
    let pack ?loc ?attrs a = mk ?loc ?attrs (Pexp_pack a)
    let open_ ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_open (a, b, c))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pexp_extension a)

    let case lhs ?guard rhs =
      {
       pc_lhs = lhs;
       pc_guard = guard;
       pc_rhs = rhs;
      }
  end

  module Mty = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {pmty_desc = d; pmty_loc = loc; pmty_attributes = attrs}
    let attr d a = {d with pmty_attributes = d.pmty_attributes @ [a]}

    let ident ?loc ?attrs a = mk ?loc ?attrs (Pmty_ident a)
    let alias ?loc ?attrs a = mk ?loc ?attrs (Pmty_alias a)
    let signature ?loc ?attrs a = mk ?loc ?attrs (Pmty_signature a)
    let functor_ ?loc ?attrs a b c = mk ?loc ?attrs (Pmty_functor (a, b, c))
    let with_ ?loc ?attrs a b = mk ?loc ?attrs (Pmty_with (a, b))
    let typeof_ ?loc ?attrs a = mk ?loc ?attrs (Pmty_typeof a)
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pmty_extension a)
  end

  module Mod = struct
  let mk ?(loc = !default_loc) ?(attrs = []) d =
    {pmod_desc = d; pmod_loc = loc; pmod_attributes = attrs}
    let attr d a = {d with pmod_attributes = d.pmod_attributes @ [a]}

    let ident ?loc ?attrs x = mk ?loc ?attrs (Pmod_ident x)
    let structure ?loc ?attrs x = mk ?loc ?attrs (Pmod_structure x)
    let functor_ ?loc ?attrs arg arg_ty body =
      mk ?loc ?attrs (Pmod_functor (arg, arg_ty, body))
    let apply ?loc ?attrs m1 m2 = mk ?loc ?attrs (Pmod_apply (m1, m2))
    let constraint_ ?loc ?attrs m mty = mk ?loc ?attrs (Pmod_constraint (m, mty))
    let unpack ?loc ?attrs e = mk ?loc ?attrs (Pmod_unpack e)
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pmod_extension a)
  end

  module Sig = struct
    let mk ?(loc = !default_loc) d = {psig_desc = d; psig_loc = loc}

    let value ?loc a = mk ?loc (Psig_value a)
    let type_ ?loc a = mk ?loc (Psig_type a)
    let type_extension ?loc a = mk ?loc (Psig_typext a)
    let exception_ ?loc a = mk ?loc (Psig_exception a)
    let module_ ?loc a = mk ?loc (Psig_module a)
    let rec_module ?loc a = mk ?loc (Psig_recmodule a)
    let modtype ?loc a = mk ?loc (Psig_modtype a)
    let open_ ?loc a = mk ?loc (Psig_open a)
    let include_ ?loc a = mk ?loc (Psig_include a)
    let class_ ?loc a = mk ?loc (Psig_class a)
    let class_type ?loc a = mk ?loc (Psig_class_type a)
    let extension ?loc ?(attrs = []) a = mk ?loc (Psig_extension (a, attrs))
    let attribute ?loc a = mk ?loc (Psig_attribute a)
    let text txt =
      List.map
        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
        txt
  end

  module Str = struct
    let mk ?(loc = !default_loc) d = {pstr_desc = d; pstr_loc = loc}

    let eval ?loc ?(attrs = []) a = mk ?loc (Pstr_eval (a, attrs))
    let value ?loc a b = mk ?loc (Pstr_value (a, b))
    let primitive ?loc a = mk ?loc (Pstr_primitive a)
    let type_ ?loc a = mk ?loc (Pstr_type a)
    let type_extension ?loc a = mk ?loc (Pstr_typext a)
    let exception_ ?loc a = mk ?loc (Pstr_exception a)
    let module_ ?loc a = mk ?loc (Pstr_module a)
    let rec_module ?loc a = mk ?loc (Pstr_recmodule a)
    let modtype ?loc a = mk ?loc (Pstr_modtype a)
    let open_ ?loc a = mk ?loc (Pstr_open a)
    let class_ ?loc a = mk ?loc (Pstr_class a)
    let class_type ?loc a = mk ?loc (Pstr_class_type a)
    let include_ ?loc a = mk ?loc (Pstr_include a)
    let extension ?loc ?(attrs = []) a = mk ?loc (Pstr_extension (a, attrs))
    let attribute ?loc a = mk ?loc (Pstr_attribute a)
    let text txt =
      List.map
        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
        txt
  end

  module Cl = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {
       pcl_desc = d;
       pcl_loc = loc;
       pcl_attributes = attrs;
      }
    let attr d a = {d with pcl_attributes = d.pcl_attributes @ [a]}

    let constr ?loc ?attrs a b = mk ?loc ?attrs (Pcl_constr (a, b))
    let structure ?loc ?attrs a = mk ?loc ?attrs (Pcl_structure a)
    let fun_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pcl_fun (a, b, c, d))
    let apply ?loc ?attrs a b = mk ?loc ?attrs (Pcl_apply (a, b))
    let let_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcl_let (a, b, c))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pcl_constraint (a, b))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pcl_extension a)
  end

  module Cty = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {
       pcty_desc = d;
       pcty_loc = loc;
       pcty_attributes = attrs;
      }
    let attr d a = {d with pcty_attributes = d.pcty_attributes @ [a]}

    let constr ?loc ?attrs a b = mk ?loc ?attrs (Pcty_constr (a, b))
    let signature ?loc ?attrs a = mk ?loc ?attrs (Pcty_signature a)
    let arrow ?loc ?attrs a b c = mk ?loc ?attrs (Pcty_arrow (a, b, c))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pcty_extension a)
  end

  module Ctf = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
             ?(docs = empty_docs) d =
      {
       pctf_desc = d;
       pctf_loc = loc;
       pctf_attributes = add_docs_attrs docs attrs;
      }

    let inherit_ ?loc ?attrs a = mk ?loc ?attrs (Pctf_inherit a)
    let val_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pctf_val (a, b, c, d))
    let method_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pctf_method (a, b, c, d))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pctf_constraint (a, b))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pctf_extension a)
    let attribute ?loc a = mk ?loc (Pctf_attribute a)
    let text txt =
      List.map
        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
        txt

    let attr d a = {d with pctf_attributes = d.pctf_attributes @ [a]}

  end

  module Cf = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) d =
      {
       pcf_desc = d;
       pcf_loc = loc;
       pcf_attributes = add_docs_attrs docs attrs;
      }

    let inherit_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_inherit (a, b, c))
    let val_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_val (a, b, c))
    let method_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_method (a, b, c))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pcf_constraint (a, b))
    let initializer_ ?loc ?attrs a = mk ?loc ?attrs (Pcf_initializer a)
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pcf_extension a)
    let attribute ?loc a = mk ?loc (Pcf_attribute a)
    let text txt =
      List.map
        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
        txt

    let virtual_ ct = Cfk_virtual ct
    let concrete o e = Cfk_concrete (o, e)

    let attr d a = {d with pcf_attributes = d.pcf_attributes @ [a]}

  end

  module Val = struct
    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
          ?(prim = []) name typ =
      {
       pval_name = name;
       pval_type = typ;
       pval_attributes = add_docs_attrs docs attrs;
       pval_loc = loc;
       pval_prim = prim;
      }
  end

  module Md = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = []) name typ =
      {
       pmd_name = name;
       pmd_type = typ;
       pmd_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pmd_loc = loc;
      }
  end

  module Mtd = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = []) ?typ name =
      {
       pmtd_name = name;
       pmtd_type = typ;
       pmtd_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pmtd_loc = loc;
      }
  end

  module Mb = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = []) name expr =
      {
       pmb_name = name;
       pmb_expr = expr;
       pmb_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pmb_loc = loc;
      }
  end

  module Opn = struct
    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
          ?(override = Fresh) lid =
      {
       popen_lid = lid;
       popen_override = override;
       popen_loc = loc;
       popen_attributes = add_docs_attrs docs attrs;
      }
  end

  module Incl = struct
    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs) mexpr =
      {
       pincl_mod = mexpr;
       pincl_loc = loc;
       pincl_attributes = add_docs_attrs docs attrs;
      }

  end

  module Vb = struct
    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
          ?(text = []) pat expr =
      {
       pvb_pat = pat;
       pvb_expr = expr;
       pvb_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pvb_loc = loc;
      }
  end

  module Ci = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = [])
          ?(virt = Concrete) ?(params = []) name expr =
      {
       pci_virt = virt;
       pci_params = params;
       pci_name = name;
       pci_expr = expr;
       pci_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pci_loc = loc;
      }
  end

  module Type = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = [])
        ?(params = [])
        ?(cstrs = [])
        ?(kind = Ptype_abstract)
        ?(priv = Public)
        ?manifest
        name =
      {
       ptype_name = name;
       ptype_params = params;
       ptype_cstrs = cstrs;
       ptype_kind = kind;
       ptype_private = priv;
       ptype_manifest = manifest;
       ptype_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       ptype_loc = loc;
      }

    let constructor ?(loc = !default_loc) ?(attrs = []) ?(info = empty_info)
          ?(args = []) ?res name =
      {
       pcd_name = name;
       pcd_args = args;
       pcd_res = res;
       pcd_loc = loc;
       pcd_attributes = add_info_attrs info attrs;
      }

    let field ?(loc = !default_loc) ?(attrs = []) ?(info = empty_info)
          ?(mut = Immutable) name typ =
      {
       pld_name = name;
       pld_mutable = mut;
       pld_type = typ;
       pld_loc = loc;
       pld_attributes = add_info_attrs info attrs;
      }

  end

  (** Type extensions *)
  module Te = struct
    let mk ?(attrs = []) ?(docs = empty_docs)
          ?(params = []) ?(priv = Public) path constructors =
      {
       ptyext_path = path;
       ptyext_params = params;
       ptyext_constructors = constructors;
       ptyext_private = priv;
       ptyext_attributes = add_docs_attrs docs attrs;
      }

    let constructor ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(info = empty_info) name kind =
      {
       pext_name = name;
       pext_kind = kind;
       pext_loc = loc;
       pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);
      }

    let decl ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(info = empty_info) ?(args = []) ?res name =
      {
       pext_name = name;
       pext_kind = Pext_decl(args, res);
       pext_loc = loc;
       pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);
      }

    let rebind ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(info = empty_info) name lid =
      {
       pext_name = name;
       pext_kind = Pext_rebind lid;
       pext_loc = loc;
       pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);
      }

  end

  module Csig = struct
    let mk self fields =
      {
       pcsig_self = self;
       pcsig_fields = fields;
      }
  end

  module Cstr = struct
    let mk self fields =
      {
       pcstr_self = self;
       pcstr_fields = fields;
      }
  end

end

module Ast_mapper : sig
  (** The interface of a -ppx rewriter

    A -ppx rewriter is a program that accepts a serialized abstract syntax
    tree and outputs another, possibly modified, abstract syntax tree.
    This module encapsulates the interface between the compiler and
    the -ppx rewriters, handling such details as the serialization format,
    forwarding of command-line flags, and storing state.

    {!mapper} allows to implement AST rewriting using open recursion.
    A typical mapper would be based on {!default_mapper}, a deep
    identity mapper, and will fall back on it for handling the syntax it
    does not modify. For example:

    {[
  open Asttypes
  open Parsetree
  open Ast_mapper

  let test_mapper argv =
    { default_mapper with
      expr = fun mapper expr ->
        match expr with
        | { pexp_desc = Pexp_extension ({ txt = "test" }, PStr [])} ->
          Ast_helper.Exp.constant (Const_int 42)
        | other -> default_mapper.expr mapper other; }

  let () =
    register "ppx_test" test_mapper]}

    This -ppx rewriter, which replaces [[%test]] in expressions with
    the constant [42], can be compiled using
    [ocamlc -o ppx_test -I +compiler-libs ocamlcommon.cma ppx_test.ml].

    *)

  open Parsetree

  (** {2 A generic Parsetree mapper} *)

  type mapper              = Ast_mapper.mapper   = {
    attribute: mapper -> attribute -> attribute;
    attributes: mapper -> attribute list -> attribute list;
    case: mapper -> case -> case;
    cases: mapper -> case list -> case list;
    class_declaration: mapper -> class_declaration -> class_declaration;
    class_description: mapper -> class_description -> class_description;
    class_expr: mapper -> class_expr -> class_expr;
    class_field: mapper -> class_field -> class_field;
    class_signature: mapper -> class_signature -> class_signature;
    class_structure: mapper -> class_structure -> class_structure;
    class_type: mapper -> class_type -> class_type;
    class_type_declaration: mapper -> class_type_declaration
                            -> class_type_declaration;
    class_type_field: mapper -> class_type_field -> class_type_field;
    constructor_declaration: mapper -> constructor_declaration
                             -> constructor_declaration;
    expr: mapper -> expression -> expression;
    extension: mapper -> extension -> extension;
    extension_constructor: mapper -> extension_constructor
                           -> extension_constructor;
    include_declaration: mapper -> include_declaration -> include_declaration;
    include_description: mapper -> include_description -> include_description;
    label_declaration: mapper -> label_declaration -> label_declaration;
    location: mapper -> Location.t -> Location.t;
    module_binding: mapper -> module_binding -> module_binding;
    module_declaration: mapper -> module_declaration -> module_declaration;
    module_expr: mapper -> module_expr -> module_expr;
    module_type: mapper -> module_type -> module_type;
    module_type_declaration: mapper -> module_type_declaration
                             -> module_type_declaration;
    open_description: mapper -> open_description -> open_description;
    pat: mapper -> pattern -> pattern;
    payload: mapper -> payload -> payload;
    signature: mapper -> signature -> signature;
    signature_item: mapper -> signature_item -> signature_item;
    structure: mapper -> structure -> structure;
    structure_item: mapper -> structure_item -> structure_item;
    typ: mapper -> core_type -> core_type;
    type_declaration: mapper -> type_declaration -> type_declaration;
    type_extension: mapper -> type_extension -> type_extension;
    type_kind: mapper -> type_kind -> type_kind;
    value_binding: mapper -> value_binding -> value_binding;
    value_description: mapper -> value_description -> value_description;
    with_constraint: mapper -> with_constraint -> with_constraint;
  }
  (** A mapper record implements one "method" per syntactic category,
      using an open recursion style: each method takes as its first
      argument the mapper to be applied to children in the syntax
      tree. *)

  val default_mapper: mapper
  (** A default mapper, which implements a "deep identity" mapping. *)

  (** {2 Convenience functions to write mappers} *)

  val map_opt: ('a -> 'b) -> 'a option -> 'b option

  val extension_of_error: Location.error -> extension
  (** Encode an error into an 'ocaml.error' extension node which can be
      inserted in a generated Parsetree.  The compiler will be
      responsible for reporting the error. *)

  val attribute_of_warning: Location.t -> string -> attribute
  (** Encode a warning message into an 'ocaml.ppwarning' attribute which can be
      inserted in a generated Parsetree.  The compiler will be
      responsible for reporting the warning. *)

end = struct
  (* A generic Parsetree mapping class *)

  (*
  [@@@ocaml.warning "+9"]
    (* Ensure that record patterns don't miss any field. *)
  *)


  open Parsetree
  open Ast_helper
  open Location

  type mapper              = Ast_mapper.mapper   = {
    attribute: mapper -> attribute -> attribute;
    attributes: mapper -> attribute list -> attribute list;
    case: mapper -> case -> case;
    cases: mapper -> case list -> case list;
    class_declaration: mapper -> class_declaration -> class_declaration;
    class_description: mapper -> class_description -> class_description;
    class_expr: mapper -> class_expr -> class_expr;
    class_field: mapper -> class_field -> class_field;
    class_signature: mapper -> class_signature -> class_signature;
    class_structure: mapper -> class_structure -> class_structure;
    class_type: mapper -> class_type -> class_type;
    class_type_declaration: mapper -> class_type_declaration
                            -> class_type_declaration;
    class_type_field: mapper -> class_type_field -> class_type_field;
    constructor_declaration: mapper -> constructor_declaration
                             -> constructor_declaration;
    expr: mapper -> expression -> expression;
    extension: mapper -> extension -> extension;
    extension_constructor: mapper -> extension_constructor
                           -> extension_constructor;
    include_declaration: mapper -> include_declaration -> include_declaration;
    include_description: mapper -> include_description -> include_description;
    label_declaration: mapper -> label_declaration -> label_declaration;
    location: mapper -> Location.t -> Location.t;
    module_binding: mapper -> module_binding -> module_binding;
    module_declaration: mapper -> module_declaration -> module_declaration;
    module_expr: mapper -> module_expr -> module_expr;
    module_type: mapper -> module_type -> module_type;
    module_type_declaration: mapper -> module_type_declaration
                             -> module_type_declaration;
    open_description: mapper -> open_description -> open_description;
    pat: mapper -> pattern -> pattern;
    payload: mapper -> payload -> payload;
    signature: mapper -> signature -> signature;
    signature_item: mapper -> signature_item -> signature_item;
    structure: mapper -> structure -> structure;
    structure_item: mapper -> structure_item -> structure_item;
    typ: mapper -> core_type -> core_type;
    type_declaration: mapper -> type_declaration -> type_declaration;
    type_extension: mapper -> type_extension -> type_extension;
    type_kind: mapper -> type_kind -> type_kind;
    value_binding: mapper -> value_binding -> value_binding;
    value_description: mapper -> value_description -> value_description;
    with_constraint: mapper -> with_constraint -> with_constraint;
  }

  let map_fst f (x, y) = (f x, y)
  let map_snd f (x, y) = (x, f y)
  let map_tuple f1 f2 (x, y) = (f1 x, f2 y)
  let map_tuple3 f1 f2 f3 (x, y, z) = (f1 x, f2 y, f3 z)
  let map_opt f = function None -> None | Some x -> Some (f x)

  let map_loc sub {loc; txt} = {loc = sub.location sub loc; txt}

  module T = struct
    (* Type expressions for the core language *)

    let row_field sub = function
      | Rtag (l, attrs, b, tl) ->
          Rtag (l, sub.attributes sub attrs, b, List.map (sub.typ sub) tl)
      | Rinherit t -> Rinherit (sub.typ sub t)

    let map sub {ptyp_desc = desc; ptyp_loc = loc; ptyp_attributes = attrs} =
      let open Typ in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Ptyp_any -> any ~loc ~attrs ()
      | Ptyp_var s -> var ~loc ~attrs s
      | Ptyp_arrow (lab, t1, t2) ->
          arrow ~loc ~attrs lab (sub.typ sub t1) (sub.typ sub t2)
      | Ptyp_tuple tyl -> tuple ~loc ~attrs (List.map (sub.typ sub) tyl)
      | Ptyp_constr (lid, tl) ->
          constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tl)
      | Ptyp_object (l, o) ->
          let f (s, a, t) = (s, sub.attributes sub a, sub.typ sub t) in
          object_ ~loc ~attrs (List.map f l) o
      | Ptyp_class (lid, tl) ->
          class_ ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tl)
      | Ptyp_alias (t, s) -> alias ~loc ~attrs (sub.typ sub t) s
      | Ptyp_variant (rl, b, ll) ->
          variant ~loc ~attrs (List.map (row_field sub) rl) b ll
      | Ptyp_poly (sl, t) -> poly ~loc ~attrs sl (sub.typ sub t)
      | Ptyp_package (lid, l) ->
          package ~loc ~attrs (map_loc sub lid)
            (List.map (map_tuple (map_loc sub) (sub.typ sub)) l)
      | Ptyp_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_type_declaration sub
        {ptype_name; ptype_params; ptype_cstrs;
         ptype_kind;
         ptype_private;
         ptype_manifest;
         ptype_attributes;
         ptype_loc} =
      Type.mk (map_loc sub ptype_name)
        ~params:(List.map (map_fst (sub.typ sub)) ptype_params)
        ~priv:ptype_private
        ~cstrs:(List.map
                  (map_tuple3 (sub.typ sub) (sub.typ sub) (sub.location sub))
                  ptype_cstrs)
        ~kind:(sub.type_kind sub ptype_kind)
        ?manifest:(map_opt (sub.typ sub) ptype_manifest)
        ~loc:(sub.location sub ptype_loc)
        ~attrs:(sub.attributes sub ptype_attributes)

    let map_type_kind sub = function
      | Ptype_abstract -> Ptype_abstract
      | Ptype_variant l ->
          Ptype_variant (List.map (sub.constructor_declaration sub) l)
      | Ptype_record l -> Ptype_record (List.map (sub.label_declaration sub) l)
      | Ptype_open -> Ptype_open

    let map_type_extension sub
        {ptyext_path; ptyext_params;
         ptyext_constructors;
         ptyext_private;
         ptyext_attributes} =
      Te.mk
        (map_loc sub ptyext_path)
        (List.map (sub.extension_constructor sub) ptyext_constructors)
        ~params:(List.map (map_fst (sub.typ sub)) ptyext_params)
        ~priv:ptyext_private
        ~attrs:(sub.attributes sub ptyext_attributes)

    let map_extension_constructor_kind sub = function
        Pext_decl(ctl, cto) ->
          Pext_decl(List.map (sub.typ sub) ctl, map_opt (sub.typ sub) cto)
      | Pext_rebind li ->
          Pext_rebind (map_loc sub li)

    let map_extension_constructor sub
        {pext_name;
         pext_kind;
         pext_loc;
         pext_attributes} =
      Te.constructor
        (map_loc sub pext_name)
        (map_extension_constructor_kind sub pext_kind)
        ~loc:(sub.location sub pext_loc)
        ~attrs:(sub.attributes sub pext_attributes)

  end

  module CT = struct
    (* Type expressions for the class language *)

    let map sub {pcty_loc = loc; pcty_desc = desc; pcty_attributes = attrs} =
      let open Cty in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pcty_constr (lid, tys) ->
          constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tys)
      | Pcty_signature x -> signature ~loc ~attrs (sub.class_signature sub x)
      | Pcty_arrow (lab, t, ct) ->
          arrow ~loc ~attrs lab (sub.typ sub t) (sub.class_type sub ct)
      | Pcty_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_field sub {pctf_desc = desc; pctf_loc = loc; pctf_attributes = attrs}
      =
      let open Ctf in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pctf_inherit ct -> inherit_ ~loc ~attrs (sub.class_type sub ct)
      | Pctf_val (s, m, v, t) -> val_ ~loc ~attrs s m v (sub.typ sub t)
      | Pctf_method (s, p, v, t) -> method_ ~loc ~attrs s p v (sub.typ sub t)
      | Pctf_constraint (t1, t2) ->
          constraint_ ~loc ~attrs (sub.typ sub t1) (sub.typ sub t2)
      | Pctf_attribute x -> attribute ~loc (sub.attribute sub x)
      | Pctf_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_signature sub {pcsig_self; pcsig_fields} =
      Csig.mk
        (sub.typ sub pcsig_self)
        (List.map (sub.class_type_field sub) pcsig_fields)
  end

  module MT = struct
    (* Type expressions for the module language *)

    let map sub {pmty_desc = desc; pmty_loc = loc; pmty_attributes = attrs} =
      let open Mty in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pmty_ident s -> ident ~loc ~attrs (map_loc sub s)
      | Pmty_alias s -> alias ~loc ~attrs (map_loc sub s)
      | Pmty_signature sg -> signature ~loc ~attrs (sub.signature sub sg)
      | Pmty_functor (s, mt1, mt2) ->
          functor_ ~loc ~attrs (map_loc sub s)
            (Misc.may_map (sub.module_type sub) mt1)
            (sub.module_type sub mt2)
      | Pmty_with (mt, l) ->
          with_ ~loc ~attrs (sub.module_type sub mt)
            (List.map (sub.with_constraint sub) l)
      | Pmty_typeof me -> typeof_ ~loc ~attrs (sub.module_expr sub me)
      | Pmty_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_with_constraint sub = function
      | Pwith_type (lid, d) ->
          Pwith_type (map_loc sub lid, sub.type_declaration sub d)
      | Pwith_module (lid, lid2) ->
          Pwith_module (map_loc sub lid, map_loc sub lid2)
      | Pwith_typesubst d -> Pwith_typesubst (sub.type_declaration sub d)
      | Pwith_modsubst (s, lid) ->
          Pwith_modsubst (map_loc sub s, map_loc sub lid)

    let map_signature_item sub {psig_desc = desc; psig_loc = loc} =
      let open Sig in
      let loc = sub.location sub loc in
      match desc with
      | Psig_value vd -> value ~loc (sub.value_description sub vd)
      | Psig_type l -> type_ ~loc (List.map (sub.type_declaration sub) l)
      | Psig_typext te -> type_extension ~loc (sub.type_extension sub te)
      | Psig_exception ed -> exception_ ~loc (sub.extension_constructor sub ed)
      | Psig_module x -> module_ ~loc (sub.module_declaration sub x)
      | Psig_recmodule l ->
          rec_module ~loc (List.map (sub.module_declaration sub) l)
      | Psig_modtype x -> modtype ~loc (sub.module_type_declaration sub x)
      | Psig_open x -> open_ ~loc (sub.open_description sub x)
      | Psig_include x -> include_ ~loc (sub.include_description sub x)
      | Psig_class l -> class_ ~loc (List.map (sub.class_description sub) l)
      | Psig_class_type l ->
          class_type ~loc (List.map (sub.class_type_declaration sub) l)
      | Psig_extension (x, attrs) ->
          extension ~loc (sub.extension sub x) ~attrs:(sub.attributes sub attrs)
      | Psig_attribute x -> attribute ~loc (sub.attribute sub x)
  end


  module M = struct
    (* Value expressions for the module language *)

    let map sub {pmod_loc = loc; pmod_desc = desc; pmod_attributes = attrs} =
      let open Mod in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pmod_ident x -> ident ~loc ~attrs (map_loc sub x)
      | Pmod_structure str -> structure ~loc ~attrs (sub.structure sub str)
      | Pmod_functor (arg, arg_ty, body) ->
          functor_ ~loc ~attrs (map_loc sub arg)
            (Misc.may_map (sub.module_type sub) arg_ty)
            (sub.module_expr sub body)
      | Pmod_apply (m1, m2) ->
          apply ~loc ~attrs (sub.module_expr sub m1) (sub.module_expr sub m2)
      | Pmod_constraint (m, mty) ->
          constraint_ ~loc ~attrs (sub.module_expr sub m)
                      (sub.module_type sub mty)
      | Pmod_unpack e -> unpack ~loc ~attrs (sub.expr sub e)
      | Pmod_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_structure_item sub {pstr_loc = loc; pstr_desc = desc} =
      let open Str in
      let loc = sub.location sub loc in
      match desc with
      | Pstr_eval (x, attrs) ->
          eval ~loc ~attrs:(sub.attributes sub attrs) (sub.expr sub x)
      | Pstr_value (r, vbs) -> value ~loc r (List.map (sub.value_binding sub) vbs)
      | Pstr_primitive vd -> primitive ~loc (sub.value_description sub vd)
      | Pstr_type l -> type_ ~loc (List.map (sub.type_declaration sub) l)
      | Pstr_typext te -> type_extension ~loc (sub.type_extension sub te)
      | Pstr_exception ed -> exception_ ~loc (sub.extension_constructor sub ed)
      | Pstr_module x -> module_ ~loc (sub.module_binding sub x)
      | Pstr_recmodule l -> rec_module ~loc (List.map (sub.module_binding sub) l)
      | Pstr_modtype x -> modtype ~loc (sub.module_type_declaration sub x)
      | Pstr_open x -> open_ ~loc (sub.open_description sub x)
      | Pstr_class l -> class_ ~loc (List.map (sub.class_declaration sub) l)
      | Pstr_class_type l ->
          class_type ~loc (List.map (sub.class_type_declaration sub) l)
      | Pstr_include x -> include_ ~loc (sub.include_declaration sub x)
      | Pstr_extension (x, attrs) ->
          extension ~loc (sub.extension sub x) ~attrs:(sub.attributes sub attrs)
      | Pstr_attribute x -> attribute ~loc (sub.attribute sub x)
  end

  module E = struct
    (* Value expressions for the core language *)

    let map sub {pexp_loc = loc; pexp_desc = desc; pexp_attributes = attrs} =
      let open Exp in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pexp_ident x -> ident ~loc ~attrs (map_loc sub x)
      | Pexp_constant x -> constant ~loc ~attrs x
      | Pexp_let (r, vbs, e) ->
          let_ ~loc ~attrs r (List.map (sub.value_binding sub) vbs)
            (sub.expr sub e)
      | Pexp_fun (lab, def, p, e) ->
          fun_ ~loc ~attrs lab (map_opt (sub.expr sub) def) (sub.pat sub p)
            (sub.expr sub e)
      | Pexp_function pel -> function_ ~loc ~attrs (sub.cases sub pel)
      | Pexp_apply (e, l) ->
          apply ~loc ~attrs (sub.expr sub e) (List.map (map_snd (sub.expr sub)) l)
      | Pexp_match (e, pel) ->
          match_ ~loc ~attrs (sub.expr sub e) (sub.cases sub pel)
      | Pexp_try (e, pel) -> try_ ~loc ~attrs (sub.expr sub e) (sub.cases sub pel)
      | Pexp_tuple el -> tuple ~loc ~attrs (List.map (sub.expr sub) el)
      | Pexp_construct (lid, arg) ->
          construct ~loc ~attrs (map_loc sub lid) (map_opt (sub.expr sub) arg)
      | Pexp_variant (lab, eo) ->
          variant ~loc ~attrs lab (map_opt (sub.expr sub) eo)
      | Pexp_record (l, eo) ->
          record ~loc ~attrs (List.map (map_tuple (map_loc sub) (sub.expr sub)) l)
            (map_opt (sub.expr sub) eo)
      | Pexp_field (e, lid) ->
          field ~loc ~attrs (sub.expr sub e) (map_loc sub lid)
      | Pexp_setfield (e1, lid, e2) ->
          setfield ~loc ~attrs (sub.expr sub e1) (map_loc sub lid)
            (sub.expr sub e2)
      | Pexp_array el -> array ~loc ~attrs (List.map (sub.expr sub) el)
      | Pexp_ifthenelse (e1, e2, e3) ->
          ifthenelse ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)
            (map_opt (sub.expr sub) e3)
      | Pexp_sequence (e1, e2) ->
          sequence ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)
      | Pexp_while (e1, e2) ->
          while_ ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)
      | Pexp_for (p, e1, e2, d, e3) ->
          for_ ~loc ~attrs (sub.pat sub p) (sub.expr sub e1) (sub.expr sub e2) d
            (sub.expr sub e3)
      | Pexp_coerce (e, t1, t2) ->
          coerce ~loc ~attrs (sub.expr sub e) (map_opt (sub.typ sub) t1)
            (sub.typ sub t2)
      | Pexp_constraint (e, t) ->
          constraint_ ~loc ~attrs (sub.expr sub e) (sub.typ sub t)
      | Pexp_send (e, s) -> send ~loc ~attrs (sub.expr sub e) s
      | Pexp_new lid -> new_ ~loc ~attrs (map_loc sub lid)
      | Pexp_setinstvar (s, e) ->
          setinstvar ~loc ~attrs (map_loc sub s) (sub.expr sub e)
      | Pexp_override sel ->
          override ~loc ~attrs
            (List.map (map_tuple (map_loc sub) (sub.expr sub)) sel)
      | Pexp_letmodule (s, me, e) ->
          letmodule ~loc ~attrs (map_loc sub s) (sub.module_expr sub me)
            (sub.expr sub e)
      | Pexp_assert e -> assert_ ~loc ~attrs (sub.expr sub e)
      | Pexp_lazy e -> lazy_ ~loc ~attrs (sub.expr sub e)
      | Pexp_poly (e, t) ->
          poly ~loc ~attrs (sub.expr sub e) (map_opt (sub.typ sub) t)
      | Pexp_object cls -> object_ ~loc ~attrs (sub.class_structure sub cls)
      | Pexp_newtype (s, e) -> newtype ~loc ~attrs s (sub.expr sub e)
      | Pexp_pack me -> pack ~loc ~attrs (sub.module_expr sub me)
      | Pexp_open (ovf, lid, e) ->
          open_ ~loc ~attrs ovf (map_loc sub lid) (sub.expr sub e)
      | Pexp_extension x -> extension ~loc ~attrs (sub.extension sub x)
  end

  module P = struct
    (* Patterns *)

    let map sub {ppat_desc = desc; ppat_loc = loc; ppat_attributes = attrs} =
      let open Pat in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Ppat_any -> any ~loc ~attrs ()
      | Ppat_var s -> var ~loc ~attrs (map_loc sub s)
      | Ppat_alias (p, s) -> alias ~loc ~attrs (sub.pat sub p) (map_loc sub s)
      | Ppat_constant c -> constant ~loc ~attrs c
      | Ppat_interval (c1, c2) -> interval ~loc ~attrs c1 c2
      | Ppat_tuple pl -> tuple ~loc ~attrs (List.map (sub.pat sub) pl)
      | Ppat_construct (l, p) ->
          construct ~loc ~attrs (map_loc sub l) (map_opt (sub.pat sub) p)
      | Ppat_variant (l, p) -> variant ~loc ~attrs l (map_opt (sub.pat sub) p)
      | Ppat_record (lpl, cf) ->
          record ~loc ~attrs
                 (List.map (map_tuple (map_loc sub) (sub.pat sub)) lpl) cf
      | Ppat_array pl -> array ~loc ~attrs (List.map (sub.pat sub) pl)
      | Ppat_or (p1, p2) -> or_ ~loc ~attrs (sub.pat sub p1) (sub.pat sub p2)
      | Ppat_constraint (p, t) ->
          constraint_ ~loc ~attrs (sub.pat sub p) (sub.typ sub t)
      | Ppat_type s -> type_ ~loc ~attrs (map_loc sub s)
      | Ppat_lazy p -> lazy_ ~loc ~attrs (sub.pat sub p)
      | Ppat_unpack s -> unpack ~loc ~attrs (map_loc sub s)
      | Ppat_exception p -> exception_ ~loc ~attrs (sub.pat sub p)
      | Ppat_extension x -> extension ~loc ~attrs (sub.extension sub x)
  end

  module CE = struct
    (* Value expressions for the class language *)

    let map sub {pcl_loc = loc; pcl_desc = desc; pcl_attributes = attrs} =
      let open Cl in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pcl_constr (lid, tys) ->
          constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tys)
      | Pcl_structure s ->
          structure ~loc ~attrs (sub.class_structure sub s)
      | Pcl_fun (lab, e, p, ce) ->
          fun_ ~loc ~attrs lab
            (map_opt (sub.expr sub) e)
            (sub.pat sub p)
            (sub.class_expr sub ce)
      | Pcl_apply (ce, l) ->
          apply ~loc ~attrs (sub.class_expr sub ce)
            (List.map (map_snd (sub.expr sub)) l)
      | Pcl_let (r, vbs, ce) ->
          let_ ~loc ~attrs r (List.map (sub.value_binding sub) vbs)
            (sub.class_expr sub ce)
      | Pcl_constraint (ce, ct) ->
          constraint_ ~loc ~attrs (sub.class_expr sub ce) (sub.class_type sub ct)
      | Pcl_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_kind sub = function
      | Cfk_concrete (o, e) -> Cfk_concrete (o, sub.expr sub e)
      | Cfk_virtual t -> Cfk_virtual (sub.typ sub t)

    let map_field sub {pcf_desc = desc; pcf_loc = loc; pcf_attributes = attrs} =
      let open Cf in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pcf_inherit (o, ce, s) -> inherit_ ~loc ~attrs o (sub.class_expr sub ce) s
      | Pcf_val (s, m, k) -> val_ ~loc ~attrs (map_loc sub s) m (map_kind sub k)
      | Pcf_method (s, p, k) ->
          method_ ~loc ~attrs (map_loc sub s) p (map_kind sub k)
      | Pcf_constraint (t1, t2) ->
          constraint_ ~loc ~attrs (sub.typ sub t1) (sub.typ sub t2)
      | Pcf_initializer e -> initializer_ ~loc ~attrs (sub.expr sub e)
      | Pcf_attribute x -> attribute ~loc (sub.attribute sub x)
      | Pcf_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_structure sub {pcstr_self; pcstr_fields} =
      {
        pcstr_self = sub.pat sub pcstr_self;
        pcstr_fields = List.map (sub.class_field sub) pcstr_fields;
      }

    let class_infos sub f {pci_virt; pci_params = pl; pci_name; pci_expr;
                           pci_loc; pci_attributes} =
      Ci.mk
       ~virt:pci_virt
       ~params:(List.map (map_fst (sub.typ sub)) pl)
        (map_loc sub pci_name)
        (f pci_expr)
        ~loc:(sub.location sub pci_loc)
        ~attrs:(sub.attributes sub pci_attributes)
  end

  (* Now, a generic AST mapper, to be extended to cover all kinds and
     cases of the OCaml grammar.  The default behavior of the mapper is
     the identity. *)

  let default_mapper =
    {
      structure = (fun this l -> List.map (this.structure_item this) l);
      structure_item = M.map_structure_item;
      module_expr = M.map;
      signature = (fun this l -> List.map (this.signature_item this) l);
      signature_item = MT.map_signature_item;
      module_type = MT.map;
      with_constraint = MT.map_with_constraint;
      class_declaration =
        (fun this -> CE.class_infos this (this.class_expr this));
      class_expr = CE.map;
      class_field = CE.map_field;
      class_structure = CE.map_structure;
      class_type = CT.map;
      class_type_field = CT.map_field;
      class_signature = CT.map_signature;
      class_type_declaration =
        (fun this -> CE.class_infos this (this.class_type this));
      class_description =
        (fun this -> CE.class_infos this (this.class_type this));
      type_declaration = T.map_type_declaration;
      type_kind = T.map_type_kind;
      typ = T.map;
      type_extension = T.map_type_extension;
      extension_constructor = T.map_extension_constructor;
      value_description =
        (fun this {pval_name; pval_type; pval_prim; pval_loc;
                   pval_attributes} ->
          Val.mk
            (map_loc this pval_name)
            (this.typ this pval_type)
            ~attrs:(this.attributes this pval_attributes)
            ~loc:(this.location this pval_loc)
            ~prim:pval_prim
        );

      pat = P.map;
      expr = E.map;

      module_declaration =
        (fun this {pmd_name; pmd_type; pmd_attributes; pmd_loc} ->
           Md.mk
             (map_loc this pmd_name)
             (this.module_type this pmd_type)
             ~attrs:(this.attributes this pmd_attributes)
             ~loc:(this.location this pmd_loc)
        );

      module_type_declaration =
        (fun this {pmtd_name; pmtd_type; pmtd_attributes; pmtd_loc} ->
           Mtd.mk
             (map_loc this pmtd_name)
             ?typ:(map_opt (this.module_type this) pmtd_type)
             ~attrs:(this.attributes this pmtd_attributes)
             ~loc:(this.location this pmtd_loc)
        );

      module_binding =
        (fun this {pmb_name; pmb_expr; pmb_attributes; pmb_loc} ->
           Mb.mk (map_loc this pmb_name) (this.module_expr this pmb_expr)
             ~attrs:(this.attributes this pmb_attributes)
             ~loc:(this.location this pmb_loc)
        );


      open_description =
        (fun this {popen_lid; popen_override; popen_attributes; popen_loc} ->
           Opn.mk (map_loc this popen_lid)
             ~override:popen_override
             ~loc:(this.location this popen_loc)
             ~attrs:(this.attributes this popen_attributes)
        );


      include_description =
        (fun this {pincl_mod; pincl_attributes; pincl_loc} ->
           Incl.mk (this.module_type this pincl_mod)
             ~loc:(this.location this pincl_loc)
             ~attrs:(this.attributes this pincl_attributes)
        );

      include_declaration =
        (fun this {pincl_mod; pincl_attributes; pincl_loc} ->
           Incl.mk (this.module_expr this pincl_mod)
             ~loc:(this.location this pincl_loc)
             ~attrs:(this.attributes this pincl_attributes)
        );


      value_binding =
        (fun this {pvb_pat; pvb_expr; pvb_attributes; pvb_loc} ->
           Vb.mk
             (this.pat this pvb_pat)
             (this.expr this pvb_expr)
             ~loc:(this.location this pvb_loc)
             ~attrs:(this.attributes this pvb_attributes)
        );


      constructor_declaration =
        (fun this {pcd_name; pcd_args; pcd_res; pcd_loc; pcd_attributes} ->
          Type.constructor
            (map_loc this pcd_name)
            ~args:(List.map (this.typ this) pcd_args)
            ?res:(map_opt (this.typ this) pcd_res)
            ~loc:(this.location this pcd_loc)
            ~attrs:(this.attributes this pcd_attributes)
        );

      label_declaration =
        (fun this {pld_name; pld_type; pld_loc; pld_mutable; pld_attributes} ->
           Type.field
             (map_loc this pld_name)
             (this.typ this pld_type)
             ~mut:pld_mutable
             ~loc:(this.location this pld_loc)
             ~attrs:(this.attributes this pld_attributes)
        );

      cases = (fun this l -> List.map (this.case this) l);
      case =
        (fun this {pc_lhs; pc_guard; pc_rhs} ->
           {
             pc_lhs = this.pat this pc_lhs;
             pc_guard = map_opt (this.expr this) pc_guard;
             pc_rhs = this.expr this pc_rhs;
           }
        );



      location = (fun _this l -> l);

      extension = (fun this (s, e) -> (map_loc this s, this.payload this e));
      attribute = (fun this (s, e) -> (map_loc this s, this.payload this e));
      attributes = (fun this l -> List.map (this.attribute this) l);
      payload =
        (fun this -> function
           | PStr x -> PStr (this.structure this x)
           | PTyp x -> PTyp (this.typ this x)
           | PPat (x, g) -> PPat (this.pat this x, map_opt (this.expr this) g)
        );
    }

  let rec extension_of_error {loc; msg; if_highlight; sub} =
    { loc; txt = "ocaml.error" },
    PStr ([Str.eval (Exp.constant (Asttypes.Const_string (msg, None)));
           Str.eval (Exp.constant (Asttypes.Const_string (if_highlight, None)))] @
          (List.map (fun ext -> Str.extension (extension_of_error ext)) sub))

  let attribute_of_warning loc s =
    { loc; txt = "ocaml.ppwarning" },
    PStr ([Str.eval ~loc (Exp.constant (Asttypes.Const_string (s, None)))])
end

module Outcometree = struct
  (* Module [Outcometree]: results displayed by the toplevel *)

  (* These types represent messages that the toplevel displays as normal
     results or errors. The real displaying is customisable using the hooks:
        [Toploop.print_out_value]
        [Toploop.print_out_type]
        [Toploop.print_out_sig_item]
        [Toploop.print_out_phrase] *)

  type out_ident              = Outcometree.out_ident    =
    | Oide_apply of out_ident * out_ident
    | Oide_dot of out_ident * string
    | Oide_ident of string

  type out_value              = Outcometree.out_value    =
    | Oval_array of out_value list
    | Oval_char of char
    | Oval_constr of out_ident * out_value list
    | Oval_ellipsis
    | Oval_float of float
    | Oval_int of int
    | Oval_int32 of int32
    | Oval_int64 of int64
    | Oval_nativeint of nativeint
    | Oval_list of out_value list
    | Oval_printer of (Format.formatter -> unit)
    | Oval_record of (out_ident * out_value) list
    | Oval_string of string
    | Oval_stuff of string
    | Oval_tuple of out_value list
    | Oval_variant of string * out_value option

  type out_type              = Outcometree.out_type    =
    | Otyp_abstract
    | Otyp_open
    | Otyp_alias of out_type * string
    | Otyp_arrow of string * out_type * out_type
    | Otyp_class of bool * out_ident * out_type list
    | Otyp_constr of out_ident * out_type list
    | Otyp_manifest of out_type * out_type
    | Otyp_object of (string * out_type) list * bool option
    | Otyp_record of (string * bool * out_type) list
    | Otyp_stuff of string
    | Otyp_sum of (string * out_type list * out_type option) list
    | Otyp_tuple of out_type list
    | Otyp_var of bool * string
    | Otyp_variant of
        bool * out_variant * bool * (string list) option
    | Otyp_poly of string list * out_type
    | Otyp_module of string * string list * out_type list

  and out_variant              = Outcometree.out_variant    =
    | Ovar_fields of (string * bool * out_type list) list
    | Ovar_name of out_ident * out_type list

  type out_class_type              = Outcometree.out_class_type    =
    | Octy_constr of out_ident * out_type list
    | Octy_arrow of string * out_type * out_class_type
    | Octy_signature of out_type option * out_class_sig_item list
  and out_class_sig_item               = Outcometree.out_class_sig_item    =
    | Ocsg_constraint of out_type * out_type
    | Ocsg_method of string * bool * bool * out_type
    | Ocsg_value of string * bool * bool * out_type

  type out_module_type              = Outcometree.out_module_type    =
    | Omty_abstract
    | Omty_functor of string * out_module_type option * out_module_type
    | Omty_ident of out_ident
    | Omty_signature of out_sig_item list
    | Omty_alias of out_ident
  and out_sig_item               = Outcometree.out_sig_item    =
    | Osig_class of
        bool * string * (string * (bool * bool)) list * out_class_type *
          out_rec_status
    | Osig_class_type of
        bool * string * (string * (bool * bool)) list * out_class_type *
          out_rec_status
    | Osig_typext of out_extension_constructor * out_ext_status
    | Osig_modtype of string * out_module_type
    | Osig_module of string * out_module_type * out_rec_status
    | Osig_type of out_type_decl * out_rec_status
    | Osig_value of string * out_type * string list
  and out_type_decl               = Outcometree.out_type_decl    =
    { otype_name: string;
      otype_params: (string * (bool * bool)) list;
      otype_type: out_type;
      otype_private: Asttypes.private_flag;
      otype_cstrs: (out_type * out_type) list }
  and out_extension_constructor              = Outcometree.out_extension_constructor    =
    { oext_name: string;
      oext_type_name: string;
      oext_type_params: string list;
      oext_args: out_type list;
      oext_ret_type: out_type option;
      oext_private: Asttypes.private_flag }
  and out_type_extension              = Outcometree.out_type_extension    =
    { otyext_name: string;
      otyext_params: string list;
      otyext_constructors: (string * out_type list * out_type option) list;
      otyext_private: Asttypes.private_flag }
  and out_rec_status              = Outcometree.out_rec_status    =
    | Orec_not
    | Orec_first
    | Orec_next
  and out_ext_status              = Outcometree.out_ext_status   =
    | Oext_first
    | Oext_next
    | Oext_exception

  type out_phrase              = Outcometree.out_phrase    =
    | Ophr_eval of out_value * out_type
    | Ophr_signature of (out_sig_item * out_value option) list
    | Ophr_exception of (exn * out_value)

end

module Config = struct
  let ast_impl_magic_number = "Caml1999M016"
  let ast_intf_magic_number = "Caml1999N015"
end

let map_signature mapper = mapper.Ast_mapper.signature mapper
let map_structure mapper = mapper.Ast_mapper.structure mapper

let shallow_identity =
  let id _ x = x in
  {
    Ast_mapper.
    structure               = id;
    structure_item          = id;
    module_expr             = id;
    signature               = id;
    signature_item          = id;
    module_type             = id;
    with_constraint         = id;
    class_declaration       = id;
    class_expr              = id;
    class_field             = id;
    class_structure         = id;
    class_type              = id;
    class_type_field        = id;
    class_signature         = id;
    class_type_declaration  = id;
    class_description       = id;
    type_declaration        = id;
    type_kind               = id;
    typ                     = id;
    type_extension          = id;
    extension_constructor   = id;
    value_description       = id;
    pat                     = id;
    expr                    = id;
    module_declaration      = id;
    module_type_declaration = id;
    module_binding          = id;
    open_description        = id;
    include_description     = id;
    include_declaration     = id;
    value_binding           = id;
    constructor_declaration = id;
    label_declaration       = id;
    cases                   = id;
    case                    = id;
    location                = id;
    extension               = id;
    attribute               = id;
    attributes              = id;
    payload                 = id;
  }

let failing_mapper =
  let fail _ _ =
    invalid_arg "failing_mapper: this mapper function should never get called"
  in
  {
    Ast_mapper.
    structure               = fail;
    structure_item          = fail;
    module_expr             = fail;
    signature               = fail;
    signature_item          = fail;
    module_type             = fail;
    with_constraint         = fail;
    class_declaration       = fail;
    class_expr              = fail;
    class_field             = fail;
    class_structure         = fail;
    class_type              = fail;
    class_type_field        = fail;
    class_signature         = fail;
    class_type_declaration  = fail;
    class_description       = fail;
    type_declaration        = fail;
    type_kind               = fail;
    typ                     = fail;
    type_extension          = fail;
    extension_constructor   = fail;
    value_description       = fail;
    pat                     = fail;
    expr                    = fail;
    module_declaration      = fail;
    module_type_declaration = fail;
    module_binding          = fail;
    open_description        = fail;
    include_description     = fail;
    include_declaration     = fail;
    value_binding           = fail;
    constructor_declaration = fail;
    label_declaration       = fail;
    cases                   = fail;
    case                    = fail;
    location                = fail;
    extension               = fail;
    attribute               = fail;
    attributes              = fail;
    payload                 = fail;
  }

let make_top_mapper ~signature ~structure =
  {failing_mapper with Ast_mapper.
                    signature = (fun _ x -> signature x);
                    structure = (fun _ x -> structure x) }

end
module Ast_403
= struct
#1 "ast_403.ml"
# 1 "src/ast_403.ml"
# 1 "src/ast_403.ml"
# 1 "src/ast_403.ml"
# 1 "src/ast_403.ml"
# 1 "src/ast_403.ml"
# 1 "src/ast_403.ml"
# 1 "src/ast_403.ml"
# 1 "src/ast_403.ml"
# 1 "src/ast_403.ml"
# 1 "src/ast_403.ml"
# 1 "src/ast_403.ml"
# 1 "src/ast_403.ml"
# 1 "src/ast_403.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*            Jérémie Dimino and Leo White, Jane Street Europe            *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt            *)
(*                         Alain Frisch, LexiFi                           *)
(*       Daniel de Rauglaudre, projet Cristal, INRIA Rocquencourt         *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

module Location = Location
module Longident = Longident

module Asttypes = struct
  (* Auxiliary a.s.t. types used by parsetree and typedtree. *)

  type constant (*IF_CURRENT = Asttypes.constant *) =
      Const_int of int
    | Const_char of char
    | Const_string of string * string option
    | Const_float of string
    | Const_int32 of int32
    | Const_int64 of int64
    | Const_nativeint of nativeint

  type rec_flag (*IF_CURRENT = Asttypes.rec_flag *) = Nonrecursive | Recursive

  type direction_flag (*IF_CURRENT = Asttypes.direction_flag *) = Upto | Downto

  (* Order matters, used in polymorphic comparison *)
  type private_flag (*IF_CURRENT = Asttypes.private_flag *) = Private | Public

  type mutable_flag (*IF_CURRENT = Asttypes.mutable_flag *) = Immutable | Mutable

  type virtual_flag (*IF_CURRENT = Asttypes.virtual_flag *) = Virtual | Concrete

  type override_flag (*IF_CURRENT = Asttypes.override_flag *) = Override | Fresh

  type closed_flag (*IF_CURRENT = Asttypes.closed_flag *) = Closed | Open

  type label = string

  type arg_label (*IF_CURRENT = Asttypes.arg_label *) =
      Nolabel
    | Labelled of string (*  label:T -> ... *)
    | Optional of string (* ?label:T -> ... *)

  type 'a loc = 'a Location.loc = {
    txt : 'a;
    loc : Location.t;
  }


  type variance (*IF_CURRENT = Asttypes.variance *) =
    | Covariant
    | Contravariant
    | Invariant
end

module Parsetree = struct
  (** Abstract syntax tree produced by parsing *)

  open Asttypes

  type constant (*IF_CURRENT = Parsetree.constant *) =
      Pconst_integer of string * char option
    (* 3 3l 3L 3n

       Suffixes [g-z][G-Z] are accepted by the parser.
       Suffixes except 'l', 'L' and 'n' are rejected by the typechecker
    *)
    | Pconst_char of char
    (* 'c' *)
    | Pconst_string of string * string option
    (* "constant"
       {delim|other constant|delim}
    *)
    | Pconst_float of string * char option
    (* 3.4 2e5 1.4e-4

       Suffixes [g-z][G-Z] are accepted by the parser.
       Suffixes are rejected by the typechecker.
    *)

  (** {2 Extension points} *)

  type attribute = string loc * payload
         (* [@id ARG]
            [@@id ARG]

            Metadata containers passed around within the AST.
            The compiler ignores unknown attributes.
         *)

  and extension = string loc * payload
        (* [%id ARG]
           [%%id ARG]

           Sub-language placeholder -- rejected by the typechecker.
        *)

  and attributes = attribute list

  and payload (*IF_CURRENT = Parsetree.payload *) =
    | PStr of structure
    | PSig of signature (* : SIG *)
    | PTyp of core_type  (* : T *)
    | PPat of pattern * expression option  (* ? P  or  ? P when E *)

  (** {2 Core language} *)

  (* Type expressions *)

  and core_type (*IF_CURRENT = Parsetree.core_type *) =
      {
       ptyp_desc: core_type_desc;
       ptyp_loc: Location.t;
       ptyp_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and core_type_desc (*IF_CURRENT = Parsetree.core_type_desc *) =
    | Ptyp_any
          (*  _ *)
    | Ptyp_var of string
          (* 'a *)
    | Ptyp_arrow of arg_label * core_type * core_type
          (* T1 -> T2       Simple
             ~l:T1 -> T2    Labelled
             ?l:T1 -> T2    Otional
           *)
    | Ptyp_tuple of core_type list
          (* T1 * ... * Tn

             Invariant: n >= 2
          *)
    | Ptyp_constr of Longident.t loc * core_type list
          (* tconstr
             T tconstr
             (T1, ..., Tn) tconstr
           *)
    | Ptyp_object of (string * attributes * core_type) list * closed_flag
          (* < l1:T1; ...; ln:Tn >     (flag = Closed)
             < l1:T1; ...; ln:Tn; .. > (flag = Open)
           *)
    | Ptyp_class of Longident.t loc * core_type list
          (* #tconstr
             T #tconstr
             (T1, ..., Tn) #tconstr
           *)
    | Ptyp_alias of core_type * string
          (* T as 'a *)
    | Ptyp_variant of row_field list * closed_flag * label list option
          (* [ `A|`B ]         (flag = Closed; labels = None)
             [> `A|`B ]        (flag = Open;   labels = None)
             [< `A|`B ]        (flag = Closed; labels = Some [])
             [< `A|`B > `X `Y ](flag = Closed; labels = Some ["X";"Y"])
           *)
    | Ptyp_poly of string list * core_type
          (* 'a1 ... 'an. T

             Can only appear in the following context:

             - As the core_type of a Ppat_constraint node corresponding
               to a constraint on a let-binding: let x : 'a1 ... 'an. T
               = e ...

             - Under Cfk_virtual for methods (not values).

             - As the core_type of a Pctf_method node.

             - As the core_type of a Pexp_poly node.

             - As the pld_type field of a label_declaration.

             - As a core_type of a Ptyp_object node.
           *)

    | Ptyp_package of package_type
          (* (module S) *)
    | Ptyp_extension of extension
          (* [%id] *)

  and package_type = Longident.t loc * (Longident.t loc * core_type) list
        (*
          (module S)
          (module S with type t1 = T1 and ... and tn = Tn)
         *)

  and row_field (*IF_CURRENT = Parsetree.row_field *) =
    | Rtag of label * attributes * bool * core_type list
          (* [`A]                   ( true,  [] )
             [`A of T]              ( false, [T] )
             [`A of T1 & .. & Tn]   ( false, [T1;...Tn] )
             [`A of & T1 & .. & Tn] ( true,  [T1;...Tn] )

            - The 2nd field is true if the tag contains a
              constant (empty) constructor.
            - '&' occurs when several types are used for the same constructor
              (see 4.2 in the manual)

            - TODO: switch to a record representation, and keep location
          *)
    | Rinherit of core_type
          (* [ T ] *)

  (* Patterns *)

  and pattern (*IF_CURRENT = Parsetree.pattern *) =
      {
       ppat_desc: pattern_desc;
       ppat_loc: Location.t;
       ppat_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and pattern_desc (*IF_CURRENT = Parsetree.pattern_desc *) =
    | Ppat_any
          (* _ *)
    | Ppat_var of string loc
          (* x *)
    | Ppat_alias of pattern * string loc
          (* P as 'a *)
    | Ppat_constant of constant
          (* 1, 'a', "true", 1.0, 1l, 1L, 1n *)
    | Ppat_interval of constant * constant
          (* 'a'..'z'

             Other forms of interval are recognized by the parser
             but rejected by the type-checker. *)
    | Ppat_tuple of pattern list
          (* (P1, ..., Pn)

             Invariant: n >= 2
          *)
    | Ppat_construct of Longident.t loc * pattern option
          (* C                None
             C P              Some P
             C (P1, ..., Pn)  Some (Ppat_tuple [P1; ...; Pn])
           *)
    | Ppat_variant of label * pattern option
          (* `A             (None)
             `A P           (Some P)
           *)
    | Ppat_record of (Longident.t loc * pattern) list * closed_flag
          (* { l1=P1; ...; ln=Pn }     (flag = Closed)
             { l1=P1; ...; ln=Pn; _}   (flag = Open)

             Invariant: n > 0
           *)
    | Ppat_array of pattern list
          (* [| P1; ...; Pn |] *)
    | Ppat_or of pattern * pattern
          (* P1 | P2 *)
    | Ppat_constraint of pattern * core_type
          (* (P : T) *)
    | Ppat_type of Longident.t loc
          (* #tconst *)
    | Ppat_lazy of pattern
          (* lazy P *)
    | Ppat_unpack of string loc
          (* (module P)
             Note: (module P : S) is represented as
             Ppat_constraint(Ppat_unpack, Ptyp_package)
           *)
    | Ppat_exception of pattern
          (* exception P *)
    | Ppat_extension of extension
          (* [%id] *)

  (* Value expressions *)

  and expression (*IF_CURRENT = Parsetree.expression *) =
      {
       pexp_desc: expression_desc;
       pexp_loc: Location.t;
       pexp_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and expression_desc (*IF_CURRENT = Parsetree.expression_desc *) =
    | Pexp_ident of Longident.t loc
          (* x
             M.x
           *)
    | Pexp_constant of constant
          (* 1, 'a', "true", 1.0, 1l, 1L, 1n *)
    | Pexp_let of rec_flag * value_binding list * expression
          (* let P1 = E1 and ... and Pn = EN in E       (flag = Nonrecursive)
             let rec P1 = E1 and ... and Pn = EN in E   (flag = Recursive)
           *)
    | Pexp_function of case list
          (* function P1 -> E1 | ... | Pn -> En *)
    | Pexp_fun of arg_label * expression option * pattern * expression
          (* fun P -> E1                          (Simple, None)
             fun ~l:P -> E1                       (Labelled l, None)
             fun ?l:P -> E1                       (Optional l, None)
             fun ?l:(P = E0) -> E1                (Optional l, Some E0)

             Notes:
             - If E0 is provided, only Optional is allowed.
             - "fun P1 P2 .. Pn -> E1" is represented as nested Pexp_fun.
             - "let f P = E" is represented using Pexp_fun.
           *)
    | Pexp_apply of expression * (arg_label * expression) list
          (* E0 ~l1:E1 ... ~ln:En
             li can be empty (non labeled argument) or start with '?'
             (optional argument).

             Invariant: n > 0
           *)
    | Pexp_match of expression * case list
          (* match E0 with P1 -> E1 | ... | Pn -> En *)
    | Pexp_try of expression * case list
          (* try E0 with P1 -> E1 | ... | Pn -> En *)
    | Pexp_tuple of expression list
          (* (E1, ..., En)

             Invariant: n >= 2
          *)
    | Pexp_construct of Longident.t loc * expression option
          (* C                None
             C E              Some E
             C (E1, ..., En)  Some (Pexp_tuple[E1;...;En])
          *)
    | Pexp_variant of label * expression option
          (* `A             (None)
             `A E           (Some E)
           *)
    | Pexp_record of (Longident.t loc * expression) list * expression option
          (* { l1=P1; ...; ln=Pn }     (None)
             { E0 with l1=P1; ...; ln=Pn }   (Some E0)

             Invariant: n > 0
           *)
    | Pexp_field of expression * Longident.t loc
          (* E.l *)
    | Pexp_setfield of expression * Longident.t loc * expression
          (* E1.l <- E2 *)
    | Pexp_array of expression list
          (* [| E1; ...; En |] *)
    | Pexp_ifthenelse of expression * expression * expression option
          (* if E1 then E2 else E3 *)
    | Pexp_sequence of expression * expression
          (* E1; E2 *)
    | Pexp_while of expression * expression
          (* while E1 do E2 done *)
    | Pexp_for of
        pattern *  expression * expression * direction_flag * expression
          (* for i = E1 to E2 do E3 done      (flag = Upto)
             for i = E1 downto E2 do E3 done  (flag = Downto)
           *)
    | Pexp_constraint of expression * core_type
          (* (E : T) *)
    | Pexp_coerce of expression * core_type option * core_type
          (* (E :> T)        (None, T)
             (E : T0 :> T)   (Some T0, T)
           *)
    | Pexp_send of expression * string
          (*  E # m *)
    | Pexp_new of Longident.t loc
          (* new M.c *)
    | Pexp_setinstvar of string loc * expression
          (* x <- 2 *)
    | Pexp_override of (string loc * expression) list
          (* {< x1 = E1; ...; Xn = En >} *)
    | Pexp_letmodule of string loc * module_expr * expression
          (* let module M = ME in E *)
    | Pexp_assert of expression
          (* assert E
             Note: "assert false" is treated in a special way by the
             type-checker. *)
    | Pexp_lazy of expression
          (* lazy E *)
    | Pexp_poly of expression * core_type option
          (* Used for method bodies.

             Can only be used as the expression under Cfk_concrete
             for methods (not values). *)
    | Pexp_object of class_structure
          (* object ... end *)
    | Pexp_newtype of string * expression
          (* fun (type t) -> E *)
    | Pexp_pack of module_expr
          (* (module ME)

             (module ME : S) is represented as
             Pexp_constraint(Pexp_pack, Ptyp_package S) *)
    | Pexp_open of override_flag * Longident.t loc * expression
          (* let open M in E
             let! open M in E
          *)
    | Pexp_extension of extension
          (* [%id] *)
    | Pexp_unreachable
          (* . *)

  and case (*IF_CURRENT = Parsetree.case *) =   (* (P -> E) or (P when E0 -> E) *)
      {
       pc_lhs: pattern;
       pc_guard: expression option;
       pc_rhs: expression;
      }

  (* Value descriptions *)

  and value_description (*IF_CURRENT = Parsetree.value_description *) =
      {
       pval_name: string loc;
       pval_type: core_type;
       pval_prim: string list;
       pval_attributes: attributes;  (* ... [@@id1] [@@id2] *)
       pval_loc: Location.t;
      }

  (*
    val x: T                            (prim = [])
    external x: T = "s1" ... "sn"       (prim = ["s1";..."sn"])
  *)

  (* Type declarations *)

  and type_declaration (*IF_CURRENT = Parsetree.type_declaration *) =
      {
       ptype_name: string loc;
       ptype_params: (core_type * variance) list;
             (* ('a1,...'an) t; None represents  _*)
       ptype_cstrs: (core_type * core_type * Location.t) list;
             (* ... constraint T1=T1'  ... constraint Tn=Tn' *)
       ptype_kind: type_kind;
       ptype_private: private_flag;   (* = private ... *)
       ptype_manifest: core_type option;  (* = T *)
       ptype_attributes: attributes;   (* ... [@@id1] [@@id2] *)
       ptype_loc: Location.t;
      }

  (*
    type t                     (abstract, no manifest)
    type t = T0                (abstract, manifest=T0)
    type t = C of T | ...      (variant,  no manifest)
    type t = T0 = C of T | ... (variant,  manifest=T0)
    type t = {l: T; ...}       (record,   no manifest)
    type t = T0 = {l : T; ...} (record,   manifest=T0)
    type t = ..                (open,     no manifest)
  *)

  and type_kind (*IF_CURRENT = Parsetree.type_kind *) =
    | Ptype_abstract
    | Ptype_variant of constructor_declaration list
          (* Invariant: non-empty list *)
    | Ptype_record of label_declaration list
          (* Invariant: non-empty list *)
    | Ptype_open

  and label_declaration (*IF_CURRENT = Parsetree.label_declaration *) =
      {
       pld_name: string loc;
       pld_mutable: mutable_flag;
       pld_type: core_type;
       pld_loc: Location.t;
       pld_attributes: attributes; (* l [@id1] [@id2] : T *)
      }

  (*  { ...; l: T; ... }            (mutable=Immutable)
      { ...; mutable l: T; ... }    (mutable=Mutable)

      Note: T can be a Ptyp_poly.
  *)

  and constructor_declaration (*IF_CURRENT = Parsetree.constructor_declaration *) =
      {
       pcd_name: string loc;
       pcd_args: constructor_arguments;
       pcd_res: core_type option;
       pcd_loc: Location.t;
       pcd_attributes: attributes; (* C [@id1] [@id2] of ... *)
      }

  and constructor_arguments (*IF_CURRENT = Parsetree.constructor_arguments *) =
    | Pcstr_tuple of core_type list
    | Pcstr_record of label_declaration list

  (*
    | C of T1 * ... * Tn     (res = None,    args = Pcstr_tuple [])
    | C: T0                  (res = Some T0, args = [])
    | C: T1 * ... * Tn -> T0 (res = Some T0, args = Pcstr_tuple)
    | C of {...}             (res = None,    args = Pcstr_record)
    | C: {...} -> T0         (res = Some T0, args = Pcstr_record)
    | C of {...} as t        (res = None,    args = Pcstr_record)
  *)

  and type_extension (*IF_CURRENT = Parsetree.type_extension *) =
      {
       ptyext_path: Longident.t loc;
       ptyext_params: (core_type * variance) list;
       ptyext_constructors: extension_constructor list;
       ptyext_private: private_flag;
       ptyext_attributes: attributes;   (* ... [@@id1] [@@id2] *)
      }
  (*
    type t += ...
  *)

  and extension_constructor (*IF_CURRENT = Parsetree.extension_constructor *) =
      {
       pext_name: string loc;
       pext_kind : extension_constructor_kind;
       pext_loc : Location.t;
       pext_attributes: attributes; (* C [@id1] [@id2] of ... *)
      }

  and extension_constructor_kind (*IF_CURRENT = Parsetree.extension_constructor_kind *) =
      Pext_decl of constructor_arguments * core_type option
        (*
           | C of T1 * ... * Tn     ([T1; ...; Tn], None)
           | C: T0                  ([], Some T0)
           | C: T1 * ... * Tn -> T0 ([T1; ...; Tn], Some T0)
         *)
    | Pext_rebind of Longident.t loc
        (*
           | C = D
         *)

  (** {2 Class language} *)

  (* Type expressions for the class language *)

  and class_type (*IF_CURRENT = Parsetree.class_type *) =
      {
       pcty_desc: class_type_desc;
       pcty_loc: Location.t;
       pcty_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and class_type_desc (*IF_CURRENT = Parsetree.class_type_desc *) =
    | Pcty_constr of Longident.t loc * core_type list
          (* c
             ['a1, ..., 'an] c *)
    | Pcty_signature of class_signature
          (* object ... end *)
    | Pcty_arrow of arg_label * core_type * class_type
          (* T -> CT       Simple
             ~l:T -> CT    Labelled l
             ?l:T -> CT    Optional l
           *)
    | Pcty_extension of extension
          (* [%id] *)

  and class_signature (*IF_CURRENT = Parsetree.class_signature *) =
      {
       pcsig_self: core_type;
       pcsig_fields: class_type_field list;
      }
  (* object('selfpat) ... end
     object ... end             (self = Ptyp_any)
   *)

  and class_type_field (*IF_CURRENT = Parsetree.class_type_field *) =
      {
       pctf_desc: class_type_field_desc;
       pctf_loc: Location.t;
       pctf_attributes: attributes; (* ... [@@id1] [@@id2] *)
      }

  and class_type_field_desc (*IF_CURRENT = Parsetree.class_type_field_desc *) =
    | Pctf_inherit of class_type
          (* inherit CT *)
    | Pctf_val of (string * mutable_flag * virtual_flag * core_type)
          (* val x: T *)
    | Pctf_method  of (string * private_flag * virtual_flag * core_type)
          (* method x: T

             Note: T can be a Ptyp_poly.
           *)
    | Pctf_constraint  of (core_type * core_type)
          (* constraint T1 = T2 *)
    | Pctf_attribute of attribute
          (* [@@@id] *)
    | Pctf_extension of extension
          (* [%%id] *)

  and 'a class_infos (*IF_CURRENT = 'a Parsetree.class_infos *) =
      {
       pci_virt: virtual_flag;
       pci_params: (core_type * variance) list;
       pci_name: string loc;
       pci_expr: 'a;
       pci_loc: Location.t;
       pci_attributes: attributes;  (* ... [@@id1] [@@id2] *)
      }
  (* class c = ...
     class ['a1,...,'an] c = ...
     class virtual c = ...

     Also used for "class type" declaration.
  *)

  and class_description = class_type class_infos

  and class_type_declaration = class_type class_infos

  (* Value expressions for the class language *)

  and class_expr (*IF_CURRENT = Parsetree.class_expr *) =
      {
       pcl_desc: class_expr_desc;
       pcl_loc: Location.t;
       pcl_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and class_expr_desc (*IF_CURRENT = Parsetree.class_expr_desc *) =
    | Pcl_constr of Longident.t loc * core_type list
          (* c
             ['a1, ..., 'an] c *)
    | Pcl_structure of class_structure
          (* object ... end *)
    | Pcl_fun of arg_label * expression option * pattern * class_expr
          (* fun P -> CE                          (Simple, None)
             fun ~l:P -> CE                       (Labelled l, None)
             fun ?l:P -> CE                       (Optional l, None)
             fun ?l:(P = E0) -> CE                (Optional l, Some E0)
           *)
    | Pcl_apply of class_expr * (arg_label * expression) list
          (* CE ~l1:E1 ... ~ln:En
             li can be empty (non labeled argument) or start with '?'
             (optional argument).

             Invariant: n > 0
           *)
    | Pcl_let of rec_flag * value_binding list * class_expr
          (* let P1 = E1 and ... and Pn = EN in CE      (flag = Nonrecursive)
             let rec P1 = E1 and ... and Pn = EN in CE  (flag = Recursive)
           *)
    | Pcl_constraint of class_expr * class_type
          (* (CE : CT) *)
    | Pcl_extension of extension
          (* [%id] *)

  and class_structure (*IF_CURRENT = Parsetree.class_structure *) =
      {
       pcstr_self: pattern;
       pcstr_fields: class_field list;
      }
  (* object(selfpat) ... end
     object ... end           (self = Ppat_any)
   *)

  and class_field (*IF_CURRENT = Parsetree.class_field *) =
      {
       pcf_desc: class_field_desc;
       pcf_loc: Location.t;
       pcf_attributes: attributes; (* ... [@@id1] [@@id2] *)
      }

  and class_field_desc (*IF_CURRENT = Parsetree.class_field_desc *) =
    | Pcf_inherit of override_flag * class_expr * string option
          (* inherit CE
             inherit CE as x
             inherit! CE
             inherit! CE as x
           *)
    | Pcf_val of (string loc * mutable_flag * class_field_kind)
          (* val x = E
             val virtual x: T
           *)
    | Pcf_method of (string loc * private_flag * class_field_kind)
          (* method x = E            (E can be a Pexp_poly)
             method virtual x: T     (T can be a Ptyp_poly)
           *)
    | Pcf_constraint of (core_type * core_type)
          (* constraint T1 = T2 *)
    | Pcf_initializer of expression
          (* initializer E *)
    | Pcf_attribute of attribute
          (* [@@@id] *)
    | Pcf_extension of extension
          (* [%%id] *)

  and class_field_kind (*IF_CURRENT = Parsetree.class_field_kind *) =
    | Cfk_virtual of core_type
    | Cfk_concrete of override_flag * expression

  and class_declaration = class_expr class_infos

  (** {2 Module language} *)

  (* Type expressions for the module language *)

  and module_type (*IF_CURRENT = Parsetree.module_type *) =
      {
       pmty_desc: module_type_desc;
       pmty_loc: Location.t;
       pmty_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and module_type_desc (*IF_CURRENT = Parsetree.module_type_desc *) =
    | Pmty_ident of Longident.t loc
          (* S *)
    | Pmty_signature of signature
          (* sig ... end *)
    | Pmty_functor of string loc * module_type option * module_type
          (* functor(X : MT1) -> MT2 *)
    | Pmty_with of module_type * with_constraint list
          (* MT with ... *)
    | Pmty_typeof of module_expr
          (* module type of ME *)
    | Pmty_extension of extension
          (* [%id] *)
    | Pmty_alias of Longident.t loc
          (* (module M) *)

  and signature = signature_item list

  and signature_item (*IF_CURRENT = Parsetree.signature_item *) =
      {
       psig_desc: signature_item_desc;
       psig_loc: Location.t;
      }

  and signature_item_desc (*IF_CURRENT = Parsetree.signature_item_desc *) =
    | Psig_value of value_description
          (*
            val x: T
            external x: T = "s1" ... "sn"
           *)
    | Psig_type of rec_flag * type_declaration list
          (* type t1 = ... and ... and tn = ... *)
    | Psig_typext of type_extension
          (* type t1 += ... *)
    | Psig_exception of extension_constructor
          (* exception C of T *)
    | Psig_module of module_declaration
          (* module X : MT *)
    | Psig_recmodule of module_declaration list
          (* module rec X1 : MT1 and ... and Xn : MTn *)
    | Psig_modtype of module_type_declaration
          (* module type S = MT
             module type S *)
    | Psig_open of open_description
          (* open X *)
    | Psig_include of include_description
          (* include MT *)
    | Psig_class of class_description list
          (* class c1 : ... and ... and cn : ... *)
    | Psig_class_type of class_type_declaration list
          (* class type ct1 = ... and ... and ctn = ... *)
    | Psig_attribute of attribute
          (* [@@@id] *)
    | Psig_extension of extension * attributes
          (* [%%id] *)

  and module_declaration (*IF_CURRENT = Parsetree.module_declaration *) =
      {
       pmd_name: string loc;
       pmd_type: module_type;
       pmd_attributes: attributes; (* ... [@@id1] [@@id2] *)
       pmd_loc: Location.t;
      }
  (* S : MT *)

  and module_type_declaration (*IF_CURRENT = Parsetree.module_type_declaration *) =
      {
       pmtd_name: string loc;
       pmtd_type: module_type option;
       pmtd_attributes: attributes; (* ... [@@id1] [@@id2] *)
       pmtd_loc: Location.t;
      }
  (* S = MT
     S       (abstract module type declaration, pmtd_type = None)
  *)

  and open_description (*IF_CURRENT = Parsetree.open_description *) =
      {
       popen_lid: Longident.t loc;
       popen_override: override_flag;
       popen_loc: Location.t;
       popen_attributes: attributes;
      }
  (* open! X - popen_override = Override (silences the 'used identifier
                                shadowing' warning)
     open  X - popen_override = Fresh
   *)

  and 'a include_infos (*IF_CURRENT = 'a Parsetree.include_infos *) =
      {
       pincl_mod: 'a;
       pincl_loc: Location.t;
       pincl_attributes: attributes;
      }

  and include_description = module_type include_infos
  (* include MT *)

  and include_declaration = module_expr include_infos
  (* include ME *)

  and with_constraint (*IF_CURRENT = Parsetree.with_constraint *) =
    | Pwith_type of Longident.t loc * type_declaration
          (* with type X.t = ...

             Note: the last component of the longident must match
             the name of the type_declaration. *)
    | Pwith_module of Longident.t loc * Longident.t loc
          (* with module X.Y = Z *)
    | Pwith_typesubst of type_declaration
          (* with type t := ... *)
    | Pwith_modsubst of string loc * Longident.t loc
          (* with module X := Z *)

  (* Value expressions for the module language *)

  and module_expr (*IF_CURRENT = Parsetree.module_expr *) =
      {
       pmod_desc: module_expr_desc;
       pmod_loc: Location.t;
       pmod_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and module_expr_desc (*IF_CURRENT = Parsetree.module_expr_desc *) =
    | Pmod_ident of Longident.t loc
          (* X *)
    | Pmod_structure of structure
          (* struct ... end *)
    | Pmod_functor of string loc * module_type option * module_expr
          (* functor(X : MT1) -> ME *)
    | Pmod_apply of module_expr * module_expr
          (* ME1(ME2) *)
    | Pmod_constraint of module_expr * module_type
          (* (ME : MT) *)
    | Pmod_unpack of expression
          (* (val E) *)
    | Pmod_extension of extension
          (* [%id] *)

  and structure = structure_item list

  and structure_item (*IF_CURRENT = Parsetree.structure_item *) =
      {
       pstr_desc: structure_item_desc;
       pstr_loc: Location.t;
      }

  and structure_item_desc (*IF_CURRENT = Parsetree.structure_item_desc *) =
    | Pstr_eval of expression * attributes
          (* E *)
    | Pstr_value of rec_flag * value_binding list
          (* let P1 = E1 and ... and Pn = EN       (flag = Nonrecursive)
             let rec P1 = E1 and ... and Pn = EN   (flag = Recursive)
           *)
    | Pstr_primitive of value_description
          (*  val x: T
              external x: T = "s1" ... "sn" *)
    | Pstr_type of rec_flag * type_declaration list
          (* type t1 = ... and ... and tn = ... *)
    | Pstr_typext of type_extension
          (* type t1 += ... *)
    | Pstr_exception of extension_constructor
          (* exception C of T
             exception C = M.X *)
    | Pstr_module of module_binding
          (* module X = ME *)
    | Pstr_recmodule of module_binding list
          (* module rec X1 = ME1 and ... and Xn = MEn *)
    | Pstr_modtype of module_type_declaration
          (* module type S = MT *)
    | Pstr_open of open_description
          (* open X *)
    | Pstr_class of class_declaration list
          (* class c1 = ... and ... and cn = ... *)
    | Pstr_class_type of class_type_declaration list
          (* class type ct1 = ... and ... and ctn = ... *)
    | Pstr_include of include_declaration
          (* include ME *)
    | Pstr_attribute of attribute
          (* [@@@id] *)
    | Pstr_extension of extension * attributes
          (* [%%id] *)

  and value_binding (*IF_CURRENT = Parsetree.value_binding *) =
    {
      pvb_pat: pattern;
      pvb_expr: expression;
      pvb_attributes: attributes;
      pvb_loc: Location.t;
    }

  and module_binding (*IF_CURRENT = Parsetree.module_binding *) =
      {
       pmb_name: string loc;
       pmb_expr: module_expr;
       pmb_attributes: attributes;
       pmb_loc: Location.t;
      }
  (* X = ME *)

  (** {2 Toplevel} *)

  (* Toplevel phrases *)

  type toplevel_phrase (*IF_CURRENT = Parsetree.toplevel_phrase *) =
    | Ptop_def of structure
    | Ptop_dir of string * directive_argument
       (* #use, #load ... *)

  and directive_argument (*IF_CURRENT = Parsetree.directive_argument *) =
    | Pdir_none
    | Pdir_string of string
    | Pdir_int of string * char option
    | Pdir_ident of Longident.t
    | Pdir_bool of bool
end

module Docstrings : sig
  (** {3 Docstrings} *)

  (** Documentation comments *)
  type docstring

  (** Create a docstring *)
  val docstring : string -> Location.t -> docstring

  (** Get the text of a docstring *)
  val docstring_body : docstring -> string

  (** Get the location of a docstring *)
  val docstring_loc : docstring -> Location.t

  (** {3 Items}

      The {!docs} type represents documentation attached to an item. *)

  type docs =
    { docs_pre: docstring option;
      docs_post: docstring option; }

  val empty_docs : docs

  val docs_attr : docstring -> Parsetree.attribute

  (** Convert item documentation to attributes and add them to an
      attribute list *)
  val add_docs_attrs : docs -> Parsetree.attributes -> Parsetree.attributes

  (** {3 Fields and constructors}

      The {!info} type represents documentation attached to a field or
      constructor. *)

  type info = docstring option

  val empty_info : info

  val info_attr : docstring -> Parsetree.attribute

  (** Convert field info to attributes and add them to an
      attribute list *)
  val add_info_attrs : info -> Parsetree.attributes -> Parsetree.attributes

  (** {3 Unattached comments}

      The {!text} type represents documentation which is not attached to
      anything. *)

  type text = docstring list

  val empty_text : text

  val text_attr : docstring -> Parsetree.attribute

  (** Convert text to attributes and add them to an attribute list *)
  val add_text_attrs : text -> Parsetree.attributes -> Parsetree.attributes

end = struct
  open Location

  (* Docstrings *)

  type docstring =
    { ds_body: string;
      ds_loc: Location.t; }

  (* Docstring constructors and destructors *)

  let docstring body loc =
    let ds =
      { ds_body = body;
        ds_loc = loc; }
    in
    ds

  let docstring_body ds = ds.ds_body

  let docstring_loc ds = ds.ds_loc

  (* Docstrings attached to items *)

  type docs =
    { docs_pre: docstring option;
      docs_post: docstring option; }

  let empty_docs = { docs_pre = None; docs_post = None }

  let doc_loc = {txt = "ocaml.doc"; loc = Location.none}

  let docs_attr ds =
    let open Parsetree in
    let exp =
      { pexp_desc = Pexp_constant (Pconst_string(ds.ds_body, None));
        pexp_loc = ds.ds_loc;
        pexp_attributes = []; }
    in
    let item =
      { pstr_desc = Pstr_eval (exp, []); pstr_loc = exp.pexp_loc }
    in
      (doc_loc, PStr [item])

  let add_docs_attrs docs attrs =
    let attrs =
      match docs.docs_pre with
      | None | Some { ds_body=""; _ } -> attrs
      | Some ds -> docs_attr ds :: attrs
    in
    let attrs =
      match docs.docs_post with
      | None | Some { ds_body=""; _ } -> attrs
      | Some ds -> attrs @ [docs_attr ds]
    in
    attrs

  (* Docstrings attached to constructors or fields *)

  type info = docstring option

  let empty_info = None

  let info_attr = docs_attr

  let add_info_attrs info attrs =
    match info with
    | None | Some {ds_body=""; _} -> attrs
    | Some ds -> attrs @ [info_attr ds]

  (* Docstrings not attached to a specific item *)

  type text = docstring list

  let empty_text = []

  let text_loc = {txt = "ocaml.text"; loc = Location.none}

  let text_attr ds =
    let open Parsetree in
    let exp =
      { pexp_desc = Pexp_constant (Pconst_string(ds.ds_body, None));
        pexp_loc = ds.ds_loc;
        pexp_attributes = []; }
    in
    let item =
      { pstr_desc = Pstr_eval (exp, []); pstr_loc = exp.pexp_loc }
    in
      (text_loc, PStr [item])

  let add_text_attrs dsl attrs =
    let fdsl = List.filter (function {ds_body=""; _} -> false| _ ->true) dsl in
    (List.map text_attr fdsl) @ attrs

end

module Ast_helper : sig
  (** Helpers to produce Parsetree fragments *)

  open Asttypes
  open Docstrings
  open Parsetree

  type lid = Longident.t loc
  type str = string loc
  type loc = Location.t
  type attrs = attribute list

  (** {2 Default locations} *)

  val default_loc: loc ref
      (** Default value for all optional location arguments. *)

  val with_default_loc: loc -> (unit -> 'a) -> 'a
      (** Set the [default_loc] within the scope of the execution
          of the provided function. *)

  (** {2 Constants} *)

  module Const : sig
    val char : char -> constant
    val string : ?quotation_delimiter:string -> string -> constant
    val integer : ?suffix:char -> string -> constant
    val int : ?suffix:char -> int -> constant
    val int32 : ?suffix:char -> int32 -> constant
    val int64 : ?suffix:char -> int64 -> constant
    val nativeint : ?suffix:char -> nativeint -> constant
    val float : ?suffix:char -> string -> constant
  end

  (** {2 Core language} *)

  (** Type expressions *)
  module Typ :
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> core_type_desc -> core_type
      val attr: core_type -> attribute -> core_type

      val any: ?loc:loc -> ?attrs:attrs -> unit -> core_type
      val var: ?loc:loc -> ?attrs:attrs -> string -> core_type
      val arrow: ?loc:loc -> ?attrs:attrs -> arg_label -> core_type -> core_type
                 -> core_type
      val tuple: ?loc:loc -> ?attrs:attrs -> core_type list -> core_type
      val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> core_type
      val object_: ?loc:loc -> ?attrs:attrs ->
                    (string * attributes * core_type) list -> closed_flag ->
                    core_type
      val class_: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> core_type
      val alias: ?loc:loc -> ?attrs:attrs -> core_type -> string -> core_type
      val variant: ?loc:loc -> ?attrs:attrs -> row_field list -> closed_flag
                   -> label list option -> core_type
      val poly: ?loc:loc -> ?attrs:attrs -> string list -> core_type -> core_type
      val package: ?loc:loc -> ?attrs:attrs -> lid -> (lid * core_type) list
                   -> core_type
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> core_type

      val force_poly: core_type -> core_type
    end

  (** Patterns *)
  module Pat:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> pattern_desc -> pattern
      val attr:pattern -> attribute -> pattern

      val any: ?loc:loc -> ?attrs:attrs -> unit -> pattern
      val var: ?loc:loc -> ?attrs:attrs -> str -> pattern
      val alias: ?loc:loc -> ?attrs:attrs -> pattern -> str -> pattern
      val constant: ?loc:loc -> ?attrs:attrs -> constant -> pattern
      val interval: ?loc:loc -> ?attrs:attrs -> constant -> constant -> pattern
      val tuple: ?loc:loc -> ?attrs:attrs -> pattern list -> pattern
      val construct: ?loc:loc -> ?attrs:attrs -> lid -> pattern option -> pattern
      val variant: ?loc:loc -> ?attrs:attrs -> label -> pattern option -> pattern
      val record: ?loc:loc -> ?attrs:attrs -> (lid * pattern) list -> closed_flag
                  -> pattern
      val array: ?loc:loc -> ?attrs:attrs -> pattern list -> pattern
      val or_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern -> pattern
      val constraint_: ?loc:loc -> ?attrs:attrs -> pattern -> core_type -> pattern
      val type_: ?loc:loc -> ?attrs:attrs -> lid -> pattern
      val lazy_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern
      val unpack: ?loc:loc -> ?attrs:attrs -> str -> pattern
      val exception_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> pattern
    end

  (** Expressions *)
  module Exp:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> expression_desc -> expression
      val attr: expression -> attribute -> expression

      val ident: ?loc:loc -> ?attrs:attrs -> lid -> expression
      val constant: ?loc:loc -> ?attrs:attrs -> constant -> expression
      val let_: ?loc:loc -> ?attrs:attrs -> rec_flag -> value_binding list
                -> expression -> expression
      val fun_: ?loc:loc -> ?attrs:attrs -> arg_label -> expression option
                -> pattern -> expression -> expression
      val function_: ?loc:loc -> ?attrs:attrs -> case list -> expression
      val apply: ?loc:loc -> ?attrs:attrs -> expression
                 -> (arg_label * expression) list -> expression
      val match_: ?loc:loc -> ?attrs:attrs -> expression -> case list
                  -> expression
      val try_: ?loc:loc -> ?attrs:attrs -> expression -> case list -> expression
      val tuple: ?loc:loc -> ?attrs:attrs -> expression list -> expression
      val construct: ?loc:loc -> ?attrs:attrs -> lid -> expression option
                     -> expression
      val variant: ?loc:loc -> ?attrs:attrs -> label -> expression option
                   -> expression
      val record: ?loc:loc -> ?attrs:attrs -> (lid * expression) list
                  -> expression option -> expression
      val field: ?loc:loc -> ?attrs:attrs -> expression -> lid -> expression
      val setfield: ?loc:loc -> ?attrs:attrs -> expression -> lid -> expression
                    -> expression
      val array: ?loc:loc -> ?attrs:attrs -> expression list -> expression
      val ifthenelse: ?loc:loc -> ?attrs:attrs -> expression -> expression
                      -> expression option -> expression
      val sequence: ?loc:loc -> ?attrs:attrs -> expression -> expression
                    -> expression
      val while_: ?loc:loc -> ?attrs:attrs -> expression -> expression
                  -> expression
      val for_: ?loc:loc -> ?attrs:attrs -> pattern -> expression -> expression
                -> direction_flag -> expression -> expression
      val coerce: ?loc:loc -> ?attrs:attrs -> expression -> core_type option
                  -> core_type -> expression
      val constraint_: ?loc:loc -> ?attrs:attrs -> expression -> core_type
                       -> expression
      val send: ?loc:loc -> ?attrs:attrs -> expression -> string -> expression
      val new_: ?loc:loc -> ?attrs:attrs -> lid -> expression
      val setinstvar: ?loc:loc -> ?attrs:attrs -> str -> expression -> expression
      val override: ?loc:loc -> ?attrs:attrs -> (str * expression) list
                    -> expression
      val letmodule: ?loc:loc -> ?attrs:attrs -> str -> module_expr -> expression
                     -> expression
      val assert_: ?loc:loc -> ?attrs:attrs -> expression -> expression
      val lazy_: ?loc:loc -> ?attrs:attrs -> expression -> expression
      val poly: ?loc:loc -> ?attrs:attrs -> expression -> core_type option
                -> expression
      val object_: ?loc:loc -> ?attrs:attrs -> class_structure -> expression
      val newtype: ?loc:loc -> ?attrs:attrs -> string -> expression -> expression
      val pack: ?loc:loc -> ?attrs:attrs -> module_expr -> expression
      val open_: ?loc:loc -> ?attrs:attrs -> override_flag -> lid -> expression
                 -> expression
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> expression
      val unreachable: ?loc:loc -> ?attrs:attrs -> unit -> expression

      val case: pattern -> ?guard:expression -> expression -> case
    end

  (** Value declarations *)
  module Val:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs ->
        ?prim:string list -> str -> core_type -> value_description
    end

  (** Type declarations *)
  module Type:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        ?params:(core_type * variance) list ->
        ?cstrs:(core_type * core_type * loc) list ->
        ?kind:type_kind -> ?priv:private_flag -> ?manifest:core_type -> str ->
        type_declaration

      val constructor: ?loc:loc -> ?attrs:attrs -> ?info:info ->
        ?args:constructor_arguments -> ?res:core_type -> str ->
        constructor_declaration
      val field: ?loc:loc -> ?attrs:attrs -> ?info:info ->
        ?mut:mutable_flag -> str -> core_type -> label_declaration
    end

  (** Type extensions *)
  module Te:
    sig
      val mk: ?attrs:attrs -> ?docs:docs ->
        ?params:(core_type * variance) list -> ?priv:private_flag ->
        lid -> extension_constructor list -> type_extension

      val constructor: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->
        str -> extension_constructor_kind -> extension_constructor

      val decl: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->
        ?args:constructor_arguments -> ?res:core_type -> str ->
        extension_constructor
      val rebind: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->
        str -> lid -> extension_constructor
    end

  (** {2 Module language} *)

  (** Module type expressions *)
  module Mty:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> module_type_desc -> module_type
      val attr: module_type -> attribute -> module_type

      val ident: ?loc:loc -> ?attrs:attrs -> lid -> module_type
      val alias: ?loc:loc -> ?attrs:attrs -> lid -> module_type
      val signature: ?loc:loc -> ?attrs:attrs -> signature -> module_type
      val functor_: ?loc:loc -> ?attrs:attrs ->
        str -> module_type option -> module_type -> module_type
      val with_: ?loc:loc -> ?attrs:attrs -> module_type ->
        with_constraint list -> module_type
      val typeof_: ?loc:loc -> ?attrs:attrs -> module_expr -> module_type
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> module_type
    end

  (** Module expressions *)
  module Mod:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> module_expr_desc -> module_expr
      val attr: module_expr -> attribute -> module_expr

      val ident: ?loc:loc -> ?attrs:attrs -> lid -> module_expr
      val structure: ?loc:loc -> ?attrs:attrs -> structure -> module_expr
      val functor_: ?loc:loc -> ?attrs:attrs ->
        str -> module_type option -> module_expr -> module_expr
      val apply: ?loc:loc -> ?attrs:attrs -> module_expr -> module_expr ->
        module_expr
      val constraint_: ?loc:loc -> ?attrs:attrs -> module_expr -> module_type ->
        module_expr
      val unpack: ?loc:loc -> ?attrs:attrs -> expression -> module_expr
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> module_expr
    end

  (** Signature items *)
  module Sig:
    sig
      val mk: ?loc:loc -> signature_item_desc -> signature_item

      val value: ?loc:loc -> value_description -> signature_item
      val type_: ?loc:loc -> rec_flag -> type_declaration list -> signature_item
      val type_extension: ?loc:loc -> type_extension -> signature_item
      val exception_: ?loc:loc -> extension_constructor -> signature_item
      val module_: ?loc:loc -> module_declaration -> signature_item
      val rec_module: ?loc:loc -> module_declaration list -> signature_item
      val modtype: ?loc:loc -> module_type_declaration -> signature_item
      val open_: ?loc:loc -> open_description -> signature_item
      val include_: ?loc:loc -> include_description -> signature_item
      val class_: ?loc:loc -> class_description list -> signature_item
      val class_type: ?loc:loc -> class_type_declaration list -> signature_item
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> signature_item
      val attribute: ?loc:loc -> attribute -> signature_item
      val text: text -> signature_item list
    end

  (** Structure items *)
  module Str:
    sig
      val mk: ?loc:loc -> structure_item_desc -> structure_item

      val eval: ?loc:loc -> ?attrs:attributes -> expression -> structure_item
      val value: ?loc:loc -> rec_flag -> value_binding list -> structure_item
      val primitive: ?loc:loc -> value_description -> structure_item
      val type_: ?loc:loc -> rec_flag -> type_declaration list -> structure_item
      val type_extension: ?loc:loc -> type_extension -> structure_item
      val exception_: ?loc:loc -> extension_constructor -> structure_item
      val module_: ?loc:loc -> module_binding -> structure_item
      val rec_module: ?loc:loc -> module_binding list -> structure_item
      val modtype: ?loc:loc -> module_type_declaration -> structure_item
      val open_: ?loc:loc -> open_description -> structure_item
      val class_: ?loc:loc -> class_declaration list -> structure_item
      val class_type: ?loc:loc -> class_type_declaration list -> structure_item
      val include_: ?loc:loc -> include_declaration -> structure_item
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> structure_item
      val attribute: ?loc:loc -> attribute -> structure_item
      val text: text -> structure_item list
    end

  (** Module declarations *)
  module Md:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        str -> module_type -> module_declaration
    end

  (** Module type declarations *)
  module Mtd:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        ?typ:module_type -> str -> module_type_declaration
    end

  (** Module bindings *)
  module Mb:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        str -> module_expr -> module_binding
    end

  (* Opens *)
  module Opn:
    sig
      val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs ->
        ?override:override_flag -> lid -> open_description
    end

  (* Includes *)
  module Incl:
    sig
      val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs -> 'a -> 'a include_infos
    end

  (** Value bindings *)

  module Vb:
    sig
      val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        pattern -> expression -> value_binding
    end


  (** {2 Class language} *)

  (** Class type expressions *)
  module Cty:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> class_type_desc -> class_type
      val attr: class_type -> attribute -> class_type

      val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> class_type
      val signature: ?loc:loc -> ?attrs:attrs -> class_signature -> class_type
      val arrow: ?loc:loc -> ?attrs:attrs -> arg_label -> core_type ->
        class_type -> class_type
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_type
    end

  (** Class type fields *)
  module Ctf:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs ->
        class_type_field_desc -> class_type_field
      val attr: class_type_field -> attribute -> class_type_field

      val inherit_: ?loc:loc -> ?attrs:attrs -> class_type -> class_type_field
      val val_: ?loc:loc -> ?attrs:attrs -> string -> mutable_flag ->
        virtual_flag -> core_type -> class_type_field
      val method_: ?loc:loc -> ?attrs:attrs -> string -> private_flag ->
        virtual_flag -> core_type -> class_type_field
      val constraint_: ?loc:loc -> ?attrs:attrs -> core_type -> core_type ->
        class_type_field
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_type_field
      val attribute: ?loc:loc -> attribute -> class_type_field
      val text: text -> class_type_field list
    end

  (** Class expressions *)
  module Cl:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> class_expr_desc -> class_expr
      val attr: class_expr -> attribute -> class_expr

      val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> class_expr
      val structure: ?loc:loc -> ?attrs:attrs -> class_structure -> class_expr
      val fun_: ?loc:loc -> ?attrs:attrs -> arg_label -> expression option ->
        pattern -> class_expr -> class_expr
      val apply: ?loc:loc -> ?attrs:attrs -> class_expr ->
        (arg_label * expression) list -> class_expr
      val let_: ?loc:loc -> ?attrs:attrs -> rec_flag -> value_binding list ->
        class_expr -> class_expr
      val constraint_: ?loc:loc -> ?attrs:attrs -> class_expr -> class_type ->
        class_expr
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_expr
    end

  (** Class fields *)
  module Cf:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> class_field_desc ->
        class_field
      val attr: class_field -> attribute -> class_field

      val inherit_: ?loc:loc -> ?attrs:attrs -> override_flag -> class_expr ->
        string option -> class_field
      val val_: ?loc:loc -> ?attrs:attrs -> str -> mutable_flag ->
        class_field_kind -> class_field
      val method_: ?loc:loc -> ?attrs:attrs -> str -> private_flag ->
        class_field_kind -> class_field
      val constraint_: ?loc:loc -> ?attrs:attrs -> core_type -> core_type ->
        class_field
      val initializer_: ?loc:loc -> ?attrs:attrs -> expression -> class_field
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_field
      val attribute: ?loc:loc -> attribute -> class_field
      val text: text -> class_field list

      val virtual_: core_type -> class_field_kind
      val concrete: override_flag -> expression -> class_field_kind

    end

  (** Classes *)
  module Ci:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        ?virt:virtual_flag -> ?params:(core_type * variance) list ->
        str -> 'a -> 'a class_infos
    end

  (** Class signatures *)
  module Csig:
    sig
      val mk: core_type -> class_type_field list -> class_signature
    end

  (** Class structures *)
  module Cstr:
    sig
      val mk: pattern -> class_field list -> class_structure
    end

end = struct
  (** Helpers to produce Parsetree fragments *)

  open Asttypes
  open Parsetree
  open Docstrings

  type lid = Longident.t loc
  type str = string loc
  type loc = Location.t
  type attrs = attribute list

  let default_loc = ref Location.none

  let with_default_loc l f =
    let old = !default_loc in
    default_loc := l;
    try let r = f () in default_loc := old; r
    with exn -> default_loc := old; raise exn

  module Const = struct
    let integer ?suffix i = Pconst_integer (i, suffix)
    let int ?suffix i = integer ?suffix (string_of_int i)
    let int32 ?(suffix='l') i = integer ~suffix (Int32.to_string i)
    let int64 ?(suffix='L') i = integer ~suffix (Int64.to_string i)
    let nativeint ?(suffix='n') i = integer ~suffix (Nativeint.to_string i)
    let float ?suffix f = Pconst_float (f, suffix)
    let char c = Pconst_char c
    let string ?quotation_delimiter s = Pconst_string (s, quotation_delimiter)
  end

  module Typ = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {ptyp_desc = d; ptyp_loc = loc; ptyp_attributes = attrs}
    let attr d a = {d with ptyp_attributes = d.ptyp_attributes @ [a]}

    let any ?loc ?attrs () = mk ?loc ?attrs Ptyp_any
    let var ?loc ?attrs a = mk ?loc ?attrs (Ptyp_var a)
    let arrow ?loc ?attrs a b c = mk ?loc ?attrs (Ptyp_arrow (a, b, c))
    let tuple ?loc ?attrs a = mk ?loc ?attrs (Ptyp_tuple a)
    let constr ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_constr (a, b))
    let object_ ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_object (a, b))
    let class_ ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_class (a, b))
    let alias ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_alias (a, b))
    let variant ?loc ?attrs a b c = mk ?loc ?attrs (Ptyp_variant (a, b, c))
    let poly ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_poly (a, b))
    let package ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_package (a, b))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Ptyp_extension a)

    let force_poly t =
      match t.ptyp_desc with
      | Ptyp_poly _ -> t
      | _ -> poly ~loc:t.ptyp_loc [] t (* -> ghost? *)
  end

  module Pat = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {ppat_desc = d; ppat_loc = loc; ppat_attributes = attrs}
    let attr d a = {d with ppat_attributes = d.ppat_attributes @ [a]}

    let any ?loc ?attrs () = mk ?loc ?attrs Ppat_any
    let var ?loc ?attrs a = mk ?loc ?attrs (Ppat_var a)
    let alias ?loc ?attrs a b = mk ?loc ?attrs (Ppat_alias (a, b))
    let constant ?loc ?attrs a = mk ?loc ?attrs (Ppat_constant a)
    let interval ?loc ?attrs a b = mk ?loc ?attrs (Ppat_interval (a, b))
    let tuple ?loc ?attrs a = mk ?loc ?attrs (Ppat_tuple a)
    let construct ?loc ?attrs a b = mk ?loc ?attrs (Ppat_construct (a, b))
    let variant ?loc ?attrs a b = mk ?loc ?attrs (Ppat_variant (a, b))
    let record ?loc ?attrs a b = mk ?loc ?attrs (Ppat_record (a, b))
    let array ?loc ?attrs a = mk ?loc ?attrs (Ppat_array a)
    let or_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_or (a, b))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_constraint (a, b))
    let type_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_type a)
    let lazy_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_lazy a)
    let unpack ?loc ?attrs a = mk ?loc ?attrs (Ppat_unpack a)
    let exception_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_exception a)
    let extension ?loc ?attrs a = mk ?loc ?attrs (Ppat_extension a)
  end

  module Exp = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {pexp_desc = d; pexp_loc = loc; pexp_attributes = attrs}
    let attr d a = {d with pexp_attributes = d.pexp_attributes @ [a]}

    let ident ?loc ?attrs a = mk ?loc ?attrs (Pexp_ident a)
    let constant ?loc ?attrs a = mk ?loc ?attrs (Pexp_constant a)
    let let_ ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_let (a, b, c))
    let fun_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pexp_fun (a, b, c, d))
    let function_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_function a)
    let apply ?loc ?attrs a b = mk ?loc ?attrs (Pexp_apply (a, b))
    let match_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_match (a, b))
    let try_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_try (a, b))
    let tuple ?loc ?attrs a = mk ?loc ?attrs (Pexp_tuple a)
    let construct ?loc ?attrs a b = mk ?loc ?attrs (Pexp_construct (a, b))
    let variant ?loc ?attrs a b = mk ?loc ?attrs (Pexp_variant (a, b))
    let record ?loc ?attrs a b = mk ?loc ?attrs (Pexp_record (a, b))
    let field ?loc ?attrs a b = mk ?loc ?attrs (Pexp_field (a, b))
    let setfield ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_setfield (a, b, c))
    let array ?loc ?attrs a = mk ?loc ?attrs (Pexp_array a)
    let ifthenelse ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_ifthenelse (a, b, c))
    let sequence ?loc ?attrs a b = mk ?loc ?attrs (Pexp_sequence (a, b))
    let while_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_while (a, b))
    let for_ ?loc ?attrs a b c d e = mk ?loc ?attrs (Pexp_for (a, b, c, d, e))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_constraint (a, b))
    let coerce ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_coerce (a, b, c))
    let send ?loc ?attrs a b = mk ?loc ?attrs (Pexp_send (a, b))
    let new_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_new a)
    let setinstvar ?loc ?attrs a b = mk ?loc ?attrs (Pexp_setinstvar (a, b))
    let override ?loc ?attrs a = mk ?loc ?attrs (Pexp_override a)
    let letmodule ?loc ?attrs a b c= mk ?loc ?attrs (Pexp_letmodule (a, b, c))
    let assert_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_assert a)
    let lazy_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_lazy a)
    let poly ?loc ?attrs a b = mk ?loc ?attrs (Pexp_poly (a, b))
    let object_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_object a)
    let newtype ?loc ?attrs a b = mk ?loc ?attrs (Pexp_newtype (a, b))
    let pack ?loc ?attrs a = mk ?loc ?attrs (Pexp_pack a)
    let open_ ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_open (a, b, c))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pexp_extension a)
    let unreachable ?loc ?attrs () = mk ?loc ?attrs Pexp_unreachable

    let case lhs ?guard rhs =
      {
       pc_lhs = lhs;
       pc_guard = guard;
       pc_rhs = rhs;
      }
  end

  module Mty = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {pmty_desc = d; pmty_loc = loc; pmty_attributes = attrs}
    let attr d a = {d with pmty_attributes = d.pmty_attributes @ [a]}

    let ident ?loc ?attrs a = mk ?loc ?attrs (Pmty_ident a)
    let alias ?loc ?attrs a = mk ?loc ?attrs (Pmty_alias a)
    let signature ?loc ?attrs a = mk ?loc ?attrs (Pmty_signature a)
    let functor_ ?loc ?attrs a b c = mk ?loc ?attrs (Pmty_functor (a, b, c))
    let with_ ?loc ?attrs a b = mk ?loc ?attrs (Pmty_with (a, b))
    let typeof_ ?loc ?attrs a = mk ?loc ?attrs (Pmty_typeof a)
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pmty_extension a)
  end

  module Mod = struct
  let mk ?(loc = !default_loc) ?(attrs = []) d =
    {pmod_desc = d; pmod_loc = loc; pmod_attributes = attrs}
    let attr d a = {d with pmod_attributes = d.pmod_attributes @ [a]}

    let ident ?loc ?attrs x = mk ?loc ?attrs (Pmod_ident x)
    let structure ?loc ?attrs x = mk ?loc ?attrs (Pmod_structure x)
    let functor_ ?loc ?attrs arg arg_ty body =
      mk ?loc ?attrs (Pmod_functor (arg, arg_ty, body))
    let apply ?loc ?attrs m1 m2 = mk ?loc ?attrs (Pmod_apply (m1, m2))
    let constraint_ ?loc ?attrs m mty = mk ?loc ?attrs (Pmod_constraint (m, mty))
    let unpack ?loc ?attrs e = mk ?loc ?attrs (Pmod_unpack e)
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pmod_extension a)
  end

  module Sig = struct
    let mk ?(loc = !default_loc) d = {psig_desc = d; psig_loc = loc}

    let value ?loc a = mk ?loc (Psig_value a)
    let type_ ?loc rec_flag a = mk ?loc (Psig_type (rec_flag, a))
    let type_extension ?loc a = mk ?loc (Psig_typext a)
    let exception_ ?loc a = mk ?loc (Psig_exception a)
    let module_ ?loc a = mk ?loc (Psig_module a)
    let rec_module ?loc a = mk ?loc (Psig_recmodule a)
    let modtype ?loc a = mk ?loc (Psig_modtype a)
    let open_ ?loc a = mk ?loc (Psig_open a)
    let include_ ?loc a = mk ?loc (Psig_include a)
    let class_ ?loc a = mk ?loc (Psig_class a)
    let class_type ?loc a = mk ?loc (Psig_class_type a)
    let extension ?loc ?(attrs = []) a = mk ?loc (Psig_extension (a, attrs))
    let attribute ?loc a = mk ?loc (Psig_attribute a)
    let text txt =
      List.map
        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
        txt
  end

  module Str = struct
    let mk ?(loc = !default_loc) d = {pstr_desc = d; pstr_loc = loc}

    let eval ?loc ?(attrs = []) a = mk ?loc (Pstr_eval (a, attrs))
    let value ?loc a b = mk ?loc (Pstr_value (a, b))
    let primitive ?loc a = mk ?loc (Pstr_primitive a)
    let type_ ?loc rec_flag a = mk ?loc (Pstr_type (rec_flag, a))
    let type_extension ?loc a = mk ?loc (Pstr_typext a)
    let exception_ ?loc a = mk ?loc (Pstr_exception a)
    let module_ ?loc a = mk ?loc (Pstr_module a)
    let rec_module ?loc a = mk ?loc (Pstr_recmodule a)
    let modtype ?loc a = mk ?loc (Pstr_modtype a)
    let open_ ?loc a = mk ?loc (Pstr_open a)
    let class_ ?loc a = mk ?loc (Pstr_class a)
    let class_type ?loc a = mk ?loc (Pstr_class_type a)
    let include_ ?loc a = mk ?loc (Pstr_include a)
    let extension ?loc ?(attrs = []) a = mk ?loc (Pstr_extension (a, attrs))
    let attribute ?loc a = mk ?loc (Pstr_attribute a)
    let text txt =
      List.map
        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
        txt
  end

  module Cl = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {
       pcl_desc = d;
       pcl_loc = loc;
       pcl_attributes = attrs;
      }
    let attr d a = {d with pcl_attributes = d.pcl_attributes @ [a]}

    let constr ?loc ?attrs a b = mk ?loc ?attrs (Pcl_constr (a, b))
    let structure ?loc ?attrs a = mk ?loc ?attrs (Pcl_structure a)
    let fun_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pcl_fun (a, b, c, d))
    let apply ?loc ?attrs a b = mk ?loc ?attrs (Pcl_apply (a, b))
    let let_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcl_let (a, b, c))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pcl_constraint (a, b))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pcl_extension a)
  end

  module Cty = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {
       pcty_desc = d;
       pcty_loc = loc;
       pcty_attributes = attrs;
      }
    let attr d a = {d with pcty_attributes = d.pcty_attributes @ [a]}

    let constr ?loc ?attrs a b = mk ?loc ?attrs (Pcty_constr (a, b))
    let signature ?loc ?attrs a = mk ?loc ?attrs (Pcty_signature a)
    let arrow ?loc ?attrs a b c = mk ?loc ?attrs (Pcty_arrow (a, b, c))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pcty_extension a)
  end

  module Ctf = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
             ?(docs = empty_docs) d =
      {
       pctf_desc = d;
       pctf_loc = loc;
       pctf_attributes = add_docs_attrs docs attrs;
      }

    let inherit_ ?loc ?attrs a = mk ?loc ?attrs (Pctf_inherit a)
    let val_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pctf_val (a, b, c, d))
    let method_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pctf_method (a, b, c, d))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pctf_constraint (a, b))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pctf_extension a)
    let attribute ?loc a = mk ?loc (Pctf_attribute a)
    let text txt =
      List.map
        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
        txt

    let attr d a = {d with pctf_attributes = d.pctf_attributes @ [a]}

  end

  module Cf = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) d =
      {
       pcf_desc = d;
       pcf_loc = loc;
       pcf_attributes = add_docs_attrs docs attrs;
      }

    let inherit_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_inherit (a, b, c))
    let val_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_val (a, b, c))
    let method_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_method (a, b, c))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pcf_constraint (a, b))
    let initializer_ ?loc ?attrs a = mk ?loc ?attrs (Pcf_initializer a)
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pcf_extension a)
    let attribute ?loc a = mk ?loc (Pcf_attribute a)
    let text txt =
      List.map
        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
        txt

    let virtual_ ct = Cfk_virtual ct
    let concrete o e = Cfk_concrete (o, e)

    let attr d a = {d with pcf_attributes = d.pcf_attributes @ [a]}

  end

  module Val = struct
    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
          ?(prim = []) name typ =
      {
       pval_name = name;
       pval_type = typ;
       pval_attributes = add_docs_attrs docs attrs;
       pval_loc = loc;
       pval_prim = prim;
      }
  end

  module Md = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = []) name typ =
      {
       pmd_name = name;
       pmd_type = typ;
       pmd_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pmd_loc = loc;
      }
  end

  module Mtd = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = []) ?typ name =
      {
       pmtd_name = name;
       pmtd_type = typ;
       pmtd_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pmtd_loc = loc;
      }
  end

  module Mb = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = []) name expr =
      {
       pmb_name = name;
       pmb_expr = expr;
       pmb_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pmb_loc = loc;
      }
  end

  module Opn = struct
    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
          ?(override = Fresh) lid =
      {
       popen_lid = lid;
       popen_override = override;
       popen_loc = loc;
       popen_attributes = add_docs_attrs docs attrs;
      }
  end

  module Incl = struct
    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs) mexpr =
      {
       pincl_mod = mexpr;
       pincl_loc = loc;
       pincl_attributes = add_docs_attrs docs attrs;
      }

  end

  module Vb = struct
    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
          ?(text = []) pat expr =
      {
       pvb_pat = pat;
       pvb_expr = expr;
       pvb_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pvb_loc = loc;
      }
  end

  module Ci = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = [])
          ?(virt = Concrete) ?(params = []) name expr =
      {
       pci_virt = virt;
       pci_params = params;
       pci_name = name;
       pci_expr = expr;
       pci_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pci_loc = loc;
      }
  end

  module Type = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = [])
        ?(params = [])
        ?(cstrs = [])
        ?(kind = Ptype_abstract)
        ?(priv = Public)
        ?manifest
        name =
      {
       ptype_name = name;
       ptype_params = params;
       ptype_cstrs = cstrs;
       ptype_kind = kind;
       ptype_private = priv;
       ptype_manifest = manifest;
       ptype_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       ptype_loc = loc;
      }

    let constructor ?(loc = !default_loc) ?(attrs = []) ?(info = empty_info)
          ?(args = Pcstr_tuple []) ?res name =
      {
       pcd_name = name;
       pcd_args = args;
       pcd_res = res;
       pcd_loc = loc;
       pcd_attributes = add_info_attrs info attrs;
      }

    let field ?(loc = !default_loc) ?(attrs = []) ?(info = empty_info)
          ?(mut = Immutable) name typ =
      {
       pld_name = name;
       pld_mutable = mut;
       pld_type = typ;
       pld_loc = loc;
       pld_attributes = add_info_attrs info attrs;
      }

  end

  (** Type extensions *)
  module Te = struct
    let mk ?(attrs = []) ?(docs = empty_docs)
          ?(params = []) ?(priv = Public) path constructors =
      {
       ptyext_path = path;
       ptyext_params = params;
       ptyext_constructors = constructors;
       ptyext_private = priv;
       ptyext_attributes = add_docs_attrs docs attrs;
      }

    let constructor ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(info = empty_info) name kind =
      {
       pext_name = name;
       pext_kind = kind;
       pext_loc = loc;
       pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);
      }

    let decl ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
               ?(info = empty_info) ?(args = Pcstr_tuple []) ?res name =
      {
       pext_name = name;
       pext_kind = Pext_decl(args, res);
       pext_loc = loc;
       pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);
      }

    let rebind ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(info = empty_info) name lid =
      {
       pext_name = name;
       pext_kind = Pext_rebind lid;
       pext_loc = loc;
       pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);
      }

  end

  module Csig = struct
    let mk self fields =
      {
       pcsig_self = self;
       pcsig_fields = fields;
      }
  end

  module Cstr = struct
    let mk self fields =
      {
       pcstr_self = self;
       pcstr_fields = fields;
      }
  end

end

module Ast_mapper : sig
  (** The interface of a -ppx rewriter

    A -ppx rewriter is a program that accepts a serialized abstract syntax
    tree and outputs another, possibly modified, abstract syntax tree.
    This module encapsulates the interface between the compiler and
    the -ppx rewriters, handling such details as the serialization format,
    forwarding of command-line flags, and storing state.

    {!mapper} allows to implement AST rewriting using open recursion.
    A typical mapper would be based on {!default_mapper}, a deep
    identity mapper, and will fall back on it for handling the syntax it
    does not modify. For example:

    {[
  open Asttypes
  open Parsetree
  open Ast_mapper

  let test_mapper argv =
    { default_mapper with
      expr = fun mapper expr ->
        match expr with
        | { pexp_desc = Pexp_extension ({ txt = "test" }, PStr [])} ->
          Ast_helper.Exp.constant (Const_int 42)
        | other -> default_mapper.expr mapper other; }

  let () =
    register "ppx_test" test_mapper]}

    This -ppx rewriter, which replaces [[%test]] in expressions with
    the constant [42], can be compiled using
    [ocamlc -o ppx_test -I +compiler-libs ocamlcommon.cma ppx_test.ml].

    *)

  open Parsetree

  (** {2 A generic Parsetree mapper} *)

  type mapper (*IF_CURRENT = Ast_mapper.mapper*) = {
    attribute: mapper -> attribute -> attribute;
    attributes: mapper -> attribute list -> attribute list;
    case: mapper -> case -> case;
    cases: mapper -> case list -> case list;
    class_declaration: mapper -> class_declaration -> class_declaration;
    class_description: mapper -> class_description -> class_description;
    class_expr: mapper -> class_expr -> class_expr;
    class_field: mapper -> class_field -> class_field;
    class_signature: mapper -> class_signature -> class_signature;
    class_structure: mapper -> class_structure -> class_structure;
    class_type: mapper -> class_type -> class_type;
    class_type_declaration: mapper -> class_type_declaration
                            -> class_type_declaration;
    class_type_field: mapper -> class_type_field -> class_type_field;
    constructor_declaration: mapper -> constructor_declaration
                             -> constructor_declaration;
    expr: mapper -> expression -> expression;
    extension: mapper -> extension -> extension;
    extension_constructor: mapper -> extension_constructor
                           -> extension_constructor;
    include_declaration: mapper -> include_declaration -> include_declaration;
    include_description: mapper -> include_description -> include_description;
    label_declaration: mapper -> label_declaration -> label_declaration;
    location: mapper -> Location.t -> Location.t;
    module_binding: mapper -> module_binding -> module_binding;
    module_declaration: mapper -> module_declaration -> module_declaration;
    module_expr: mapper -> module_expr -> module_expr;
    module_type: mapper -> module_type -> module_type;
    module_type_declaration: mapper -> module_type_declaration
                             -> module_type_declaration;
    open_description: mapper -> open_description -> open_description;
    pat: mapper -> pattern -> pattern;
    payload: mapper -> payload -> payload;
    signature: mapper -> signature -> signature;
    signature_item: mapper -> signature_item -> signature_item;
    structure: mapper -> structure -> structure;
    structure_item: mapper -> structure_item -> structure_item;
    typ: mapper -> core_type -> core_type;
    type_declaration: mapper -> type_declaration -> type_declaration;
    type_extension: mapper -> type_extension -> type_extension;
    type_kind: mapper -> type_kind -> type_kind;
    value_binding: mapper -> value_binding -> value_binding;
    value_description: mapper -> value_description -> value_description;
    with_constraint: mapper -> with_constraint -> with_constraint;
  }
  (** A mapper record implements one "method" per syntactic category,
      using an open recursion style: each method takes as its first
      argument the mapper to be applied to children in the syntax
      tree. *)

  val default_mapper: mapper
  (** A default mapper, which implements a "deep identity" mapping. *)

  (** {2 Convenience functions to write mappers} *)

  val map_opt: ('a -> 'b) -> 'a option -> 'b option

  val extension_of_error: Location.error -> extension
  (** Encode an error into an 'ocaml.error' extension node which can be
      inserted in a generated Parsetree.  The compiler will be
      responsible for reporting the error. *)

  val attribute_of_warning: Location.t -> string -> attribute
  (** Encode a warning message into an 'ocaml.ppwarning' attribute which can be
      inserted in a generated Parsetree.  The compiler will be
      responsible for reporting the warning. *)

end = struct
  (* A generic Parsetree mapping class *)

  (*
  [@@@ocaml.warning "+9"]
    (* Ensure that record patterns don't miss any field. *)
  *)


  open Parsetree
  open Ast_helper
  open Location

  type mapper (*IF_CURRENT = Ast_mapper.mapper*) = {
    attribute: mapper -> attribute -> attribute;
    attributes: mapper -> attribute list -> attribute list;
    case: mapper -> case -> case;
    cases: mapper -> case list -> case list;
    class_declaration: mapper -> class_declaration -> class_declaration;
    class_description: mapper -> class_description -> class_description;
    class_expr: mapper -> class_expr -> class_expr;
    class_field: mapper -> class_field -> class_field;
    class_signature: mapper -> class_signature -> class_signature;
    class_structure: mapper -> class_structure -> class_structure;
    class_type: mapper -> class_type -> class_type;
    class_type_declaration: mapper -> class_type_declaration
                            -> class_type_declaration;
    class_type_field: mapper -> class_type_field -> class_type_field;
    constructor_declaration: mapper -> constructor_declaration
                             -> constructor_declaration;
    expr: mapper -> expression -> expression;
    extension: mapper -> extension -> extension;
    extension_constructor: mapper -> extension_constructor
                           -> extension_constructor;
    include_declaration: mapper -> include_declaration -> include_declaration;
    include_description: mapper -> include_description -> include_description;
    label_declaration: mapper -> label_declaration -> label_declaration;
    location: mapper -> Location.t -> Location.t;
    module_binding: mapper -> module_binding -> module_binding;
    module_declaration: mapper -> module_declaration -> module_declaration;
    module_expr: mapper -> module_expr -> module_expr;
    module_type: mapper -> module_type -> module_type;
    module_type_declaration: mapper -> module_type_declaration
                             -> module_type_declaration;
    open_description: mapper -> open_description -> open_description;
    pat: mapper -> pattern -> pattern;
    payload: mapper -> payload -> payload;
    signature: mapper -> signature -> signature;
    signature_item: mapper -> signature_item -> signature_item;
    structure: mapper -> structure -> structure;
    structure_item: mapper -> structure_item -> structure_item;
    typ: mapper -> core_type -> core_type;
    type_declaration: mapper -> type_declaration -> type_declaration;
    type_extension: mapper -> type_extension -> type_extension;
    type_kind: mapper -> type_kind -> type_kind;
    value_binding: mapper -> value_binding -> value_binding;
    value_description: mapper -> value_description -> value_description;
    with_constraint: mapper -> with_constraint -> with_constraint;
  }

  let map_fst f (x, y) = (f x, y)
  let map_snd f (x, y) = (x, f y)
  let map_tuple f1 f2 (x, y) = (f1 x, f2 y)
  let map_tuple3 f1 f2 f3 (x, y, z) = (f1 x, f2 y, f3 z)
  let map_opt f = function None -> None | Some x -> Some (f x)

  let map_loc sub {loc; txt} = {loc = sub.location sub loc; txt}

  module T = struct
    (* Type expressions for the core language *)

    let row_field sub = function
      | Rtag (l, attrs, b, tl) ->
          Rtag (l, sub.attributes sub attrs, b, List.map (sub.typ sub) tl)
      | Rinherit t -> Rinherit (sub.typ sub t)

    let map sub {ptyp_desc = desc; ptyp_loc = loc; ptyp_attributes = attrs} =
      let open Typ in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Ptyp_any -> any ~loc ~attrs ()
      | Ptyp_var s -> var ~loc ~attrs s
      | Ptyp_arrow (lab, t1, t2) ->
          arrow ~loc ~attrs lab (sub.typ sub t1) (sub.typ sub t2)
      | Ptyp_tuple tyl -> tuple ~loc ~attrs (List.map (sub.typ sub) tyl)
      | Ptyp_constr (lid, tl) ->
          constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tl)
      | Ptyp_object (l, o) ->
          let f (s, a, t) = (s, sub.attributes sub a, sub.typ sub t) in
          object_ ~loc ~attrs (List.map f l) o
      | Ptyp_class (lid, tl) ->
          class_ ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tl)
      | Ptyp_alias (t, s) -> alias ~loc ~attrs (sub.typ sub t) s
      | Ptyp_variant (rl, b, ll) ->
          variant ~loc ~attrs (List.map (row_field sub) rl) b ll
      | Ptyp_poly (sl, t) -> poly ~loc ~attrs sl (sub.typ sub t)
      | Ptyp_package (lid, l) ->
          package ~loc ~attrs (map_loc sub lid)
            (List.map (map_tuple (map_loc sub) (sub.typ sub)) l)
      | Ptyp_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_type_declaration sub
        {ptype_name; ptype_params; ptype_cstrs;
         ptype_kind;
         ptype_private;
         ptype_manifest;
         ptype_attributes;
         ptype_loc} =
      Type.mk (map_loc sub ptype_name)
        ~params:(List.map (map_fst (sub.typ sub)) ptype_params)
        ~priv:ptype_private
        ~cstrs:(List.map
                  (map_tuple3 (sub.typ sub) (sub.typ sub) (sub.location sub))
                  ptype_cstrs)
        ~kind:(sub.type_kind sub ptype_kind)
        ?manifest:(map_opt (sub.typ sub) ptype_manifest)
        ~loc:(sub.location sub ptype_loc)
        ~attrs:(sub.attributes sub ptype_attributes)

    let map_type_kind sub = function
      | Ptype_abstract -> Ptype_abstract
      | Ptype_variant l ->
          Ptype_variant (List.map (sub.constructor_declaration sub) l)
      | Ptype_record l -> Ptype_record (List.map (sub.label_declaration sub) l)
      | Ptype_open -> Ptype_open

    let map_constructor_arguments sub = function
      | Pcstr_tuple l -> Pcstr_tuple (List.map (sub.typ sub) l)
      | Pcstr_record l ->
          Pcstr_record (List.map (sub.label_declaration sub) l)

    let map_type_extension sub
        {ptyext_path; ptyext_params;
         ptyext_constructors;
         ptyext_private;
         ptyext_attributes} =
      Te.mk
        (map_loc sub ptyext_path)
        (List.map (sub.extension_constructor sub) ptyext_constructors)
        ~params:(List.map (map_fst (sub.typ sub)) ptyext_params)
        ~priv:ptyext_private
        ~attrs:(sub.attributes sub ptyext_attributes)

    let map_extension_constructor_kind sub = function
        Pext_decl(ctl, cto) ->
          Pext_decl(map_constructor_arguments sub ctl, map_opt (sub.typ sub) cto)
      | Pext_rebind li ->
          Pext_rebind (map_loc sub li)

    let map_extension_constructor sub
        {pext_name;
         pext_kind;
         pext_loc;
         pext_attributes} =
      Te.constructor
        (map_loc sub pext_name)
        (map_extension_constructor_kind sub pext_kind)
        ~loc:(sub.location sub pext_loc)
        ~attrs:(sub.attributes sub pext_attributes)

  end

  module CT = struct
    (* Type expressions for the class language *)

    let map sub {pcty_loc = loc; pcty_desc = desc; pcty_attributes = attrs} =
      let open Cty in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pcty_constr (lid, tys) ->
          constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tys)
      | Pcty_signature x -> signature ~loc ~attrs (sub.class_signature sub x)
      | Pcty_arrow (lab, t, ct) ->
          arrow ~loc ~attrs lab (sub.typ sub t) (sub.class_type sub ct)
      | Pcty_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_field sub {pctf_desc = desc; pctf_loc = loc; pctf_attributes = attrs}
      =
      let open Ctf in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pctf_inherit ct -> inherit_ ~loc ~attrs (sub.class_type sub ct)
      | Pctf_val (s, m, v, t) -> val_ ~loc ~attrs s m v (sub.typ sub t)
      | Pctf_method (s, p, v, t) -> method_ ~loc ~attrs s p v (sub.typ sub t)
      | Pctf_constraint (t1, t2) ->
          constraint_ ~loc ~attrs (sub.typ sub t1) (sub.typ sub t2)
      | Pctf_attribute x -> attribute ~loc (sub.attribute sub x)
      | Pctf_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_signature sub {pcsig_self; pcsig_fields} =
      Csig.mk
        (sub.typ sub pcsig_self)
        (List.map (sub.class_type_field sub) pcsig_fields)
  end

  module MT = struct
    (* Type expressions for the module language *)

    let map sub {pmty_desc = desc; pmty_loc = loc; pmty_attributes = attrs} =
      let open Mty in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pmty_ident s -> ident ~loc ~attrs (map_loc sub s)
      | Pmty_alias s -> alias ~loc ~attrs (map_loc sub s)
      | Pmty_signature sg -> signature ~loc ~attrs (sub.signature sub sg)
      | Pmty_functor (s, mt1, mt2) ->
          functor_ ~loc ~attrs (map_loc sub s)
            (Misc.may_map (sub.module_type sub) mt1)
            (sub.module_type sub mt2)
      | Pmty_with (mt, l) ->
          with_ ~loc ~attrs (sub.module_type sub mt)
            (List.map (sub.with_constraint sub) l)
      | Pmty_typeof me -> typeof_ ~loc ~attrs (sub.module_expr sub me)
      | Pmty_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_with_constraint sub = function
      | Pwith_type (lid, d) ->
          Pwith_type (map_loc sub lid, sub.type_declaration sub d)
      | Pwith_module (lid, lid2) ->
          Pwith_module (map_loc sub lid, map_loc sub lid2)
      | Pwith_typesubst d -> Pwith_typesubst (sub.type_declaration sub d)
      | Pwith_modsubst (s, lid) ->
          Pwith_modsubst (map_loc sub s, map_loc sub lid)

    let map_signature_item sub {psig_desc = desc; psig_loc = loc} =
      let open Sig in
      let loc = sub.location sub loc in
      match desc with
      | Psig_value vd -> value ~loc (sub.value_description sub vd)
      | Psig_type (rf, l) -> type_ ~loc rf (List.map (sub.type_declaration sub) l)
      | Psig_typext te -> type_extension ~loc (sub.type_extension sub te)
      | Psig_exception ed -> exception_ ~loc (sub.extension_constructor sub ed)
      | Psig_module x -> module_ ~loc (sub.module_declaration sub x)
      | Psig_recmodule l ->
          rec_module ~loc (List.map (sub.module_declaration sub) l)
      | Psig_modtype x -> modtype ~loc (sub.module_type_declaration sub x)
      | Psig_open x -> open_ ~loc (sub.open_description sub x)
      | Psig_include x -> include_ ~loc (sub.include_description sub x)
      | Psig_class l -> class_ ~loc (List.map (sub.class_description sub) l)
      | Psig_class_type l ->
          class_type ~loc (List.map (sub.class_type_declaration sub) l)
      | Psig_extension (x, attrs) ->
          extension ~loc (sub.extension sub x) ~attrs:(sub.attributes sub attrs)
      | Psig_attribute x -> attribute ~loc (sub.attribute sub x)
  end


  module M = struct
    (* Value expressions for the module language *)

    let map sub {pmod_loc = loc; pmod_desc = desc; pmod_attributes = attrs} =
      let open Mod in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pmod_ident x -> ident ~loc ~attrs (map_loc sub x)
      | Pmod_structure str -> structure ~loc ~attrs (sub.structure sub str)
      | Pmod_functor (arg, arg_ty, body) ->
          functor_ ~loc ~attrs (map_loc sub arg)
            (Misc.may_map (sub.module_type sub) arg_ty)
            (sub.module_expr sub body)
      | Pmod_apply (m1, m2) ->
          apply ~loc ~attrs (sub.module_expr sub m1) (sub.module_expr sub m2)
      | Pmod_constraint (m, mty) ->
          constraint_ ~loc ~attrs (sub.module_expr sub m)
                      (sub.module_type sub mty)
      | Pmod_unpack e -> unpack ~loc ~attrs (sub.expr sub e)
      | Pmod_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_structure_item sub {pstr_loc = loc; pstr_desc = desc} =
      let open Str in
      let loc = sub.location sub loc in
      match desc with
      | Pstr_eval (x, attrs) ->
          eval ~loc ~attrs:(sub.attributes sub attrs) (sub.expr sub x)
      | Pstr_value (r, vbs) -> value ~loc r (List.map (sub.value_binding sub) vbs)
      | Pstr_primitive vd -> primitive ~loc (sub.value_description sub vd)
      | Pstr_type (rf, l) -> type_ ~loc rf (List.map (sub.type_declaration sub) l)
      | Pstr_typext te -> type_extension ~loc (sub.type_extension sub te)
      | Pstr_exception ed -> exception_ ~loc (sub.extension_constructor sub ed)
      | Pstr_module x -> module_ ~loc (sub.module_binding sub x)
      | Pstr_recmodule l -> rec_module ~loc (List.map (sub.module_binding sub) l)
      | Pstr_modtype x -> modtype ~loc (sub.module_type_declaration sub x)
      | Pstr_open x -> open_ ~loc (sub.open_description sub x)
      | Pstr_class l -> class_ ~loc (List.map (sub.class_declaration sub) l)
      | Pstr_class_type l ->
          class_type ~loc (List.map (sub.class_type_declaration sub) l)
      | Pstr_include x -> include_ ~loc (sub.include_declaration sub x)
      | Pstr_extension (x, attrs) ->
          extension ~loc (sub.extension sub x) ~attrs:(sub.attributes sub attrs)
      | Pstr_attribute x -> attribute ~loc (sub.attribute sub x)
  end

  module E = struct
    (* Value expressions for the core language *)

    let map sub {pexp_loc = loc; pexp_desc = desc; pexp_attributes = attrs} =
      let open Exp in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pexp_ident x -> ident ~loc ~attrs (map_loc sub x)
      | Pexp_constant x -> constant ~loc ~attrs x
      | Pexp_let (r, vbs, e) ->
          let_ ~loc ~attrs r (List.map (sub.value_binding sub) vbs)
            (sub.expr sub e)
      | Pexp_fun (lab, def, p, e) ->
          fun_ ~loc ~attrs lab (map_opt (sub.expr sub) def) (sub.pat sub p)
            (sub.expr sub e)
      | Pexp_function pel -> function_ ~loc ~attrs (sub.cases sub pel)
      | Pexp_apply (e, l) ->
          apply ~loc ~attrs (sub.expr sub e) (List.map (map_snd (sub.expr sub)) l)
      | Pexp_match (e, pel) ->
          match_ ~loc ~attrs (sub.expr sub e) (sub.cases sub pel)
      | Pexp_try (e, pel) -> try_ ~loc ~attrs (sub.expr sub e) (sub.cases sub pel)
      | Pexp_tuple el -> tuple ~loc ~attrs (List.map (sub.expr sub) el)
      | Pexp_construct (lid, arg) ->
          construct ~loc ~attrs (map_loc sub lid) (map_opt (sub.expr sub) arg)
      | Pexp_variant (lab, eo) ->
          variant ~loc ~attrs lab (map_opt (sub.expr sub) eo)
      | Pexp_record (l, eo) ->
          record ~loc ~attrs (List.map (map_tuple (map_loc sub) (sub.expr sub)) l)
            (map_opt (sub.expr sub) eo)
      | Pexp_field (e, lid) ->
          field ~loc ~attrs (sub.expr sub e) (map_loc sub lid)
      | Pexp_setfield (e1, lid, e2) ->
          setfield ~loc ~attrs (sub.expr sub e1) (map_loc sub lid)
            (sub.expr sub e2)
      | Pexp_array el -> array ~loc ~attrs (List.map (sub.expr sub) el)
      | Pexp_ifthenelse (e1, e2, e3) ->
          ifthenelse ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)
            (map_opt (sub.expr sub) e3)
      | Pexp_sequence (e1, e2) ->
          sequence ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)
      | Pexp_while (e1, e2) ->
          while_ ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)
      | Pexp_for (p, e1, e2, d, e3) ->
          for_ ~loc ~attrs (sub.pat sub p) (sub.expr sub e1) (sub.expr sub e2) d
            (sub.expr sub e3)
      | Pexp_coerce (e, t1, t2) ->
          coerce ~loc ~attrs (sub.expr sub e) (map_opt (sub.typ sub) t1)
            (sub.typ sub t2)
      | Pexp_constraint (e, t) ->
          constraint_ ~loc ~attrs (sub.expr sub e) (sub.typ sub t)
      | Pexp_send (e, s) -> send ~loc ~attrs (sub.expr sub e) s
      | Pexp_new lid -> new_ ~loc ~attrs (map_loc sub lid)
      | Pexp_setinstvar (s, e) ->
          setinstvar ~loc ~attrs (map_loc sub s) (sub.expr sub e)
      | Pexp_override sel ->
          override ~loc ~attrs
            (List.map (map_tuple (map_loc sub) (sub.expr sub)) sel)
      | Pexp_letmodule (s, me, e) ->
          letmodule ~loc ~attrs (map_loc sub s) (sub.module_expr sub me)
            (sub.expr sub e)
      | Pexp_assert e -> assert_ ~loc ~attrs (sub.expr sub e)
      | Pexp_lazy e -> lazy_ ~loc ~attrs (sub.expr sub e)
      | Pexp_poly (e, t) ->
          poly ~loc ~attrs (sub.expr sub e) (map_opt (sub.typ sub) t)
      | Pexp_object cls -> object_ ~loc ~attrs (sub.class_structure sub cls)
      | Pexp_newtype (s, e) -> newtype ~loc ~attrs s (sub.expr sub e)
      | Pexp_pack me -> pack ~loc ~attrs (sub.module_expr sub me)
      | Pexp_open (ovf, lid, e) ->
          open_ ~loc ~attrs ovf (map_loc sub lid) (sub.expr sub e)
      | Pexp_extension x -> extension ~loc ~attrs (sub.extension sub x)
      | Pexp_unreachable -> unreachable ~loc ~attrs ()
  end

  module P = struct
    (* Patterns *)

    let map sub {ppat_desc = desc; ppat_loc = loc; ppat_attributes = attrs} =
      let open Pat in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Ppat_any -> any ~loc ~attrs ()
      | Ppat_var s -> var ~loc ~attrs (map_loc sub s)
      | Ppat_alias (p, s) -> alias ~loc ~attrs (sub.pat sub p) (map_loc sub s)
      | Ppat_constant c -> constant ~loc ~attrs c
      | Ppat_interval (c1, c2) -> interval ~loc ~attrs c1 c2
      | Ppat_tuple pl -> tuple ~loc ~attrs (List.map (sub.pat sub) pl)
      | Ppat_construct (l, p) ->
          construct ~loc ~attrs (map_loc sub l) (map_opt (sub.pat sub) p)
      | Ppat_variant (l, p) -> variant ~loc ~attrs l (map_opt (sub.pat sub) p)
      | Ppat_record (lpl, cf) ->
          record ~loc ~attrs
                 (List.map (map_tuple (map_loc sub) (sub.pat sub)) lpl) cf
      | Ppat_array pl -> array ~loc ~attrs (List.map (sub.pat sub) pl)
      | Ppat_or (p1, p2) -> or_ ~loc ~attrs (sub.pat sub p1) (sub.pat sub p2)
      | Ppat_constraint (p, t) ->
          constraint_ ~loc ~attrs (sub.pat sub p) (sub.typ sub t)
      | Ppat_type s -> type_ ~loc ~attrs (map_loc sub s)
      | Ppat_lazy p -> lazy_ ~loc ~attrs (sub.pat sub p)
      | Ppat_unpack s -> unpack ~loc ~attrs (map_loc sub s)
      | Ppat_exception p -> exception_ ~loc ~attrs (sub.pat sub p)
      | Ppat_extension x -> extension ~loc ~attrs (sub.extension sub x)
  end

  module CE = struct
    (* Value expressions for the class language *)

    let map sub {pcl_loc = loc; pcl_desc = desc; pcl_attributes = attrs} =
      let open Cl in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pcl_constr (lid, tys) ->
          constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tys)
      | Pcl_structure s ->
          structure ~loc ~attrs (sub.class_structure sub s)
      | Pcl_fun (lab, e, p, ce) ->
          fun_ ~loc ~attrs lab
            (map_opt (sub.expr sub) e)
            (sub.pat sub p)
            (sub.class_expr sub ce)
      | Pcl_apply (ce, l) ->
          apply ~loc ~attrs (sub.class_expr sub ce)
            (List.map (map_snd (sub.expr sub)) l)
      | Pcl_let (r, vbs, ce) ->
          let_ ~loc ~attrs r (List.map (sub.value_binding sub) vbs)
            (sub.class_expr sub ce)
      | Pcl_constraint (ce, ct) ->
          constraint_ ~loc ~attrs (sub.class_expr sub ce) (sub.class_type sub ct)
      | Pcl_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_kind sub = function
      | Cfk_concrete (o, e) -> Cfk_concrete (o, sub.expr sub e)
      | Cfk_virtual t -> Cfk_virtual (sub.typ sub t)

    let map_field sub {pcf_desc = desc; pcf_loc = loc; pcf_attributes = attrs} =
      let open Cf in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pcf_inherit (o, ce, s) -> inherit_ ~loc ~attrs o (sub.class_expr sub ce) s
      | Pcf_val (s, m, k) -> val_ ~loc ~attrs (map_loc sub s) m (map_kind sub k)
      | Pcf_method (s, p, k) ->
          method_ ~loc ~attrs (map_loc sub s) p (map_kind sub k)
      | Pcf_constraint (t1, t2) ->
          constraint_ ~loc ~attrs (sub.typ sub t1) (sub.typ sub t2)
      | Pcf_initializer e -> initializer_ ~loc ~attrs (sub.expr sub e)
      | Pcf_attribute x -> attribute ~loc (sub.attribute sub x)
      | Pcf_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_structure sub {pcstr_self; pcstr_fields} =
      {
        pcstr_self = sub.pat sub pcstr_self;
        pcstr_fields = List.map (sub.class_field sub) pcstr_fields;
      }

    let class_infos sub f {pci_virt; pci_params = pl; pci_name; pci_expr;
                           pci_loc; pci_attributes} =
      Ci.mk
       ~virt:pci_virt
       ~params:(List.map (map_fst (sub.typ sub)) pl)
        (map_loc sub pci_name)
        (f pci_expr)
        ~loc:(sub.location sub pci_loc)
        ~attrs:(sub.attributes sub pci_attributes)
  end

  (* Now, a generic AST mapper, to be extended to cover all kinds and
     cases of the OCaml grammar.  The default behavior of the mapper is
     the identity. *)

  let default_mapper =
    {
      structure = (fun this l -> List.map (this.structure_item this) l);
      structure_item = M.map_structure_item;
      module_expr = M.map;
      signature = (fun this l -> List.map (this.signature_item this) l);
      signature_item = MT.map_signature_item;
      module_type = MT.map;
      with_constraint = MT.map_with_constraint;
      class_declaration =
        (fun this -> CE.class_infos this (this.class_expr this));
      class_expr = CE.map;
      class_field = CE.map_field;
      class_structure = CE.map_structure;
      class_type = CT.map;
      class_type_field = CT.map_field;
      class_signature = CT.map_signature;
      class_type_declaration =
        (fun this -> CE.class_infos this (this.class_type this));
      class_description =
        (fun this -> CE.class_infos this (this.class_type this));
      type_declaration = T.map_type_declaration;
      type_kind = T.map_type_kind;
      typ = T.map;
      type_extension = T.map_type_extension;
      extension_constructor = T.map_extension_constructor;
      value_description =
        (fun this {pval_name; pval_type; pval_prim; pval_loc;
                   pval_attributes} ->
          Val.mk
            (map_loc this pval_name)
            (this.typ this pval_type)
            ~attrs:(this.attributes this pval_attributes)
            ~loc:(this.location this pval_loc)
            ~prim:pval_prim
        );

      pat = P.map;
      expr = E.map;

      module_declaration =
        (fun this {pmd_name; pmd_type; pmd_attributes; pmd_loc} ->
           Md.mk
             (map_loc this pmd_name)
             (this.module_type this pmd_type)
             ~attrs:(this.attributes this pmd_attributes)
             ~loc:(this.location this pmd_loc)
        );

      module_type_declaration =
        (fun this {pmtd_name; pmtd_type; pmtd_attributes; pmtd_loc} ->
           Mtd.mk
             (map_loc this pmtd_name)
             ?typ:(map_opt (this.module_type this) pmtd_type)
             ~attrs:(this.attributes this pmtd_attributes)
             ~loc:(this.location this pmtd_loc)
        );

      module_binding =
        (fun this {pmb_name; pmb_expr; pmb_attributes; pmb_loc} ->
           Mb.mk (map_loc this pmb_name) (this.module_expr this pmb_expr)
             ~attrs:(this.attributes this pmb_attributes)
             ~loc:(this.location this pmb_loc)
        );


      open_description =
        (fun this {popen_lid; popen_override; popen_attributes; popen_loc} ->
           Opn.mk (map_loc this popen_lid)
             ~override:popen_override
             ~loc:(this.location this popen_loc)
             ~attrs:(this.attributes this popen_attributes)
        );


      include_description =
        (fun this {pincl_mod; pincl_attributes; pincl_loc} ->
           Incl.mk (this.module_type this pincl_mod)
             ~loc:(this.location this pincl_loc)
             ~attrs:(this.attributes this pincl_attributes)
        );

      include_declaration =
        (fun this {pincl_mod; pincl_attributes; pincl_loc} ->
           Incl.mk (this.module_expr this pincl_mod)
             ~loc:(this.location this pincl_loc)
             ~attrs:(this.attributes this pincl_attributes)
        );


      value_binding =
        (fun this {pvb_pat; pvb_expr; pvb_attributes; pvb_loc} ->
           Vb.mk
             (this.pat this pvb_pat)
             (this.expr this pvb_expr)
             ~loc:(this.location this pvb_loc)
             ~attrs:(this.attributes this pvb_attributes)
        );


      constructor_declaration =
        (fun this {pcd_name; pcd_args; pcd_res; pcd_loc; pcd_attributes} ->
          Type.constructor
            (map_loc this pcd_name)
            ~args:(T.map_constructor_arguments this pcd_args)
            ?res:(map_opt (this.typ this) pcd_res)
            ~loc:(this.location this pcd_loc)
            ~attrs:(this.attributes this pcd_attributes)
        );

      label_declaration =
        (fun this {pld_name; pld_type; pld_loc; pld_mutable; pld_attributes} ->
           Type.field
             (map_loc this pld_name)
             (this.typ this pld_type)
             ~mut:pld_mutable
             ~loc:(this.location this pld_loc)
             ~attrs:(this.attributes this pld_attributes)
        );

      cases = (fun this l -> List.map (this.case this) l);
      case =
        (fun this {pc_lhs; pc_guard; pc_rhs} ->
           {
             pc_lhs = this.pat this pc_lhs;
             pc_guard = map_opt (this.expr this) pc_guard;
             pc_rhs = this.expr this pc_rhs;
           }
        );



      location = (fun _this l -> l);

      extension = (fun this (s, e) -> (map_loc this s, this.payload this e));
      attribute = (fun this (s, e) -> (map_loc this s, this.payload this e));
      attributes = (fun this l -> List.map (this.attribute this) l);
      payload =
        (fun this -> function
           | PStr x -> PStr (this.structure this x)
           | PSig x -> PSig (this.signature this x)
           | PTyp x -> PTyp (this.typ this x)
           | PPat (x, g) -> PPat (this.pat this x, map_opt (this.expr this) g)
        );
    }

  let rec extension_of_error {loc; msg; if_highlight; sub} =
    { loc; txt = "ocaml.error" },
    PStr ([Str.eval (Exp.constant (Pconst_string (msg, None)));
           Str.eval (Exp.constant (Pconst_string (if_highlight, None)))] @
          (List.map (fun ext -> Str.extension (extension_of_error ext)) sub))

  let attribute_of_warning loc s =
    { loc; txt = "ocaml.ppwarning" },
    PStr ([Str.eval ~loc (Exp.constant (Pconst_string (s, None)))])

end

module Outcometree = struct
  (* Module [Outcometree]: results displayed by the toplevel *)

  (* These types represent messages that the toplevel displays as normal
     results or errors. The real displaying is customisable using the hooks:
        [Toploop.print_out_value]
        [Toploop.print_out_type]
        [Toploop.print_out_sig_item]
        [Toploop.print_out_phrase] *)

  type out_ident (*IF_CURRENT = Outcometree.out_ident *) =
    | Oide_apply of out_ident * out_ident
    | Oide_dot of out_ident * string
    | Oide_ident of string

  type out_attribute (*IF_CURRENT = Outcometree.out_attribute *) =
    { oattr_name: string }

  type out_value (*IF_CURRENT = Outcometree.out_value *) =
    | Oval_array of out_value list
    | Oval_char of char
    | Oval_constr of out_ident * out_value list
    | Oval_ellipsis
    | Oval_float of float
    | Oval_int of int
    | Oval_int32 of int32
    | Oval_int64 of int64
    | Oval_nativeint of nativeint
    | Oval_list of out_value list
    | Oval_printer of (Format.formatter -> unit)
    | Oval_record of (out_ident * out_value) list
    | Oval_string of string
    | Oval_stuff of string
    | Oval_tuple of out_value list
    | Oval_variant of string * out_value option

  type out_type (*IF_CURRENT = Outcometree.out_type *) =
    | Otyp_abstract
    | Otyp_open
    | Otyp_alias of out_type * string
    | Otyp_arrow of string * out_type * out_type
    | Otyp_class of bool * out_ident * out_type list
    | Otyp_constr of out_ident * out_type list
    | Otyp_manifest of out_type * out_type
    | Otyp_object of (string * out_type) list * bool option
    | Otyp_record of (string * bool * out_type) list
    | Otyp_stuff of string
    | Otyp_sum of (string * out_type list * out_type option) list
    | Otyp_tuple of out_type list
    | Otyp_var of bool * string
    | Otyp_variant of
        bool * out_variant * bool * (string list) option
    | Otyp_poly of string list * out_type
    | Otyp_module of string * string list * out_type list
    | Otyp_attribute of out_type * out_attribute

  and out_variant (*IF_CURRENT = Outcometree.out_variant *) =
    | Ovar_fields of (string * bool * out_type list) list
    | Ovar_name of out_ident * out_type list

  type out_class_type (*IF_CURRENT = Outcometree.out_class_type *) =
    | Octy_constr of out_ident * out_type list
    | Octy_arrow of string * out_type * out_class_type
    | Octy_signature of out_type option * out_class_sig_item list
  and out_class_sig_item (*IF_CURRENT = Outcometree.out_class_sig_item *) =
    | Ocsg_constraint of out_type * out_type
    | Ocsg_method of string * bool * bool * out_type
    | Ocsg_value of string * bool * bool * out_type

  type out_module_type (*IF_CURRENT = Outcometree.out_module_type *) =
    | Omty_abstract
    | Omty_functor of string * out_module_type option * out_module_type
    | Omty_ident of out_ident
    | Omty_signature of out_sig_item list
    | Omty_alias of out_ident
  and out_sig_item (*IF_CURRENT = Outcometree.out_sig_item *) =
    | Osig_class of
        bool * string * (string * (bool * bool)) list * out_class_type *
          out_rec_status
    | Osig_class_type of
        bool * string * (string * (bool * bool)) list * out_class_type *
          out_rec_status
    | Osig_typext of out_extension_constructor * out_ext_status
    | Osig_modtype of string * out_module_type
    | Osig_module of string * out_module_type * out_rec_status
    | Osig_type of out_type_decl * out_rec_status
    | Osig_value of out_val_decl
    | Osig_ellipsis
  and out_type_decl (*IF_CURRENT = Outcometree.out_type_decl *) =
    { otype_name: string;
      otype_params: (string * (bool * bool)) list;
      otype_type: out_type;
      otype_private: Asttypes.private_flag;
      otype_immediate: bool;
      otype_cstrs: (out_type * out_type) list }
  and out_extension_constructor (*IF_CURRENT = Outcometree.out_extension_constructor *) =
    { oext_name: string;
      oext_type_name: string;
      oext_type_params: string list;
      oext_args: out_type list;
      oext_ret_type: out_type option;
      oext_private: Asttypes.private_flag }
  and out_type_extension (*IF_CURRENT = Outcometree.out_type_extension *) =
    { otyext_name: string;
      otyext_params: string list;
      otyext_constructors: (string * out_type list * out_type option) list;
      otyext_private: Asttypes.private_flag }
  and out_val_decl (*IF_CURRENT = Outcometree.out_val_decl *) =
    { oval_name: string;
      oval_type: out_type;
      oval_prims: string list;
      oval_attributes: out_attribute list }
  and out_rec_status (*IF_CURRENT = Outcometree.out_rec_status *) =
    | Orec_not
    | Orec_first
    | Orec_next
  and out_ext_status (*IF_CURRENT = Outcometree.out_ext_status *) =
    | Oext_first
    | Oext_next
    | Oext_exception

  type out_phrase (*IF_CURRENT = Outcometree.out_phrase *) =
    | Ophr_eval of out_value * out_type
    | Ophr_signature of (out_sig_item * out_value option) list
    | Ophr_exception of (exn * out_value)

end

module Config = struct
  let ast_impl_magic_number = "Caml1999M019"
  let ast_intf_magic_number = "Caml1999N018"
end

let map_signature mapper = mapper.Ast_mapper.signature mapper
let map_structure mapper = mapper.Ast_mapper.structure mapper

let shallow_identity =
  let id _ x = x in
  {
    Ast_mapper.
    structure               = id;
    structure_item          = id;
    module_expr             = id;
    signature               = id;
    signature_item          = id;
    module_type             = id;
    with_constraint         = id;
    class_declaration       = id;
    class_expr              = id;
    class_field             = id;
    class_structure         = id;
    class_type              = id;
    class_type_field        = id;
    class_signature         = id;
    class_type_declaration  = id;
    class_description       = id;
    type_declaration        = id;
    type_kind               = id;
    typ                     = id;
    type_extension          = id;
    extension_constructor   = id;
    value_description       = id;
    pat                     = id;
    expr                    = id;
    module_declaration      = id;
    module_type_declaration = id;
    module_binding          = id;
    open_description        = id;
    include_description     = id;
    include_declaration     = id;
    value_binding           = id;
    constructor_declaration = id;
    label_declaration       = id;
    cases                   = id;
    case                    = id;
    location                = id;
    extension               = id;
    attribute               = id;
    attributes              = id;
    payload                 = id;
  }

let failing_mapper =
  let fail _ _ =
    invalid_arg "failing_mapper: this mapper function should never get called"
  in
  {
    Ast_mapper.
    structure               = fail;
    structure_item          = fail;
    module_expr             = fail;
    signature               = fail;
    signature_item          = fail;
    module_type             = fail;
    with_constraint         = fail;
    class_declaration       = fail;
    class_expr              = fail;
    class_field             = fail;
    class_structure         = fail;
    class_type              = fail;
    class_type_field        = fail;
    class_signature         = fail;
    class_type_declaration  = fail;
    class_description       = fail;
    type_declaration        = fail;
    type_kind               = fail;
    typ                     = fail;
    type_extension          = fail;
    extension_constructor   = fail;
    value_description       = fail;
    pat                     = fail;
    expr                    = fail;
    module_declaration      = fail;
    module_type_declaration = fail;
    module_binding          = fail;
    open_description        = fail;
    include_description     = fail;
    include_declaration     = fail;
    value_binding           = fail;
    constructor_declaration = fail;
    label_declaration       = fail;
    cases                   = fail;
    case                    = fail;
    location                = fail;
    extension               = fail;
    attribute               = fail;
    attributes              = fail;
    payload                 = fail;
  }

let make_top_mapper ~signature ~structure =
  {failing_mapper with Ast_mapper.
                    signature = (fun _ x -> signature x);
                    structure = (fun _ x -> structure x) }

end
module Ast_405
= struct
#1 "ast_405.ml"
# 1 "src/ast_405.ml"
# 1 "src/ast_405.ml"
# 1 "src/ast_405.ml"
# 1 "src/ast_405.ml"
# 1 "src/ast_405.ml"
# 1 "src/ast_405.ml"
# 1 "src/ast_405.ml"
# 1 "src/ast_405.ml"
# 1 "src/ast_405.ml"
# 1 "src/ast_405.ml"
# 1 "src/ast_405.ml"
# 1 "src/ast_405.ml"
# 1 "src/ast_405.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*            Jérémie Dimino and Leo White, Jane Street Europe            *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt            *)
(*                         Alain Frisch, LexiFi                           *)
(*       Daniel de Rauglaudre, projet Cristal, INRIA Rocquencourt         *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

module Location = Location
module Longident = Longident

module Asttypes = struct
  (** Auxiliary AST types used by parsetree and typedtree. *)

  type constant (*IF_CURRENT = Asttypes.constant *) =
      Const_int of int
    | Const_char of char
    | Const_string of string * string option
    | Const_float of string
    | Const_int32 of int32
    | Const_int64 of int64
    | Const_nativeint of nativeint

  type rec_flag (*IF_CURRENT = Asttypes.rec_flag *) = Nonrecursive | Recursive

  type direction_flag (*IF_CURRENT = Asttypes.direction_flag *) = Upto | Downto

  (* Order matters, used in polymorphic comparison *)
  type private_flag (*IF_CURRENT = Asttypes.private_flag *) = Private | Public

  type mutable_flag (*IF_CURRENT = Asttypes.mutable_flag *) = Immutable | Mutable

  type virtual_flag (*IF_CURRENT = Asttypes.virtual_flag *) = Virtual | Concrete

  type override_flag (*IF_CURRENT = Asttypes.override_flag *) = Override | Fresh

  type closed_flag (*IF_CURRENT = Asttypes.closed_flag *) = Closed | Open

  type label = string

  type arg_label (*IF_CURRENT = Asttypes.arg_label *) =
      Nolabel
    | Labelled of string (*  label:T -> ... *)
    | Optional of string (* ?label:T -> ... *)

  type 'a loc = 'a Location.loc = {
    txt : 'a;
    loc : Location.t;
  }


  type variance (*IF_CURRENT = Asttypes.variance *) =
    | Covariant
    | Contravariant
    | Invariant
end

module Parsetree = struct
  (** Abstract syntax tree produced by parsing *)

  open Asttypes

  type constant (*IF_CURRENT = Parsetree.constant *) =
      Pconst_integer of string * char option
    (* 3 3l 3L 3n

       Suffixes [g-z][G-Z] are accepted by the parser.
       Suffixes except 'l', 'L' and 'n' are rejected by the typechecker
    *)
    | Pconst_char of char
    (* 'c' *)
    | Pconst_string of string * string option
    (* "constant"
       {delim|other constant|delim}
    *)
    | Pconst_float of string * char option
    (* 3.4 2e5 1.4e-4

       Suffixes [g-z][G-Z] are accepted by the parser.
       Suffixes are rejected by the typechecker.
    *)

  (** {2 Extension points} *)

  type attribute = string loc * payload
         (* [@id ARG]
            [@@id ARG]

            Metadata containers passed around within the AST.
            The compiler ignores unknown attributes.
         *)

  and extension = string loc * payload
        (* [%id ARG]
           [%%id ARG]

           Sub-language placeholder -- rejected by the typechecker.
        *)

  and attributes = attribute list

  and payload (*IF_CURRENT = Parsetree.payload *) =
    | PStr of structure
    | PSig of signature (* : SIG *)
    | PTyp of core_type  (* : T *)
    | PPat of pattern * expression option  (* ? P  or  ? P when E *)

  (** {2 Core language} *)

  (* Type expressions *)

  and core_type (*IF_CURRENT = Parsetree.core_type *) =
      {
       ptyp_desc: core_type_desc;
       ptyp_loc: Location.t;
       ptyp_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and core_type_desc (*IF_CURRENT = Parsetree.core_type_desc *) =
    | Ptyp_any
          (*  _ *)
    | Ptyp_var of string
          (* 'a *)
    | Ptyp_arrow of arg_label * core_type * core_type
          (* T1 -> T2       Simple
             ~l:T1 -> T2    Labelled
             ?l:T1 -> T2    Otional
           *)
    | Ptyp_tuple of core_type list
          (* T1 * ... * Tn

             Invariant: n >= 2
          *)
    | Ptyp_constr of Longident.t loc * core_type list
          (* tconstr
             T tconstr
             (T1, ..., Tn) tconstr
           *)
    | Ptyp_object of (string loc * attributes * core_type) list * closed_flag
          (* < l1:T1; ...; ln:Tn >     (flag = Closed)
             < l1:T1; ...; ln:Tn; .. > (flag = Open)
           *)
    | Ptyp_class of Longident.t loc * core_type list
          (* #tconstr
             T #tconstr
             (T1, ..., Tn) #tconstr
           *)
    | Ptyp_alias of core_type * string
          (* T as 'a *)
    | Ptyp_variant of row_field list * closed_flag * label list option
          (* [ `A|`B ]         (flag = Closed; labels = None)
             [> `A|`B ]        (flag = Open;   labels = None)
             [< `A|`B ]        (flag = Closed; labels = Some [])
             [< `A|`B > `X `Y ](flag = Closed; labels = Some ["X";"Y"])
           *)
    | Ptyp_poly of string loc list * core_type
          (* 'a1 ... 'an. T

             Can only appear in the following context:

             - As the core_type of a Ppat_constraint node corresponding
               to a constraint on a let-binding: let x : 'a1 ... 'an. T
               = e ...

             - Under Cfk_virtual for methods (not values).

             - As the core_type of a Pctf_method node.

             - As the core_type of a Pexp_poly node.

             - As the pld_type field of a label_declaration.

             - As a core_type of a Ptyp_object node.
           *)

    | Ptyp_package of package_type
          (* (module S) *)
    | Ptyp_extension of extension
          (* [%id] *)

  and package_type = Longident.t loc * (Longident.t loc * core_type) list
        (*
          (module S)
          (module S with type t1 = T1 and ... and tn = Tn)
         *)

  and row_field (*IF_CURRENT = Parsetree.row_field *) =
    | Rtag of label * attributes * bool * core_type list
          (* [`A]                   ( true,  [] )
             [`A of T]              ( false, [T] )
             [`A of T1 & .. & Tn]   ( false, [T1;...Tn] )
             [`A of & T1 & .. & Tn] ( true,  [T1;...Tn] )

            - The 2nd field is true if the tag contains a
              constant (empty) constructor.
            - '&' occurs when several types are used for the same constructor
              (see 4.2 in the manual)

            - TODO: switch to a record representation, and keep location
          *)
    | Rinherit of core_type
          (* [ T ] *)

  (* Patterns *)

  and pattern (*IF_CURRENT = Parsetree.pattern *) =
      {
       ppat_desc: pattern_desc;
       ppat_loc: Location.t;
       ppat_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and pattern_desc (*IF_CURRENT = Parsetree.pattern_desc *) =
    | Ppat_any
          (* _ *)
    | Ppat_var of string loc
          (* x *)
    | Ppat_alias of pattern * string loc
          (* P as 'a *)
    | Ppat_constant of constant
          (* 1, 'a', "true", 1.0, 1l, 1L, 1n *)
    | Ppat_interval of constant * constant
          (* 'a'..'z'

             Other forms of interval are recognized by the parser
             but rejected by the type-checker. *)
    | Ppat_tuple of pattern list
          (* (P1, ..., Pn)

             Invariant: n >= 2
          *)
    | Ppat_construct of Longident.t loc * pattern option
          (* C                None
             C P              Some P
             C (P1, ..., Pn)  Some (Ppat_tuple [P1; ...; Pn])
           *)
    | Ppat_variant of label * pattern option
          (* `A             (None)
             `A P           (Some P)
           *)
    | Ppat_record of (Longident.t loc * pattern) list * closed_flag
          (* { l1=P1; ...; ln=Pn }     (flag = Closed)
             { l1=P1; ...; ln=Pn; _}   (flag = Open)

             Invariant: n > 0
           *)
    | Ppat_array of pattern list
          (* [| P1; ...; Pn |] *)
    | Ppat_or of pattern * pattern
          (* P1 | P2 *)
    | Ppat_constraint of pattern * core_type
          (* (P : T) *)
    | Ppat_type of Longident.t loc
          (* #tconst *)
    | Ppat_lazy of pattern
          (* lazy P *)
    | Ppat_unpack of string loc
          (* (module P)
             Note: (module P : S) is represented as
             Ppat_constraint(Ppat_unpack, Ptyp_package)
           *)
    | Ppat_exception of pattern
          (* exception P *)
    | Ppat_extension of extension
          (* [%id] *)
    | Ppat_open of Longident.t loc * pattern
          (* M.(P) *)

  (* Value expressions *)

  and expression (*IF_CURRENT = Parsetree.expression *) =
      {
       pexp_desc: expression_desc;
       pexp_loc: Location.t;
       pexp_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and expression_desc (*IF_CURRENT = Parsetree.expression_desc *) =
    | Pexp_ident of Longident.t loc
          (* x
             M.x
           *)
    | Pexp_constant of constant
          (* 1, 'a', "true", 1.0, 1l, 1L, 1n *)
    | Pexp_let of rec_flag * value_binding list * expression
          (* let P1 = E1 and ... and Pn = EN in E       (flag = Nonrecursive)
             let rec P1 = E1 and ... and Pn = EN in E   (flag = Recursive)
           *)
    | Pexp_function of case list
          (* function P1 -> E1 | ... | Pn -> En *)
    | Pexp_fun of arg_label * expression option * pattern * expression
          (* fun P -> E1                          (Simple, None)
             fun ~l:P -> E1                       (Labelled l, None)
             fun ?l:P -> E1                       (Optional l, None)
             fun ?l:(P = E0) -> E1                (Optional l, Some E0)

             Notes:
             - If E0 is provided, only Optional is allowed.
             - "fun P1 P2 .. Pn -> E1" is represented as nested Pexp_fun.
             - "let f P = E" is represented using Pexp_fun.
           *)
    | Pexp_apply of expression * (arg_label * expression) list
          (* E0 ~l1:E1 ... ~ln:En
             li can be empty (non labeled argument) or start with '?'
             (optional argument).

             Invariant: n > 0
           *)
    | Pexp_match of expression * case list
          (* match E0 with P1 -> E1 | ... | Pn -> En *)
    | Pexp_try of expression * case list
          (* try E0 with P1 -> E1 | ... | Pn -> En *)
    | Pexp_tuple of expression list
          (* (E1, ..., En)

             Invariant: n >= 2
          *)
    | Pexp_construct of Longident.t loc * expression option
          (* C                None
             C E              Some E
             C (E1, ..., En)  Some (Pexp_tuple[E1;...;En])
          *)
    | Pexp_variant of label * expression option
          (* `A             (None)
             `A E           (Some E)
           *)
    | Pexp_record of (Longident.t loc * expression) list * expression option
          (* { l1=P1; ...; ln=Pn }     (None)
             { E0 with l1=P1; ...; ln=Pn }   (Some E0)

             Invariant: n > 0
           *)
    | Pexp_field of expression * Longident.t loc
          (* E.l *)
    | Pexp_setfield of expression * Longident.t loc * expression
          (* E1.l <- E2 *)
    | Pexp_array of expression list
          (* [| E1; ...; En |] *)
    | Pexp_ifthenelse of expression * expression * expression option
          (* if E1 then E2 else E3 *)
    | Pexp_sequence of expression * expression
          (* E1; E2 *)
    | Pexp_while of expression * expression
          (* while E1 do E2 done *)
    | Pexp_for of
        pattern *  expression * expression * direction_flag * expression
          (* for i = E1 to E2 do E3 done      (flag = Upto)
             for i = E1 downto E2 do E3 done  (flag = Downto)
           *)
    | Pexp_constraint of expression * core_type
          (* (E : T) *)
    | Pexp_coerce of expression * core_type option * core_type
          (* (E :> T)        (None, T)
             (E : T0 :> T)   (Some T0, T)
           *)
    | Pexp_send of expression * string loc
          (*  E # m *)
    | Pexp_new of Longident.t loc
          (* new M.c *)
    | Pexp_setinstvar of string loc * expression
          (* x <- 2 *)
    | Pexp_override of (string loc * expression) list
          (* {< x1 = E1; ...; Xn = En >} *)
    | Pexp_letmodule of string loc * module_expr * expression
          (* let module M = ME in E *)
    | Pexp_letexception of extension_constructor * expression
          (* let exception C in E *)
    | Pexp_assert of expression
          (* assert E
             Note: "assert false" is treated in a special way by the
             type-checker. *)
    | Pexp_lazy of expression
          (* lazy E *)
    | Pexp_poly of expression * core_type option
          (* Used for method bodies.

             Can only be used as the expression under Cfk_concrete
             for methods (not values). *)
    | Pexp_object of class_structure
          (* object ... end *)
    | Pexp_newtype of string loc * expression
          (* fun (type t) -> E *)
    | Pexp_pack of module_expr
          (* (module ME)

             (module ME : S) is represented as
             Pexp_constraint(Pexp_pack, Ptyp_package S) *)
    | Pexp_open of override_flag * Longident.t loc * expression
          (* M.(E)
             let open M in E
             let! open M in E *)
    | Pexp_extension of extension
          (* [%id] *)
    | Pexp_unreachable
          (* . *)

  and case (*IF_CURRENT = Parsetree.case *) =   (* (P -> E) or (P when E0 -> E) *)
      {
       pc_lhs: pattern;
       pc_guard: expression option;
       pc_rhs: expression;
      }

  (* Value descriptions *)

  and value_description (*IF_CURRENT = Parsetree.value_description *) =
      {
       pval_name: string loc;
       pval_type: core_type;
       pval_prim: string list;
       pval_attributes: attributes;  (* ... [@@id1] [@@id2] *)
       pval_loc: Location.t;
      }

  (*
    val x: T                            (prim = [])
    external x: T = "s1" ... "sn"       (prim = ["s1";..."sn"])
  *)

  (* Type declarations *)

  and type_declaration (*IF_CURRENT = Parsetree.type_declaration *) =
      {
       ptype_name: string loc;
       ptype_params: (core_type * variance) list;
             (* ('a1,...'an) t; None represents  _*)
       ptype_cstrs: (core_type * core_type * Location.t) list;
             (* ... constraint T1=T1'  ... constraint Tn=Tn' *)
       ptype_kind: type_kind;
       ptype_private: private_flag;   (* = private ... *)
       ptype_manifest: core_type option;  (* = T *)
       ptype_attributes: attributes;   (* ... [@@id1] [@@id2] *)
       ptype_loc: Location.t;
      }

  (*
    type t                     (abstract, no manifest)
    type t = T0                (abstract, manifest=T0)
    type t = C of T | ...      (variant,  no manifest)
    type t = T0 = C of T | ... (variant,  manifest=T0)
    type t = {l: T; ...}       (record,   no manifest)
    type t = T0 = {l : T; ...} (record,   manifest=T0)
    type t = ..                (open,     no manifest)
  *)

  and type_kind (*IF_CURRENT = Parsetree.type_kind *) =
    | Ptype_abstract
    | Ptype_variant of constructor_declaration list
          (* Invariant: non-empty list *)
    | Ptype_record of label_declaration list
          (* Invariant: non-empty list *)
    | Ptype_open

  and label_declaration (*IF_CURRENT = Parsetree.label_declaration *) =
      {
       pld_name: string loc;
       pld_mutable: mutable_flag;
       pld_type: core_type;
       pld_loc: Location.t;
       pld_attributes: attributes; (* l [@id1] [@id2] : T *)
      }

  (*  { ...; l: T; ... }            (mutable=Immutable)
      { ...; mutable l: T; ... }    (mutable=Mutable)

      Note: T can be a Ptyp_poly.
  *)

  and constructor_declaration (*IF_CURRENT = Parsetree.constructor_declaration *) =
      {
       pcd_name: string loc;
       pcd_args: constructor_arguments;
       pcd_res: core_type option;
       pcd_loc: Location.t;
       pcd_attributes: attributes; (* C [@id1] [@id2] of ... *)
      }

  and constructor_arguments (*IF_CURRENT = Parsetree.constructor_arguments *) =
    | Pcstr_tuple of core_type list
    | Pcstr_record of label_declaration list

  (*
    | C of T1 * ... * Tn     (res = None,    args = Pcstr_tuple [])
    | C: T0                  (res = Some T0, args = [])
    | C: T1 * ... * Tn -> T0 (res = Some T0, args = Pcstr_tuple)
    | C of {...}             (res = None,    args = Pcstr_record)
    | C: {...} -> T0         (res = Some T0, args = Pcstr_record)
    | C of {...} as t        (res = None,    args = Pcstr_record)
  *)

  and type_extension (*IF_CURRENT = Parsetree.type_extension *) =
      {
       ptyext_path: Longident.t loc;
       ptyext_params: (core_type * variance) list;
       ptyext_constructors: extension_constructor list;
       ptyext_private: private_flag;
       ptyext_attributes: attributes;   (* ... [@@id1] [@@id2] *)
      }
  (*
    type t += ...
  *)

  and extension_constructor (*IF_CURRENT = Parsetree.extension_constructor *) =
      {
       pext_name: string loc;
       pext_kind : extension_constructor_kind;
       pext_loc : Location.t;
       pext_attributes: attributes; (* C [@id1] [@id2] of ... *)
      }

  and extension_constructor_kind (*IF_CURRENT = Parsetree.extension_constructor_kind *) =
      Pext_decl of constructor_arguments * core_type option
        (*
           | C of T1 * ... * Tn     ([T1; ...; Tn], None)
           | C: T0                  ([], Some T0)
           | C: T1 * ... * Tn -> T0 ([T1; ...; Tn], Some T0)
         *)
    | Pext_rebind of Longident.t loc
        (*
           | C = D
         *)

  (** {2 Class language} *)

  (* Type expressions for the class language *)

  and class_type (*IF_CURRENT = Parsetree.class_type *) =
      {
       pcty_desc: class_type_desc;
       pcty_loc: Location.t;
       pcty_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and class_type_desc (*IF_CURRENT = Parsetree.class_type_desc *) =
    | Pcty_constr of Longident.t loc * core_type list
          (* c
             ['a1, ..., 'an] c *)
    | Pcty_signature of class_signature
          (* object ... end *)
    | Pcty_arrow of arg_label * core_type * class_type
          (* T -> CT       Simple
             ~l:T -> CT    Labelled l
             ?l:T -> CT    Optional l
           *)
    | Pcty_extension of extension
          (* [%id] *)

  and class_signature (*IF_CURRENT = Parsetree.class_signature *) =
      {
       pcsig_self: core_type;
       pcsig_fields: class_type_field list;
      }
  (* object('selfpat) ... end
     object ... end             (self = Ptyp_any)
   *)

  and class_type_field (*IF_CURRENT = Parsetree.class_type_field *) =
      {
       pctf_desc: class_type_field_desc;
       pctf_loc: Location.t;
       pctf_attributes: attributes; (* ... [@@id1] [@@id2] *)
      }

  and class_type_field_desc (*IF_CURRENT = Parsetree.class_type_field_desc *) =
    | Pctf_inherit of class_type
          (* inherit CT *)
    | Pctf_val of (string loc * mutable_flag * virtual_flag * core_type)
          (* val x: T *)
    | Pctf_method  of (string loc * private_flag * virtual_flag * core_type)
          (* method x: T

             Note: T can be a Ptyp_poly.
           *)
    | Pctf_constraint  of (core_type * core_type)
          (* constraint T1 = T2 *)
    | Pctf_attribute of attribute
          (* [@@@id] *)
    | Pctf_extension of extension
          (* [%%id] *)

  and 'a class_infos (*IF_CURRENT = 'a Parsetree.class_infos *) =
      {
       pci_virt: virtual_flag;
       pci_params: (core_type * variance) list;
       pci_name: string loc;
       pci_expr: 'a;
       pci_loc: Location.t;
       pci_attributes: attributes;  (* ... [@@id1] [@@id2] *)
      }
  (* class c = ...
     class ['a1,...,'an] c = ...
     class virtual c = ...

     Also used for "class type" declaration.
  *)

  and class_description = class_type class_infos

  and class_type_declaration = class_type class_infos

  (* Value expressions for the class language *)

  and class_expr (*IF_CURRENT = Parsetree.class_expr *) =
      {
       pcl_desc: class_expr_desc;
       pcl_loc: Location.t;
       pcl_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and class_expr_desc (*IF_CURRENT = Parsetree.class_expr_desc *) =
    | Pcl_constr of Longident.t loc * core_type list
          (* c
             ['a1, ..., 'an] c *)
    | Pcl_structure of class_structure
          (* object ... end *)
    | Pcl_fun of arg_label * expression option * pattern * class_expr
          (* fun P -> CE                          (Simple, None)
             fun ~l:P -> CE                       (Labelled l, None)
             fun ?l:P -> CE                       (Optional l, None)
             fun ?l:(P = E0) -> CE                (Optional l, Some E0)
           *)
    | Pcl_apply of class_expr * (arg_label * expression) list
          (* CE ~l1:E1 ... ~ln:En
             li can be empty (non labeled argument) or start with '?'
             (optional argument).

             Invariant: n > 0
           *)
    | Pcl_let of rec_flag * value_binding list * class_expr
          (* let P1 = E1 and ... and Pn = EN in CE      (flag = Nonrecursive)
             let rec P1 = E1 and ... and Pn = EN in CE  (flag = Recursive)
           *)
    | Pcl_constraint of class_expr * class_type
          (* (CE : CT) *)
    | Pcl_extension of extension
          (* [%id] *)

  and class_structure (*IF_CURRENT = Parsetree.class_structure *) =
      {
       pcstr_self: pattern;
       pcstr_fields: class_field list;
      }
  (* object(selfpat) ... end
     object ... end           (self = Ppat_any)
   *)

  and class_field (*IF_CURRENT = Parsetree.class_field *) =
      {
       pcf_desc: class_field_desc;
       pcf_loc: Location.t;
       pcf_attributes: attributes; (* ... [@@id1] [@@id2] *)
      }

  and class_field_desc (*IF_CURRENT = Parsetree.class_field_desc *) =
    | Pcf_inherit of override_flag * class_expr * string loc option
          (* inherit CE
             inherit CE as x
             inherit! CE
             inherit! CE as x
           *)
    | Pcf_val of (string loc * mutable_flag * class_field_kind)
          (* val x = E
             val virtual x: T
           *)
    | Pcf_method of (string loc * private_flag * class_field_kind)
          (* method x = E            (E can be a Pexp_poly)
             method virtual x: T     (T can be a Ptyp_poly)
           *)
    | Pcf_constraint of (core_type * core_type)
          (* constraint T1 = T2 *)
    | Pcf_initializer of expression
          (* initializer E *)
    | Pcf_attribute of attribute
          (* [@@@id] *)
    | Pcf_extension of extension
          (* [%%id] *)

  and class_field_kind (*IF_CURRENT = Parsetree.class_field_kind *) =
    | Cfk_virtual of core_type
    | Cfk_concrete of override_flag * expression

  and class_declaration = class_expr class_infos

  (** {2 Module language} *)

  (* Type expressions for the module language *)

  and module_type (*IF_CURRENT = Parsetree.module_type *) =
      {
       pmty_desc: module_type_desc;
       pmty_loc: Location.t;
       pmty_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and module_type_desc (*IF_CURRENT = Parsetree.module_type_desc *) =
    | Pmty_ident of Longident.t loc
          (* S *)
    | Pmty_signature of signature
          (* sig ... end *)
    | Pmty_functor of string loc * module_type option * module_type
          (* functor(X : MT1) -> MT2 *)
    | Pmty_with of module_type * with_constraint list
          (* MT with ... *)
    | Pmty_typeof of module_expr
          (* module type of ME *)
    | Pmty_extension of extension
          (* [%id] *)
    | Pmty_alias of Longident.t loc
          (* (module M) *)

  and signature = signature_item list

  and signature_item (*IF_CURRENT = Parsetree.signature_item *) =
      {
       psig_desc: signature_item_desc;
       psig_loc: Location.t;
      }

  and signature_item_desc (*IF_CURRENT = Parsetree.signature_item_desc *) =
    | Psig_value of value_description
          (*
            val x: T
            external x: T = "s1" ... "sn"
           *)
    | Psig_type of rec_flag * type_declaration list
          (* type t1 = ... and ... and tn = ... *)
    | Psig_typext of type_extension
          (* type t1 += ... *)
    | Psig_exception of extension_constructor
          (* exception C of T *)
    | Psig_module of module_declaration
          (* module X : MT *)
    | Psig_recmodule of module_declaration list
          (* module rec X1 : MT1 and ... and Xn : MTn *)
    | Psig_modtype of module_type_declaration
          (* module type S = MT
             module type S *)
    | Psig_open of open_description
          (* open X *)
    | Psig_include of include_description
          (* include MT *)
    | Psig_class of class_description list
          (* class c1 : ... and ... and cn : ... *)
    | Psig_class_type of class_type_declaration list
          (* class type ct1 = ... and ... and ctn = ... *)
    | Psig_attribute of attribute
          (* [@@@id] *)
    | Psig_extension of extension * attributes
          (* [%%id] *)

  and module_declaration (*IF_CURRENT = Parsetree.module_declaration *) =
      {
       pmd_name: string loc;
       pmd_type: module_type;
       pmd_attributes: attributes; (* ... [@@id1] [@@id2] *)
       pmd_loc: Location.t;
      }
  (* S : MT *)

  and module_type_declaration (*IF_CURRENT = Parsetree.module_type_declaration *) =
      {
       pmtd_name: string loc;
       pmtd_type: module_type option;
       pmtd_attributes: attributes; (* ... [@@id1] [@@id2] *)
       pmtd_loc: Location.t;
      }
  (* S = MT
     S       (abstract module type declaration, pmtd_type = None)
  *)

  and open_description (*IF_CURRENT = Parsetree.open_description *) =
      {
       popen_lid: Longident.t loc;
       popen_override: override_flag;
       popen_loc: Location.t;
       popen_attributes: attributes;
      }
  (* open! X - popen_override = Override (silences the 'used identifier
                                shadowing' warning)
     open  X - popen_override = Fresh
   *)

  and 'a include_infos (*IF_CURRENT = 'a Parsetree.include_infos *) =
      {
       pincl_mod: 'a;
       pincl_loc: Location.t;
       pincl_attributes: attributes;
      }

  and include_description = module_type include_infos
  (* include MT *)

  and include_declaration = module_expr include_infos
  (* include ME *)

  and with_constraint (*IF_CURRENT = Parsetree.with_constraint *) =
    | Pwith_type of Longident.t loc * type_declaration
          (* with type X.t = ...

             Note: the last component of the longident must match
             the name of the type_declaration. *)
    | Pwith_module of Longident.t loc * Longident.t loc
          (* with module X.Y = Z *)
    | Pwith_typesubst of type_declaration
          (* with type t := ... *)
    | Pwith_modsubst of string loc * Longident.t loc
          (* with module X := Z *)

  (* Value expressions for the module language *)

  and module_expr (*IF_CURRENT = Parsetree.module_expr *) =
      {
       pmod_desc: module_expr_desc;
       pmod_loc: Location.t;
       pmod_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and module_expr_desc (*IF_CURRENT = Parsetree.module_expr_desc *) =
    | Pmod_ident of Longident.t loc
          (* X *)
    | Pmod_structure of structure
          (* struct ... end *)
    | Pmod_functor of string loc * module_type option * module_expr
          (* functor(X : MT1) -> ME *)
    | Pmod_apply of module_expr * module_expr
          (* ME1(ME2) *)
    | Pmod_constraint of module_expr * module_type
          (* (ME : MT) *)
    | Pmod_unpack of expression
          (* (val E) *)
    | Pmod_extension of extension
          (* [%id] *)

  and structure = structure_item list

  and structure_item (*IF_CURRENT = Parsetree.structure_item *) =
      {
       pstr_desc: structure_item_desc;
       pstr_loc: Location.t;
      }

  and structure_item_desc (*IF_CURRENT = Parsetree.structure_item_desc *) =
    | Pstr_eval of expression * attributes
          (* E *)
    | Pstr_value of rec_flag * value_binding list
          (* let P1 = E1 and ... and Pn = EN       (flag = Nonrecursive)
             let rec P1 = E1 and ... and Pn = EN   (flag = Recursive)
           *)
    | Pstr_primitive of value_description
          (*  val x: T
              external x: T = "s1" ... "sn" *)
    | Pstr_type of rec_flag * type_declaration list
          (* type t1 = ... and ... and tn = ... *)
    | Pstr_typext of type_extension
          (* type t1 += ... *)
    | Pstr_exception of extension_constructor
          (* exception C of T
             exception C = M.X *)
    | Pstr_module of module_binding
          (* module X = ME *)
    | Pstr_recmodule of module_binding list
          (* module rec X1 = ME1 and ... and Xn = MEn *)
    | Pstr_modtype of module_type_declaration
          (* module type S = MT *)
    | Pstr_open of open_description
          (* open X *)
    | Pstr_class of class_declaration list
          (* class c1 = ... and ... and cn = ... *)
    | Pstr_class_type of class_type_declaration list
          (* class type ct1 = ... and ... and ctn = ... *)
    | Pstr_include of include_declaration
          (* include ME *)
    | Pstr_attribute of attribute
          (* [@@@id] *)
    | Pstr_extension of extension * attributes
          (* [%%id] *)

  and value_binding (*IF_CURRENT = Parsetree.value_binding *) =
    {
      pvb_pat: pattern;
      pvb_expr: expression;
      pvb_attributes: attributes;
      pvb_loc: Location.t;
    }

  and module_binding (*IF_CURRENT = Parsetree.module_binding *) =
      {
       pmb_name: string loc;
       pmb_expr: module_expr;
       pmb_attributes: attributes;
       pmb_loc: Location.t;
      }
  (* X = ME *)

  (** {2 Toplevel} *)

  (* Toplevel phrases *)

  type toplevel_phrase (*IF_CURRENT = Parsetree.toplevel_phrase *) =
    | Ptop_def of structure
    | Ptop_dir of string * directive_argument
       (* #use, #load ... *)

  and directive_argument (*IF_CURRENT = Parsetree.directive_argument *) =
    | Pdir_none
    | Pdir_string of string
    | Pdir_int of string * char option
    | Pdir_ident of Longident.t
    | Pdir_bool of bool

end

module Docstrings : sig
  (** {3 Docstrings} *)

  (** Documentation comments *)
  type docstring

  (** Create a docstring *)
  val docstring : string -> Location.t -> docstring

  (** Get the text of a docstring *)
  val docstring_body : docstring -> string

  (** Get the location of a docstring *)
  val docstring_loc : docstring -> Location.t

  (** {3 Items}

      The {!docs} type represents documentation attached to an item. *)

  type docs =
    { docs_pre: docstring option;
      docs_post: docstring option; }

  val empty_docs : docs

  val docs_attr : docstring -> Parsetree.attribute

  (** Convert item documentation to attributes and add them to an
      attribute list *)
  val add_docs_attrs : docs -> Parsetree.attributes -> Parsetree.attributes

  (** {3 Fields and constructors}

      The {!info} type represents documentation attached to a field or
      constructor. *)

  type info = docstring option

  val empty_info : info

  val info_attr : docstring -> Parsetree.attribute

  (** Convert field info to attributes and add them to an
      attribute list *)
  val add_info_attrs : info -> Parsetree.attributes -> Parsetree.attributes

  (** {3 Unattached comments}

      The {!text} type represents documentation which is not attached to
      anything. *)

  type text = docstring list

  val empty_text : text

  val text_attr : docstring -> Parsetree.attribute

  (** Convert text to attributes and add them to an attribute list *)
  val add_text_attrs : text -> Parsetree.attributes -> Parsetree.attributes

end = struct
  open Location

  (* Docstrings *)

  type docstring =
    { ds_body: string;
      ds_loc: Location.t;
    }

  (* Docstring constructors and destructors *)

  let docstring body loc =
    let ds =
      { ds_body = body;
        ds_loc = loc;
      }
    in
    ds

  let docstring_body ds = ds.ds_body

  let docstring_loc ds = ds.ds_loc

  (* Docstrings attached to items *)

  type docs =
    { docs_pre: docstring option;
      docs_post: docstring option; }

  let empty_docs = { docs_pre = None; docs_post = None }

  let doc_loc = {txt = "ocaml.doc"; loc = Location.none}

  let docs_attr ds =
    let open Parsetree in
    let exp =
      { pexp_desc = Pexp_constant (Pconst_string(ds.ds_body, None));
        pexp_loc = ds.ds_loc;
        pexp_attributes = []; }
    in
    let item =
      { pstr_desc = Pstr_eval (exp, []); pstr_loc = exp.pexp_loc }
    in
      (doc_loc, PStr [item])

  let add_docs_attrs docs attrs =
    let attrs =
      match docs.docs_pre with
      | None | Some { ds_body=""; _ } -> attrs
      | Some ds -> docs_attr ds :: attrs
    in
    let attrs =
      match docs.docs_post with
      | None | Some { ds_body=""; _ } -> attrs
      | Some ds -> attrs @ [docs_attr ds]
    in
    attrs

  (* Docstrings attached to constructors or fields *)

  type info = docstring option

  let empty_info = None

  let info_attr = docs_attr

  let add_info_attrs info attrs =
    match info with
    | None | Some {ds_body=""; _} -> attrs
    | Some ds -> attrs @ [info_attr ds]

  (* Docstrings not attached to a specific item *)

  type text = docstring list

  let empty_text = []

  let text_loc = {txt = "ocaml.text"; loc = Location.none}

  let text_attr ds =
    let open Parsetree in
    let exp =
      { pexp_desc = Pexp_constant (Pconst_string(ds.ds_body, None));
        pexp_loc = ds.ds_loc;
        pexp_attributes = []; }
    in
    let item =
      { pstr_desc = Pstr_eval (exp, []); pstr_loc = exp.pexp_loc }
    in
      (text_loc, PStr [item])

  let add_text_attrs dsl attrs =
    let fdsl = List.filter (function {ds_body=""; _} -> false| _ ->true) dsl in
    (List.map text_attr fdsl) @ attrs

end

module Ast_helper : sig

  (** Helpers to produce Parsetree fragments *)

  open Asttypes
  open Docstrings
  open Parsetree

  type lid = Longident.t loc
  type str = string loc
  type loc = Location.t
  type attrs = attribute list

  (** {2 Default locations} *)

  val default_loc: loc ref
      (** Default value for all optional location arguments. *)

  val with_default_loc: loc -> (unit -> 'a) -> 'a
      (** Set the [default_loc] within the scope of the execution
          of the provided function. *)

  (** {2 Constants} *)

  module Const : sig
    val char : char -> constant
    val string : ?quotation_delimiter:string -> string -> constant
    val integer : ?suffix:char -> string -> constant
    val int : ?suffix:char -> int -> constant
    val int32 : ?suffix:char -> int32 -> constant
    val int64 : ?suffix:char -> int64 -> constant
    val nativeint : ?suffix:char -> nativeint -> constant
    val float : ?suffix:char -> string -> constant
  end

  (** {2 Core language} *)

  (** Type expressions *)
  module Typ :
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> core_type_desc -> core_type
      val attr: core_type -> attribute -> core_type

      val any: ?loc:loc -> ?attrs:attrs -> unit -> core_type
      val var: ?loc:loc -> ?attrs:attrs -> string -> core_type
      val arrow: ?loc:loc -> ?attrs:attrs -> arg_label -> core_type -> core_type
                 -> core_type
      val tuple: ?loc:loc -> ?attrs:attrs -> core_type list -> core_type
      val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> core_type
      val object_: ?loc:loc -> ?attrs:attrs ->
                    (str * attributes * core_type) list -> closed_flag ->
                    core_type
      val class_: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> core_type
      val alias: ?loc:loc -> ?attrs:attrs -> core_type -> string -> core_type
      val variant: ?loc:loc -> ?attrs:attrs -> row_field list -> closed_flag
                   -> label list option -> core_type
      val poly: ?loc:loc -> ?attrs:attrs -> str list -> core_type -> core_type
      val package: ?loc:loc -> ?attrs:attrs -> lid -> (lid * core_type) list
                   -> core_type
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> core_type

      val force_poly: core_type -> core_type

      val varify_constructors: str list -> core_type -> core_type
      (** [varify_constructors newtypes te] is type expression [te], of which
          any of nullary type constructor [tc] is replaced by type variable of
          the same name, if [tc]'s name appears in [newtypes].
          Raise [Syntaxerr.Variable_in_scope] if any type variable inside [te]
          appears in [newtypes].
          @since 4.05
       *)
    end

  (** Patterns *)
  module Pat:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> pattern_desc -> pattern
      val attr:pattern -> attribute -> pattern

      val any: ?loc:loc -> ?attrs:attrs -> unit -> pattern
      val var: ?loc:loc -> ?attrs:attrs -> str -> pattern
      val alias: ?loc:loc -> ?attrs:attrs -> pattern -> str -> pattern
      val constant: ?loc:loc -> ?attrs:attrs -> constant -> pattern
      val interval: ?loc:loc -> ?attrs:attrs -> constant -> constant -> pattern
      val tuple: ?loc:loc -> ?attrs:attrs -> pattern list -> pattern
      val construct: ?loc:loc -> ?attrs:attrs -> lid -> pattern option -> pattern
      val variant: ?loc:loc -> ?attrs:attrs -> label -> pattern option -> pattern
      val record: ?loc:loc -> ?attrs:attrs -> (lid * pattern) list -> closed_flag
                  -> pattern
      val array: ?loc:loc -> ?attrs:attrs -> pattern list -> pattern
      val or_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern -> pattern
      val constraint_: ?loc:loc -> ?attrs:attrs -> pattern -> core_type -> pattern
      val type_: ?loc:loc -> ?attrs:attrs -> lid -> pattern
      val lazy_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern
      val unpack: ?loc:loc -> ?attrs:attrs -> str -> pattern
      val open_: ?loc:loc -> ?attrs:attrs  -> lid -> pattern -> pattern
      val exception_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> pattern
    end

  (** Expressions *)
  module Exp:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> expression_desc -> expression
      val attr: expression -> attribute -> expression

      val ident: ?loc:loc -> ?attrs:attrs -> lid -> expression
      val constant: ?loc:loc -> ?attrs:attrs -> constant -> expression
      val let_: ?loc:loc -> ?attrs:attrs -> rec_flag -> value_binding list
                -> expression -> expression
      val fun_: ?loc:loc -> ?attrs:attrs -> arg_label -> expression option
                -> pattern -> expression -> expression
      val function_: ?loc:loc -> ?attrs:attrs -> case list -> expression
      val apply: ?loc:loc -> ?attrs:attrs -> expression
                 -> (arg_label * expression) list -> expression
      val match_: ?loc:loc -> ?attrs:attrs -> expression -> case list
                  -> expression
      val try_: ?loc:loc -> ?attrs:attrs -> expression -> case list -> expression
      val tuple: ?loc:loc -> ?attrs:attrs -> expression list -> expression
      val construct: ?loc:loc -> ?attrs:attrs -> lid -> expression option
                     -> expression
      val variant: ?loc:loc -> ?attrs:attrs -> label -> expression option
                   -> expression
      val record: ?loc:loc -> ?attrs:attrs -> (lid * expression) list
                  -> expression option -> expression
      val field: ?loc:loc -> ?attrs:attrs -> expression -> lid -> expression
      val setfield: ?loc:loc -> ?attrs:attrs -> expression -> lid -> expression
                    -> expression
      val array: ?loc:loc -> ?attrs:attrs -> expression list -> expression
      val ifthenelse: ?loc:loc -> ?attrs:attrs -> expression -> expression
                      -> expression option -> expression
      val sequence: ?loc:loc -> ?attrs:attrs -> expression -> expression
                    -> expression
      val while_: ?loc:loc -> ?attrs:attrs -> expression -> expression
                  -> expression
      val for_: ?loc:loc -> ?attrs:attrs -> pattern -> expression -> expression
                -> direction_flag -> expression -> expression
      val coerce: ?loc:loc -> ?attrs:attrs -> expression -> core_type option
                  -> core_type -> expression
      val constraint_: ?loc:loc -> ?attrs:attrs -> expression -> core_type
                       -> expression
      val send: ?loc:loc -> ?attrs:attrs -> expression -> str -> expression
      val new_: ?loc:loc -> ?attrs:attrs -> lid -> expression
      val setinstvar: ?loc:loc -> ?attrs:attrs -> str -> expression -> expression
      val override: ?loc:loc -> ?attrs:attrs -> (str * expression) list
                    -> expression
      val letmodule: ?loc:loc -> ?attrs:attrs -> str -> module_expr -> expression
                     -> expression
      val letexception:
        ?loc:loc -> ?attrs:attrs -> extension_constructor -> expression
        -> expression
      val assert_: ?loc:loc -> ?attrs:attrs -> expression -> expression
      val lazy_: ?loc:loc -> ?attrs:attrs -> expression -> expression
      val poly: ?loc:loc -> ?attrs:attrs -> expression -> core_type option
                -> expression
      val object_: ?loc:loc -> ?attrs:attrs -> class_structure -> expression
      val newtype: ?loc:loc -> ?attrs:attrs -> str -> expression -> expression
      val pack: ?loc:loc -> ?attrs:attrs -> module_expr -> expression
      val open_: ?loc:loc -> ?attrs:attrs -> override_flag -> lid -> expression
                 -> expression
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> expression
      val unreachable: ?loc:loc -> ?attrs:attrs -> unit -> expression

      val case: pattern -> ?guard:expression -> expression -> case
    end

  (** Value declarations *)
  module Val:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs ->
        ?prim:string list -> str -> core_type -> value_description
    end

  (** Type declarations *)
  module Type:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        ?params:(core_type * variance) list ->
        ?cstrs:(core_type * core_type * loc) list ->
        ?kind:type_kind -> ?priv:private_flag -> ?manifest:core_type -> str ->
        type_declaration

      val constructor: ?loc:loc -> ?attrs:attrs -> ?info:info ->
        ?args:constructor_arguments -> ?res:core_type -> str ->
        constructor_declaration
      val field: ?loc:loc -> ?attrs:attrs -> ?info:info ->
        ?mut:mutable_flag -> str -> core_type -> label_declaration
    end

  (** Type extensions *)
  module Te:
    sig
      val mk: ?attrs:attrs -> ?docs:docs ->
        ?params:(core_type * variance) list -> ?priv:private_flag ->
        lid -> extension_constructor list -> type_extension

      val constructor: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->
        str -> extension_constructor_kind -> extension_constructor

      val decl: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->
        ?args:constructor_arguments -> ?res:core_type -> str ->
        extension_constructor
      val rebind: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->
        str -> lid -> extension_constructor
    end

  (** {2 Module language} *)

  (** Module type expressions *)
  module Mty:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> module_type_desc -> module_type
      val attr: module_type -> attribute -> module_type

      val ident: ?loc:loc -> ?attrs:attrs -> lid -> module_type
      val alias: ?loc:loc -> ?attrs:attrs -> lid -> module_type
      val signature: ?loc:loc -> ?attrs:attrs -> signature -> module_type
      val functor_: ?loc:loc -> ?attrs:attrs ->
        str -> module_type option -> module_type -> module_type
      val with_: ?loc:loc -> ?attrs:attrs -> module_type ->
        with_constraint list -> module_type
      val typeof_: ?loc:loc -> ?attrs:attrs -> module_expr -> module_type
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> module_type
    end

  (** Module expressions *)
  module Mod:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> module_expr_desc -> module_expr
      val attr: module_expr -> attribute -> module_expr

      val ident: ?loc:loc -> ?attrs:attrs -> lid -> module_expr
      val structure: ?loc:loc -> ?attrs:attrs -> structure -> module_expr
      val functor_: ?loc:loc -> ?attrs:attrs ->
        str -> module_type option -> module_expr -> module_expr
      val apply: ?loc:loc -> ?attrs:attrs -> module_expr -> module_expr ->
        module_expr
      val constraint_: ?loc:loc -> ?attrs:attrs -> module_expr -> module_type ->
        module_expr
      val unpack: ?loc:loc -> ?attrs:attrs -> expression -> module_expr
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> module_expr
    end

  (** Signature items *)
  module Sig:
    sig
      val mk: ?loc:loc -> signature_item_desc -> signature_item

      val value: ?loc:loc -> value_description -> signature_item
      val type_: ?loc:loc -> rec_flag -> type_declaration list -> signature_item
      val type_extension: ?loc:loc -> type_extension -> signature_item
      val exception_: ?loc:loc -> extension_constructor -> signature_item
      val module_: ?loc:loc -> module_declaration -> signature_item
      val rec_module: ?loc:loc -> module_declaration list -> signature_item
      val modtype: ?loc:loc -> module_type_declaration -> signature_item
      val open_: ?loc:loc -> open_description -> signature_item
      val include_: ?loc:loc -> include_description -> signature_item
      val class_: ?loc:loc -> class_description list -> signature_item
      val class_type: ?loc:loc -> class_type_declaration list -> signature_item
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> signature_item
      val attribute: ?loc:loc -> attribute -> signature_item
      val text: text -> signature_item list
    end

  (** Structure items *)
  module Str:
    sig
      val mk: ?loc:loc -> structure_item_desc -> structure_item

      val eval: ?loc:loc -> ?attrs:attributes -> expression -> structure_item
      val value: ?loc:loc -> rec_flag -> value_binding list -> structure_item
      val primitive: ?loc:loc -> value_description -> structure_item
      val type_: ?loc:loc -> rec_flag -> type_declaration list -> structure_item
      val type_extension: ?loc:loc -> type_extension -> structure_item
      val exception_: ?loc:loc -> extension_constructor -> structure_item
      val module_: ?loc:loc -> module_binding -> structure_item
      val rec_module: ?loc:loc -> module_binding list -> structure_item
      val modtype: ?loc:loc -> module_type_declaration -> structure_item
      val open_: ?loc:loc -> open_description -> structure_item
      val class_: ?loc:loc -> class_declaration list -> structure_item
      val class_type: ?loc:loc -> class_type_declaration list -> structure_item
      val include_: ?loc:loc -> include_declaration -> structure_item
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> structure_item
      val attribute: ?loc:loc -> attribute -> structure_item
      val text: text -> structure_item list
    end

  (** Module declarations *)
  module Md:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        str -> module_type -> module_declaration
    end

  (** Module type declarations *)
  module Mtd:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        ?typ:module_type -> str -> module_type_declaration
    end

  (** Module bindings *)
  module Mb:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        str -> module_expr -> module_binding
    end

  (** Opens *)
  module Opn:
    sig
      val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs ->
        ?override:override_flag -> lid -> open_description
    end

  (** Includes *)
  module Incl:
    sig
      val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs -> 'a -> 'a include_infos
    end

  (** Value bindings *)
  module Vb:
    sig
      val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        pattern -> expression -> value_binding
    end


  (** {2 Class language} *)

  (** Class type expressions *)
  module Cty:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> class_type_desc -> class_type
      val attr: class_type -> attribute -> class_type

      val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> class_type
      val signature: ?loc:loc -> ?attrs:attrs -> class_signature -> class_type
      val arrow: ?loc:loc -> ?attrs:attrs -> arg_label -> core_type ->
        class_type -> class_type
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_type
    end

  (** Class type fields *)
  module Ctf:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs ->
        class_type_field_desc -> class_type_field
      val attr: class_type_field -> attribute -> class_type_field

      val inherit_: ?loc:loc -> ?attrs:attrs -> class_type -> class_type_field
      val val_: ?loc:loc -> ?attrs:attrs -> str -> mutable_flag ->
        virtual_flag -> core_type -> class_type_field
      val method_: ?loc:loc -> ?attrs:attrs -> str -> private_flag ->
        virtual_flag -> core_type -> class_type_field
      val constraint_: ?loc:loc -> ?attrs:attrs -> core_type -> core_type ->
        class_type_field
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_type_field
      val attribute: ?loc:loc -> attribute -> class_type_field
      val text: text -> class_type_field list
    end

  (** Class expressions *)
  module Cl:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> class_expr_desc -> class_expr
      val attr: class_expr -> attribute -> class_expr

      val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> class_expr
      val structure: ?loc:loc -> ?attrs:attrs -> class_structure -> class_expr
      val fun_: ?loc:loc -> ?attrs:attrs -> arg_label -> expression option ->
        pattern -> class_expr -> class_expr
      val apply: ?loc:loc -> ?attrs:attrs -> class_expr ->
        (arg_label * expression) list -> class_expr
      val let_: ?loc:loc -> ?attrs:attrs -> rec_flag -> value_binding list ->
        class_expr -> class_expr
      val constraint_: ?loc:loc -> ?attrs:attrs -> class_expr -> class_type ->
        class_expr
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_expr
    end

  (** Class fields *)
  module Cf:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> class_field_desc ->
        class_field
      val attr: class_field -> attribute -> class_field

      val inherit_: ?loc:loc -> ?attrs:attrs -> override_flag -> class_expr ->
        str option -> class_field
      val val_: ?loc:loc -> ?attrs:attrs -> str -> mutable_flag ->
        class_field_kind -> class_field
      val method_: ?loc:loc -> ?attrs:attrs -> str -> private_flag ->
        class_field_kind -> class_field
      val constraint_: ?loc:loc -> ?attrs:attrs -> core_type -> core_type ->
        class_field
      val initializer_: ?loc:loc -> ?attrs:attrs -> expression -> class_field
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_field
      val attribute: ?loc:loc -> attribute -> class_field
      val text: text -> class_field list

      val virtual_: core_type -> class_field_kind
      val concrete: override_flag -> expression -> class_field_kind

    end

  (** Classes *)
  module Ci:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        ?virt:virtual_flag -> ?params:(core_type * variance) list ->
        str -> 'a -> 'a class_infos
    end

  (** Class signatures *)
  module Csig:
    sig
      val mk: core_type -> class_type_field list -> class_signature
    end

  (** Class structures *)
  module Cstr:
    sig
      val mk: pattern -> class_field list -> class_structure
    end

end = struct
  (** Helpers to produce Parsetree fragments *)

  open Asttypes
  open Parsetree
  open Docstrings

  type lid = Longident.t loc
  type str = string loc
  type loc = Location.t
  type attrs = attribute list

  let default_loc = ref Location.none

  let with_default_loc l f =
    let old = !default_loc in
    default_loc := l;
    try let r = f () in default_loc := old; r
    with exn -> default_loc := old; raise exn

  module Const = struct
    let integer ?suffix i = Pconst_integer (i, suffix)
    let int ?suffix i = integer ?suffix (string_of_int i)
    let int32 ?(suffix='l') i = integer ~suffix (Int32.to_string i)
    let int64 ?(suffix='L') i = integer ~suffix (Int64.to_string i)
    let nativeint ?(suffix='n') i = integer ~suffix (Nativeint.to_string i)
    let float ?suffix f = Pconst_float (f, suffix)
    let char c = Pconst_char c
    let string ?quotation_delimiter s = Pconst_string (s, quotation_delimiter)
  end

  module Typ = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {ptyp_desc = d; ptyp_loc = loc; ptyp_attributes = attrs}
    let attr d a = {d with ptyp_attributes = d.ptyp_attributes @ [a]}

    let any ?loc ?attrs () = mk ?loc ?attrs Ptyp_any
    let var ?loc ?attrs a = mk ?loc ?attrs (Ptyp_var a)
    let arrow ?loc ?attrs a b c = mk ?loc ?attrs (Ptyp_arrow (a, b, c))
    let tuple ?loc ?attrs a = mk ?loc ?attrs (Ptyp_tuple a)
    let constr ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_constr (a, b))
    let object_ ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_object (a, b))
    let class_ ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_class (a, b))
    let alias ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_alias (a, b))
    let variant ?loc ?attrs a b c = mk ?loc ?attrs (Ptyp_variant (a, b, c))
    let poly ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_poly (a, b))
    let package ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_package (a, b))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Ptyp_extension a)

    let force_poly t =
      match t.ptyp_desc with
      | Ptyp_poly _ -> t
      | _ -> poly ~loc:t.ptyp_loc [] t (* -> ghost? *)

    let varify_constructors var_names t =
      let check_variable vl loc v =
        if List.mem v vl then
          raise Syntaxerr.(Error(Variable_in_scope(loc,v))) in
      let var_names = List.map (fun v -> v.txt) var_names in
      let rec loop t =
        let desc =
          match t.ptyp_desc with
          | Ptyp_any -> Ptyp_any
          | Ptyp_var x ->
              check_variable var_names t.ptyp_loc x;
              Ptyp_var x
          | Ptyp_arrow (label,core_type,core_type') ->
              Ptyp_arrow(label, loop core_type, loop core_type')
          | Ptyp_tuple lst -> Ptyp_tuple (List.map loop lst)
          | Ptyp_constr( { txt = Longident.Lident s; _ }, [])
            when List.mem s var_names ->
              Ptyp_var s
          | Ptyp_constr(longident, lst) ->
              Ptyp_constr(longident, List.map loop lst)
          | Ptyp_object (lst, o) ->
              Ptyp_object
                (List.map (fun (s, attrs, t) -> (s, attrs, loop t)) lst, o)
          | Ptyp_class (longident, lst) ->
              Ptyp_class (longident, List.map loop lst)
          | Ptyp_alias(core_type, string) ->
              check_variable var_names t.ptyp_loc string;
              Ptyp_alias(loop core_type, string)
          | Ptyp_variant(row_field_list, flag, lbl_lst_option) ->
              Ptyp_variant(List.map loop_row_field row_field_list,
                           flag, lbl_lst_option)
          | Ptyp_poly(string_lst, core_type) ->
            List.iter (fun v ->
              check_variable var_names t.ptyp_loc v.txt) string_lst;
              Ptyp_poly(string_lst, loop core_type)
          | Ptyp_package(longident,lst) ->
              Ptyp_package(longident,List.map (fun (n,typ) -> (n,loop typ) ) lst)
          | Ptyp_extension (s, arg) ->
              Ptyp_extension (s, arg)
        in
        {t with ptyp_desc = desc}
      and loop_row_field  =
        function
          | Rtag(label,attrs,flag,lst) ->
              Rtag(label,attrs,flag,List.map loop lst)
          | Rinherit t ->
              Rinherit (loop t)
      in
      loop t

  end

  module Pat = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {ppat_desc = d; ppat_loc = loc; ppat_attributes = attrs}
    let attr d a = {d with ppat_attributes = d.ppat_attributes @ [a]}

    let any ?loc ?attrs () = mk ?loc ?attrs Ppat_any
    let var ?loc ?attrs a = mk ?loc ?attrs (Ppat_var a)
    let alias ?loc ?attrs a b = mk ?loc ?attrs (Ppat_alias (a, b))
    let constant ?loc ?attrs a = mk ?loc ?attrs (Ppat_constant a)
    let interval ?loc ?attrs a b = mk ?loc ?attrs (Ppat_interval (a, b))
    let tuple ?loc ?attrs a = mk ?loc ?attrs (Ppat_tuple a)
    let construct ?loc ?attrs a b = mk ?loc ?attrs (Ppat_construct (a, b))
    let variant ?loc ?attrs a b = mk ?loc ?attrs (Ppat_variant (a, b))
    let record ?loc ?attrs a b = mk ?loc ?attrs (Ppat_record (a, b))
    let array ?loc ?attrs a = mk ?loc ?attrs (Ppat_array a)
    let or_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_or (a, b))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_constraint (a, b))
    let type_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_type a)
    let lazy_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_lazy a)
    let unpack ?loc ?attrs a = mk ?loc ?attrs (Ppat_unpack a)
    let open_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_open (a, b))
    let exception_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_exception a)
    let extension ?loc ?attrs a = mk ?loc ?attrs (Ppat_extension a)
  end

  module Exp = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {pexp_desc = d; pexp_loc = loc; pexp_attributes = attrs}
    let attr d a = {d with pexp_attributes = d.pexp_attributes @ [a]}

    let ident ?loc ?attrs a = mk ?loc ?attrs (Pexp_ident a)
    let constant ?loc ?attrs a = mk ?loc ?attrs (Pexp_constant a)
    let let_ ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_let (a, b, c))
    let fun_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pexp_fun (a, b, c, d))
    let function_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_function a)
    let apply ?loc ?attrs a b = mk ?loc ?attrs (Pexp_apply (a, b))
    let match_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_match (a, b))
    let try_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_try (a, b))
    let tuple ?loc ?attrs a = mk ?loc ?attrs (Pexp_tuple a)
    let construct ?loc ?attrs a b = mk ?loc ?attrs (Pexp_construct (a, b))
    let variant ?loc ?attrs a b = mk ?loc ?attrs (Pexp_variant (a, b))
    let record ?loc ?attrs a b = mk ?loc ?attrs (Pexp_record (a, b))
    let field ?loc ?attrs a b = mk ?loc ?attrs (Pexp_field (a, b))
    let setfield ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_setfield (a, b, c))
    let array ?loc ?attrs a = mk ?loc ?attrs (Pexp_array a)
    let ifthenelse ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_ifthenelse (a, b, c))
    let sequence ?loc ?attrs a b = mk ?loc ?attrs (Pexp_sequence (a, b))
    let while_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_while (a, b))
    let for_ ?loc ?attrs a b c d e = mk ?loc ?attrs (Pexp_for (a, b, c, d, e))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_constraint (a, b))
    let coerce ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_coerce (a, b, c))
    let send ?loc ?attrs a b = mk ?loc ?attrs (Pexp_send (a, b))
    let new_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_new a)
    let setinstvar ?loc ?attrs a b = mk ?loc ?attrs (Pexp_setinstvar (a, b))
    let override ?loc ?attrs a = mk ?loc ?attrs (Pexp_override a)
    let letmodule ?loc ?attrs a b c= mk ?loc ?attrs (Pexp_letmodule (a, b, c))
    let letexception ?loc ?attrs a b = mk ?loc ?attrs (Pexp_letexception (a, b))
    let assert_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_assert a)
    let lazy_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_lazy a)
    let poly ?loc ?attrs a b = mk ?loc ?attrs (Pexp_poly (a, b))
    let object_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_object a)
    let newtype ?loc ?attrs a b = mk ?loc ?attrs (Pexp_newtype (a, b))
    let pack ?loc ?attrs a = mk ?loc ?attrs (Pexp_pack a)
    let open_ ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_open (a, b, c))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pexp_extension a)
    let unreachable ?loc ?attrs () = mk ?loc ?attrs Pexp_unreachable

    let case lhs ?guard rhs =
      {
       pc_lhs = lhs;
       pc_guard = guard;
       pc_rhs = rhs;
      }
  end

  module Mty = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {pmty_desc = d; pmty_loc = loc; pmty_attributes = attrs}
    let attr d a = {d with pmty_attributes = d.pmty_attributes @ [a]}

    let ident ?loc ?attrs a = mk ?loc ?attrs (Pmty_ident a)
    let alias ?loc ?attrs a = mk ?loc ?attrs (Pmty_alias a)
    let signature ?loc ?attrs a = mk ?loc ?attrs (Pmty_signature a)
    let functor_ ?loc ?attrs a b c = mk ?loc ?attrs (Pmty_functor (a, b, c))
    let with_ ?loc ?attrs a b = mk ?loc ?attrs (Pmty_with (a, b))
    let typeof_ ?loc ?attrs a = mk ?loc ?attrs (Pmty_typeof a)
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pmty_extension a)
  end

  module Mod = struct
  let mk ?(loc = !default_loc) ?(attrs = []) d =
    {pmod_desc = d; pmod_loc = loc; pmod_attributes = attrs}
    let attr d a = {d with pmod_attributes = d.pmod_attributes @ [a]}

    let ident ?loc ?attrs x = mk ?loc ?attrs (Pmod_ident x)
    let structure ?loc ?attrs x = mk ?loc ?attrs (Pmod_structure x)
    let functor_ ?loc ?attrs arg arg_ty body =
      mk ?loc ?attrs (Pmod_functor (arg, arg_ty, body))
    let apply ?loc ?attrs m1 m2 = mk ?loc ?attrs (Pmod_apply (m1, m2))
    let constraint_ ?loc ?attrs m mty = mk ?loc ?attrs (Pmod_constraint (m, mty))
    let unpack ?loc ?attrs e = mk ?loc ?attrs (Pmod_unpack e)
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pmod_extension a)
  end

  module Sig = struct
    let mk ?(loc = !default_loc) d = {psig_desc = d; psig_loc = loc}

    let value ?loc a = mk ?loc (Psig_value a)
    let type_ ?loc rec_flag a = mk ?loc (Psig_type (rec_flag, a))
    let type_extension ?loc a = mk ?loc (Psig_typext a)
    let exception_ ?loc a = mk ?loc (Psig_exception a)
    let module_ ?loc a = mk ?loc (Psig_module a)
    let rec_module ?loc a = mk ?loc (Psig_recmodule a)
    let modtype ?loc a = mk ?loc (Psig_modtype a)
    let open_ ?loc a = mk ?loc (Psig_open a)
    let include_ ?loc a = mk ?loc (Psig_include a)
    let class_ ?loc a = mk ?loc (Psig_class a)
    let class_type ?loc a = mk ?loc (Psig_class_type a)
    let extension ?loc ?(attrs = []) a = mk ?loc (Psig_extension (a, attrs))
    let attribute ?loc a = mk ?loc (Psig_attribute a)
    let text txt =
      let f_txt = List.filter (fun ds -> docstring_body ds <> "") txt in
      List.map
        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
        f_txt
  end

  module Str = struct
    let mk ?(loc = !default_loc) d = {pstr_desc = d; pstr_loc = loc}

    let eval ?loc ?(attrs = []) a = mk ?loc (Pstr_eval (a, attrs))
    let value ?loc a b = mk ?loc (Pstr_value (a, b))
    let primitive ?loc a = mk ?loc (Pstr_primitive a)
    let type_ ?loc rec_flag a = mk ?loc (Pstr_type (rec_flag, a))
    let type_extension ?loc a = mk ?loc (Pstr_typext a)
    let exception_ ?loc a = mk ?loc (Pstr_exception a)
    let module_ ?loc a = mk ?loc (Pstr_module a)
    let rec_module ?loc a = mk ?loc (Pstr_recmodule a)
    let modtype ?loc a = mk ?loc (Pstr_modtype a)
    let open_ ?loc a = mk ?loc (Pstr_open a)
    let class_ ?loc a = mk ?loc (Pstr_class a)
    let class_type ?loc a = mk ?loc (Pstr_class_type a)
    let include_ ?loc a = mk ?loc (Pstr_include a)
    let extension ?loc ?(attrs = []) a = mk ?loc (Pstr_extension (a, attrs))
    let attribute ?loc a = mk ?loc (Pstr_attribute a)
    let text txt =
      let f_txt = List.filter (fun ds -> docstring_body ds <> "") txt in
      List.map
        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
        f_txt
  end

  module Cl = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {
       pcl_desc = d;
       pcl_loc = loc;
       pcl_attributes = attrs;
      }
    let attr d a = {d with pcl_attributes = d.pcl_attributes @ [a]}

    let constr ?loc ?attrs a b = mk ?loc ?attrs (Pcl_constr (a, b))
    let structure ?loc ?attrs a = mk ?loc ?attrs (Pcl_structure a)
    let fun_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pcl_fun (a, b, c, d))
    let apply ?loc ?attrs a b = mk ?loc ?attrs (Pcl_apply (a, b))
    let let_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcl_let (a, b, c))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pcl_constraint (a, b))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pcl_extension a)
  end

  module Cty = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {
       pcty_desc = d;
       pcty_loc = loc;
       pcty_attributes = attrs;
      }
    let attr d a = {d with pcty_attributes = d.pcty_attributes @ [a]}

    let constr ?loc ?attrs a b = mk ?loc ?attrs (Pcty_constr (a, b))
    let signature ?loc ?attrs a = mk ?loc ?attrs (Pcty_signature a)
    let arrow ?loc ?attrs a b c = mk ?loc ?attrs (Pcty_arrow (a, b, c))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pcty_extension a)
  end

  module Ctf = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
             ?(docs = empty_docs) d =
      {
       pctf_desc = d;
       pctf_loc = loc;
       pctf_attributes = add_docs_attrs docs attrs;
      }

    let inherit_ ?loc ?attrs a = mk ?loc ?attrs (Pctf_inherit a)
    let val_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pctf_val (a, b, c, d))
    let method_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pctf_method (a, b, c, d))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pctf_constraint (a, b))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pctf_extension a)
    let attribute ?loc a = mk ?loc (Pctf_attribute a)
    let text txt =
     let f_txt = List.filter (fun ds -> docstring_body ds <> "") txt in
       List.map
        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
        f_txt

    let attr d a = {d with pctf_attributes = d.pctf_attributes @ [a]}

  end

  module Cf = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) d =
      {
       pcf_desc = d;
       pcf_loc = loc;
       pcf_attributes = add_docs_attrs docs attrs;
      }

    let inherit_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_inherit (a, b, c))
    let val_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_val (a, b, c))
    let method_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_method (a, b, c))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pcf_constraint (a, b))
    let initializer_ ?loc ?attrs a = mk ?loc ?attrs (Pcf_initializer a)
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pcf_extension a)
    let attribute ?loc a = mk ?loc (Pcf_attribute a)
    let text txt =
      let f_txt = List.filter (fun ds -> docstring_body ds <> "") txt in
      List.map
        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
        f_txt

    let virtual_ ct = Cfk_virtual ct
    let concrete o e = Cfk_concrete (o, e)

    let attr d a = {d with pcf_attributes = d.pcf_attributes @ [a]}

  end

  module Val = struct
    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
          ?(prim = []) name typ =
      {
       pval_name = name;
       pval_type = typ;
       pval_attributes = add_docs_attrs docs attrs;
       pval_loc = loc;
       pval_prim = prim;
      }
  end

  module Md = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = []) name typ =
      {
       pmd_name = name;
       pmd_type = typ;
       pmd_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pmd_loc = loc;
      }
  end

  module Mtd = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = []) ?typ name =
      {
       pmtd_name = name;
       pmtd_type = typ;
       pmtd_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pmtd_loc = loc;
      }
  end

  module Mb = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = []) name expr =
      {
       pmb_name = name;
       pmb_expr = expr;
       pmb_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pmb_loc = loc;
      }
  end

  module Opn = struct
    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
          ?(override = Fresh) lid =
      {
       popen_lid = lid;
       popen_override = override;
       popen_loc = loc;
       popen_attributes = add_docs_attrs docs attrs;
      }
  end

  module Incl = struct
    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs) mexpr =
      {
       pincl_mod = mexpr;
       pincl_loc = loc;
       pincl_attributes = add_docs_attrs docs attrs;
      }

  end

  module Vb = struct
    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
          ?(text = []) pat expr =
      {
       pvb_pat = pat;
       pvb_expr = expr;
       pvb_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pvb_loc = loc;
      }
  end

  module Ci = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = [])
          ?(virt = Concrete) ?(params = []) name expr =
      {
       pci_virt = virt;
       pci_params = params;
       pci_name = name;
       pci_expr = expr;
       pci_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pci_loc = loc;
      }
  end

  module Type = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = [])
        ?(params = [])
        ?(cstrs = [])
        ?(kind = Ptype_abstract)
        ?(priv = Public)
        ?manifest
        name =
      {
       ptype_name = name;
       ptype_params = params;
       ptype_cstrs = cstrs;
       ptype_kind = kind;
       ptype_private = priv;
       ptype_manifest = manifest;
       ptype_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       ptype_loc = loc;
      }

    let constructor ?(loc = !default_loc) ?(attrs = []) ?(info = empty_info)
          ?(args = Pcstr_tuple []) ?res name =
      {
       pcd_name = name;
       pcd_args = args;
       pcd_res = res;
       pcd_loc = loc;
       pcd_attributes = add_info_attrs info attrs;
       }

    let field ?(loc = !default_loc) ?(attrs = []) ?(info = empty_info)
          ?(mut = Immutable) name typ =
      {
       pld_name = name;
       pld_mutable = mut;
       pld_type = typ;
       pld_loc = loc;
       pld_attributes = add_info_attrs info attrs;
      }

  end

  (** Type extensions *)
  module Te = struct
    let mk ?(attrs = []) ?(docs = empty_docs)
          ?(params = []) ?(priv = Public) path constructors =
      {
       ptyext_path = path;
       ptyext_params = params;
       ptyext_constructors = constructors;
       ptyext_private = priv;
       ptyext_attributes = add_docs_attrs docs attrs;
      }

    let constructor ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(info = empty_info) name kind =
      {
       pext_name = name;
       pext_kind = kind;
       pext_loc = loc;
       pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);
      }

    let decl ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
               ?(info = empty_info) ?(args = Pcstr_tuple []) ?res name =
      {
       pext_name = name;
       pext_kind = Pext_decl(args, res);
       pext_loc = loc;
       pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);
      }

    let rebind ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(info = empty_info) name lid =
      {
       pext_name = name;
       pext_kind = Pext_rebind lid;
       pext_loc = loc;
       pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);
      }

  end

  module Csig = struct
    let mk self fields =
      {
       pcsig_self = self;
       pcsig_fields = fields;
      }
  end

  module Cstr = struct
    let mk self fields =
      {
       pcstr_self = self;
       pcstr_fields = fields;
      }
  end

end

module Ast_mapper : sig
  (** The interface of a -ppx rewriter

    A -ppx rewriter is a program that accepts a serialized abstract syntax
    tree and outputs another, possibly modified, abstract syntax tree.
    This module encapsulates the interface between the compiler and
    the -ppx rewriters, handling such details as the serialization format,
    forwarding of command-line flags, and storing state.

    {!mapper} allows to implement AST rewriting using open recursion.
    A typical mapper would be based on {!default_mapper}, a deep
    identity mapper, and will fall back on it for handling the syntax it
    does not modify. For example:

    {[
  open Asttypes
  open Parsetree
  open Ast_mapper

  let test_mapper argv =
    { default_mapper with
      expr = fun mapper expr ->
        match expr with
        | { pexp_desc = Pexp_extension ({ txt = "test" }, PStr [])} ->
          Ast_helper.Exp.constant (Const_int 42)
        | other -> default_mapper.expr mapper other; }

  let () =
    register "ppx_test" test_mapper]}

    This -ppx rewriter, which replaces [[%test]] in expressions with
    the constant [42], can be compiled using
    [ocamlc -o ppx_test -I +compiler-libs ocamlcommon.cma ppx_test.ml].

    *)

  open Parsetree

  (** {2 A generic Parsetree mapper} *)

  type mapper (*IF_CURRENT = Ast_mapper.mapper*) = {
    attribute: mapper -> attribute -> attribute;
    attributes: mapper -> attribute list -> attribute list;
    case: mapper -> case -> case;
    cases: mapper -> case list -> case list;
    class_declaration: mapper -> class_declaration -> class_declaration;
    class_description: mapper -> class_description -> class_description;
    class_expr: mapper -> class_expr -> class_expr;
    class_field: mapper -> class_field -> class_field;
    class_signature: mapper -> class_signature -> class_signature;
    class_structure: mapper -> class_structure -> class_structure;
    class_type: mapper -> class_type -> class_type;
    class_type_declaration: mapper -> class_type_declaration
                            -> class_type_declaration;
    class_type_field: mapper -> class_type_field -> class_type_field;
    constructor_declaration: mapper -> constructor_declaration
                             -> constructor_declaration;
    expr: mapper -> expression -> expression;
    extension: mapper -> extension -> extension;
    extension_constructor: mapper -> extension_constructor
                           -> extension_constructor;
    include_declaration: mapper -> include_declaration -> include_declaration;
    include_description: mapper -> include_description -> include_description;
    label_declaration: mapper -> label_declaration -> label_declaration;
    location: mapper -> Location.t -> Location.t;
    module_binding: mapper -> module_binding -> module_binding;
    module_declaration: mapper -> module_declaration -> module_declaration;
    module_expr: mapper -> module_expr -> module_expr;
    module_type: mapper -> module_type -> module_type;
    module_type_declaration: mapper -> module_type_declaration
                             -> module_type_declaration;
    open_description: mapper -> open_description -> open_description;
    pat: mapper -> pattern -> pattern;
    payload: mapper -> payload -> payload;
    signature: mapper -> signature -> signature;
    signature_item: mapper -> signature_item -> signature_item;
    structure: mapper -> structure -> structure;
    structure_item: mapper -> structure_item -> structure_item;
    typ: mapper -> core_type -> core_type;
    type_declaration: mapper -> type_declaration -> type_declaration;
    type_extension: mapper -> type_extension -> type_extension;
    type_kind: mapper -> type_kind -> type_kind;
    value_binding: mapper -> value_binding -> value_binding;
    value_description: mapper -> value_description -> value_description;
    with_constraint: mapper -> with_constraint -> with_constraint;
  }
  (** A mapper record implements one "method" per syntactic category,
      using an open recursion style: each method takes as its first
      argument the mapper to be applied to children in the syntax
      tree. *)

  val default_mapper: mapper
  (** A default mapper, which implements a "deep identity" mapping. *)

  (** {2 Convenience functions to write mappers} *)

  val map_opt: ('a -> 'b) -> 'a option -> 'b option

  val extension_of_error: Location.error -> extension
  (** Encode an error into an 'ocaml.error' extension node which can be
      inserted in a generated Parsetree.  The compiler will be
      responsible for reporting the error. *)

  val attribute_of_warning: Location.t -> string -> attribute
  (** Encode a warning message into an 'ocaml.ppwarning' attribute which can be
      inserted in a generated Parsetree.  The compiler will be
      responsible for reporting the warning. *)

end = struct
  (* A generic Parsetree mapping class *)

  (*
  [@@@ocaml.warning "+9"]
    (* Ensure that record patterns don't miss any field. *)
  *)


  open Parsetree
  open Ast_helper
  open Location

  type mapper (*IF_CURRENT = Ast_mapper.mapper*) = {
    attribute: mapper -> attribute -> attribute;
    attributes: mapper -> attribute list -> attribute list;
    case: mapper -> case -> case;
    cases: mapper -> case list -> case list;
    class_declaration: mapper -> class_declaration -> class_declaration;
    class_description: mapper -> class_description -> class_description;
    class_expr: mapper -> class_expr -> class_expr;
    class_field: mapper -> class_field -> class_field;
    class_signature: mapper -> class_signature -> class_signature;
    class_structure: mapper -> class_structure -> class_structure;
    class_type: mapper -> class_type -> class_type;
    class_type_declaration: mapper -> class_type_declaration
                            -> class_type_declaration;
    class_type_field: mapper -> class_type_field -> class_type_field;
    constructor_declaration: mapper -> constructor_declaration
                             -> constructor_declaration;
    expr: mapper -> expression -> expression;
    extension: mapper -> extension -> extension;
    extension_constructor: mapper -> extension_constructor
                           -> extension_constructor;
    include_declaration: mapper -> include_declaration -> include_declaration;
    include_description: mapper -> include_description -> include_description;
    label_declaration: mapper -> label_declaration -> label_declaration;
    location: mapper -> Location.t -> Location.t;
    module_binding: mapper -> module_binding -> module_binding;
    module_declaration: mapper -> module_declaration -> module_declaration;
    module_expr: mapper -> module_expr -> module_expr;
    module_type: mapper -> module_type -> module_type;
    module_type_declaration: mapper -> module_type_declaration
                             -> module_type_declaration;
    open_description: mapper -> open_description -> open_description;
    pat: mapper -> pattern -> pattern;
    payload: mapper -> payload -> payload;
    signature: mapper -> signature -> signature;
    signature_item: mapper -> signature_item -> signature_item;
    structure: mapper -> structure -> structure;
    structure_item: mapper -> structure_item -> structure_item;
    typ: mapper -> core_type -> core_type;
    type_declaration: mapper -> type_declaration -> type_declaration;
    type_extension: mapper -> type_extension -> type_extension;
    type_kind: mapper -> type_kind -> type_kind;
    value_binding: mapper -> value_binding -> value_binding;
    value_description: mapper -> value_description -> value_description;
    with_constraint: mapper -> with_constraint -> with_constraint;
  }

  let map_fst f (x, y) = (f x, y)
  let map_snd f (x, y) = (x, f y)
  let map_tuple f1 f2 (x, y) = (f1 x, f2 y)
  let map_tuple3 f1 f2 f3 (x, y, z) = (f1 x, f2 y, f3 z)
  let map_opt f = function None -> None | Some x -> Some (f x)

  let map_loc sub {loc; txt} = {loc = sub.location sub loc; txt}

  module T = struct
    (* Type expressions for the core language *)

    let row_field sub = function
      | Rtag (l, attrs, b, tl) ->
          Rtag (l, sub.attributes sub attrs, b, List.map (sub.typ sub) tl)
      | Rinherit t -> Rinherit (sub.typ sub t)

    let map sub {ptyp_desc = desc; ptyp_loc = loc; ptyp_attributes = attrs} =
      let open Typ in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Ptyp_any -> any ~loc ~attrs ()
      | Ptyp_var s -> var ~loc ~attrs s
      | Ptyp_arrow (lab, t1, t2) ->
          arrow ~loc ~attrs lab (sub.typ sub t1) (sub.typ sub t2)
      | Ptyp_tuple tyl -> tuple ~loc ~attrs (List.map (sub.typ sub) tyl)
      | Ptyp_constr (lid, tl) ->
          constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tl)
      | Ptyp_object (l, o) ->
          let f (s, a, t) =
            (map_loc sub s, sub.attributes sub a, sub.typ sub t) in
          object_ ~loc ~attrs (List.map f l) o
      | Ptyp_class (lid, tl) ->
          class_ ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tl)
      | Ptyp_alias (t, s) -> alias ~loc ~attrs (sub.typ sub t) s
      | Ptyp_variant (rl, b, ll) ->
          variant ~loc ~attrs (List.map (row_field sub) rl) b ll
      | Ptyp_poly (sl, t) -> poly ~loc ~attrs
                               (List.map (map_loc sub) sl) (sub.typ sub t)
      | Ptyp_package (lid, l) ->
          package ~loc ~attrs (map_loc sub lid)
            (List.map (map_tuple (map_loc sub) (sub.typ sub)) l)
      | Ptyp_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_type_declaration sub
        {ptype_name; ptype_params; ptype_cstrs;
         ptype_kind;
         ptype_private;
         ptype_manifest;
         ptype_attributes;
         ptype_loc} =
      Type.mk (map_loc sub ptype_name)
        ~params:(List.map (map_fst (sub.typ sub)) ptype_params)
        ~priv:ptype_private
        ~cstrs:(List.map
                  (map_tuple3 (sub.typ sub) (sub.typ sub) (sub.location sub))
                  ptype_cstrs)
        ~kind:(sub.type_kind sub ptype_kind)
        ?manifest:(map_opt (sub.typ sub) ptype_manifest)
        ~loc:(sub.location sub ptype_loc)
        ~attrs:(sub.attributes sub ptype_attributes)

    let map_type_kind sub = function
      | Ptype_abstract -> Ptype_abstract
      | Ptype_variant l ->
          Ptype_variant (List.map (sub.constructor_declaration sub) l)
      | Ptype_record l -> Ptype_record (List.map (sub.label_declaration sub) l)
      | Ptype_open -> Ptype_open

    let map_constructor_arguments sub = function
      | Pcstr_tuple l -> Pcstr_tuple (List.map (sub.typ sub) l)
      | Pcstr_record l ->
          Pcstr_record (List.map (sub.label_declaration sub) l)

    let map_type_extension sub
        {ptyext_path; ptyext_params;
         ptyext_constructors;
         ptyext_private;
         ptyext_attributes} =
      Te.mk
        (map_loc sub ptyext_path)
        (List.map (sub.extension_constructor sub) ptyext_constructors)
        ~params:(List.map (map_fst (sub.typ sub)) ptyext_params)
        ~priv:ptyext_private
        ~attrs:(sub.attributes sub ptyext_attributes)

    let map_extension_constructor_kind sub = function
        Pext_decl(ctl, cto) ->
          Pext_decl(map_constructor_arguments sub ctl, map_opt (sub.typ sub) cto)
      | Pext_rebind li ->
          Pext_rebind (map_loc sub li)

    let map_extension_constructor sub
        {pext_name;
         pext_kind;
         pext_loc;
         pext_attributes} =
      Te.constructor
        (map_loc sub pext_name)
        (map_extension_constructor_kind sub pext_kind)
        ~loc:(sub.location sub pext_loc)
        ~attrs:(sub.attributes sub pext_attributes)

  end

  module CT = struct
    (* Type expressions for the class language *)

    let map sub {pcty_loc = loc; pcty_desc = desc; pcty_attributes = attrs} =
      let open Cty in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pcty_constr (lid, tys) ->
          constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tys)
      | Pcty_signature x -> signature ~loc ~attrs (sub.class_signature sub x)
      | Pcty_arrow (lab, t, ct) ->
          arrow ~loc ~attrs lab (sub.typ sub t) (sub.class_type sub ct)
      | Pcty_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_field sub {pctf_desc = desc; pctf_loc = loc; pctf_attributes = attrs}
      =
      let open Ctf in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pctf_inherit ct -> inherit_ ~loc ~attrs (sub.class_type sub ct)
      | Pctf_val (s, m, v, t) ->
          val_ ~loc ~attrs (map_loc sub s) m v (sub.typ sub t)
      | Pctf_method (s, p, v, t) ->
          method_ ~loc ~attrs (map_loc sub s) p v (sub.typ sub t)
      | Pctf_constraint (t1, t2) ->
          constraint_ ~loc ~attrs (sub.typ sub t1) (sub.typ sub t2)
      | Pctf_attribute x -> attribute ~loc (sub.attribute sub x)
      | Pctf_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_signature sub {pcsig_self; pcsig_fields} =
      Csig.mk
        (sub.typ sub pcsig_self)
        (List.map (sub.class_type_field sub) pcsig_fields)
  end

  module MT = struct
    (* Type expressions for the module language *)

    let map sub {pmty_desc = desc; pmty_loc = loc; pmty_attributes = attrs} =
      let open Mty in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pmty_ident s -> ident ~loc ~attrs (map_loc sub s)
      | Pmty_alias s -> alias ~loc ~attrs (map_loc sub s)
      | Pmty_signature sg -> signature ~loc ~attrs (sub.signature sub sg)
      | Pmty_functor (s, mt1, mt2) ->
          functor_ ~loc ~attrs (map_loc sub s)
            (Misc.may_map (sub.module_type sub) mt1)
            (sub.module_type sub mt2)
      | Pmty_with (mt, l) ->
          with_ ~loc ~attrs (sub.module_type sub mt)
            (List.map (sub.with_constraint sub) l)
      | Pmty_typeof me -> typeof_ ~loc ~attrs (sub.module_expr sub me)
      | Pmty_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_with_constraint sub = function
      | Pwith_type (lid, d) ->
          Pwith_type (map_loc sub lid, sub.type_declaration sub d)
      | Pwith_module (lid, lid2) ->
          Pwith_module (map_loc sub lid, map_loc sub lid2)
      | Pwith_typesubst d -> Pwith_typesubst (sub.type_declaration sub d)
      | Pwith_modsubst (s, lid) ->
          Pwith_modsubst (map_loc sub s, map_loc sub lid)

    let map_signature_item sub {psig_desc = desc; psig_loc = loc} =
      let open Sig in
      let loc = sub.location sub loc in
      match desc with
      | Psig_value vd -> value ~loc (sub.value_description sub vd)
      | Psig_type (rf, l) -> type_ ~loc rf (List.map (sub.type_declaration sub) l)
      | Psig_typext te -> type_extension ~loc (sub.type_extension sub te)
      | Psig_exception ed -> exception_ ~loc (sub.extension_constructor sub ed)
      | Psig_module x -> module_ ~loc (sub.module_declaration sub x)
      | Psig_recmodule l ->
          rec_module ~loc (List.map (sub.module_declaration sub) l)
      | Psig_modtype x -> modtype ~loc (sub.module_type_declaration sub x)
      | Psig_open x -> open_ ~loc (sub.open_description sub x)
      | Psig_include x -> include_ ~loc (sub.include_description sub x)
      | Psig_class l -> class_ ~loc (List.map (sub.class_description sub) l)
      | Psig_class_type l ->
          class_type ~loc (List.map (sub.class_type_declaration sub) l)
      | Psig_extension (x, attrs) ->
          extension ~loc (sub.extension sub x) ~attrs:(sub.attributes sub attrs)
      | Psig_attribute x -> attribute ~loc (sub.attribute sub x)
  end


  module M = struct
    (* Value expressions for the module language *)

    let map sub {pmod_loc = loc; pmod_desc = desc; pmod_attributes = attrs} =
      let open Mod in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pmod_ident x -> ident ~loc ~attrs (map_loc sub x)
      | Pmod_structure str -> structure ~loc ~attrs (sub.structure sub str)
      | Pmod_functor (arg, arg_ty, body) ->
          functor_ ~loc ~attrs (map_loc sub arg)
            (Misc.may_map (sub.module_type sub) arg_ty)
            (sub.module_expr sub body)
      | Pmod_apply (m1, m2) ->
          apply ~loc ~attrs (sub.module_expr sub m1) (sub.module_expr sub m2)
      | Pmod_constraint (m, mty) ->
          constraint_ ~loc ~attrs (sub.module_expr sub m)
                      (sub.module_type sub mty)
      | Pmod_unpack e -> unpack ~loc ~attrs (sub.expr sub e)
      | Pmod_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_structure_item sub {pstr_loc = loc; pstr_desc = desc} =
      let open Str in
      let loc = sub.location sub loc in
      match desc with
      | Pstr_eval (x, attrs) ->
          eval ~loc ~attrs:(sub.attributes sub attrs) (sub.expr sub x)
      | Pstr_value (r, vbs) -> value ~loc r (List.map (sub.value_binding sub) vbs)
      | Pstr_primitive vd -> primitive ~loc (sub.value_description sub vd)
      | Pstr_type (rf, l) -> type_ ~loc rf (List.map (sub.type_declaration sub) l)
      | Pstr_typext te -> type_extension ~loc (sub.type_extension sub te)
      | Pstr_exception ed -> exception_ ~loc (sub.extension_constructor sub ed)
      | Pstr_module x -> module_ ~loc (sub.module_binding sub x)
      | Pstr_recmodule l -> rec_module ~loc (List.map (sub.module_binding sub) l)
      | Pstr_modtype x -> modtype ~loc (sub.module_type_declaration sub x)
      | Pstr_open x -> open_ ~loc (sub.open_description sub x)
      | Pstr_class l -> class_ ~loc (List.map (sub.class_declaration sub) l)
      | Pstr_class_type l ->
          class_type ~loc (List.map (sub.class_type_declaration sub) l)
      | Pstr_include x -> include_ ~loc (sub.include_declaration sub x)
      | Pstr_extension (x, attrs) ->
          extension ~loc (sub.extension sub x) ~attrs:(sub.attributes sub attrs)
      | Pstr_attribute x -> attribute ~loc (sub.attribute sub x)
  end

  module E = struct
    (* Value expressions for the core language *)

    let map sub {pexp_loc = loc; pexp_desc = desc; pexp_attributes = attrs} =
      let open Exp in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pexp_ident x -> ident ~loc ~attrs (map_loc sub x)
      | Pexp_constant x -> constant ~loc ~attrs x
      | Pexp_let (r, vbs, e) ->
          let_ ~loc ~attrs r (List.map (sub.value_binding sub) vbs)
            (sub.expr sub e)
      | Pexp_fun (lab, def, p, e) ->
          fun_ ~loc ~attrs lab (map_opt (sub.expr sub) def) (sub.pat sub p)
            (sub.expr sub e)
      | Pexp_function pel -> function_ ~loc ~attrs (sub.cases sub pel)
      | Pexp_apply (e, l) ->
          apply ~loc ~attrs (sub.expr sub e) (List.map (map_snd (sub.expr sub)) l)
      | Pexp_match (e, pel) ->
          match_ ~loc ~attrs (sub.expr sub e) (sub.cases sub pel)
      | Pexp_try (e, pel) -> try_ ~loc ~attrs (sub.expr sub e) (sub.cases sub pel)
      | Pexp_tuple el -> tuple ~loc ~attrs (List.map (sub.expr sub) el)
      | Pexp_construct (lid, arg) ->
          construct ~loc ~attrs (map_loc sub lid) (map_opt (sub.expr sub) arg)
      | Pexp_variant (lab, eo) ->
          variant ~loc ~attrs lab (map_opt (sub.expr sub) eo)
      | Pexp_record (l, eo) ->
          record ~loc ~attrs (List.map (map_tuple (map_loc sub) (sub.expr sub)) l)
            (map_opt (sub.expr sub) eo)
      | Pexp_field (e, lid) ->
          field ~loc ~attrs (sub.expr sub e) (map_loc sub lid)
      | Pexp_setfield (e1, lid, e2) ->
          setfield ~loc ~attrs (sub.expr sub e1) (map_loc sub lid)
            (sub.expr sub e2)
      | Pexp_array el -> array ~loc ~attrs (List.map (sub.expr sub) el)
      | Pexp_ifthenelse (e1, e2, e3) ->
          ifthenelse ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)
            (map_opt (sub.expr sub) e3)
      | Pexp_sequence (e1, e2) ->
          sequence ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)
      | Pexp_while (e1, e2) ->
          while_ ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)
      | Pexp_for (p, e1, e2, d, e3) ->
          for_ ~loc ~attrs (sub.pat sub p) (sub.expr sub e1) (sub.expr sub e2) d
            (sub.expr sub e3)
      | Pexp_coerce (e, t1, t2) ->
          coerce ~loc ~attrs (sub.expr sub e) (map_opt (sub.typ sub) t1)
            (sub.typ sub t2)
      | Pexp_constraint (e, t) ->
          constraint_ ~loc ~attrs (sub.expr sub e) (sub.typ sub t)
      | Pexp_send (e, s) ->
          send ~loc ~attrs (sub.expr sub e) (map_loc sub s)
      | Pexp_new lid -> new_ ~loc ~attrs (map_loc sub lid)
      | Pexp_setinstvar (s, e) ->
          setinstvar ~loc ~attrs (map_loc sub s) (sub.expr sub e)
      | Pexp_override sel ->
          override ~loc ~attrs
            (List.map (map_tuple (map_loc sub) (sub.expr sub)) sel)
      | Pexp_letmodule (s, me, e) ->
          letmodule ~loc ~attrs (map_loc sub s) (sub.module_expr sub me)
            (sub.expr sub e)
      | Pexp_letexception (cd, e) ->
          letexception ~loc ~attrs
            (sub.extension_constructor sub cd)
            (sub.expr sub e)
      | Pexp_assert e -> assert_ ~loc ~attrs (sub.expr sub e)
      | Pexp_lazy e -> lazy_ ~loc ~attrs (sub.expr sub e)
      | Pexp_poly (e, t) ->
          poly ~loc ~attrs (sub.expr sub e) (map_opt (sub.typ sub) t)
      | Pexp_object cls -> object_ ~loc ~attrs (sub.class_structure sub cls)
      | Pexp_newtype (s, e) ->
          newtype ~loc ~attrs (map_loc sub s) (sub.expr sub e)
      | Pexp_pack me -> pack ~loc ~attrs (sub.module_expr sub me)
      | Pexp_open (ovf, lid, e) ->
          open_ ~loc ~attrs ovf (map_loc sub lid) (sub.expr sub e)
      | Pexp_extension x -> extension ~loc ~attrs (sub.extension sub x)
      | Pexp_unreachable -> unreachable ~loc ~attrs ()
  end

  module P = struct
    (* Patterns *)

    let map sub {ppat_desc = desc; ppat_loc = loc; ppat_attributes = attrs} =
      let open Pat in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Ppat_any -> any ~loc ~attrs ()
      | Ppat_var s -> var ~loc ~attrs (map_loc sub s)
      | Ppat_alias (p, s) -> alias ~loc ~attrs (sub.pat sub p) (map_loc sub s)
      | Ppat_constant c -> constant ~loc ~attrs c
      | Ppat_interval (c1, c2) -> interval ~loc ~attrs c1 c2
      | Ppat_tuple pl -> tuple ~loc ~attrs (List.map (sub.pat sub) pl)
      | Ppat_construct (l, p) ->
          construct ~loc ~attrs (map_loc sub l) (map_opt (sub.pat sub) p)
      | Ppat_variant (l, p) -> variant ~loc ~attrs l (map_opt (sub.pat sub) p)
      | Ppat_record (lpl, cf) ->
          record ~loc ~attrs
                 (List.map (map_tuple (map_loc sub) (sub.pat sub)) lpl) cf
      | Ppat_array pl -> array ~loc ~attrs (List.map (sub.pat sub) pl)
      | Ppat_or (p1, p2) -> or_ ~loc ~attrs (sub.pat sub p1) (sub.pat sub p2)
      | Ppat_constraint (p, t) ->
          constraint_ ~loc ~attrs (sub.pat sub p) (sub.typ sub t)
      | Ppat_type s -> type_ ~loc ~attrs (map_loc sub s)
      | Ppat_lazy p -> lazy_ ~loc ~attrs (sub.pat sub p)
      | Ppat_unpack s -> unpack ~loc ~attrs (map_loc sub s)
      | Ppat_open (lid,p) -> open_ ~loc ~attrs (map_loc sub lid) (sub.pat sub p)
      | Ppat_exception p -> exception_ ~loc ~attrs (sub.pat sub p)
      | Ppat_extension x -> extension ~loc ~attrs (sub.extension sub x)
  end

  module CE = struct
    (* Value expressions for the class language *)

    let map sub {pcl_loc = loc; pcl_desc = desc; pcl_attributes = attrs} =
      let open Cl in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pcl_constr (lid, tys) ->
          constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tys)
      | Pcl_structure s ->
          structure ~loc ~attrs (sub.class_structure sub s)
      | Pcl_fun (lab, e, p, ce) ->
          fun_ ~loc ~attrs lab
            (map_opt (sub.expr sub) e)
            (sub.pat sub p)
            (sub.class_expr sub ce)
      | Pcl_apply (ce, l) ->
          apply ~loc ~attrs (sub.class_expr sub ce)
            (List.map (map_snd (sub.expr sub)) l)
      | Pcl_let (r, vbs, ce) ->
          let_ ~loc ~attrs r (List.map (sub.value_binding sub) vbs)
            (sub.class_expr sub ce)
      | Pcl_constraint (ce, ct) ->
          constraint_ ~loc ~attrs (sub.class_expr sub ce) (sub.class_type sub ct)
      | Pcl_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_kind sub = function
      | Cfk_concrete (o, e) -> Cfk_concrete (o, sub.expr sub e)
      | Cfk_virtual t -> Cfk_virtual (sub.typ sub t)

    let map_field sub {pcf_desc = desc; pcf_loc = loc; pcf_attributes = attrs} =
      let open Cf in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pcf_inherit (o, ce, s) ->
          inherit_ ~loc ~attrs o (sub.class_expr sub ce)
            (map_opt (map_loc sub) s)
      | Pcf_val (s, m, k) -> val_ ~loc ~attrs (map_loc sub s) m (map_kind sub k)
      | Pcf_method (s, p, k) ->
          method_ ~loc ~attrs (map_loc sub s) p (map_kind sub k)
      | Pcf_constraint (t1, t2) ->
          constraint_ ~loc ~attrs (sub.typ sub t1) (sub.typ sub t2)
      | Pcf_initializer e -> initializer_ ~loc ~attrs (sub.expr sub e)
      | Pcf_attribute x -> attribute ~loc (sub.attribute sub x)
      | Pcf_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_structure sub {pcstr_self; pcstr_fields} =
      {
        pcstr_self = sub.pat sub pcstr_self;
        pcstr_fields = List.map (sub.class_field sub) pcstr_fields;
      }

    let class_infos sub f {pci_virt; pci_params = pl; pci_name; pci_expr;
                           pci_loc; pci_attributes} =
      Ci.mk
       ~virt:pci_virt
       ~params:(List.map (map_fst (sub.typ sub)) pl)
        (map_loc sub pci_name)
        (f pci_expr)
        ~loc:(sub.location sub pci_loc)
        ~attrs:(sub.attributes sub pci_attributes)
  end

  (* Now, a generic AST mapper, to be extended to cover all kinds and
     cases of the OCaml grammar.  The default behavior of the mapper is
     the identity. *)

  let default_mapper =
    {
      structure = (fun this l -> List.map (this.structure_item this) l);
      structure_item = M.map_structure_item;
      module_expr = M.map;
      signature = (fun this l -> List.map (this.signature_item this) l);
      signature_item = MT.map_signature_item;
      module_type = MT.map;
      with_constraint = MT.map_with_constraint;
      class_declaration =
        (fun this -> CE.class_infos this (this.class_expr this));
      class_expr = CE.map;
      class_field = CE.map_field;
      class_structure = CE.map_structure;
      class_type = CT.map;
      class_type_field = CT.map_field;
      class_signature = CT.map_signature;
      class_type_declaration =
        (fun this -> CE.class_infos this (this.class_type this));
      class_description =
        (fun this -> CE.class_infos this (this.class_type this));
      type_declaration = T.map_type_declaration;
      type_kind = T.map_type_kind;
      typ = T.map;
      type_extension = T.map_type_extension;
      extension_constructor = T.map_extension_constructor;
      value_description =
        (fun this {pval_name; pval_type; pval_prim; pval_loc;
                   pval_attributes} ->
          Val.mk
            (map_loc this pval_name)
            (this.typ this pval_type)
            ~attrs:(this.attributes this pval_attributes)
            ~loc:(this.location this pval_loc)
            ~prim:pval_prim
        );

      pat = P.map;
      expr = E.map;

      module_declaration =
        (fun this {pmd_name; pmd_type; pmd_attributes; pmd_loc} ->
           Md.mk
             (map_loc this pmd_name)
             (this.module_type this pmd_type)
             ~attrs:(this.attributes this pmd_attributes)
             ~loc:(this.location this pmd_loc)
        );

      module_type_declaration =
        (fun this {pmtd_name; pmtd_type; pmtd_attributes; pmtd_loc} ->
           Mtd.mk
             (map_loc this pmtd_name)
             ?typ:(map_opt (this.module_type this) pmtd_type)
             ~attrs:(this.attributes this pmtd_attributes)
             ~loc:(this.location this pmtd_loc)
        );

      module_binding =
        (fun this {pmb_name; pmb_expr; pmb_attributes; pmb_loc} ->
           Mb.mk (map_loc this pmb_name) (this.module_expr this pmb_expr)
             ~attrs:(this.attributes this pmb_attributes)
             ~loc:(this.location this pmb_loc)
        );


      open_description =
        (fun this {popen_lid; popen_override; popen_attributes; popen_loc} ->
           Opn.mk (map_loc this popen_lid)
             ~override:popen_override
             ~loc:(this.location this popen_loc)
             ~attrs:(this.attributes this popen_attributes)
        );


      include_description =
        (fun this {pincl_mod; pincl_attributes; pincl_loc} ->
           Incl.mk (this.module_type this pincl_mod)
             ~loc:(this.location this pincl_loc)
             ~attrs:(this.attributes this pincl_attributes)
        );

      include_declaration =
        (fun this {pincl_mod; pincl_attributes; pincl_loc} ->
           Incl.mk (this.module_expr this pincl_mod)
             ~loc:(this.location this pincl_loc)
             ~attrs:(this.attributes this pincl_attributes)
        );


      value_binding =
        (fun this {pvb_pat; pvb_expr; pvb_attributes; pvb_loc} ->
           Vb.mk
             (this.pat this pvb_pat)
             (this.expr this pvb_expr)
             ~loc:(this.location this pvb_loc)
             ~attrs:(this.attributes this pvb_attributes)
        );


      constructor_declaration =
        (fun this {pcd_name; pcd_args; pcd_res; pcd_loc; pcd_attributes} ->
          Type.constructor
            (map_loc this pcd_name)
            ~args:(T.map_constructor_arguments this pcd_args)
            ?res:(map_opt (this.typ this) pcd_res)
            ~loc:(this.location this pcd_loc)
            ~attrs:(this.attributes this pcd_attributes)
        );

      label_declaration =
        (fun this {pld_name; pld_type; pld_loc; pld_mutable; pld_attributes} ->
           Type.field
             (map_loc this pld_name)
             (this.typ this pld_type)
             ~mut:pld_mutable
             ~loc:(this.location this pld_loc)
             ~attrs:(this.attributes this pld_attributes)
        );

      cases = (fun this l -> List.map (this.case this) l);
      case =
        (fun this {pc_lhs; pc_guard; pc_rhs} ->
           {
             pc_lhs = this.pat this pc_lhs;
             pc_guard = map_opt (this.expr this) pc_guard;
             pc_rhs = this.expr this pc_rhs;
           }
        );



      location = (fun _this l -> l);

      extension = (fun this (s, e) -> (map_loc this s, this.payload this e));
      attribute = (fun this (s, e) -> (map_loc this s, this.payload this e));
      attributes = (fun this l -> List.map (this.attribute this) l);
      payload =
        (fun this -> function
           | PStr x -> PStr (this.structure this x)
           | PSig x -> PSig (this.signature this x)
           | PTyp x -> PTyp (this.typ this x)
           | PPat (x, g) -> PPat (this.pat this x, map_opt (this.expr this) g)
        );
    }

  let rec extension_of_error {loc; msg; if_highlight; sub} =
    { loc; txt = "ocaml.error" },
    PStr ([Str.eval (Exp.constant (Pconst_string (msg, None)));
           Str.eval (Exp.constant (Pconst_string (if_highlight, None)))] @
          (List.map (fun ext -> Str.extension (extension_of_error ext)) sub))

  let attribute_of_warning loc s =
    { loc; txt = "ocaml.ppwarning" },
    PStr ([Str.eval ~loc (Exp.constant (Pconst_string (s, None)))])

end

module Outcometree = struct
  (* Module [Outcometree]: results displayed by the toplevel *)

  (* These types represent messages that the toplevel displays as normal
     results or errors. The real displaying is customisable using the hooks:
        [Toploop.print_out_value]
        [Toploop.print_out_type]
        [Toploop.print_out_sig_item]
        [Toploop.print_out_phrase] *)

  type out_ident (*IF_CURRENT = Outcometree.out_ident *) =
    | Oide_apply of out_ident * out_ident
    | Oide_dot of out_ident * string
    | Oide_ident of string

  type out_attribute (*IF_CURRENT = Outcometree.out_attribute *) =
    { oattr_name: string }

  type out_value (*IF_CURRENT = Outcometree.out_value *) =
    | Oval_array of out_value list
    | Oval_char of char
    | Oval_constr of out_ident * out_value list
    | Oval_ellipsis
    | Oval_float of float
    | Oval_int of int
    | Oval_int32 of int32
    | Oval_int64 of int64
    | Oval_nativeint of nativeint
    | Oval_list of out_value list
    | Oval_printer of (Format.formatter -> unit)
    | Oval_record of (out_ident * out_value) list
    | Oval_string of string
    | Oval_stuff of string
    | Oval_tuple of out_value list
    | Oval_variant of string * out_value option

  type out_type (*IF_CURRENT = Outcometree.out_type *) =
    | Otyp_abstract
    | Otyp_open
    | Otyp_alias of out_type * string
    | Otyp_arrow of string * out_type * out_type
    | Otyp_class of bool * out_ident * out_type list
    | Otyp_constr of out_ident * out_type list
    | Otyp_manifest of out_type * out_type
    | Otyp_object of (string * out_type) list * bool option
    | Otyp_record of (string * bool * out_type) list
    | Otyp_stuff of string
    | Otyp_sum of (string * out_type list * out_type option) list
    | Otyp_tuple of out_type list
    | Otyp_var of bool * string
    | Otyp_variant of
        bool * out_variant * bool * (string list) option
    | Otyp_poly of string list * out_type
    | Otyp_module of string * string list * out_type list
    | Otyp_attribute of out_type * out_attribute

  and out_variant (*IF_CURRENT = Outcometree.out_variant *) =
    | Ovar_fields of (string * bool * out_type list) list
    | Ovar_typ of out_type

  type out_class_type (*IF_CURRENT = Outcometree.out_class_type *) =
    | Octy_constr of out_ident * out_type list
    | Octy_arrow of string * out_type * out_class_type
    | Octy_signature of out_type option * out_class_sig_item list
  and out_class_sig_item (*IF_CURRENT = Outcometree.out_class_sig_item *) =
    | Ocsg_constraint of out_type * out_type
    | Ocsg_method of string * bool * bool * out_type
    | Ocsg_value of string * bool * bool * out_type

  type out_module_type (*IF_CURRENT = Outcometree.out_module_type *) =
    | Omty_abstract
    | Omty_functor of string * out_module_type option * out_module_type
    | Omty_ident of out_ident
    | Omty_signature of out_sig_item list
    | Omty_alias of out_ident
  and out_sig_item (*IF_CURRENT = Outcometree.out_sig_item *) =
    | Osig_class of
        bool * string * (string * (bool * bool)) list * out_class_type *
          out_rec_status
    | Osig_class_type of
        bool * string * (string * (bool * bool)) list * out_class_type *
          out_rec_status
    | Osig_typext of out_extension_constructor * out_ext_status
    | Osig_modtype of string * out_module_type
    | Osig_module of string * out_module_type * out_rec_status
    | Osig_type of out_type_decl * out_rec_status
    | Osig_value of out_val_decl
    | Osig_ellipsis
  and out_type_decl (*IF_CURRENT = Outcometree.out_type_decl *) =
    { otype_name: string;
      otype_params: (string * (bool * bool)) list;
      otype_type: out_type;
      otype_private: Asttypes.private_flag;
      otype_immediate: bool;
      otype_unboxed: bool;
      otype_cstrs: (out_type * out_type) list }
  and out_extension_constructor (*IF_CURRENT = Outcometree.out_extension_constructor *) =
    { oext_name: string;
      oext_type_name: string;
      oext_type_params: string list;
      oext_args: out_type list;
      oext_ret_type: out_type option;
      oext_private: Asttypes.private_flag }
  and out_type_extension (*IF_CURRENT = Outcometree.out_type_extension *) =
    { otyext_name: string;
      otyext_params: string list;
      otyext_constructors: (string * out_type list * out_type option) list;
      otyext_private: Asttypes.private_flag }
  and out_val_decl (*IF_CURRENT = Outcometree.out_val_decl *) =
    { oval_name: string;
      oval_type: out_type;
      oval_prims: string list;
      oval_attributes: out_attribute list }
  and out_rec_status (*IF_CURRENT = Outcometree.out_rec_status *) =
    | Orec_not
    | Orec_first
    | Orec_next
  and out_ext_status (*IF_CURRENT = Outcometree.out_ext_status *) =
    | Oext_first
    | Oext_next
    | Oext_exception

  type out_phrase (*IF_CURRENT = Outcometree.out_phrase *) =
    | Ophr_eval of out_value * out_type
    | Ophr_signature of (out_sig_item * out_value option) list
    | Ophr_exception of (exn * out_value)

end

module Config = struct
  let ast_impl_magic_number = "Caml1999M020"
  let ast_intf_magic_number = "Caml1999N018"
end

let map_signature mapper = mapper.Ast_mapper.signature mapper
let map_structure mapper = mapper.Ast_mapper.structure mapper

let shallow_identity =
  let id _ x = x in
  {
    Ast_mapper.
    structure               = id;
    structure_item          = id;
    module_expr             = id;
    signature               = id;
    signature_item          = id;
    module_type             = id;
    with_constraint         = id;
    class_declaration       = id;
    class_expr              = id;
    class_field             = id;
    class_structure         = id;
    class_type              = id;
    class_type_field        = id;
    class_signature         = id;
    class_type_declaration  = id;
    class_description       = id;
    type_declaration        = id;
    type_kind               = id;
    typ                     = id;
    type_extension          = id;
    extension_constructor   = id;
    value_description       = id;
    pat                     = id;
    expr                    = id;
    module_declaration      = id;
    module_type_declaration = id;
    module_binding          = id;
    open_description        = id;
    include_description     = id;
    include_declaration     = id;
    value_binding           = id;
    constructor_declaration = id;
    label_declaration       = id;
    cases                   = id;
    case                    = id;
    location                = id;
    extension               = id;
    attribute               = id;
    attributes              = id;
    payload                 = id;
  }

let failing_mapper =
  let fail _ _ =
    invalid_arg "failing_mapper: this mapper function should never get called"
  in
  {
    Ast_mapper.
    structure               = fail;
    structure_item          = fail;
    module_expr             = fail;
    signature               = fail;
    signature_item          = fail;
    module_type             = fail;
    with_constraint         = fail;
    class_declaration       = fail;
    class_expr              = fail;
    class_field             = fail;
    class_structure         = fail;
    class_type              = fail;
    class_type_field        = fail;
    class_signature         = fail;
    class_type_declaration  = fail;
    class_description       = fail;
    type_declaration        = fail;
    type_kind               = fail;
    typ                     = fail;
    type_extension          = fail;
    extension_constructor   = fail;
    value_description       = fail;
    pat                     = fail;
    expr                    = fail;
    module_declaration      = fail;
    module_type_declaration = fail;
    module_binding          = fail;
    open_description        = fail;
    include_description     = fail;
    include_declaration     = fail;
    value_binding           = fail;
    constructor_declaration = fail;
    label_declaration       = fail;
    cases                   = fail;
    case                    = fail;
    location                = fail;
    extension               = fail;
    attribute               = fail;
    attributes              = fail;
    payload                 = fail;
  }

let make_top_mapper ~signature ~structure =
  {failing_mapper with Ast_mapper.
                    signature = (fun _ x -> signature x);
                    structure = (fun _ x -> structure x) }

end
module Migrate_parsetree_402_403_migrate
= struct
#1 "migrate_parsetree_402_403_migrate.ml"
# 1 "src/migrate_parsetree_402_403_migrate.ml"
# 1 "src/migrate_parsetree_402_403_migrate.ml"
# 1 "src/migrate_parsetree_402_403_migrate.ml"
# 1 "src/migrate_parsetree_402_403_migrate.ml"
# 1 "src/migrate_parsetree_402_403_migrate.ml"
# 1 "src/migrate_parsetree_402_403_migrate.ml"
# 1 "src/migrate_parsetree_402_403_migrate.ml"
# 1 "src/migrate_parsetree_402_403_migrate.ml"
# 1 "src/migrate_parsetree_402_403_migrate.ml"
# 1 "src/migrate_parsetree_402_403_migrate.ml"
# 1 "src/migrate_parsetree_402_403_migrate.ml"
# 1 "src/migrate_parsetree_402_403_migrate.ml"
# 1 "src/migrate_parsetree_402_403_migrate.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*                         Alain Frisch, LexiFi                           *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

module From = Ast_402
module To = Ast_403

let extract_predef_option label typ =
  let open From in
  let open Longident in
  match label, typ.Parsetree.ptyp_desc with
  | To.Asttypes.Optional _,
    From.Parsetree.Ptyp_constr (
      {Location.txt = Ldot (Lident "*predef*", "option"); _}, [d]) ->
      d
  | _ -> typ

let rec copy_expression :
  From.Parsetree.expression ->
    To.Parsetree.expression
  =
  fun
    { From.Parsetree.pexp_desc = pexp_desc;
      From.Parsetree.pexp_loc = pexp_loc;
      From.Parsetree.pexp_attributes = pexp_attributes }
     ->
    {
      To.Parsetree.pexp_desc =
        (copy_expression_desc pexp_desc);
      To.Parsetree.pexp_loc =
        (copy_location pexp_loc);
      To.Parsetree.pexp_attributes =
        (copy_attributes pexp_attributes)
    }

and copy_expression_desc :
  From.Parsetree.expression_desc ->
    To.Parsetree.expression_desc
  =
  function
  | From.Parsetree.Pexp_ident x0 ->
      To.Parsetree.Pexp_ident
        (copy_loc copy_longident
           x0)
  | From.Parsetree.Pexp_constant x0 ->
      To.Parsetree.Pexp_constant
        (copy_constant x0)
  | From.Parsetree.Pexp_let (x0,x1,x2) ->
      To.Parsetree.Pexp_let
        ((copy_rec_flag x0),
          (List.map copy_value_binding x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_function x0 ->
      To.Parsetree.Pexp_function
        (List.map copy_case x0)
  | From.Parsetree.Pexp_fun (x0,x1,x2,x3) ->
      To.Parsetree.Pexp_fun
        ((copy_arg_label x0),
          (copy_option copy_expression x1),
          (copy_pattern x2),
          (copy_expression x3))
  | From.Parsetree.Pexp_apply (x0,x1) ->
      To.Parsetree.Pexp_apply
        ((copy_expression x0),
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                ((copy_arg_label x0),
                  (copy_expression x1))) x1))
  | From.Parsetree.Pexp_match (x0,x1) ->
      To.Parsetree.Pexp_match
        ((copy_expression x0),
          (List.map copy_case x1))
  | From.Parsetree.Pexp_try (x0,x1) ->
      To.Parsetree.Pexp_try
        ((copy_expression x0),
          (List.map copy_case x1))
  | From.Parsetree.Pexp_tuple x0 ->
      To.Parsetree.Pexp_tuple
        (List.map copy_expression x0)
  | From.Parsetree.Pexp_construct (x0,x1) ->
      To.Parsetree.Pexp_construct
        ((copy_loc
            copy_longident x0),
          (copy_option copy_expression x1))
  | From.Parsetree.Pexp_variant (x0,x1) ->
      To.Parsetree.Pexp_variant
        ((copy_label x0),
          (copy_option copy_expression x1))
  | From.Parsetree.Pexp_record (x0,x1) ->
      To.Parsetree.Pexp_record
        ((List.map
            (fun x  ->
               let (x0,x1) = x  in
               ((copy_loc
                   copy_longident x0),
                 (copy_expression x1))) x0),
          (copy_option copy_expression x1))
  | From.Parsetree.Pexp_field (x0,x1) ->
      To.Parsetree.Pexp_field
        ((copy_expression x0),
          (copy_loc
             copy_longident x1))
  | From.Parsetree.Pexp_setfield (x0,x1,x2) ->
      To.Parsetree.Pexp_setfield
        ((copy_expression x0),
          (copy_loc
             copy_longident x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_array x0 ->
      To.Parsetree.Pexp_array
        (List.map copy_expression x0)
  | From.Parsetree.Pexp_ifthenelse (x0,x1,x2) ->
      To.Parsetree.Pexp_ifthenelse
        ((copy_expression x0),
          (copy_expression x1),
          (copy_option copy_expression x2))
  | From.Parsetree.Pexp_sequence (x0,x1) ->
      To.Parsetree.Pexp_sequence
        ((copy_expression x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_while (x0,x1) ->
      To.Parsetree.Pexp_while
        ((copy_expression x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_for (x0,x1,x2,x3,x4) ->
      To.Parsetree.Pexp_for
        ((copy_pattern x0),
          (copy_expression x1),
          (copy_expression x2),
          (copy_direction_flag x3),
          (copy_expression x4))
  | From.Parsetree.Pexp_constraint (x0,x1) ->
      To.Parsetree.Pexp_constraint
        ((copy_expression x0),
          (copy_core_type x1))
  | From.Parsetree.Pexp_coerce (x0,x1,x2) ->
      To.Parsetree.Pexp_coerce
        ((copy_expression x0),
          (copy_option copy_core_type x1),
          (copy_core_type x2))
  | From.Parsetree.Pexp_send (x0,x1) ->
      To.Parsetree.Pexp_send
        ((copy_expression x0), x1)
  | From.Parsetree.Pexp_new x0 ->
      To.Parsetree.Pexp_new
        (copy_loc copy_longident
           x0)
  | From.Parsetree.Pexp_setinstvar (x0,x1) ->
      To.Parsetree.Pexp_setinstvar
        ((copy_loc (fun x  -> x) x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_override x0 ->
      To.Parsetree.Pexp_override
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_loc (fun x  -> x) x0),
                (copy_expression x1))) x0)
  | From.Parsetree.Pexp_letmodule (x0,x1,x2) ->
      To.Parsetree.Pexp_letmodule
        ((copy_loc (fun x  -> x) x0),
          (copy_module_expr x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_assert x0 ->
      To.Parsetree.Pexp_assert
        (copy_expression x0)
  | From.Parsetree.Pexp_lazy x0 ->
      To.Parsetree.Pexp_lazy
        (copy_expression x0)
  | From.Parsetree.Pexp_poly (x0,x1) ->
      To.Parsetree.Pexp_poly
        ((copy_expression x0),
          (copy_option copy_core_type x1))
  | From.Parsetree.Pexp_object x0 ->
      To.Parsetree.Pexp_object
        (copy_class_structure x0)
  | From.Parsetree.Pexp_newtype (x0,x1) ->
      To.Parsetree.Pexp_newtype
        (x0, (copy_expression x1))
  | From.Parsetree.Pexp_pack x0 ->
      To.Parsetree.Pexp_pack
        (copy_module_expr x0)
  | From.Parsetree.Pexp_open (x0,x1,x2) ->
      To.Parsetree.Pexp_open
        ((copy_override_flag x0),
          (copy_loc
             copy_longident x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_extension x0 ->
      To.Parsetree.Pexp_extension
        (copy_extension x0)

and copy_direction_flag :
  From.Asttypes.direction_flag ->
    To.Asttypes.direction_flag
  =
  function
  | From.Asttypes.Upto  -> To.Asttypes.Upto
  | From.Asttypes.Downto  -> To.Asttypes.Downto

and copy_case :
  From.Parsetree.case -> To.Parsetree.case =
  fun
    { From.Parsetree.pc_lhs = pc_lhs;
      From.Parsetree.pc_guard = pc_guard;
      From.Parsetree.pc_rhs = pc_rhs }
     ->
    {
      To.Parsetree.pc_lhs =
        (copy_pattern pc_lhs);
      To.Parsetree.pc_guard =
        (copy_option copy_expression pc_guard);
      To.Parsetree.pc_rhs =
        (copy_expression pc_rhs)
    }

and copy_value_binding :
  From.Parsetree.value_binding ->
    To.Parsetree.value_binding
  =
  fun
    { From.Parsetree.pvb_pat = pvb_pat;
      From.Parsetree.pvb_expr = pvb_expr;
      From.Parsetree.pvb_attributes = pvb_attributes;
      From.Parsetree.pvb_loc = pvb_loc }
     ->
    {
      To.Parsetree.pvb_pat =
        (copy_pattern pvb_pat);
      To.Parsetree.pvb_expr =
        (copy_expression pvb_expr);
      To.Parsetree.pvb_attributes =
        (copy_attributes pvb_attributes);
      To.Parsetree.pvb_loc =
        (copy_location pvb_loc)
    }

and copy_pattern :
  From.Parsetree.pattern -> To.Parsetree.pattern =
  fun
    { From.Parsetree.ppat_desc = ppat_desc;
      From.Parsetree.ppat_loc = ppat_loc;
      From.Parsetree.ppat_attributes = ppat_attributes }
     ->
    {
      To.Parsetree.ppat_desc =
        (copy_pattern_desc ppat_desc);
      To.Parsetree.ppat_loc =
        (copy_location ppat_loc);
      To.Parsetree.ppat_attributes =
        (copy_attributes ppat_attributes)
    }

and copy_pattern_desc :
  From.Parsetree.pattern_desc ->
    To.Parsetree.pattern_desc
  =
  function
  | From.Parsetree.Ppat_any  ->
      To.Parsetree.Ppat_any
  | From.Parsetree.Ppat_var x0 ->
      To.Parsetree.Ppat_var
        (copy_loc (fun x  -> x) x0)
  | From.Parsetree.Ppat_alias (x0,x1) ->
      To.Parsetree.Ppat_alias
        ((copy_pattern x0),
          (copy_loc (fun x  -> x) x1))
  | From.Parsetree.Ppat_constant x0 ->
      To.Parsetree.Ppat_constant
        (copy_constant x0)
  | From.Parsetree.Ppat_interval (x0,x1) ->
      To.Parsetree.Ppat_interval
        ((copy_constant x0),
          (copy_constant x1))
  | From.Parsetree.Ppat_tuple x0 ->
      To.Parsetree.Ppat_tuple
        (List.map copy_pattern x0)
  | From.Parsetree.Ppat_construct (x0,x1) ->
      To.Parsetree.Ppat_construct
        ((copy_loc
            copy_longident x0),
          (copy_option copy_pattern x1))
  | From.Parsetree.Ppat_variant (x0,x1) ->
      To.Parsetree.Ppat_variant
        ((copy_label x0),
          (copy_option copy_pattern x1))
  | From.Parsetree.Ppat_record (x0,x1) ->
      To.Parsetree.Ppat_record
        ((List.map
            (fun x  ->
               let (x0,x1) = x  in
               ((copy_loc
                   copy_longident x0),
                 (copy_pattern x1))) x0),
          (copy_closed_flag x1))
  | From.Parsetree.Ppat_array x0 ->
      To.Parsetree.Ppat_array
        (List.map copy_pattern x0)
  | From.Parsetree.Ppat_or (x0,x1) ->
      To.Parsetree.Ppat_or
        ((copy_pattern x0),
          (copy_pattern x1))
  | From.Parsetree.Ppat_constraint (x0,x1) ->
      To.Parsetree.Ppat_constraint
        ((copy_pattern x0),
          (copy_core_type x1))
  | From.Parsetree.Ppat_type x0 ->
      To.Parsetree.Ppat_type
        (copy_loc copy_longident
           x0)
  | From.Parsetree.Ppat_lazy x0 ->
      To.Parsetree.Ppat_lazy
        (copy_pattern x0)
  | From.Parsetree.Ppat_unpack x0 ->
      To.Parsetree.Ppat_unpack
        (copy_loc (fun x  -> x) x0)
  | From.Parsetree.Ppat_exception x0 ->
      To.Parsetree.Ppat_exception
        (copy_pattern x0)
  | From.Parsetree.Ppat_extension x0 ->
      To.Parsetree.Ppat_extension
        (copy_extension x0)

and copy_core_type :
  From.Parsetree.core_type ->
    To.Parsetree.core_type
  =
  fun
    { From.Parsetree.ptyp_desc = ptyp_desc;
      From.Parsetree.ptyp_loc = ptyp_loc;
      From.Parsetree.ptyp_attributes = ptyp_attributes }
     ->
    {
      To.Parsetree.ptyp_desc =
        (copy_core_type_desc ptyp_desc);
      To.Parsetree.ptyp_loc =
        (copy_location ptyp_loc);
      To.Parsetree.ptyp_attributes =
        (copy_attributes ptyp_attributes)
    }

and copy_core_type_desc :
  From.Parsetree.core_type_desc ->
    To.Parsetree.core_type_desc
  =
  function
  | From.Parsetree.Ptyp_any  ->
      To.Parsetree.Ptyp_any
  | From.Parsetree.Ptyp_var x0 ->
      To.Parsetree.Ptyp_var x0
  | From.Parsetree.Ptyp_arrow (x0,x1,x2) ->
      let label = copy_arg_label x0 in
      To.Parsetree.Ptyp_arrow
        (label,
         copy_core_type (extract_predef_option label x1),
         copy_core_type x2)
  | From.Parsetree.Ptyp_tuple x0 ->
      To.Parsetree.Ptyp_tuple
        (List.map copy_core_type x0)
  | From.Parsetree.Ptyp_constr (x0,x1) ->
      To.Parsetree.Ptyp_constr
        ((copy_loc
            copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Ptyp_object (x0,x1) ->
      To.Parsetree.Ptyp_object
        ((List.map
            (fun x  ->
               let (x0,x1,x2) = x  in
               (x0, (copy_attributes x1),
                 (copy_core_type x2))) x0),
          (copy_closed_flag x1))
  | From.Parsetree.Ptyp_class (x0,x1) ->
      To.Parsetree.Ptyp_class
        ((copy_loc
            copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Ptyp_alias (x0,x1) ->
      To.Parsetree.Ptyp_alias
        ((copy_core_type x0), x1)
  | From.Parsetree.Ptyp_variant (x0,x1,x2) ->
      To.Parsetree.Ptyp_variant
        ((List.map copy_row_field x0),
          (copy_closed_flag x1),
          (copy_option
             (fun x  -> List.map copy_label x) x2))
  | From.Parsetree.Ptyp_poly (x0,x1) ->
      To.Parsetree.Ptyp_poly
        ((List.map (fun x  -> x) x0),
          (copy_core_type x1))
  | From.Parsetree.Ptyp_package x0 ->
      To.Parsetree.Ptyp_package
        (copy_package_type x0)
  | From.Parsetree.Ptyp_extension x0 ->
      To.Parsetree.Ptyp_extension
        (copy_extension x0)

and copy_package_type :
  From.Parsetree.package_type ->
    To.Parsetree.package_type
  =
  fun x  ->
    let (x0,x1) = x  in
    ((copy_loc copy_longident x0),
      (List.map
         (fun x  ->
            let (x0,x1) = x  in
            ((copy_loc
                copy_longident x0),
              (copy_core_type x1))) x1))

and copy_row_field :
  From.Parsetree.row_field ->
    To.Parsetree.row_field
  =
  function
  | From.Parsetree.Rtag (x0,x1,x2,x3) ->
      To.Parsetree.Rtag
        ((copy_label x0),
          (copy_attributes x1), (copy_bool x2),
          (List.map copy_core_type x3))
  | From.Parsetree.Rinherit x0 ->
      To.Parsetree.Rinherit
        (copy_core_type x0)

and copy_attributes :
  From.Parsetree.attributes ->
    To.Parsetree.attributes
  = fun x  -> List.map copy_attribute x

and copy_attribute :
  From.Parsetree.attribute ->
    To.Parsetree.attribute
  =
  fun x  ->
    let (x0,x1) = x  in
    ((copy_loc (fun x  -> x) x0),
      (copy_payload x1))

and copy_payload :
  From.Parsetree.payload -> To.Parsetree.payload =
  function
  | From.Parsetree.PStr x0 ->
      To.Parsetree.PStr
        (copy_structure x0)
  | From.Parsetree.PTyp x0 ->
      To.Parsetree.PTyp
        (copy_core_type x0)
  | From.Parsetree.PPat (x0,x1) ->
      To.Parsetree.PPat
        ((copy_pattern x0),
          (copy_option copy_expression x1))

and copy_structure :
  From.Parsetree.structure ->
    To.Parsetree.structure
  = fun x  -> List.map copy_structure_item x

and copy_structure_item :
  From.Parsetree.structure_item ->
    To.Parsetree.structure_item
  =
  fun
    { From.Parsetree.pstr_desc = pstr_desc;
      From.Parsetree.pstr_loc = pstr_loc }
     ->
    {
      To.Parsetree.pstr_desc =
        (copy_structure_item_desc pstr_desc);
      To.Parsetree.pstr_loc =
        (copy_location pstr_loc)
    }

and copy_structure_item_desc :
  From.Parsetree.structure_item_desc ->
    To.Parsetree.structure_item_desc
  =
  function
  | From.Parsetree.Pstr_eval (x0,x1) ->
      To.Parsetree.Pstr_eval
        ((copy_expression x0),
          (copy_attributes x1))
  | From.Parsetree.Pstr_value (x0,x1) ->
      To.Parsetree.Pstr_value
        ((copy_rec_flag x0),
          (List.map copy_value_binding x1))
  | From.Parsetree.Pstr_primitive x0 ->
      To.Parsetree.Pstr_primitive
        (copy_value_description x0)
  | From.Parsetree.Pstr_type x0 ->
      let recflag, types = type_declarations x0 in
      To.Parsetree.Pstr_type (recflag, types)
  | From.Parsetree.Pstr_typext x0 ->
      To.Parsetree.Pstr_typext
        (copy_type_extension x0)
  | From.Parsetree.Pstr_exception x0 ->
      To.Parsetree.Pstr_exception
        (copy_extension_constructor x0)
  | From.Parsetree.Pstr_module x0 ->
      To.Parsetree.Pstr_module
        (copy_module_binding x0)
  | From.Parsetree.Pstr_recmodule x0 ->
      To.Parsetree.Pstr_recmodule
        (List.map copy_module_binding x0)
  | From.Parsetree.Pstr_modtype x0 ->
      To.Parsetree.Pstr_modtype
        (copy_module_type_declaration x0)
  | From.Parsetree.Pstr_open x0 ->
      To.Parsetree.Pstr_open
        (copy_open_description x0)
  | From.Parsetree.Pstr_class x0 ->
      To.Parsetree.Pstr_class
        (List.map copy_class_declaration x0)
  | From.Parsetree.Pstr_class_type x0 ->
      To.Parsetree.Pstr_class_type
        (List.map copy_class_type_declaration x0)
  | From.Parsetree.Pstr_include x0 ->
      To.Parsetree.Pstr_include
        (copy_include_declaration x0)
  | From.Parsetree.Pstr_attribute x0 ->
      To.Parsetree.Pstr_attribute
        (copy_attribute x0)
  | From.Parsetree.Pstr_extension (x0,x1) ->
      To.Parsetree.Pstr_extension
        ((copy_extension x0),
          (copy_attributes x1))

and copy_include_declaration :
  From.Parsetree.include_declaration ->
    To.Parsetree.include_declaration
  =
  fun x  ->
    copy_include_infos
      copy_module_expr x

and copy_class_declaration :
  From.Parsetree.class_declaration ->
    To.Parsetree.class_declaration
  =
  fun x  ->
    copy_class_infos
      copy_class_expr x

and copy_class_expr :
  From.Parsetree.class_expr ->
    To.Parsetree.class_expr
  =
  fun
    { From.Parsetree.pcl_desc = pcl_desc;
      From.Parsetree.pcl_loc = pcl_loc;
      From.Parsetree.pcl_attributes = pcl_attributes }
     ->
    {
      To.Parsetree.pcl_desc =
        (copy_class_expr_desc pcl_desc);
      To.Parsetree.pcl_loc =
        (copy_location pcl_loc);
      To.Parsetree.pcl_attributes =
        (copy_attributes pcl_attributes)
    }

and copy_class_expr_desc :
  From.Parsetree.class_expr_desc ->
    To.Parsetree.class_expr_desc
  =
  function
  | From.Parsetree.Pcl_constr (x0,x1) ->
      To.Parsetree.Pcl_constr
        ((copy_loc
            copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Pcl_structure x0 ->
      To.Parsetree.Pcl_structure
        (copy_class_structure x0)
  | From.Parsetree.Pcl_fun (x0,x1,x2,x3) ->
      To.Parsetree.Pcl_fun
        ((copy_arg_label x0),
          (copy_option copy_expression x1),
          (copy_pattern x2),
          (copy_class_expr x3))
  | From.Parsetree.Pcl_apply (x0,x1) ->
      To.Parsetree.Pcl_apply
        ((copy_class_expr x0),
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                ((copy_arg_label x0),
                  (copy_expression x1))) x1))
  | From.Parsetree.Pcl_let (x0,x1,x2) ->
      To.Parsetree.Pcl_let
        ((copy_rec_flag x0),
          (List.map copy_value_binding x1),
          (copy_class_expr x2))
  | From.Parsetree.Pcl_constraint (x0,x1) ->
      To.Parsetree.Pcl_constraint
        ((copy_class_expr x0),
          (copy_class_type x1))
  | From.Parsetree.Pcl_extension x0 ->
      To.Parsetree.Pcl_extension
        (copy_extension x0)

and copy_class_structure :
  From.Parsetree.class_structure ->
    To.Parsetree.class_structure
  =
  fun
    { From.Parsetree.pcstr_self = pcstr_self;
      From.Parsetree.pcstr_fields = pcstr_fields }
     ->
    {
      To.Parsetree.pcstr_self =
        (copy_pattern pcstr_self);
      To.Parsetree.pcstr_fields =
        (List.map copy_class_field pcstr_fields)
    }

and copy_class_field :
  From.Parsetree.class_field ->
    To.Parsetree.class_field
  =
  fun
    { From.Parsetree.pcf_desc = pcf_desc;
      From.Parsetree.pcf_loc = pcf_loc;
      From.Parsetree.pcf_attributes = pcf_attributes }
     ->
    {
      To.Parsetree.pcf_desc =
        (copy_class_field_desc pcf_desc);
      To.Parsetree.pcf_loc =
        (copy_location pcf_loc);
      To.Parsetree.pcf_attributes =
        (copy_attributes pcf_attributes)
    }

and copy_class_field_desc :
  From.Parsetree.class_field_desc ->
    To.Parsetree.class_field_desc
  =
  function
  | From.Parsetree.Pcf_inherit (x0,x1,x2) ->
      To.Parsetree.Pcf_inherit
        ((copy_override_flag x0),
          (copy_class_expr x1),
          (copy_option (fun x  -> x) x2))
  | From.Parsetree.Pcf_val x0 ->
      To.Parsetree.Pcf_val
        (let (x0,x1,x2) = x0  in
         ((copy_loc (fun x  -> x) x0),
           (copy_mutable_flag x1),
           (copy_class_field_kind x2)))
  | From.Parsetree.Pcf_method x0 ->
      To.Parsetree.Pcf_method
        (let (x0,x1,x2) = x0  in
         ((copy_loc (fun x  -> x) x0),
           (copy_private_flag x1),
           (copy_class_field_kind x2)))
  | From.Parsetree.Pcf_constraint x0 ->
      To.Parsetree.Pcf_constraint
        (let (x0,x1) = x0  in
         ((copy_core_type x0),
           (copy_core_type x1)))
  | From.Parsetree.Pcf_initializer x0 ->
      To.Parsetree.Pcf_initializer
        (copy_expression x0)
  | From.Parsetree.Pcf_attribute x0 ->
      To.Parsetree.Pcf_attribute
        (copy_attribute x0)
  | From.Parsetree.Pcf_extension x0 ->
      To.Parsetree.Pcf_extension
        (copy_extension x0)

and copy_class_field_kind :
  From.Parsetree.class_field_kind ->
    To.Parsetree.class_field_kind
  =
  function
  | From.Parsetree.Cfk_virtual x0 ->
      To.Parsetree.Cfk_virtual
        (copy_core_type x0)
  | From.Parsetree.Cfk_concrete (x0,x1) ->
      To.Parsetree.Cfk_concrete
        ((copy_override_flag x0),
          (copy_expression x1))

and copy_module_binding :
  From.Parsetree.module_binding ->
    To.Parsetree.module_binding
  =
  fun
    { From.Parsetree.pmb_name = pmb_name;
      From.Parsetree.pmb_expr = pmb_expr;
      From.Parsetree.pmb_attributes = pmb_attributes;
      From.Parsetree.pmb_loc = pmb_loc }
     ->
    {
      To.Parsetree.pmb_name =
        (copy_loc (fun x  -> x) pmb_name);
      To.Parsetree.pmb_expr =
        (copy_module_expr pmb_expr);
      To.Parsetree.pmb_attributes =
        (copy_attributes pmb_attributes);
      To.Parsetree.pmb_loc =
        (copy_location pmb_loc)
    }

and copy_module_expr :
  From.Parsetree.module_expr ->
    To.Parsetree.module_expr
  =
  fun
    { From.Parsetree.pmod_desc = pmod_desc;
      From.Parsetree.pmod_loc = pmod_loc;
      From.Parsetree.pmod_attributes = pmod_attributes }
     ->
    {
      To.Parsetree.pmod_desc =
        (copy_module_expr_desc pmod_desc);
      To.Parsetree.pmod_loc =
        (copy_location pmod_loc);
      To.Parsetree.pmod_attributes =
        (copy_attributes pmod_attributes)
    }

and copy_module_expr_desc :
  From.Parsetree.module_expr_desc ->
    To.Parsetree.module_expr_desc
  =
  function
  | From.Parsetree.Pmod_ident x0 ->
      To.Parsetree.Pmod_ident
        (copy_loc copy_longident
           x0)
  | From.Parsetree.Pmod_structure x0 ->
      To.Parsetree.Pmod_structure
        (copy_structure x0)
  | From.Parsetree.Pmod_functor (x0,x1,x2) ->
      To.Parsetree.Pmod_functor
        ((copy_loc (fun x  -> x) x0),
          (copy_option copy_module_type x1),
          (copy_module_expr x2))
  | From.Parsetree.Pmod_apply (x0,x1) ->
      To.Parsetree.Pmod_apply
        ((copy_module_expr x0),
          (copy_module_expr x1))
  | From.Parsetree.Pmod_constraint (x0,x1) ->
      To.Parsetree.Pmod_constraint
        ((copy_module_expr x0),
          (copy_module_type x1))
  | From.Parsetree.Pmod_unpack x0 ->
      To.Parsetree.Pmod_unpack
        (copy_expression x0)
  | From.Parsetree.Pmod_extension x0 ->
      To.Parsetree.Pmod_extension
        (copy_extension x0)

and copy_module_type :
  From.Parsetree.module_type ->
    To.Parsetree.module_type
  =
  fun
    { From.Parsetree.pmty_desc = pmty_desc;
      From.Parsetree.pmty_loc = pmty_loc;
      From.Parsetree.pmty_attributes = pmty_attributes }
     ->
    {
      To.Parsetree.pmty_desc =
        (copy_module_type_desc pmty_desc);
      To.Parsetree.pmty_loc =
        (copy_location pmty_loc);
      To.Parsetree.pmty_attributes =
        (copy_attributes pmty_attributes)
    }

and copy_module_type_desc :
  From.Parsetree.module_type_desc ->
    To.Parsetree.module_type_desc
  =
  function
  | From.Parsetree.Pmty_ident x0 ->
      To.Parsetree.Pmty_ident
        (copy_loc copy_longident
           x0)
  | From.Parsetree.Pmty_signature x0 ->
      To.Parsetree.Pmty_signature
        (copy_signature x0)
  | From.Parsetree.Pmty_functor (x0,x1,x2) ->
      To.Parsetree.Pmty_functor
        ((copy_loc (fun x  -> x) x0),
          (copy_option copy_module_type x1),
          (copy_module_type x2))
  | From.Parsetree.Pmty_with (x0,x1) ->
      To.Parsetree.Pmty_with
        ((copy_module_type x0),
          (List.map copy_with_constraint x1))
  | From.Parsetree.Pmty_typeof x0 ->
      To.Parsetree.Pmty_typeof
        (copy_module_expr x0)
  | From.Parsetree.Pmty_extension x0 ->
      To.Parsetree.Pmty_extension
        (copy_extension x0)
  | From.Parsetree.Pmty_alias x0 ->
      To.Parsetree.Pmty_alias
        (copy_loc copy_longident
           x0)

and copy_with_constraint :
  From.Parsetree.with_constraint ->
    To.Parsetree.with_constraint
  =
  function
  | From.Parsetree.Pwith_type (x0,x1) ->
      To.Parsetree.Pwith_type
        ((copy_loc
            copy_longident x0),
          (copy_type_declaration x1))
  | From.Parsetree.Pwith_module (x0,x1) ->
      To.Parsetree.Pwith_module
        ((copy_loc
            copy_longident x0),
          (copy_loc
             copy_longident x1))
  | From.Parsetree.Pwith_typesubst x0 ->
      To.Parsetree.Pwith_typesubst
        (copy_type_declaration x0)
  | From.Parsetree.Pwith_modsubst (x0,x1) ->
      To.Parsetree.Pwith_modsubst
        ((copy_loc (fun x  -> x) x0),
          (copy_loc
             copy_longident x1))

and copy_signature :
  From.Parsetree.signature ->
    To.Parsetree.signature
  = fun x  -> List.map copy_signature_item x

and copy_signature_item :
  From.Parsetree.signature_item ->
    To.Parsetree.signature_item
  =
  fun
    { From.Parsetree.psig_desc = psig_desc;
      From.Parsetree.psig_loc = psig_loc }
     ->
    {
      To.Parsetree.psig_desc =
        (copy_signature_item_desc psig_desc);
      To.Parsetree.psig_loc =
        (copy_location psig_loc)
    }

and copy_signature_item_desc :
  From.Parsetree.signature_item_desc ->
    To.Parsetree.signature_item_desc
  =
  function
  | From.Parsetree.Psig_value x0 ->
      To.Parsetree.Psig_value
        (copy_value_description x0)
  | From.Parsetree.Psig_type x0 ->
      let recflag, types = type_declarations x0 in
      To.Parsetree.Psig_type (recflag, types)
  | From.Parsetree.Psig_typext x0 ->
      To.Parsetree.Psig_typext
        (copy_type_extension x0)
  | From.Parsetree.Psig_exception x0 ->
      To.Parsetree.Psig_exception
        (copy_extension_constructor x0)
  | From.Parsetree.Psig_module x0 ->
      To.Parsetree.Psig_module
        (copy_module_declaration x0)
  | From.Parsetree.Psig_recmodule x0 ->
      To.Parsetree.Psig_recmodule
        (List.map copy_module_declaration x0)
  | From.Parsetree.Psig_modtype x0 ->
      To.Parsetree.Psig_modtype
        (copy_module_type_declaration x0)
  | From.Parsetree.Psig_open x0 ->
      To.Parsetree.Psig_open
        (copy_open_description x0)
  | From.Parsetree.Psig_include x0 ->
      To.Parsetree.Psig_include
        (copy_include_description x0)
  | From.Parsetree.Psig_class x0 ->
      To.Parsetree.Psig_class
        (List.map copy_class_description x0)
  | From.Parsetree.Psig_class_type x0 ->
      To.Parsetree.Psig_class_type
        (List.map copy_class_type_declaration x0)
  | From.Parsetree.Psig_attribute x0 ->
      To.Parsetree.Psig_attribute
        (copy_attribute x0)
  | From.Parsetree.Psig_extension (x0,x1) ->
      To.Parsetree.Psig_extension
        ((copy_extension x0),
          (copy_attributes x1))

and copy_class_type_declaration :
  From.Parsetree.class_type_declaration ->
    To.Parsetree.class_type_declaration
  =
  fun x  ->
    copy_class_infos
      copy_class_type x

and copy_class_description :
  From.Parsetree.class_description ->
    To.Parsetree.class_description
  =
  fun x  ->
    copy_class_infos
      copy_class_type x

and copy_class_type :
  From.Parsetree.class_type ->
    To.Parsetree.class_type
  =
  fun
    { From.Parsetree.pcty_desc = pcty_desc;
      From.Parsetree.pcty_loc = pcty_loc;
      From.Parsetree.pcty_attributes = pcty_attributes }
     ->
    {
      To.Parsetree.pcty_desc =
        (copy_class_type_desc pcty_desc);
      To.Parsetree.pcty_loc =
        (copy_location pcty_loc);
      To.Parsetree.pcty_attributes =
        (copy_attributes pcty_attributes)
    }

and copy_class_type_desc :
  From.Parsetree.class_type_desc ->
    To.Parsetree.class_type_desc
  =
  function
  | From.Parsetree.Pcty_constr (x0,x1) ->
      To.Parsetree.Pcty_constr
        ((copy_loc
            copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Pcty_signature x0 ->
      To.Parsetree.Pcty_signature
        (copy_class_signature x0)
  | From.Parsetree.Pcty_arrow (x0,x1,x2) ->
      let label = copy_arg_label x0 in
      To.Parsetree.Pcty_arrow
        (label,
         copy_core_type (extract_predef_option label x1),
         copy_class_type x2)
  | From.Parsetree.Pcty_extension x0 ->
      To.Parsetree.Pcty_extension
        (copy_extension x0)

and copy_class_signature :
  From.Parsetree.class_signature ->
    To.Parsetree.class_signature
  =
  fun
    { From.Parsetree.pcsig_self = pcsig_self;
      From.Parsetree.pcsig_fields = pcsig_fields }
     ->
    {
      To.Parsetree.pcsig_self =
        (copy_core_type pcsig_self);
      To.Parsetree.pcsig_fields =
        (List.map copy_class_type_field
           pcsig_fields)
    }

and copy_class_type_field :
  From.Parsetree.class_type_field ->
    To.Parsetree.class_type_field
  =
  fun
    { From.Parsetree.pctf_desc = pctf_desc;
      From.Parsetree.pctf_loc = pctf_loc;
      From.Parsetree.pctf_attributes = pctf_attributes }
     ->
    {
      To.Parsetree.pctf_desc =
        (copy_class_type_field_desc pctf_desc);
      To.Parsetree.pctf_loc =
        (copy_location pctf_loc);
      To.Parsetree.pctf_attributes =
        (copy_attributes pctf_attributes)
    }

and copy_class_type_field_desc :
  From.Parsetree.class_type_field_desc ->
    To.Parsetree.class_type_field_desc
  =
  function
  | From.Parsetree.Pctf_inherit x0 ->
      To.Parsetree.Pctf_inherit
        (copy_class_type x0)
  | From.Parsetree.Pctf_val x0 ->
      To.Parsetree.Pctf_val
        (let (x0,x1,x2,x3) = x0  in
         (x0, (copy_mutable_flag x1),
           (copy_virtual_flag x2),
           (copy_core_type x3)))
  | From.Parsetree.Pctf_method x0 ->
      To.Parsetree.Pctf_method
        (let (x0,x1,x2,x3) = x0  in
         (x0, (copy_private_flag x1),
           (copy_virtual_flag x2),
           (copy_core_type x3)))
  | From.Parsetree.Pctf_constraint x0 ->
      To.Parsetree.Pctf_constraint
        (let (x0,x1) = x0  in
         ((copy_core_type x0),
           (copy_core_type x1)))
  | From.Parsetree.Pctf_attribute x0 ->
      To.Parsetree.Pctf_attribute
        (copy_attribute x0)
  | From.Parsetree.Pctf_extension x0 ->
      To.Parsetree.Pctf_extension
        (copy_extension x0)

and copy_extension :
  From.Parsetree.extension ->
    To.Parsetree.extension
  =
  fun x  ->
    let (x0,x1) = x  in
    ((copy_loc (fun x  -> x) x0),
      (copy_payload x1))

and copy_class_infos :
  'f0 'g0 .
    ('f0 -> 'g0) ->
      'f0 From.Parsetree.class_infos ->
        'g0 To.Parsetree.class_infos
  =
  fun f0  ->
    fun
      { From.Parsetree.pci_virt = pci_virt;
        From.Parsetree.pci_params = pci_params;
        From.Parsetree.pci_name = pci_name;
        From.Parsetree.pci_expr = pci_expr;
        From.Parsetree.pci_loc = pci_loc;
        From.Parsetree.pci_attributes = pci_attributes }
       ->
      {
        To.Parsetree.pci_virt =
          (copy_virtual_flag pci_virt);
        To.Parsetree.pci_params =
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                ((copy_core_type x0),
                  (copy_variance x1))) pci_params);
        To.Parsetree.pci_name =
          (copy_loc (fun x  -> x) pci_name);
        To.Parsetree.pci_expr = (f0 pci_expr);
        To.Parsetree.pci_loc =
          (copy_location pci_loc);
        To.Parsetree.pci_attributes =
          (copy_attributes pci_attributes)
      }

and copy_virtual_flag :
  From.Asttypes.virtual_flag ->
    To.Asttypes.virtual_flag
  =
  function
  | From.Asttypes.Virtual  -> To.Asttypes.Virtual
  | From.Asttypes.Concrete  -> To.Asttypes.Concrete

and copy_include_description :
  From.Parsetree.include_description ->
    To.Parsetree.include_description
  =
  fun x  ->
    copy_include_infos
      copy_module_type x

and copy_include_infos :
  'f0 'g0 .
    ('f0 -> 'g0) ->
      'f0 From.Parsetree.include_infos ->
        'g0 To.Parsetree.include_infos
  =
  fun f0  ->
    fun
      { From.Parsetree.pincl_mod = pincl_mod;
        From.Parsetree.pincl_loc = pincl_loc;
        From.Parsetree.pincl_attributes = pincl_attributes }
       ->
      {
        To.Parsetree.pincl_mod = (f0 pincl_mod);
        To.Parsetree.pincl_loc =
          (copy_location pincl_loc);
        To.Parsetree.pincl_attributes =
          (copy_attributes pincl_attributes)
      }

and copy_open_description :
  From.Parsetree.open_description ->
    To.Parsetree.open_description
  =
  fun
    { From.Parsetree.popen_lid = popen_lid;
      From.Parsetree.popen_override = popen_override;
      From.Parsetree.popen_loc = popen_loc;
      From.Parsetree.popen_attributes = popen_attributes }
     ->
    {
      To.Parsetree.popen_lid =
        (copy_loc copy_longident
           popen_lid);
      To.Parsetree.popen_override =
        (copy_override_flag popen_override);
      To.Parsetree.popen_loc =
        (copy_location popen_loc);
      To.Parsetree.popen_attributes =
        (copy_attributes popen_attributes)
    }

and copy_override_flag :
  From.Asttypes.override_flag ->
    To.Asttypes.override_flag
  =
  function
  | From.Asttypes.Override  -> To.Asttypes.Override
  | From.Asttypes.Fresh  -> To.Asttypes.Fresh

and copy_module_type_declaration :
  From.Parsetree.module_type_declaration ->
    To.Parsetree.module_type_declaration
  =
  fun
    { From.Parsetree.pmtd_name = pmtd_name;
      From.Parsetree.pmtd_type = pmtd_type;
      From.Parsetree.pmtd_attributes = pmtd_attributes;
      From.Parsetree.pmtd_loc = pmtd_loc }
     ->
    {
      To.Parsetree.pmtd_name =
        (copy_loc (fun x  -> x) pmtd_name);
      To.Parsetree.pmtd_type =
        (copy_option copy_module_type pmtd_type);
      To.Parsetree.pmtd_attributes =
        (copy_attributes pmtd_attributes);
      To.Parsetree.pmtd_loc =
        (copy_location pmtd_loc)
    }

and copy_module_declaration :
  From.Parsetree.module_declaration ->
    To.Parsetree.module_declaration
  =
  fun
    { From.Parsetree.pmd_name = pmd_name;
      From.Parsetree.pmd_type = pmd_type;
      From.Parsetree.pmd_attributes = pmd_attributes;
      From.Parsetree.pmd_loc = pmd_loc }
     ->
    {
      To.Parsetree.pmd_name =
        (copy_loc (fun x  -> x) pmd_name);
      To.Parsetree.pmd_type =
        (copy_module_type pmd_type);
      To.Parsetree.pmd_attributes =
        (copy_attributes pmd_attributes);
      To.Parsetree.pmd_loc =
        (copy_location pmd_loc)
    }

and copy_type_extension :
  From.Parsetree.type_extension ->
    To.Parsetree.type_extension
  =
  fun
    { From.Parsetree.ptyext_path = ptyext_path;
      From.Parsetree.ptyext_params = ptyext_params;
      From.Parsetree.ptyext_constructors = ptyext_constructors;
      From.Parsetree.ptyext_private = ptyext_private;
      From.Parsetree.ptyext_attributes = ptyext_attributes }
     ->
    {
      To.Parsetree.ptyext_path =
        (copy_loc copy_longident
           ptyext_path);
      To.Parsetree.ptyext_params =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_core_type x0),
                (copy_variance x1))) ptyext_params);
      To.Parsetree.ptyext_constructors =
        (List.map copy_extension_constructor
           ptyext_constructors);
      To.Parsetree.ptyext_private =
        (copy_private_flag ptyext_private);
      To.Parsetree.ptyext_attributes =
        (copy_attributes ptyext_attributes)
    }

and copy_extension_constructor :
  From.Parsetree.extension_constructor ->
    To.Parsetree.extension_constructor
  =
  fun
    { From.Parsetree.pext_name = pext_name;
      From.Parsetree.pext_kind = pext_kind;
      From.Parsetree.pext_loc = pext_loc;
      From.Parsetree.pext_attributes = pext_attributes }
     ->
    {
      To.Parsetree.pext_name =
        (copy_loc (fun x  -> x) pext_name);
      To.Parsetree.pext_kind =
        (copy_extension_constructor_kind pext_kind);
      To.Parsetree.pext_loc =
        (copy_location pext_loc);
      To.Parsetree.pext_attributes =
        (copy_attributes pext_attributes)
    }

and copy_extension_constructor_kind :
  From.Parsetree.extension_constructor_kind ->
    To.Parsetree.extension_constructor_kind
  =
  function
  | From.Parsetree.Pext_decl (x0,x1) ->
      To.Parsetree.Pext_decl
        (To.Parsetree.Pcstr_tuple (List.map copy_core_type x0),
          (copy_option copy_core_type x1))
  | From.Parsetree.Pext_rebind x0 ->
      To.Parsetree.Pext_rebind
        (copy_loc copy_longident
           x0)

and copy_type_declaration :
  From.Parsetree.type_declaration ->
    To.Parsetree.type_declaration
  =
  fun
    { From.Parsetree.ptype_name = ptype_name;
      From.Parsetree.ptype_params = ptype_params;
      From.Parsetree.ptype_cstrs = ptype_cstrs;
      From.Parsetree.ptype_kind = ptype_kind;
      From.Parsetree.ptype_private = ptype_private;
      From.Parsetree.ptype_manifest = ptype_manifest;
      From.Parsetree.ptype_attributes = ptype_attributes;
      From.Parsetree.ptype_loc = ptype_loc }
     ->
    {
      To.Parsetree.ptype_name =
        (copy_loc (fun x  -> x) ptype_name);
      To.Parsetree.ptype_params =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_core_type x0),
                (copy_variance x1))) ptype_params);
      To.Parsetree.ptype_cstrs =
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              ((copy_core_type x0),
                (copy_core_type x1),
                (copy_location x2))) ptype_cstrs);
      To.Parsetree.ptype_kind =
        (copy_type_kind ptype_kind);
      To.Parsetree.ptype_private =
        (copy_private_flag ptype_private);
      To.Parsetree.ptype_manifest =
        (copy_option copy_core_type ptype_manifest);
      To.Parsetree.ptype_attributes =
        (copy_attributes ptype_attributes);
      To.Parsetree.ptype_loc =
        (copy_location ptype_loc)
    }

and copy_private_flag :
  From.Asttypes.private_flag ->
    To.Asttypes.private_flag
  =
  function
  | From.Asttypes.Private  -> To.Asttypes.Private
  | From.Asttypes.Public  -> To.Asttypes.Public

and copy_type_kind :
  From.Parsetree.type_kind ->
    To.Parsetree.type_kind
  =
  function
  | From.Parsetree.Ptype_abstract  ->
      To.Parsetree.Ptype_abstract
  | From.Parsetree.Ptype_variant x0 ->
      To.Parsetree.Ptype_variant
        (List.map copy_constructor_declaration x0)
  | From.Parsetree.Ptype_record x0 ->
      To.Parsetree.Ptype_record
        (List.map copy_label_declaration x0)
  | From.Parsetree.Ptype_open  ->
      To.Parsetree.Ptype_open

and copy_label_declaration :
  From.Parsetree.label_declaration ->
    To.Parsetree.label_declaration
  =
  fun
    { From.Parsetree.pld_name = pld_name;
      From.Parsetree.pld_mutable = pld_mutable;
      From.Parsetree.pld_type = pld_type;
      From.Parsetree.pld_loc = pld_loc;
      From.Parsetree.pld_attributes = pld_attributes }
     ->
    {
      To.Parsetree.pld_name =
        (copy_loc (fun x  -> x) pld_name);
      To.Parsetree.pld_mutable =
        (copy_mutable_flag pld_mutable);
      To.Parsetree.pld_type =
        (copy_core_type pld_type);
      To.Parsetree.pld_loc =
        (copy_location pld_loc);
      To.Parsetree.pld_attributes =
        (copy_attributes pld_attributes)
    }

and copy_mutable_flag :
  From.Asttypes.mutable_flag ->
    To.Asttypes.mutable_flag
  =
  function
  | From.Asttypes.Immutable  ->
      To.Asttypes.Immutable
  | From.Asttypes.Mutable  -> To.Asttypes.Mutable

and copy_constructor_declaration :
  From.Parsetree.constructor_declaration ->
    To.Parsetree.constructor_declaration
  =
  fun
    { From.Parsetree.pcd_name = pcd_name;
      From.Parsetree.pcd_args = pcd_args;
      From.Parsetree.pcd_res = pcd_res;
      From.Parsetree.pcd_loc = pcd_loc;
      From.Parsetree.pcd_attributes = pcd_attributes }
     ->
    {
      To.Parsetree.pcd_name =
        (copy_loc (fun x  -> x) pcd_name);
      To.Parsetree.pcd_args =
        To.Parsetree.Pcstr_tuple (List.map copy_core_type pcd_args);
      To.Parsetree.pcd_res =
        (copy_option copy_core_type pcd_res);
      To.Parsetree.pcd_loc =
        (copy_location pcd_loc);
      To.Parsetree.pcd_attributes =
        (copy_attributes pcd_attributes)
    }

and copy_variance :
  From.Asttypes.variance -> To.Asttypes.variance =
  function
  | From.Asttypes.Covariant  ->
      To.Asttypes.Covariant
  | From.Asttypes.Contravariant  ->
      To.Asttypes.Contravariant
  | From.Asttypes.Invariant  ->
      To.Asttypes.Invariant

and copy_value_description :
  From.Parsetree.value_description ->
    To.Parsetree.value_description
  =
  fun
    { From.Parsetree.pval_name = pval_name;
      From.Parsetree.pval_type = pval_type;
      From.Parsetree.pval_prim = pval_prim;
      From.Parsetree.pval_attributes = pval_attributes;
      From.Parsetree.pval_loc = pval_loc }
     ->
    {
      To.Parsetree.pval_name =
        (copy_loc (fun x  -> x) pval_name);
      To.Parsetree.pval_type =
        (copy_core_type pval_type);
      To.Parsetree.pval_prim =
        (List.map (fun x  -> x) pval_prim);
      To.Parsetree.pval_attributes =
        (copy_attributes pval_attributes);
      To.Parsetree.pval_loc =
        (copy_location pval_loc)
    }

and copy_closed_flag :
  From.Asttypes.closed_flag ->
    To.Asttypes.closed_flag
  =
  function
  | From.Asttypes.Closed  -> To.Asttypes.Closed
  | From.Asttypes.Open  -> To.Asttypes.Open

and copy_label :
  From.Asttypes.label -> To.Asttypes.label =
  fun x ->
    x

and copy_arg_label :
  From.Asttypes.label -> To.Asttypes.arg_label =
  fun x ->
    if x <> "" then
      if x.[0] = '?' then To.Asttypes.Optional (String.sub x 1 (String.length x - 1))
      else To.Asttypes.Labelled x
    else
      To.Asttypes.Nolabel



and copy_rec_flag :
  From.Asttypes.rec_flag -> To.Asttypes.rec_flag =
  function
  | From.Asttypes.Nonrecursive  ->
      To.Asttypes.Nonrecursive
  | From.Asttypes.Recursive  ->
      To.Asttypes.Recursive

and copy_constant :
  From.Asttypes.constant -> To.Parsetree.constant =
  function
  | From.Asttypes.Const_int x0 ->
      To.Parsetree.Pconst_integer (string_of_int x0, None)
  | From.Asttypes.Const_char x0 ->
      To.Parsetree.Pconst_char x0
  | From.Asttypes.Const_string (x0,x1) ->
      To.Parsetree.Pconst_string
        (x0, (copy_option (fun x  -> x) x1))
  | From.Asttypes.Const_float x0 ->
      To.Parsetree.Pconst_float (x0, None)
  | From.Asttypes.Const_int32 x0 ->
      To.Parsetree.Pconst_integer (Int32.to_string x0, Some 'l')
  | From.Asttypes.Const_int64 x0 ->
      To.Parsetree.Pconst_integer (Int64.to_string x0, Some 'L')
  | From.Asttypes.Const_nativeint x0 ->
      To.Parsetree.Pconst_integer (Nativeint.to_string x0, Some 'n')

and copy_option : 'f0 'g0 . ('f0 -> 'g0) -> 'f0 option -> 'g0 option =
  fun f0  -> function | None  -> None | Some x0 -> Some (f0 x0)

and copy_longident :
  From.Longident.t -> To.Longident.t =
  function
  | From.Longident.Lident x0 ->
      To.Longident.Lident x0
  | From.Longident.Ldot (x0,x1) ->
      To.Longident.Ldot ((copy_longident x0), x1)
  | From.Longident.Lapply (x0,x1) ->
      To.Longident.Lapply ((copy_longident x0), (copy_longident x1))

and copy_loc :
  'f0 'g0 .
    ('f0 -> 'g0) ->
      'f0 From.Asttypes.loc -> 'g0 To.Asttypes.loc
  =
  fun f0  ->
    fun
      { From.Asttypes.txt = txt;
        From.Asttypes.loc = loc }
       ->
      {
        To.Asttypes.txt = (f0 txt);
        To.Asttypes.loc = (copy_location loc)
      }

and copy_location :
  From.Location.t -> To.Location.t =
  fun
    { From.Location.loc_start = loc_start;
      From.Location.loc_end = loc_end;
      From.Location.loc_ghost = loc_ghost }
     ->
    {
      To.Location.loc_start = (copy_Lexing_position loc_start);
      To.Location.loc_end = (copy_Lexing_position loc_end);
      To.Location.loc_ghost = (copy_bool loc_ghost)
    }

and copy_bool : bool -> bool = function | false  -> false | true  -> true

and copy_Lexing_position : Lexing.position -> Lexing.position =
  fun
    { Lexing.pos_fname = pos_fname; Lexing.pos_lnum = pos_lnum;
      Lexing.pos_bol = pos_bol; Lexing.pos_cnum = pos_cnum }
     ->
    {
      Lexing.pos_fname = pos_fname;
      Lexing.pos_lnum = pos_lnum;
      Lexing.pos_bol = pos_bol;
      Lexing.pos_cnum = pos_cnum
    }

and type_declarations types =
  let is_nonrec (attr,_) = attr.To.Location.txt = "nonrec" in
  match List.map copy_type_declaration types with
  | (x :: xs)
    when List.exists is_nonrec x.To.Parsetree.ptype_attributes ->
      let ptype_attributes =
        List.filter (fun x -> not (is_nonrec x)) x.To.Parsetree.ptype_attributes
      in
      (To.Asttypes.Nonrecursive,
       {x with To.Parsetree.ptype_attributes} :: xs)
  | types -> (To.Asttypes.Recursive, types)

let rec copy_out_phrase :
  From.Outcometree.out_phrase -> To.Outcometree.out_phrase =
  function
  | From.Outcometree.Ophr_eval (x0,x1) ->
      To.Outcometree.Ophr_eval
        ((copy_out_value x0),
          (copy_out_type x1))
  | From.Outcometree.Ophr_signature x0 ->
      To.Outcometree.Ophr_signature
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_out_sig_item x0),
                (copy_option copy_out_value x1))) x0)
  | From.Outcometree.Ophr_exception x0 ->
      To.Outcometree.Ophr_exception
        (let (x0,x1) = x0  in
         ((copy_exn x0), (copy_out_value x1)))

and copy_exn : exn -> exn = fun x  -> x

and copy_out_sig_item :
  From.Outcometree.out_sig_item -> To.Outcometree.out_sig_item =
  function
  | From.Outcometree.Osig_class (x0,x1,x2,x3,x4) ->
      To.Outcometree.Osig_class
        ((copy_bool x0), x1,
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))
             x2), (copy_out_class_type x3),
          (copy_out_rec_status x4))
  | From.Outcometree.Osig_class_type (x0,x1,x2,x3,x4) ->
      To.Outcometree.Osig_class_type
        ((copy_bool x0), x1,
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))
             x2), (copy_out_class_type x3),
          (copy_out_rec_status x4))
  | From.Outcometree.Osig_typext (x0,x1) ->
      To.Outcometree.Osig_typext
        ((copy_out_extension_constructor x0),
          (copy_out_ext_status x1))
  | From.Outcometree.Osig_modtype (x0,x1) ->
      To.Outcometree.Osig_modtype
        (x0, (copy_out_module_type x1))
  | From.Outcometree.Osig_module (x0,x1,x2) ->
      To.Outcometree.Osig_module
        (x0, (copy_out_module_type x1),
          (copy_out_rec_status x2))
  | From.Outcometree.Osig_type (x0,x1) ->
      To.Outcometree.Osig_type
        ((copy_out_type_decl x0),
          (copy_out_rec_status x1))
  | From.Outcometree.Osig_value (x0,x1,x2) ->
      To.Outcometree.Osig_value { To.Outcometree.
                                  oval_name = x0;
                                  oval_type = copy_out_type x1;
                                  oval_prims = List.map (fun x -> x) x2;
                                  oval_attributes = [] }

and copy_out_type_decl :
  From.Outcometree.out_type_decl -> To.Outcometree.out_type_decl =
  fun
    { From.Outcometree.otype_name = otype_name;
      From.Outcometree.otype_params = otype_params;
      From.Outcometree.otype_type = otype_type;
      From.Outcometree.otype_private = otype_private;
      From.Outcometree.otype_cstrs = otype_cstrs }
     ->
    {
      To.Outcometree.otype_name = otype_name;
      To.Outcometree.otype_params =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))
           otype_params);
      To.Outcometree.otype_type =
        (copy_out_type otype_type);
      To.Outcometree.otype_private =
        (copy_private_flag otype_private);
      To.Outcometree.otype_cstrs =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_out_type x0),
               (copy_out_type x1))) otype_cstrs);
      To.Outcometree.otype_immediate = false;
    }

and copy_out_module_type :
  From.Outcometree.out_module_type -> To.Outcometree.out_module_type
  =
  function
  | From.Outcometree.Omty_abstract  -> To.Outcometree.Omty_abstract
  | From.Outcometree.Omty_functor (x0,x1,x2) ->
      To.Outcometree.Omty_functor
        (x0, (copy_option copy_out_module_type x1),
          (copy_out_module_type x2))
  | From.Outcometree.Omty_ident x0 ->
      To.Outcometree.Omty_ident (copy_out_ident x0)
  | From.Outcometree.Omty_signature x0 ->
      To.Outcometree.Omty_signature
        (List.map copy_out_sig_item x0)
  | From.Outcometree.Omty_alias x0 ->
      To.Outcometree.Omty_alias (copy_out_ident x0)

and copy_out_ext_status :
  From.Outcometree.out_ext_status -> To.Outcometree.out_ext_status =
  function
  | From.Outcometree.Oext_first  -> To.Outcometree.Oext_first
  | From.Outcometree.Oext_next  -> To.Outcometree.Oext_next
  | From.Outcometree.Oext_exception  -> To.Outcometree.Oext_exception

and copy_out_extension_constructor :
  From.Outcometree.out_extension_constructor ->
    To.Outcometree.out_extension_constructor
  =
  fun
    { From.Outcometree.oext_name = oext_name;
      From.Outcometree.oext_type_name = oext_type_name;
      From.Outcometree.oext_type_params = oext_type_params;
      From.Outcometree.oext_args = oext_args;
      From.Outcometree.oext_ret_type = oext_ret_type;
      From.Outcometree.oext_private = oext_private }
     ->
    {
      To.Outcometree.oext_name = oext_name;
      To.Outcometree.oext_type_name = oext_type_name;
      To.Outcometree.oext_type_params =
        (List.map (fun x  -> x) oext_type_params);
      To.Outcometree.oext_args =
        (List.map copy_out_type oext_args);
      To.Outcometree.oext_ret_type =
        (copy_option copy_out_type oext_ret_type);
      To.Outcometree.oext_private =
        (copy_private_flag oext_private)
    }

and copy_out_rec_status :
  From.Outcometree.out_rec_status -> To.Outcometree.out_rec_status =
  function
  | From.Outcometree.Orec_not  -> To.Outcometree.Orec_not
  | From.Outcometree.Orec_first  -> To.Outcometree.Orec_first
  | From.Outcometree.Orec_next  -> To.Outcometree.Orec_next

and copy_out_class_type :
  From.Outcometree.out_class_type -> To.Outcometree.out_class_type =
  function
  | From.Outcometree.Octy_constr (x0,x1) ->
      To.Outcometree.Octy_constr
        ((copy_out_ident x0),
          (List.map copy_out_type x1))
  | From.Outcometree.Octy_arrow (x0,x1,x2) ->
      To.Outcometree.Octy_arrow
        (x0, (copy_out_type x1),
          (copy_out_class_type x2))
  | From.Outcometree.Octy_signature (x0,x1) ->
      To.Outcometree.Octy_signature
        ((copy_option copy_out_type x0),
          (List.map copy_out_class_sig_item x1))

and copy_out_class_sig_item :
  From.Outcometree.out_class_sig_item ->
    To.Outcometree.out_class_sig_item
  =
  function
  | From.Outcometree.Ocsg_constraint (x0,x1) ->
      To.Outcometree.Ocsg_constraint
        ((copy_out_type x0),
          (copy_out_type x1))
  | From.Outcometree.Ocsg_method (x0,x1,x2,x3) ->
      To.Outcometree.Ocsg_method
        (x0, (copy_bool x1), (copy_bool x2),
          (copy_out_type x3))
  | From.Outcometree.Ocsg_value (x0,x1,x2,x3) ->
      To.Outcometree.Ocsg_value
        (x0, (copy_bool x1), (copy_bool x2),
          (copy_out_type x3))

and copy_out_type :
  From.Outcometree.out_type -> To.Outcometree.out_type =
  function
  | From.Outcometree.Otyp_abstract  -> To.Outcometree.Otyp_abstract
  | From.Outcometree.Otyp_open  -> To.Outcometree.Otyp_open
  | From.Outcometree.Otyp_alias (x0,x1) ->
      To.Outcometree.Otyp_alias
        ((copy_out_type x0), x1)
  | From.Outcometree.Otyp_arrow (x0,x1,x2) ->
      To.Outcometree.Otyp_arrow
        (x0, (copy_out_type x1),
          (copy_out_type x2))
  | From.Outcometree.Otyp_class (x0,x1,x2) ->
      To.Outcometree.Otyp_class
        ((copy_bool x0), (copy_out_ident x1),
          (List.map copy_out_type x2))
  | From.Outcometree.Otyp_constr (x0,x1) ->
      To.Outcometree.Otyp_constr
        ((copy_out_ident x0),
          (List.map copy_out_type x1))
  | From.Outcometree.Otyp_manifest (x0,x1) ->
      To.Outcometree.Otyp_manifest
        ((copy_out_type x0),
          (copy_out_type x1))
  | From.Outcometree.Otyp_object (x0,x1) ->
      To.Outcometree.Otyp_object
        ((List.map
            (fun x  ->
               let (x0,x1) = x  in
               (x0, (copy_out_type x1))) x0),
          (copy_option copy_bool x1))
  | From.Outcometree.Otyp_record x0 ->
      To.Outcometree.Otyp_record
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (copy_bool x1), (copy_out_type x2)))
           x0)
  | From.Outcometree.Otyp_stuff x0 -> To.Outcometree.Otyp_stuff x0
  | From.Outcometree.Otyp_sum x0 ->
      To.Outcometree.Otyp_sum
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (List.map copy_out_type x1),
                (copy_option copy_out_type x2))) x0)
  | From.Outcometree.Otyp_tuple x0 ->
      To.Outcometree.Otyp_tuple
        (List.map copy_out_type x0)
  | From.Outcometree.Otyp_var (x0,x1) ->
      To.Outcometree.Otyp_var ((copy_bool x0), x1)
  | From.Outcometree.Otyp_variant (x0,x1,x2,x3) ->
      To.Outcometree.Otyp_variant
        ((copy_bool x0), (copy_out_variant x1),
          (copy_bool x2),
          (copy_option (fun x  -> List.map (fun x  -> x) x) x3))
  | From.Outcometree.Otyp_poly (x0,x1) ->
      To.Outcometree.Otyp_poly
        ((List.map (fun x  -> x) x0), (copy_out_type x1))
  | From.Outcometree.Otyp_module (x0,x1,x2) ->
      To.Outcometree.Otyp_module
        (x0, (List.map (fun x  -> x) x1),
          (List.map copy_out_type x2))

and copy_out_variant :
  From.Outcometree.out_variant -> To.Outcometree.out_variant =
  function
  | From.Outcometree.Ovar_fields x0 ->
      To.Outcometree.Ovar_fields
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (copy_bool x1),
                (List.map copy_out_type x2))) x0)
  | From.Outcometree.Ovar_name (x0,x1) ->
      To.Outcometree.Ovar_name
        ((copy_out_ident x0),
          (List.map copy_out_type x1))

and copy_out_value :
  From.Outcometree.out_value -> To.Outcometree.out_value =
  function
  | From.Outcometree.Oval_array x0 ->
      To.Outcometree.Oval_array
        (List.map copy_out_value x0)
  | From.Outcometree.Oval_char x0 -> To.Outcometree.Oval_char x0
  | From.Outcometree.Oval_constr (x0,x1) ->
      To.Outcometree.Oval_constr
        ((copy_out_ident x0),
          (List.map copy_out_value x1))
  | From.Outcometree.Oval_ellipsis  -> To.Outcometree.Oval_ellipsis
  | From.Outcometree.Oval_float x0 ->
      To.Outcometree.Oval_float (copy_float x0)
  | From.Outcometree.Oval_int x0 -> To.Outcometree.Oval_int x0
  | From.Outcometree.Oval_int32 x0 -> To.Outcometree.Oval_int32 x0
  | From.Outcometree.Oval_int64 x0 -> To.Outcometree.Oval_int64 x0
  | From.Outcometree.Oval_nativeint x0 ->
      To.Outcometree.Oval_nativeint x0
  | From.Outcometree.Oval_list x0 ->
      To.Outcometree.Oval_list
        (List.map copy_out_value x0)
  | From.Outcometree.Oval_printer x0 ->
      To.Outcometree.Oval_printer x0
  | From.Outcometree.Oval_record x0 ->
      To.Outcometree.Oval_record
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_out_ident x0),
                (copy_out_value x1))) x0)
  | From.Outcometree.Oval_string x0 -> To.Outcometree.Oval_string x0
  | From.Outcometree.Oval_stuff x0 -> To.Outcometree.Oval_stuff x0
  | From.Outcometree.Oval_tuple x0 ->
      To.Outcometree.Oval_tuple
        (List.map copy_out_value x0)
  | From.Outcometree.Oval_variant (x0,x1) ->
      To.Outcometree.Oval_variant
        (x0, (copy_option copy_out_value x1))

and copy_float : float -> float = fun x  -> x

and copy_out_ident :
  From.Outcometree.out_ident -> To.Outcometree.out_ident =
  function
  | From.Outcometree.Oide_apply (x0,x1) ->
      To.Outcometree.Oide_apply
        ((copy_out_ident x0),
          (copy_out_ident x1))
  | From.Outcometree.Oide_dot (x0,x1) ->
      To.Outcometree.Oide_dot
        ((copy_out_ident x0), x1)
  | From.Outcometree.Oide_ident x0 -> To.Outcometree.Oide_ident x0

let rec copy_toplevel_phrase :
  From.Parsetree.toplevel_phrase -> To.Parsetree.toplevel_phrase =
  function
  | From.Parsetree.Ptop_def x0 ->
      To.Parsetree.Ptop_def (copy_structure x0)
  | From.Parsetree.Ptop_dir (x0,x1) ->
      To.Parsetree.Ptop_dir
        (x0, (copy_directive_argument x1))

and copy_directive_argument :
  From.Parsetree.directive_argument -> To.Parsetree.directive_argument =
  function
  | From.Parsetree.Pdir_none  -> To.Parsetree.Pdir_none
  | From.Parsetree.Pdir_string x0 -> To.Parsetree.Pdir_string x0
  | From.Parsetree.Pdir_int x0 -> To.Parsetree.Pdir_int (string_of_int x0, None)
  | From.Parsetree.Pdir_ident x0 -> To.Parsetree.Pdir_ident (copy_longident x0)
  | From.Parsetree.Pdir_bool x0 -> To.Parsetree.Pdir_bool (copy_bool x0)

let copy_out_type_extension :
  From.Outcometree.out_type_extension -> To.Outcometree.out_type_extension =
  fun
    { From.Outcometree.otyext_name = otyext_name;
      From.Outcometree.otyext_params = otyext_params;
      From.Outcometree.otyext_constructors = otyext_constructors;
      From.Outcometree.otyext_private = otyext_private }
     ->
    {
      To.Outcometree.otyext_name = otyext_name;
      To.Outcometree.otyext_params =
        (List.map (fun x  -> x) otyext_params);
      To.Outcometree.otyext_constructors =
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (List.map copy_out_type x1),
                (copy_option copy_out_type x2)))
           otyext_constructors);
      To.Outcometree.otyext_private =
        (copy_private_flag otyext_private)
    }

let copy_cases x = List.map copy_case x
let copy_pat = copy_pattern
let copy_expr = copy_expression
let copy_typ = copy_core_type

end
module Migrate_parsetree_def : sig 
#1 "migrate_parsetree_def.mli"
# 1 "src/migrate_parsetree_def.mli"
# 1 "src/migrate_parsetree_def.mli"
# 1 "src/migrate_parsetree_def.mli"
# 1 "src/migrate_parsetree_def.mli"
# 1 "src/migrate_parsetree_def.mli"
# 1 "src/migrate_parsetree_def.mli"
# 1 "src/migrate_parsetree_def.mli"
# 1 "src/migrate_parsetree_def.mli"
# 1 "src/migrate_parsetree_def.mli"
# 1 "src/migrate_parsetree_def.mli"
# 1 "src/migrate_parsetree_def.mli"
# 1 "src/migrate_parsetree_def.mli"
# 1 "src/migrate_parsetree_def.mli"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(** Features which are not available in all versions of the frontend *)
type missing_feature =
    Pexp_letexception
  | Ppat_open
  | Pexp_unreachable
  | PSig
  | Pcstr_record
  | Pconst_integer
  | Pconst_float
  | Pcl_open
  | Pcty_open

(** Exception thrown by migration functions when a feature is not supported. *)
exception Migration_error of missing_feature * Location.t

(** [missing_feature_description x] is a text describing the feature [x]. *)
val missing_feature_description : missing_feature -> string

(** [missing_feature_minimal_version x] is the OCaml version where x was
    introduced. *)
val missing_feature_minimal_version : missing_feature -> string

(** Turn a missing feature into a reasonable error message. *)
val migration_error_message : missing_feature -> string

end = struct
#1 "migrate_parsetree_def.ml"
# 1 "src/migrate_parsetree_def.ml"
# 1 "src/migrate_parsetree_def.ml"
# 1 "src/migrate_parsetree_def.ml"
# 1 "src/migrate_parsetree_def.ml"
# 1 "src/migrate_parsetree_def.ml"
# 1 "src/migrate_parsetree_def.ml"
# 1 "src/migrate_parsetree_def.ml"
# 1 "src/migrate_parsetree_def.ml"
# 1 "src/migrate_parsetree_def.ml"
# 1 "src/migrate_parsetree_def.ml"
# 1 "src/migrate_parsetree_def.ml"
# 1 "src/migrate_parsetree_def.ml"
# 1 "src/migrate_parsetree_def.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(** Errors that can happen when converting constructions that doesn't exist in
    older version of the AST. *)
type missing_feature =
  | Pexp_letexception
    (** 4.04 -> 4.03: local exception, let exception _ in ... *)
  | Ppat_open
    (** 4.04 -> 4.03: module open in pattern match x with M.(_) -> ... *)
  | Pexp_unreachable
    (** 4.04 -> 4.03: unreachable pattern -> . *)
  | PSig
    (** 4.03 -> 4.02: signature in attribute, [@: val x : int] *)
  | Pcstr_record
    (** 4.03 -> 4.02: inline record *)
  | Pconst_integer
    (** 4.03 -> 4.02: integer literal with invalid suffix, 1234d *)
  | Pconst_float
    (** 4.03 -> 4.02: float literal with invalid suffix, 1234.0g *)
  | Pcl_open
    (** 4.06 -> 4.05: let open M in <class-expression> *)
  | Pcty_open
    (** 4.06 -> 4.05: let open M in <class-type> *)

exception Migration_error of missing_feature * Location.t

(** [missing_feature_description x] is a text describing the feature [x]. *)
let missing_feature_description = function
  | Pexp_letexception -> "local exceptions"
  | Ppat_open         -> "module open in patterns"
  | Pexp_unreachable  -> "unreachable patterns"
  | PSig              -> "signatures in attribute"
  | Pcstr_record      -> "inline records"
  | Pconst_integer    -> "custom integer literals"
  | Pconst_float      -> "custom float literals"
  | Pcl_open          -> "module open in class expression"
  | Pcty_open         -> "module open in class type"

(** [missing_feature_minimal_version x] is the OCaml version where x was
    introduced. *)
let missing_feature_minimal_version = function
  | Pexp_letexception -> "OCaml 4.04"
  | Ppat_open         -> "OCaml 4.04"
  | Pexp_unreachable  -> "OCaml 4.03"
  | PSig              -> "OCaml 4.03"
  | Pcstr_record      -> "OCaml 4.03"
  | Pconst_integer    -> "OCaml 4.03"
  | Pconst_float      -> "OCaml 4.03"
  | Pcl_open          -> "OCaml 4.06"
  | Pcty_open         -> "OCaml 4.06"

(** Turn a missing feature into a reasonable error message. *)
let migration_error_message x =
  let feature = missing_feature_description x in
  let version = missing_feature_minimal_version x in
  feature ^ " are not supported before " ^ version

let () =
  let location_prefix l =
    if l = Location.none then "" else
      let {Location.loc_start; loc_end; _} = l in
      let bol = loc_start.Lexing.pos_bol in
      Printf.sprintf "File %S, line %d, characters %d-%d: "
        loc_start.Lexing.pos_fname
        loc_start.Lexing.pos_lnum
        (loc_start.Lexing.pos_cnum - bol)
        (loc_end.Lexing.pos_cnum - bol)
  in
  Printexc.register_printer (function
      | Migration_error (err, loc) ->
          Some (location_prefix loc ^ migration_error_message err)
      | _ -> None
    )

end
module Migrate_parsetree_403_402_migrate
= struct
#1 "migrate_parsetree_403_402_migrate.ml"
# 1 "src/migrate_parsetree_403_402_migrate.ml"
# 1 "src/migrate_parsetree_403_402_migrate.ml"
# 1 "src/migrate_parsetree_403_402_migrate.ml"
# 1 "src/migrate_parsetree_403_402_migrate.ml"
# 1 "src/migrate_parsetree_403_402_migrate.ml"
# 1 "src/migrate_parsetree_403_402_migrate.ml"
# 1 "src/migrate_parsetree_403_402_migrate.ml"
# 1 "src/migrate_parsetree_403_402_migrate.ml"
# 1 "src/migrate_parsetree_403_402_migrate.ml"
# 1 "src/migrate_parsetree_403_402_migrate.ml"
# 1 "src/migrate_parsetree_403_402_migrate.ml"
# 1 "src/migrate_parsetree_403_402_migrate.ml"
# 1 "src/migrate_parsetree_403_402_migrate.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*                         Alain Frisch, LexiFi                           *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

module Def = Migrate_parsetree_def
module From = Ast_403
module To = Ast_402

let inject_predef_option label d =
  let open To in
  let open Parsetree in
  match label with
  | From.Asttypes.Optional _ ->
    let loc = {d.ptyp_loc with Location.loc_ghost = true} in
    let txt = Longident.Ldot (Longident.Lident "*predef*", "option") in
    let ident = {Location. txt; loc} in
    { ptyp_desc = Ptyp_constr(ident,[d]); ptyp_loc = loc; ptyp_attributes = []}
  | _ -> d

let from_loc {From.Location. txt = _; loc} = loc

let migration_error location feature =
  raise (Def.Migration_error (feature, location))

let rec copy_expression :
  From.Parsetree.expression ->
    To.Parsetree.expression
  =
  fun
    { From.Parsetree.pexp_desc = pexp_desc;
      From.Parsetree.pexp_loc = pexp_loc;
      From.Parsetree.pexp_attributes = pexp_attributes }
     ->
    {
      To.Parsetree.pexp_desc =
        (copy_expression_desc pexp_loc pexp_desc);
      To.Parsetree.pexp_loc =
        (copy_location pexp_loc);
      To.Parsetree.pexp_attributes =
        (copy_attributes pexp_attributes)
    }

and copy_expression_desc loc :
  From.Parsetree.expression_desc ->
    To.Parsetree.expression_desc
  =
  function
  | From.Parsetree.Pexp_ident x0 ->
      To.Parsetree.Pexp_ident
        (copy_loc copy_longident
           x0)
  | From.Parsetree.Pexp_constant x0 ->
      To.Parsetree.Pexp_constant
        (copy_constant loc x0)
  | From.Parsetree.Pexp_let (x0,x1,x2) ->
      To.Parsetree.Pexp_let
        ((copy_rec_flag x0),
          (List.map copy_value_binding x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_function x0 ->
      To.Parsetree.Pexp_function
        (List.map copy_case x0)
  | From.Parsetree.Pexp_fun (x0,x1,x2,x3) ->
      To.Parsetree.Pexp_fun
        ((copy_arg_label x0),
          (copy_option copy_expression x1),
          (copy_pattern x2),
          (copy_expression x3))
  | From.Parsetree.Pexp_apply (x0,x1) ->
      To.Parsetree.Pexp_apply
        ((copy_expression x0),
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                ((copy_arg_label x0),
                  (copy_expression x1))) x1))
  | From.Parsetree.Pexp_match (x0,x1) ->
      To.Parsetree.Pexp_match
        ((copy_expression x0),
          (List.map copy_case x1))
  | From.Parsetree.Pexp_try (x0,x1) ->
      To.Parsetree.Pexp_try
        ((copy_expression x0),
          (List.map copy_case x1))
  | From.Parsetree.Pexp_tuple x0 ->
      To.Parsetree.Pexp_tuple
        (List.map copy_expression x0)
  | From.Parsetree.Pexp_construct (x0,x1) ->
      To.Parsetree.Pexp_construct
        ((copy_loc
            copy_longident x0),
          (copy_option copy_expression x1))
  | From.Parsetree.Pexp_variant (x0,x1) ->
      To.Parsetree.Pexp_variant
        ((copy_label x0),
          (copy_option copy_expression x1))
  | From.Parsetree.Pexp_record (x0,x1) ->
      To.Parsetree.Pexp_record
        ((List.map
            (fun x  ->
               let (x0,x1) = x  in
               ((copy_loc
                   copy_longident x0),
                 (copy_expression x1))) x0),
          (copy_option copy_expression x1))
  | From.Parsetree.Pexp_field (x0,x1) ->
      To.Parsetree.Pexp_field
        ((copy_expression x0),
          (copy_loc
             copy_longident x1))
  | From.Parsetree.Pexp_setfield (x0,x1,x2) ->
      To.Parsetree.Pexp_setfield
        ((copy_expression x0),
          (copy_loc
             copy_longident x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_array x0 ->
      To.Parsetree.Pexp_array
        (List.map copy_expression x0)
  | From.Parsetree.Pexp_ifthenelse (x0,x1,x2) ->
      To.Parsetree.Pexp_ifthenelse
        ((copy_expression x0),
          (copy_expression x1),
          (copy_option copy_expression x2))
  | From.Parsetree.Pexp_sequence (x0,x1) ->
      To.Parsetree.Pexp_sequence
        ((copy_expression x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_while (x0,x1) ->
      To.Parsetree.Pexp_while
        ((copy_expression x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_for (x0,x1,x2,x3,x4) ->
      To.Parsetree.Pexp_for
        ((copy_pattern x0),
          (copy_expression x1),
          (copy_expression x2),
          (copy_direction_flag x3),
          (copy_expression x4))
  | From.Parsetree.Pexp_constraint (x0,x1) ->
      To.Parsetree.Pexp_constraint
        ((copy_expression x0),
          (copy_core_type x1))
  | From.Parsetree.Pexp_coerce (x0,x1,x2) ->
      To.Parsetree.Pexp_coerce
        ((copy_expression x0),
          (copy_option copy_core_type x1),
          (copy_core_type x2))
  | From.Parsetree.Pexp_send (x0,x1) ->
      To.Parsetree.Pexp_send
        ((copy_expression x0), x1)
  | From.Parsetree.Pexp_new x0 ->
      To.Parsetree.Pexp_new
        (copy_loc copy_longident
           x0)
  | From.Parsetree.Pexp_setinstvar (x0,x1) ->
      To.Parsetree.Pexp_setinstvar
        ((copy_loc (fun x  -> x) x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_override x0 ->
      To.Parsetree.Pexp_override
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_loc (fun x  -> x) x0),
                (copy_expression x1))) x0)
  | From.Parsetree.Pexp_letmodule (x0,x1,x2) ->
      To.Parsetree.Pexp_letmodule
        ((copy_loc (fun x  -> x) x0),
          (copy_module_expr x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_assert x0 ->
      To.Parsetree.Pexp_assert
        (copy_expression x0)
  | From.Parsetree.Pexp_lazy x0 ->
      To.Parsetree.Pexp_lazy
        (copy_expression x0)
  | From.Parsetree.Pexp_poly (x0,x1) ->
      To.Parsetree.Pexp_poly
        ((copy_expression x0),
          (copy_option copy_core_type x1))
  | From.Parsetree.Pexp_object x0 ->
      To.Parsetree.Pexp_object
        (copy_class_structure x0)
  | From.Parsetree.Pexp_newtype (x0,x1) ->
      To.Parsetree.Pexp_newtype
        (x0, (copy_expression x1))
  | From.Parsetree.Pexp_pack x0 ->
      To.Parsetree.Pexp_pack
        (copy_module_expr x0)
  | From.Parsetree.Pexp_open (x0,x1,x2) ->
      To.Parsetree.Pexp_open
        ((copy_override_flag x0),
          (copy_loc
             copy_longident x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_extension x0 ->
      To.Parsetree.Pexp_extension
        (copy_extension x0)
  | From.Parsetree.Pexp_unreachable  ->
      migration_error loc Def.Pexp_unreachable

and copy_direction_flag :
  From.Asttypes.direction_flag ->
    To.Asttypes.direction_flag
  =
  function
  | From.Asttypes.Upto  -> To.Asttypes.Upto
  | From.Asttypes.Downto  -> To.Asttypes.Downto

and copy_case :
  From.Parsetree.case -> To.Parsetree.case =
  fun
    { From.Parsetree.pc_lhs = pc_lhs;
      From.Parsetree.pc_guard = pc_guard;
      From.Parsetree.pc_rhs = pc_rhs }
     ->
    {
      To.Parsetree.pc_lhs =
        (copy_pattern pc_lhs);
      To.Parsetree.pc_guard =
        (copy_option copy_expression pc_guard);
      To.Parsetree.pc_rhs =
        (copy_expression pc_rhs)
    }

and copy_value_binding :
  From.Parsetree.value_binding ->
    To.Parsetree.value_binding
  =
  fun
    { From.Parsetree.pvb_pat = pvb_pat;
      From.Parsetree.pvb_expr = pvb_expr;
      From.Parsetree.pvb_attributes = pvb_attributes;
      From.Parsetree.pvb_loc = pvb_loc }
     ->
    {
      To.Parsetree.pvb_pat =
        (copy_pattern pvb_pat);
      To.Parsetree.pvb_expr =
        (copy_expression pvb_expr);
      To.Parsetree.pvb_attributes =
        (copy_attributes pvb_attributes);
      To.Parsetree.pvb_loc =
        (copy_location pvb_loc)
    }

and copy_pattern :
  From.Parsetree.pattern -> To.Parsetree.pattern =
  fun
    { From.Parsetree.ppat_desc = ppat_desc;
      From.Parsetree.ppat_loc = ppat_loc;
      From.Parsetree.ppat_attributes = ppat_attributes }
     ->
    {
      To.Parsetree.ppat_desc =
        (copy_pattern_desc ppat_loc ppat_desc);
      To.Parsetree.ppat_loc =
        (copy_location ppat_loc);
      To.Parsetree.ppat_attributes =
        (copy_attributes ppat_attributes)
    }

and copy_pattern_desc loc :
  From.Parsetree.pattern_desc ->
    To.Parsetree.pattern_desc
  =
  function
  | From.Parsetree.Ppat_any  ->
      To.Parsetree.Ppat_any
  | From.Parsetree.Ppat_var x0 ->
      To.Parsetree.Ppat_var
        (copy_loc (fun x  -> x) x0)
  | From.Parsetree.Ppat_alias (x0,x1) ->
      To.Parsetree.Ppat_alias
        ((copy_pattern x0),
          (copy_loc (fun x  -> x) x1))
  | From.Parsetree.Ppat_constant x0 ->
      To.Parsetree.Ppat_constant
        (copy_constant loc x0)
  | From.Parsetree.Ppat_interval (x0,x1) ->
      To.Parsetree.Ppat_interval
        ((copy_constant loc x0),
          (copy_constant loc x1))
  | From.Parsetree.Ppat_tuple x0 ->
      To.Parsetree.Ppat_tuple
        (List.map copy_pattern x0)
  | From.Parsetree.Ppat_construct (x0,x1) ->
      To.Parsetree.Ppat_construct
        ((copy_loc
            copy_longident x0),
          (copy_option copy_pattern x1))
  | From.Parsetree.Ppat_variant (x0,x1) ->
      To.Parsetree.Ppat_variant
        ((copy_label x0),
          (copy_option copy_pattern x1))
  | From.Parsetree.Ppat_record (x0,x1) ->
      To.Parsetree.Ppat_record
        ((List.map
            (fun x  ->
               let (x0,x1) = x  in
               ((copy_loc
                   copy_longident x0),
                 (copy_pattern x1))) x0),
          (copy_closed_flag x1))
  | From.Parsetree.Ppat_array x0 ->
      To.Parsetree.Ppat_array
        (List.map copy_pattern x0)
  | From.Parsetree.Ppat_or (x0,x1) ->
      To.Parsetree.Ppat_or
        ((copy_pattern x0),
          (copy_pattern x1))
  | From.Parsetree.Ppat_constraint (x0,x1) ->
      To.Parsetree.Ppat_constraint
        ((copy_pattern x0),
          (copy_core_type x1))
  | From.Parsetree.Ppat_type x0 ->
      To.Parsetree.Ppat_type
        (copy_loc copy_longident
           x0)
  | From.Parsetree.Ppat_lazy x0 ->
      To.Parsetree.Ppat_lazy
        (copy_pattern x0)
  | From.Parsetree.Ppat_unpack x0 ->
      To.Parsetree.Ppat_unpack
        (copy_loc (fun x  -> x) x0)
  | From.Parsetree.Ppat_exception x0 ->
      To.Parsetree.Ppat_exception
        (copy_pattern x0)
  | From.Parsetree.Ppat_extension x0 ->
      To.Parsetree.Ppat_extension
        (copy_extension x0)

and copy_core_type :
  From.Parsetree.core_type ->
    To.Parsetree.core_type
  =
  fun
    { From.Parsetree.ptyp_desc = ptyp_desc;
      From.Parsetree.ptyp_loc = ptyp_loc;
      From.Parsetree.ptyp_attributes = ptyp_attributes }
     ->
    {
      To.Parsetree.ptyp_desc =
        (copy_core_type_desc ptyp_desc);
      To.Parsetree.ptyp_loc =
        (copy_location ptyp_loc);
      To.Parsetree.ptyp_attributes =
        (copy_attributes ptyp_attributes)
    }

and copy_core_type_desc :
  From.Parsetree.core_type_desc ->
    To.Parsetree.core_type_desc
  =
  function
  | From.Parsetree.Ptyp_any  ->
      To.Parsetree.Ptyp_any
  | From.Parsetree.Ptyp_var x0 ->
      To.Parsetree.Ptyp_var x0
  | From.Parsetree.Ptyp_arrow (x0,x1,x2) ->
      To.Parsetree.Ptyp_arrow
        ((copy_arg_label x0),
          inject_predef_option x0 (copy_core_type x1),
          (copy_core_type x2))
  | From.Parsetree.Ptyp_tuple x0 ->
      To.Parsetree.Ptyp_tuple
        (List.map copy_core_type x0)
  | From.Parsetree.Ptyp_constr (x0,x1) ->
      To.Parsetree.Ptyp_constr
        ((copy_loc
            copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Ptyp_object (x0,x1) ->
      To.Parsetree.Ptyp_object
        ((List.map
            (fun x  ->
               let (x0,x1,x2) = x  in
               (x0, (copy_attributes x1),
                 (copy_core_type x2))) x0),
          (copy_closed_flag x1))
  | From.Parsetree.Ptyp_class (x0,x1) ->
      To.Parsetree.Ptyp_class
        ((copy_loc
            copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Ptyp_alias (x0,x1) ->
      To.Parsetree.Ptyp_alias
        ((copy_core_type x0), x1)
  | From.Parsetree.Ptyp_variant (x0,x1,x2) ->
      To.Parsetree.Ptyp_variant
        ((List.map copy_row_field x0),
          (copy_closed_flag x1),
          (copy_option
             (fun x  -> List.map copy_label x) x2))
  | From.Parsetree.Ptyp_poly (x0,x1) ->
      To.Parsetree.Ptyp_poly
        ((List.map (fun x  -> x) x0),
          (copy_core_type x1))
  | From.Parsetree.Ptyp_package x0 ->
      To.Parsetree.Ptyp_package
        (copy_package_type x0)
  | From.Parsetree.Ptyp_extension x0 ->
      To.Parsetree.Ptyp_extension
        (copy_extension x0)

and copy_package_type :
  From.Parsetree.package_type ->
    To.Parsetree.package_type
  =
  fun x  ->
    let (x0,x1) = x  in
    ((copy_loc copy_longident x0),
      (List.map
         (fun x  ->
            let (x0,x1) = x  in
            ((copy_loc
                copy_longident x0),
              (copy_core_type x1))) x1))

and copy_row_field :
  From.Parsetree.row_field ->
    To.Parsetree.row_field
  =
  function
  | From.Parsetree.Rtag (x0,x1,x2,x3) ->
      To.Parsetree.Rtag
        ((copy_label x0),
          (copy_attributes x1), (copy_bool x2),
          (List.map copy_core_type x3))
  | From.Parsetree.Rinherit x0 ->
      To.Parsetree.Rinherit
        (copy_core_type x0)

and copy_attributes :
  From.Parsetree.attributes ->
    To.Parsetree.attributes
  = fun x  -> List.map copy_attribute x

and copy_attribute :
  From.Parsetree.attribute ->
    To.Parsetree.attribute
  =
  fun x  ->
    let (x0,x1) = x  in
    ((copy_loc (fun x  -> x) x0),
      (copy_payload (from_loc x0) x1))

and copy_payload loc :
  From.Parsetree.payload -> To.Parsetree.payload =
  function
  | From.Parsetree.PStr x0 ->
      To.Parsetree.PStr
        (copy_structure x0)
  | From.Parsetree.PSig _x0 ->
      migration_error loc Def.PSig
  | From.Parsetree.PTyp x0 ->
      To.Parsetree.PTyp
        (copy_core_type x0)
  | From.Parsetree.PPat (x0,x1) ->
      To.Parsetree.PPat
        ((copy_pattern x0),
          (copy_option copy_expression x1))

and copy_structure :
  From.Parsetree.structure ->
    To.Parsetree.structure
  = fun x  -> List.map copy_structure_item x

and copy_structure_item :
  From.Parsetree.structure_item ->
    To.Parsetree.structure_item
  =
  fun
    { From.Parsetree.pstr_desc = pstr_desc;
      From.Parsetree.pstr_loc = pstr_loc }
     ->
    {
      To.Parsetree.pstr_desc =
        (copy_structure_item_desc pstr_desc);
      To.Parsetree.pstr_loc =
        (copy_location pstr_loc)
    }

and copy_structure_item_desc :
  From.Parsetree.structure_item_desc ->
    To.Parsetree.structure_item_desc
  =
  function
  | From.Parsetree.Pstr_eval (x0,x1) ->
      To.Parsetree.Pstr_eval
        ((copy_expression x0),
          (copy_attributes x1))
  | From.Parsetree.Pstr_value (x0,x1) ->
      To.Parsetree.Pstr_value
        ((copy_rec_flag x0),
          (List.map copy_value_binding x1))
  | From.Parsetree.Pstr_primitive x0 ->
      To.Parsetree.Pstr_primitive
        (copy_value_description x0)
  | From.Parsetree.Pstr_type (x0,x1) ->
      To.Parsetree.Pstr_type (type_declarations x0 x1)
  | From.Parsetree.Pstr_typext x0 ->
      To.Parsetree.Pstr_typext
        (copy_type_extension x0)
  | From.Parsetree.Pstr_exception x0 ->
      To.Parsetree.Pstr_exception
        (copy_extension_constructor x0)
  | From.Parsetree.Pstr_module x0 ->
      To.Parsetree.Pstr_module
        (copy_module_binding x0)
  | From.Parsetree.Pstr_recmodule x0 ->
      To.Parsetree.Pstr_recmodule
        (List.map copy_module_binding x0)
  | From.Parsetree.Pstr_modtype x0 ->
      To.Parsetree.Pstr_modtype
        (copy_module_type_declaration x0)
  | From.Parsetree.Pstr_open x0 ->
      To.Parsetree.Pstr_open
        (copy_open_description x0)
  | From.Parsetree.Pstr_class x0 ->
      To.Parsetree.Pstr_class
        (List.map copy_class_declaration x0)
  | From.Parsetree.Pstr_class_type x0 ->
      To.Parsetree.Pstr_class_type
        (List.map copy_class_type_declaration x0)
  | From.Parsetree.Pstr_include x0 ->
      To.Parsetree.Pstr_include
        (copy_include_declaration x0)
  | From.Parsetree.Pstr_attribute x0 ->
      To.Parsetree.Pstr_attribute
        (copy_attribute x0)
  | From.Parsetree.Pstr_extension (x0,x1) ->
      To.Parsetree.Pstr_extension
        ((copy_extension x0),
          (copy_attributes x1))

and copy_include_declaration :
  From.Parsetree.include_declaration ->
    To.Parsetree.include_declaration
  =
  fun x  ->
    copy_include_infos
      copy_module_expr x

and copy_class_declaration :
  From.Parsetree.class_declaration ->
    To.Parsetree.class_declaration
  =
  fun x  ->
    copy_class_infos
      copy_class_expr x

and copy_class_expr :
  From.Parsetree.class_expr ->
    To.Parsetree.class_expr
  =
  fun
    { From.Parsetree.pcl_desc = pcl_desc;
      From.Parsetree.pcl_loc = pcl_loc;
      From.Parsetree.pcl_attributes = pcl_attributes }
     ->
    {
      To.Parsetree.pcl_desc =
        (copy_class_expr_desc pcl_desc);
      To.Parsetree.pcl_loc =
        (copy_location pcl_loc);
      To.Parsetree.pcl_attributes =
        (copy_attributes pcl_attributes)
    }

and copy_class_expr_desc :
  From.Parsetree.class_expr_desc ->
    To.Parsetree.class_expr_desc
  =
  function
  | From.Parsetree.Pcl_constr (x0,x1) ->
      To.Parsetree.Pcl_constr
        ((copy_loc
            copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Pcl_structure x0 ->
      To.Parsetree.Pcl_structure
        (copy_class_structure x0)
  | From.Parsetree.Pcl_fun (x0,x1,x2,x3) ->
      To.Parsetree.Pcl_fun
        ((copy_arg_label x0),
          (copy_option copy_expression x1),
          (copy_pattern x2),
          (copy_class_expr x3))
  | From.Parsetree.Pcl_apply (x0,x1) ->
      To.Parsetree.Pcl_apply
        ((copy_class_expr x0),
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                ((copy_arg_label x0),
                  (copy_expression x1))) x1))
  | From.Parsetree.Pcl_let (x0,x1,x2) ->
      To.Parsetree.Pcl_let
        ((copy_rec_flag x0),
          (List.map copy_value_binding x1),
          (copy_class_expr x2))
  | From.Parsetree.Pcl_constraint (x0,x1) ->
      To.Parsetree.Pcl_constraint
        ((copy_class_expr x0),
          (copy_class_type x1))
  | From.Parsetree.Pcl_extension x0 ->
      To.Parsetree.Pcl_extension
        (copy_extension x0)

and copy_class_structure :
  From.Parsetree.class_structure ->
    To.Parsetree.class_structure
  =
  fun
    { From.Parsetree.pcstr_self = pcstr_self;
      From.Parsetree.pcstr_fields = pcstr_fields }
     ->
    {
      To.Parsetree.pcstr_self =
        (copy_pattern pcstr_self);
      To.Parsetree.pcstr_fields =
        (List.map copy_class_field pcstr_fields)
    }

and copy_class_field :
  From.Parsetree.class_field ->
    To.Parsetree.class_field
  =
  fun
    { From.Parsetree.pcf_desc = pcf_desc;
      From.Parsetree.pcf_loc = pcf_loc;
      From.Parsetree.pcf_attributes = pcf_attributes }
     ->
    {
      To.Parsetree.pcf_desc =
        (copy_class_field_desc pcf_desc);
      To.Parsetree.pcf_loc =
        (copy_location pcf_loc);
      To.Parsetree.pcf_attributes =
        (copy_attributes pcf_attributes)
    }

and copy_class_field_desc :
  From.Parsetree.class_field_desc ->
    To.Parsetree.class_field_desc
  =
  function
  | From.Parsetree.Pcf_inherit (x0,x1,x2) ->
      To.Parsetree.Pcf_inherit
        ((copy_override_flag x0),
          (copy_class_expr x1),
          (copy_option (fun x  -> x) x2))
  | From.Parsetree.Pcf_val x0 ->
      To.Parsetree.Pcf_val
        (let (x0,x1,x2) = x0  in
         ((copy_loc (fun x  -> x) x0),
           (copy_mutable_flag x1),
           (copy_class_field_kind x2)))
  | From.Parsetree.Pcf_method x0 ->
      To.Parsetree.Pcf_method
        (let (x0,x1,x2) = x0  in
         ((copy_loc (fun x  -> x) x0),
           (copy_private_flag x1),
           (copy_class_field_kind x2)))
  | From.Parsetree.Pcf_constraint x0 ->
      To.Parsetree.Pcf_constraint
        (let (x0,x1) = x0  in
         ((copy_core_type x0),
           (copy_core_type x1)))
  | From.Parsetree.Pcf_initializer x0 ->
      To.Parsetree.Pcf_initializer
        (copy_expression x0)
  | From.Parsetree.Pcf_attribute x0 ->
      To.Parsetree.Pcf_attribute
        (copy_attribute x0)
  | From.Parsetree.Pcf_extension x0 ->
      To.Parsetree.Pcf_extension
        (copy_extension x0)

and copy_class_field_kind :
  From.Parsetree.class_field_kind ->
    To.Parsetree.class_field_kind
  =
  function
  | From.Parsetree.Cfk_virtual x0 ->
      To.Parsetree.Cfk_virtual
        (copy_core_type x0)
  | From.Parsetree.Cfk_concrete (x0,x1) ->
      To.Parsetree.Cfk_concrete
        ((copy_override_flag x0),
          (copy_expression x1))

and copy_module_binding :
  From.Parsetree.module_binding ->
    To.Parsetree.module_binding
  =
  fun
    { From.Parsetree.pmb_name = pmb_name;
      From.Parsetree.pmb_expr = pmb_expr;
      From.Parsetree.pmb_attributes = pmb_attributes;
      From.Parsetree.pmb_loc = pmb_loc }
     ->
    {
      To.Parsetree.pmb_name =
        (copy_loc (fun x  -> x) pmb_name);
      To.Parsetree.pmb_expr =
        (copy_module_expr pmb_expr);
      To.Parsetree.pmb_attributes =
        (copy_attributes pmb_attributes);
      To.Parsetree.pmb_loc =
        (copy_location pmb_loc)
    }

and copy_module_expr :
  From.Parsetree.module_expr ->
    To.Parsetree.module_expr
  =
  fun
    { From.Parsetree.pmod_desc = pmod_desc;
      From.Parsetree.pmod_loc = pmod_loc;
      From.Parsetree.pmod_attributes = pmod_attributes }
     ->
    {
      To.Parsetree.pmod_desc =
        (copy_module_expr_desc pmod_desc);
      To.Parsetree.pmod_loc =
        (copy_location pmod_loc);
      To.Parsetree.pmod_attributes =
        (copy_attributes pmod_attributes)
    }

and copy_module_expr_desc :
  From.Parsetree.module_expr_desc ->
    To.Parsetree.module_expr_desc
  =
  function
  | From.Parsetree.Pmod_ident x0 ->
      To.Parsetree.Pmod_ident
        (copy_loc copy_longident
           x0)
  | From.Parsetree.Pmod_structure x0 ->
      To.Parsetree.Pmod_structure
        (copy_structure x0)
  | From.Parsetree.Pmod_functor (x0,x1,x2) ->
      To.Parsetree.Pmod_functor
        ((copy_loc (fun x  -> x) x0),
          (copy_option copy_module_type x1),
          (copy_module_expr x2))
  | From.Parsetree.Pmod_apply (x0,x1) ->
      To.Parsetree.Pmod_apply
        ((copy_module_expr x0),
          (copy_module_expr x1))
  | From.Parsetree.Pmod_constraint (x0,x1) ->
      To.Parsetree.Pmod_constraint
        ((copy_module_expr x0),
          (copy_module_type x1))
  | From.Parsetree.Pmod_unpack x0 ->
      To.Parsetree.Pmod_unpack
        (copy_expression x0)
  | From.Parsetree.Pmod_extension x0 ->
      To.Parsetree.Pmod_extension
        (copy_extension x0)

and copy_module_type :
  From.Parsetree.module_type ->
    To.Parsetree.module_type
  =
  fun
    { From.Parsetree.pmty_desc = pmty_desc;
      From.Parsetree.pmty_loc = pmty_loc;
      From.Parsetree.pmty_attributes = pmty_attributes }
     ->
    {
      To.Parsetree.pmty_desc =
        (copy_module_type_desc pmty_desc);
      To.Parsetree.pmty_loc =
        (copy_location pmty_loc);
      To.Parsetree.pmty_attributes =
        (copy_attributes pmty_attributes)
    }

and copy_module_type_desc :
  From.Parsetree.module_type_desc ->
    To.Parsetree.module_type_desc
  =
  function
  | From.Parsetree.Pmty_ident x0 ->
      To.Parsetree.Pmty_ident
        (copy_loc copy_longident
           x0)
  | From.Parsetree.Pmty_signature x0 ->
      To.Parsetree.Pmty_signature
        (copy_signature x0)
  | From.Parsetree.Pmty_functor (x0,x1,x2) ->
      To.Parsetree.Pmty_functor
        ((copy_loc (fun x  -> x) x0),
          (copy_option copy_module_type x1),
          (copy_module_type x2))
  | From.Parsetree.Pmty_with (x0,x1) ->
      To.Parsetree.Pmty_with
        ((copy_module_type x0),
          (List.map copy_with_constraint x1))
  | From.Parsetree.Pmty_typeof x0 ->
      To.Parsetree.Pmty_typeof
        (copy_module_expr x0)
  | From.Parsetree.Pmty_extension x0 ->
      To.Parsetree.Pmty_extension
        (copy_extension x0)
  | From.Parsetree.Pmty_alias x0 ->
      To.Parsetree.Pmty_alias
        (copy_loc copy_longident
           x0)

and copy_with_constraint :
  From.Parsetree.with_constraint ->
    To.Parsetree.with_constraint
  =
  function
  | From.Parsetree.Pwith_type (x0,x1) ->
      To.Parsetree.Pwith_type
        ((copy_loc
            copy_longident x0),
          (copy_type_declaration x1))
  | From.Parsetree.Pwith_module (x0,x1) ->
      To.Parsetree.Pwith_module
        ((copy_loc
            copy_longident x0),
          (copy_loc
             copy_longident x1))
  | From.Parsetree.Pwith_typesubst x0 ->
      To.Parsetree.Pwith_typesubst
        (copy_type_declaration x0)
  | From.Parsetree.Pwith_modsubst (x0,x1) ->
      To.Parsetree.Pwith_modsubst
        ((copy_loc (fun x  -> x) x0),
          (copy_loc
             copy_longident x1))

and copy_signature :
  From.Parsetree.signature ->
    To.Parsetree.signature
  = fun x  -> List.map copy_signature_item x

and copy_signature_item :
  From.Parsetree.signature_item ->
    To.Parsetree.signature_item
  =
  fun
    { From.Parsetree.psig_desc = psig_desc;
      From.Parsetree.psig_loc = psig_loc }
     ->
    {
      To.Parsetree.psig_desc =
        (copy_signature_item_desc psig_desc);
      To.Parsetree.psig_loc =
        (copy_location psig_loc)
    }

and copy_signature_item_desc :
  From.Parsetree.signature_item_desc ->
    To.Parsetree.signature_item_desc
  =
  function
  | From.Parsetree.Psig_value x0 ->
      To.Parsetree.Psig_value
        (copy_value_description x0)
  | From.Parsetree.Psig_type (x0,x1) ->
      To.Parsetree.Psig_type (type_declarations x0 x1)
  | From.Parsetree.Psig_typext x0 ->
      To.Parsetree.Psig_typext
        (copy_type_extension x0)
  | From.Parsetree.Psig_exception x0 ->
      To.Parsetree.Psig_exception
        (copy_extension_constructor x0)
  | From.Parsetree.Psig_module x0 ->
      To.Parsetree.Psig_module
        (copy_module_declaration x0)
  | From.Parsetree.Psig_recmodule x0 ->
      To.Parsetree.Psig_recmodule
        (List.map copy_module_declaration x0)
  | From.Parsetree.Psig_modtype x0 ->
      To.Parsetree.Psig_modtype
        (copy_module_type_declaration x0)
  | From.Parsetree.Psig_open x0 ->
      To.Parsetree.Psig_open
        (copy_open_description x0)
  | From.Parsetree.Psig_include x0 ->
      To.Parsetree.Psig_include
        (copy_include_description x0)
  | From.Parsetree.Psig_class x0 ->
      To.Parsetree.Psig_class
        (List.map copy_class_description x0)
  | From.Parsetree.Psig_class_type x0 ->
      To.Parsetree.Psig_class_type
        (List.map copy_class_type_declaration x0)
  | From.Parsetree.Psig_attribute x0 ->
      To.Parsetree.Psig_attribute
        (copy_attribute x0)
  | From.Parsetree.Psig_extension (x0,x1) ->
      To.Parsetree.Psig_extension
        ((copy_extension x0),
          (copy_attributes x1))

and copy_class_type_declaration :
  From.Parsetree.class_type_declaration ->
    To.Parsetree.class_type_declaration
  =
  fun x  ->
    copy_class_infos
      copy_class_type x

and copy_class_description :
  From.Parsetree.class_description ->
    To.Parsetree.class_description
  =
  fun x  ->
    copy_class_infos
      copy_class_type x

and copy_class_type :
  From.Parsetree.class_type ->
    To.Parsetree.class_type
  =
  fun
    { From.Parsetree.pcty_desc = pcty_desc;
      From.Parsetree.pcty_loc = pcty_loc;
      From.Parsetree.pcty_attributes = pcty_attributes }
     ->
    {
      To.Parsetree.pcty_desc =
        (copy_class_type_desc pcty_desc);
      To.Parsetree.pcty_loc =
        (copy_location pcty_loc);
      To.Parsetree.pcty_attributes =
        (copy_attributes pcty_attributes)
    }

and copy_class_type_desc :
  From.Parsetree.class_type_desc ->
    To.Parsetree.class_type_desc
  =
  function
  | From.Parsetree.Pcty_constr (x0,x1) ->
      To.Parsetree.Pcty_constr
        ((copy_loc
            copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Pcty_signature x0 ->
      To.Parsetree.Pcty_signature
        (copy_class_signature x0)
  | From.Parsetree.Pcty_arrow (x0,x1,x2) ->
      To.Parsetree.Pcty_arrow
        ((copy_arg_label x0),
          inject_predef_option x0 (copy_core_type x1),
          (copy_class_type x2))
  | From.Parsetree.Pcty_extension x0 ->
      To.Parsetree.Pcty_extension
        (copy_extension x0)

and copy_class_signature :
  From.Parsetree.class_signature ->
    To.Parsetree.class_signature
  =
  fun
    { From.Parsetree.pcsig_self = pcsig_self;
      From.Parsetree.pcsig_fields = pcsig_fields }
     ->
    {
      To.Parsetree.pcsig_self =
        (copy_core_type pcsig_self);
      To.Parsetree.pcsig_fields =
        (List.map copy_class_type_field
           pcsig_fields)
    }

and copy_class_type_field :
  From.Parsetree.class_type_field ->
    To.Parsetree.class_type_field
  =
  fun
    { From.Parsetree.pctf_desc = pctf_desc;
      From.Parsetree.pctf_loc = pctf_loc;
      From.Parsetree.pctf_attributes = pctf_attributes }
     ->
    {
      To.Parsetree.pctf_desc =
        (copy_class_type_field_desc pctf_desc);
      To.Parsetree.pctf_loc =
        (copy_location pctf_loc);
      To.Parsetree.pctf_attributes =
        (copy_attributes pctf_attributes)
    }

and copy_class_type_field_desc :
  From.Parsetree.class_type_field_desc ->
    To.Parsetree.class_type_field_desc
  =
  function
  | From.Parsetree.Pctf_inherit x0 ->
      To.Parsetree.Pctf_inherit
        (copy_class_type x0)
  | From.Parsetree.Pctf_val x0 ->
      To.Parsetree.Pctf_val
        (let (x0,x1,x2,x3) = x0  in
         (x0, (copy_mutable_flag x1),
           (copy_virtual_flag x2),
           (copy_core_type x3)))
  | From.Parsetree.Pctf_method x0 ->
      To.Parsetree.Pctf_method
        (let (x0,x1,x2,x3) = x0  in
         (x0, (copy_private_flag x1),
           (copy_virtual_flag x2),
           (copy_core_type x3)))
  | From.Parsetree.Pctf_constraint x0 ->
      To.Parsetree.Pctf_constraint
        (let (x0,x1) = x0  in
         ((copy_core_type x0),
           (copy_core_type x1)))
  | From.Parsetree.Pctf_attribute x0 ->
      To.Parsetree.Pctf_attribute
        (copy_attribute x0)
  | From.Parsetree.Pctf_extension x0 ->
      To.Parsetree.Pctf_extension
        (copy_extension x0)

and copy_extension :
  From.Parsetree.extension ->
    To.Parsetree.extension
  =
  fun x  ->
    let (x0,x1) = x  in
    ((copy_loc (fun x  -> x) x0),
      (copy_payload (from_loc x0) x1))

and copy_class_infos :
  'f0 'g0 .
    ('f0 -> 'g0) ->
      'f0 From.Parsetree.class_infos ->
        'g0 To.Parsetree.class_infos
  =
  fun f0  ->
    fun
      { From.Parsetree.pci_virt = pci_virt;
        From.Parsetree.pci_params = pci_params;
        From.Parsetree.pci_name = pci_name;
        From.Parsetree.pci_expr = pci_expr;
        From.Parsetree.pci_loc = pci_loc;
        From.Parsetree.pci_attributes = pci_attributes }
       ->
      {
        To.Parsetree.pci_virt =
          (copy_virtual_flag pci_virt);
        To.Parsetree.pci_params =
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                ((copy_core_type x0),
                  (copy_variance x1))) pci_params);
        To.Parsetree.pci_name =
          (copy_loc (fun x  -> x) pci_name);
        To.Parsetree.pci_expr = (f0 pci_expr);
        To.Parsetree.pci_loc =
          (copy_location pci_loc);
        To.Parsetree.pci_attributes =
          (copy_attributes pci_attributes)
      }

and copy_virtual_flag :
  From.Asttypes.virtual_flag ->
    To.Asttypes.virtual_flag
  =
  function
  | From.Asttypes.Virtual  -> To.Asttypes.Virtual
  | From.Asttypes.Concrete  -> To.Asttypes.Concrete

and copy_include_description :
  From.Parsetree.include_description ->
    To.Parsetree.include_description
  =
  fun x  ->
    copy_include_infos
      copy_module_type x

and copy_include_infos :
  'f0 'g0 .
    ('f0 -> 'g0) ->
      'f0 From.Parsetree.include_infos ->
        'g0 To.Parsetree.include_infos
  =
  fun f0  ->
    fun
      { From.Parsetree.pincl_mod = pincl_mod;
        From.Parsetree.pincl_loc = pincl_loc;
        From.Parsetree.pincl_attributes = pincl_attributes }
       ->
      {
        To.Parsetree.pincl_mod = (f0 pincl_mod);
        To.Parsetree.pincl_loc =
          (copy_location pincl_loc);
        To.Parsetree.pincl_attributes =
          (copy_attributes pincl_attributes)
      }

and copy_open_description :
  From.Parsetree.open_description ->
    To.Parsetree.open_description
  =
  fun
    { From.Parsetree.popen_lid = popen_lid;
      From.Parsetree.popen_override = popen_override;
      From.Parsetree.popen_loc = popen_loc;
      From.Parsetree.popen_attributes = popen_attributes }
     ->
    {
      To.Parsetree.popen_lid =
        (copy_loc copy_longident
           popen_lid);
      To.Parsetree.popen_override =
        (copy_override_flag popen_override);
      To.Parsetree.popen_loc =
        (copy_location popen_loc);
      To.Parsetree.popen_attributes =
        (copy_attributes popen_attributes)
    }

and copy_override_flag :
  From.Asttypes.override_flag ->
    To.Asttypes.override_flag
  =
  function
  | From.Asttypes.Override  -> To.Asttypes.Override
  | From.Asttypes.Fresh  -> To.Asttypes.Fresh

and copy_module_type_declaration :
  From.Parsetree.module_type_declaration ->
    To.Parsetree.module_type_declaration
  =
  fun
    { From.Parsetree.pmtd_name = pmtd_name;
      From.Parsetree.pmtd_type = pmtd_type;
      From.Parsetree.pmtd_attributes = pmtd_attributes;
      From.Parsetree.pmtd_loc = pmtd_loc }
     ->
    {
      To.Parsetree.pmtd_name =
        (copy_loc (fun x  -> x) pmtd_name);
      To.Parsetree.pmtd_type =
        (copy_option copy_module_type pmtd_type);
      To.Parsetree.pmtd_attributes =
        (copy_attributes pmtd_attributes);
      To.Parsetree.pmtd_loc =
        (copy_location pmtd_loc)
    }

and copy_module_declaration :
  From.Parsetree.module_declaration ->
    To.Parsetree.module_declaration
  =
  fun
    { From.Parsetree.pmd_name = pmd_name;
      From.Parsetree.pmd_type = pmd_type;
      From.Parsetree.pmd_attributes = pmd_attributes;
      From.Parsetree.pmd_loc = pmd_loc }
     ->
    {
      To.Parsetree.pmd_name =
        (copy_loc (fun x  -> x) pmd_name);
      To.Parsetree.pmd_type =
        (copy_module_type pmd_type);
      To.Parsetree.pmd_attributes =
        (copy_attributes pmd_attributes);
      To.Parsetree.pmd_loc =
        (copy_location pmd_loc)
    }

and copy_type_extension :
  From.Parsetree.type_extension ->
    To.Parsetree.type_extension
  =
  fun
    { From.Parsetree.ptyext_path = ptyext_path;
      From.Parsetree.ptyext_params = ptyext_params;
      From.Parsetree.ptyext_constructors = ptyext_constructors;
      From.Parsetree.ptyext_private = ptyext_private;
      From.Parsetree.ptyext_attributes = ptyext_attributes }
     ->
    {
      To.Parsetree.ptyext_path =
        (copy_loc copy_longident
           ptyext_path);
      To.Parsetree.ptyext_params =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_core_type x0),
                (copy_variance x1))) ptyext_params);
      To.Parsetree.ptyext_constructors =
        (List.map copy_extension_constructor
           ptyext_constructors);
      To.Parsetree.ptyext_private =
        (copy_private_flag ptyext_private);
      To.Parsetree.ptyext_attributes =
        (copy_attributes ptyext_attributes)
    }

and copy_extension_constructor :
  From.Parsetree.extension_constructor ->
    To.Parsetree.extension_constructor
  =
  fun
    { From.Parsetree.pext_name = pext_name;
      From.Parsetree.pext_kind = pext_kind;
      From.Parsetree.pext_loc = pext_loc;
      From.Parsetree.pext_attributes = pext_attributes }
     ->
    {
      To.Parsetree.pext_name =
        (copy_loc (fun x  -> x) pext_name);
      To.Parsetree.pext_kind =
        (copy_extension_constructor_kind (from_loc pext_name) pext_kind);
      To.Parsetree.pext_loc =
        (copy_location pext_loc);
      To.Parsetree.pext_attributes =
        (copy_attributes pext_attributes)
    }

and copy_extension_constructor_kind loc :
  From.Parsetree.extension_constructor_kind ->
    To.Parsetree.extension_constructor_kind
  =
  function
  | From.Parsetree.Pext_decl (x0,x1) ->
      To.Parsetree.Pext_decl
        ((copy_constructor_arguments loc x0),
          (copy_option copy_core_type x1))
  | From.Parsetree.Pext_rebind x0 ->
      To.Parsetree.Pext_rebind
        (copy_loc copy_longident
           x0)

and copy_type_declaration :
  From.Parsetree.type_declaration ->
    To.Parsetree.type_declaration
  =
  fun
    { From.Parsetree.ptype_name = ptype_name;
      From.Parsetree.ptype_params = ptype_params;
      From.Parsetree.ptype_cstrs = ptype_cstrs;
      From.Parsetree.ptype_kind = ptype_kind;
      From.Parsetree.ptype_private = ptype_private;
      From.Parsetree.ptype_manifest = ptype_manifest;
      From.Parsetree.ptype_attributes = ptype_attributes;
      From.Parsetree.ptype_loc = ptype_loc }
     ->
    {
      To.Parsetree.ptype_name =
        (copy_loc (fun x  -> x) ptype_name);
      To.Parsetree.ptype_params =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_core_type x0),
                (copy_variance x1))) ptype_params);
      To.Parsetree.ptype_cstrs =
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              ((copy_core_type x0),
                (copy_core_type x1),
                (copy_location x2))) ptype_cstrs);
      To.Parsetree.ptype_kind =
        (copy_type_kind ptype_kind);
      To.Parsetree.ptype_private =
        (copy_private_flag ptype_private);
      To.Parsetree.ptype_manifest =
        (copy_option copy_core_type ptype_manifest);
      To.Parsetree.ptype_attributes =
        (copy_attributes ptype_attributes);
      To.Parsetree.ptype_loc =
        (copy_location ptype_loc)
    }

and copy_private_flag :
  From.Asttypes.private_flag ->
    To.Asttypes.private_flag
  =
  function
  | From.Asttypes.Private  -> To.Asttypes.Private
  | From.Asttypes.Public  -> To.Asttypes.Public

and copy_type_kind :
  From.Parsetree.type_kind ->
    To.Parsetree.type_kind
  =
  function
  | From.Parsetree.Ptype_abstract  ->
      To.Parsetree.Ptype_abstract
  | From.Parsetree.Ptype_variant x0 ->
      To.Parsetree.Ptype_variant
        (List.map copy_constructor_declaration x0)
  | From.Parsetree.Ptype_record x0 ->
      To.Parsetree.Ptype_record
        (List.map copy_label_declaration x0)
  | From.Parsetree.Ptype_open  ->
      To.Parsetree.Ptype_open

and copy_constructor_declaration :
  From.Parsetree.constructor_declaration ->
    To.Parsetree.constructor_declaration
  =
  fun
    { From.Parsetree.pcd_name = pcd_name;
      From.Parsetree.pcd_args = pcd_args;
      From.Parsetree.pcd_res = pcd_res;
      From.Parsetree.pcd_loc = pcd_loc;
      From.Parsetree.pcd_attributes = pcd_attributes }
     ->
    {
      To.Parsetree.pcd_name =
        (copy_loc (fun x  -> x) pcd_name);
      To.Parsetree.pcd_args =
        (copy_constructor_arguments (from_loc pcd_name) pcd_args);
      To.Parsetree.pcd_res =
        (copy_option copy_core_type pcd_res);
      To.Parsetree.pcd_loc =
        (copy_location pcd_loc);
      To.Parsetree.pcd_attributes =
        (copy_attributes pcd_attributes)
    }

and copy_constructor_arguments loc :
  From.Parsetree.constructor_arguments ->
    To.Parsetree.core_type list
  =
  function
  | From.Parsetree.Pcstr_tuple x0 ->
      List.map copy_core_type x0
  | From.Parsetree.Pcstr_record _x0 ->
      migration_error loc Def.Pcstr_record

and copy_label_declaration :
  From.Parsetree.label_declaration ->
    To.Parsetree.label_declaration
  =
  fun
    { From.Parsetree.pld_name = pld_name;
      From.Parsetree.pld_mutable = pld_mutable;
      From.Parsetree.pld_type = pld_type;
      From.Parsetree.pld_loc = pld_loc;
      From.Parsetree.pld_attributes = pld_attributes }
     ->
    {
      To.Parsetree.pld_name =
        (copy_loc (fun x  -> x) pld_name);
      To.Parsetree.pld_mutable =
        (copy_mutable_flag pld_mutable);
      To.Parsetree.pld_type =
        (copy_core_type pld_type);
      To.Parsetree.pld_loc =
        (copy_location pld_loc);
      To.Parsetree.pld_attributes =
        (copy_attributes pld_attributes)
    }

and copy_mutable_flag :
  From.Asttypes.mutable_flag ->
    To.Asttypes.mutable_flag
  =
  function
  | From.Asttypes.Immutable  ->
      To.Asttypes.Immutable
  | From.Asttypes.Mutable  -> To.Asttypes.Mutable

and copy_variance :
  From.Asttypes.variance -> To.Asttypes.variance =
  function
  | From.Asttypes.Covariant  ->
      To.Asttypes.Covariant
  | From.Asttypes.Contravariant  ->
      To.Asttypes.Contravariant
  | From.Asttypes.Invariant  ->
      To.Asttypes.Invariant

and copy_value_description :
  From.Parsetree.value_description ->
    To.Parsetree.value_description
  =
  fun
    { From.Parsetree.pval_name = pval_name;
      From.Parsetree.pval_type = pval_type;
      From.Parsetree.pval_prim = pval_prim;
      From.Parsetree.pval_attributes = pval_attributes;
      From.Parsetree.pval_loc = pval_loc }
     ->
    {
      To.Parsetree.pval_name =
        (copy_loc (fun x  -> x) pval_name);
      To.Parsetree.pval_type =
        (copy_core_type pval_type);
      To.Parsetree.pval_prim =
        (List.map (fun x  -> x) pval_prim);
      To.Parsetree.pval_attributes =
        (copy_attributes pval_attributes);
      To.Parsetree.pval_loc =
        (copy_location pval_loc)
    }

and copy_arg_label :
  From.Asttypes.arg_label -> string
  =
  function
  | From.Asttypes.Nolabel  -> ""
  | From.Asttypes.Labelled x0 -> x0
  | From.Asttypes.Optional x0 -> "?" ^ x0

and copy_closed_flag :
  From.Asttypes.closed_flag ->
    To.Asttypes.closed_flag
  =
  function
  | From.Asttypes.Closed  -> To.Asttypes.Closed
  | From.Asttypes.Open  -> To.Asttypes.Open

and copy_label :
  From.Asttypes.label -> To.Asttypes.label =
  fun x  -> x

and copy_rec_flag :
  From.Asttypes.rec_flag -> To.Asttypes.rec_flag =
  function
  | From.Asttypes.Nonrecursive  ->
      To.Asttypes.Nonrecursive
  | From.Asttypes.Recursive  ->
      To.Asttypes.Recursive

and copy_constant loc :
  From.Parsetree.constant -> To.Asttypes.constant
  =
  function
  | From.Parsetree.Pconst_integer (x0,x1) ->
     begin match x1 with
     | None -> To.Asttypes.Const_int (int_of_string x0)
     | Some 'l' ->
         To.Asttypes.Const_int32 (Int32.of_string x0)
     | Some 'L' ->
         To.Asttypes.Const_int64 (Int64.of_string x0)
     | Some 'n' ->
         To.Asttypes.Const_nativeint (Nativeint.of_string x0)
     | Some _ -> migration_error loc Def.Pconst_integer
     end
  | From.Parsetree.Pconst_char x0 ->
      To.Asttypes.Const_char x0
  | From.Parsetree.Pconst_string (x0,x1) ->
      To.Asttypes.Const_string (x0,x1)
  | From.Parsetree.Pconst_float (x0,x1) ->
      begin match x1 with
      | None -> To.Asttypes.Const_float x0
      | Some _ -> migration_error loc Def.Pconst_float
      end

and copy_option : 'f0 'g0 . ('f0 -> 'g0) -> 'f0 option -> 'g0 option =
  fun f0  -> function | None  -> None | Some x0 -> Some (f0 x0)

and copy_longident : From.Longident.t -> To.Longident.t = function
  | From.Longident.Lident x0 ->
      To.Longident.Lident x0
  | From.Longident.Ldot (x0,x1) ->
      To.Longident.Ldot
        ((copy_longident x0), x1)
  | From.Longident.Lapply (x0,x1) ->
      To.Longident.Lapply
        ((copy_longident x0), (copy_longident x1))

and copy_loc :
  'f0 'g0 .
    ('f0 -> 'g0) ->
      'f0 From.Asttypes.loc -> 'g0 To.Asttypes.loc
  =
  fun f0  ->
    fun
      { From.Asttypes.txt = txt;
        From.Asttypes.loc = loc }
       ->
      {
        To.Asttypes.txt = (f0 txt);
        To.Asttypes.loc = copy_location loc
      }

and copy_location :
  From.Location.t -> To.Location.t =
  fun
    { From.Location.loc_start = loc_start;
      From.Location.loc_end = loc_end;
      From.Location.loc_ghost = loc_ghost }
     ->
    {
      To.Location.loc_start = (copy_Lexing_position loc_start);
      To.Location.loc_end = (copy_Lexing_position loc_end);
      To.Location.loc_ghost = (copy_bool loc_ghost)
    }

and copy_bool : bool -> bool = function | false  -> false | true  -> true

and copy_Lexing_position : Lexing.position -> Lexing.position =
  fun
    { Lexing.pos_fname = pos_fname; Lexing.pos_lnum = pos_lnum;
      Lexing.pos_bol = pos_bol; Lexing.pos_cnum = pos_cnum }
     ->
    {
      Lexing.pos_fname = pos_fname;
      Lexing.pos_lnum = pos_lnum;
      Lexing.pos_bol = pos_bol;
      Lexing.pos_cnum = pos_cnum
    }

and type_declarations recflag types =
  match
    (recflag, List.map copy_type_declaration types)
  with
  | From.Asttypes.Recursive, types -> types
  | From.Asttypes.Nonrecursive, [] -> []
  | From.Asttypes.Nonrecursive, (x :: xs) ->
      let pos = {Lexing. pos_fname = "_none_"; pos_lnum = 1;
                 pos_bol = 0; pos_cnum = -1} in
      let loc = {To.Location. loc_start = pos; loc_end = pos;
                 loc_ghost = true} in
      let ptype_attributes =
        ({To.Asttypes.txt = "nonrec"; loc}, To.Parsetree.PStr []) ::
        x.To.Parsetree.ptype_attributes
      in
      {x with To.Parsetree.ptype_attributes} :: xs

let rec copy_out_phrase :
  From.Outcometree.out_phrase -> To.Outcometree.out_phrase =
  function
  | From.Outcometree.Ophr_eval (x0,x1) ->
      To.Outcometree.Ophr_eval
        ((copy_out_value x0),
          (copy_out_type x1))
  | From.Outcometree.Ophr_signature x0 ->
      To.Outcometree.Ophr_signature
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_out_sig_item x0),
                (copy_option copy_out_value x1))) x0)
  | From.Outcometree.Ophr_exception x0 ->
      To.Outcometree.Ophr_exception
        (let (x0,x1) = x0  in
         ((copy_exn x0), (copy_out_value x1)))

and copy_exn : exn -> exn = fun x  -> x

and copy_out_sig_item :
  From.Outcometree.out_sig_item -> To.Outcometree.out_sig_item =
  function
  | From.Outcometree.Osig_class (x0,x1,x2,x3,x4) ->
      To.Outcometree.Osig_class
        ((copy_bool x0), x1,
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))
             x2), (copy_out_class_type x3),
          (copy_out_rec_status x4))
  | From.Outcometree.Osig_class_type (x0,x1,x2,x3,x4) ->
      To.Outcometree.Osig_class_type
        ((copy_bool x0), x1,
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))
             x2), (copy_out_class_type x3),
          (copy_out_rec_status x4))
  | From.Outcometree.Osig_typext (x0,x1) ->
      To.Outcometree.Osig_typext
        ((copy_out_extension_constructor x0),
          (copy_out_ext_status x1))
  | From.Outcometree.Osig_modtype (x0,x1) ->
      To.Outcometree.Osig_modtype
        (x0, (copy_out_module_type x1))
  | From.Outcometree.Osig_module (x0,x1,x2) ->
      To.Outcometree.Osig_module
        (x0, (copy_out_module_type x1),
          (copy_out_rec_status x2))
  | From.Outcometree.Osig_type (x0,x1) ->
      To.Outcometree.Osig_type
        ((copy_out_type_decl x0),
          (copy_out_rec_status x1))
  | From.Outcometree.Osig_value x0 -> copy_out_val_decl x0
  | From.Outcometree.Osig_ellipsis ->
      To.Outcometree.Osig_value ("...", To.Outcometree.Otyp_abstract, [])

and copy_out_val_decl :
  From.Outcometree.out_val_decl -> To.Outcometree.out_sig_item =
  fun
    { From.Outcometree.oval_name = oval_name;
      From.Outcometree.oval_type = oval_type;
      From.Outcometree.oval_prims = oval_prims;
      From.Outcometree.oval_attributes = _ }
     ->
       To.Outcometree.Osig_value (
         oval_name,
         copy_out_type oval_type,
         List.map (fun x  -> x) oval_prims
       )

and copy_out_type_decl :
  From.Outcometree.out_type_decl -> To.Outcometree.out_type_decl =
  fun
    { From.Outcometree.otype_name = otype_name;
      From.Outcometree.otype_params = otype_params;
      From.Outcometree.otype_type = otype_type;
      From.Outcometree.otype_private = otype_private;
      From.Outcometree.otype_immediate = _;
      From.Outcometree.otype_cstrs = otype_cstrs }
     ->
    {
      To.Outcometree.otype_name = otype_name;
      To.Outcometree.otype_params =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))
           otype_params);
      To.Outcometree.otype_type =
        (copy_out_type otype_type);
      To.Outcometree.otype_private =
        (copy_From_Asttypes_private_flag otype_private);
      (*To.Outcometree.otype_immediate = (copy_bool otype_immediate);*)
      To.Outcometree.otype_cstrs =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_out_type x0),
                (copy_out_type x1))) otype_cstrs)
    }

and copy_out_module_type :
  From.Outcometree.out_module_type -> To.Outcometree.out_module_type
  =
  function
  | From.Outcometree.Omty_abstract  -> To.Outcometree.Omty_abstract
  | From.Outcometree.Omty_functor (x0,x1,x2) ->
      To.Outcometree.Omty_functor
        (x0, (copy_option copy_out_module_type x1),
          (copy_out_module_type x2))
  | From.Outcometree.Omty_ident x0 ->
      To.Outcometree.Omty_ident (copy_out_ident x0)
  | From.Outcometree.Omty_signature x0 ->
      To.Outcometree.Omty_signature
        (List.map copy_out_sig_item x0)
  | From.Outcometree.Omty_alias x0 ->
      To.Outcometree.Omty_alias (copy_out_ident x0)

and copy_out_ext_status :
  From.Outcometree.out_ext_status -> To.Outcometree.out_ext_status =
  function
  | From.Outcometree.Oext_first  -> To.Outcometree.Oext_first
  | From.Outcometree.Oext_next  -> To.Outcometree.Oext_next
  | From.Outcometree.Oext_exception  -> To.Outcometree.Oext_exception

and copy_out_extension_constructor :
  From.Outcometree.out_extension_constructor ->
    To.Outcometree.out_extension_constructor
  =
  fun
    { From.Outcometree.oext_name = oext_name;
      From.Outcometree.oext_type_name = oext_type_name;
      From.Outcometree.oext_type_params = oext_type_params;
      From.Outcometree.oext_args = oext_args;
      From.Outcometree.oext_ret_type = oext_ret_type;
      From.Outcometree.oext_private = oext_private }
     ->
    {
      To.Outcometree.oext_name = oext_name;
      To.Outcometree.oext_type_name = oext_type_name;
      To.Outcometree.oext_type_params =
        (List.map (fun x  -> x) oext_type_params);
      To.Outcometree.oext_args =
        (List.map copy_out_type oext_args);
      To.Outcometree.oext_ret_type =
        (copy_option copy_out_type oext_ret_type);
      To.Outcometree.oext_private =
        (copy_From_Asttypes_private_flag oext_private)
    }

and copy_From_Asttypes_private_flag :
  From.Asttypes.private_flag -> To.Asttypes.private_flag =
  function
  | From.Asttypes.Private  -> To.Asttypes.Private
  | From.Asttypes.Public  -> To.Asttypes.Public

and copy_out_rec_status :
  From.Outcometree.out_rec_status -> To.Outcometree.out_rec_status =
  function
  | From.Outcometree.Orec_not  -> To.Outcometree.Orec_not
  | From.Outcometree.Orec_first  -> To.Outcometree.Orec_first
  | From.Outcometree.Orec_next  -> To.Outcometree.Orec_next

and copy_out_class_type :
  From.Outcometree.out_class_type -> To.Outcometree.out_class_type =
  function
  | From.Outcometree.Octy_constr (x0,x1) ->
      To.Outcometree.Octy_constr
        ((copy_out_ident x0),
          (List.map copy_out_type x1))
  | From.Outcometree.Octy_arrow (x0,x1,x2) ->
      To.Outcometree.Octy_arrow
        (x0, (copy_out_type x1),
          (copy_out_class_type x2))
  | From.Outcometree.Octy_signature (x0,x1) ->
      To.Outcometree.Octy_signature
        ((copy_option copy_out_type x0),
          (List.map copy_out_class_sig_item x1))

and copy_out_class_sig_item :
  From.Outcometree.out_class_sig_item ->
    To.Outcometree.out_class_sig_item
  =
  function
  | From.Outcometree.Ocsg_constraint (x0,x1) ->
      To.Outcometree.Ocsg_constraint
        ((copy_out_type x0),
          (copy_out_type x1))
  | From.Outcometree.Ocsg_method (x0,x1,x2,x3) ->
      To.Outcometree.Ocsg_method
        (x0, (copy_bool x1), (copy_bool x2),
          (copy_out_type x3))
  | From.Outcometree.Ocsg_value (x0,x1,x2,x3) ->
      To.Outcometree.Ocsg_value
        (x0, (copy_bool x1), (copy_bool x2),
          (copy_out_type x3))

and copy_out_type :
  From.Outcometree.out_type -> To.Outcometree.out_type =
  function
  | From.Outcometree.Otyp_abstract  -> To.Outcometree.Otyp_abstract
  | From.Outcometree.Otyp_open  -> To.Outcometree.Otyp_open
  | From.Outcometree.Otyp_alias (x0,x1) ->
      To.Outcometree.Otyp_alias
        ((copy_out_type x0), x1)
  | From.Outcometree.Otyp_arrow (x0,x1,x2) ->
      To.Outcometree.Otyp_arrow
        (x0, (copy_out_type x1),
          (copy_out_type x2))
  | From.Outcometree.Otyp_class (x0,x1,x2) ->
      To.Outcometree.Otyp_class
        ((copy_bool x0), (copy_out_ident x1),
          (List.map copy_out_type x2))
  | From.Outcometree.Otyp_constr (x0,x1) ->
      To.Outcometree.Otyp_constr
        ((copy_out_ident x0),
          (List.map copy_out_type x1))
  | From.Outcometree.Otyp_manifest (x0,x1) ->
      To.Outcometree.Otyp_manifest
        ((copy_out_type x0),
          (copy_out_type x1))
  | From.Outcometree.Otyp_object (x0,x1) ->
      To.Outcometree.Otyp_object
        ((List.map
            (fun x  ->
               let (x0,x1) = x  in
               (x0, (copy_out_type x1))) x0),
          (copy_option copy_bool x1))
  | From.Outcometree.Otyp_record x0 ->
      To.Outcometree.Otyp_record
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (copy_bool x1), (copy_out_type x2)))
           x0)
  | From.Outcometree.Otyp_stuff x0 -> To.Outcometree.Otyp_stuff x0
  | From.Outcometree.Otyp_sum x0 ->
      To.Outcometree.Otyp_sum
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (List.map copy_out_type x1),
                (copy_option copy_out_type x2))) x0)
  | From.Outcometree.Otyp_tuple x0 ->
      To.Outcometree.Otyp_tuple
        (List.map copy_out_type x0)
  | From.Outcometree.Otyp_var (x0,x1) ->
      To.Outcometree.Otyp_var ((copy_bool x0), x1)
  | From.Outcometree.Otyp_variant (x0,x1,x2,x3) ->
      To.Outcometree.Otyp_variant
        ((copy_bool x0), (copy_out_variant x1),
          (copy_bool x2),
          (copy_option (fun x  -> List.map (fun x  -> x) x) x3))
  | From.Outcometree.Otyp_poly (x0,x1) ->
      To.Outcometree.Otyp_poly
        ((List.map (fun x  -> x) x0), (copy_out_type x1))
  | From.Outcometree.Otyp_module (x0,x1,x2) ->
      To.Outcometree.Otyp_module
        (x0, (List.map (fun x  -> x) x1),
          (List.map copy_out_type x2))
  | From.Outcometree.Otyp_attribute (_x0,_x1) ->
      To.Outcometree.Otyp_abstract
      (*To.Outcometree.Otyp_attribute
        ((copy_out_type x0),
          (copy_out_attribute x1))*)

(*and copy_out_attribute :
  From.Outcometree.out_attribute -> To.Outcometree.out_attribute =
  fun { From.Outcometree.oattr_name = oattr_name }  ->
    { To.Outcometree.oattr_name = oattr_name }*)

and copy_out_variant :
  From.Outcometree.out_variant -> To.Outcometree.out_variant =
  function
  | From.Outcometree.Ovar_fields x0 ->
      To.Outcometree.Ovar_fields
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (copy_bool x1),
                (List.map copy_out_type x2))) x0)
  | From.Outcometree.Ovar_name (x0,x1) ->
      To.Outcometree.Ovar_name
        ((copy_out_ident x0),
          (List.map copy_out_type x1))

and copy_out_value :
  From.Outcometree.out_value -> To.Outcometree.out_value =
  function
  | From.Outcometree.Oval_array x0 ->
      To.Outcometree.Oval_array
        (List.map copy_out_value x0)
  | From.Outcometree.Oval_char x0 -> To.Outcometree.Oval_char x0
  | From.Outcometree.Oval_constr (x0,x1) ->
      To.Outcometree.Oval_constr
        ((copy_out_ident x0),
          (List.map copy_out_value x1))
  | From.Outcometree.Oval_ellipsis  -> To.Outcometree.Oval_ellipsis
  | From.Outcometree.Oval_float x0 ->
      To.Outcometree.Oval_float (copy_float x0)
  | From.Outcometree.Oval_int x0 -> To.Outcometree.Oval_int x0
  | From.Outcometree.Oval_int32 x0 -> To.Outcometree.Oval_int32 x0
  | From.Outcometree.Oval_int64 x0 -> To.Outcometree.Oval_int64 x0
  | From.Outcometree.Oval_nativeint x0 ->
      To.Outcometree.Oval_nativeint x0
  | From.Outcometree.Oval_list x0 ->
      To.Outcometree.Oval_list
        (List.map copy_out_value x0)
  | From.Outcometree.Oval_printer x0 ->
      To.Outcometree.Oval_printer x0
  | From.Outcometree.Oval_record x0 ->
      To.Outcometree.Oval_record
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_out_ident x0),
                (copy_out_value x1))) x0)
  | From.Outcometree.Oval_string x0 -> To.Outcometree.Oval_string x0
  | From.Outcometree.Oval_stuff x0 -> To.Outcometree.Oval_stuff x0
  | From.Outcometree.Oval_tuple x0 ->
      To.Outcometree.Oval_tuple
        (List.map copy_out_value x0)
  | From.Outcometree.Oval_variant (x0,x1) ->
      To.Outcometree.Oval_variant
        (x0, (copy_option copy_out_value x1))

and copy_float : float -> float = fun x  -> x

and copy_out_ident :
  From.Outcometree.out_ident -> To.Outcometree.out_ident =
  function
  | From.Outcometree.Oide_apply (x0,x1) ->
      To.Outcometree.Oide_apply
        ((copy_out_ident x0),
          (copy_out_ident x1))
  | From.Outcometree.Oide_dot (x0,x1) ->
      To.Outcometree.Oide_dot
        ((copy_out_ident x0), x1)
  | From.Outcometree.Oide_ident x0 -> To.Outcometree.Oide_ident x0

let rec copy_toplevel_phrase :
  From.Parsetree.toplevel_phrase -> To.Parsetree.toplevel_phrase =
  function
  | From.Parsetree.Ptop_def x0 ->
      To.Parsetree.Ptop_def (copy_structure x0)
  | From.Parsetree.Ptop_dir (x0,x1) ->
      To.Parsetree.Ptop_dir
        (x0, (copy_directive_argument x1))

and copy_directive_argument :
  From.Parsetree.directive_argument ->
    To.Parsetree.directive_argument
  =
  function
  | From.Parsetree.Pdir_none  -> To.Parsetree.Pdir_none
  | From.Parsetree.Pdir_string x0 -> To.Parsetree.Pdir_string x0
  | From.Parsetree.Pdir_int (x0,_x1) ->
      To.Parsetree.Pdir_int (int_of_string x0)
  | From.Parsetree.Pdir_ident x0 ->
      To.Parsetree.Pdir_ident (copy_longident x0)
  | From.Parsetree.Pdir_bool x0 ->
      To.Parsetree.Pdir_bool (copy_bool x0)

let copy_out_type_extension :
  From.Outcometree.out_type_extension -> To.Outcometree.out_type_extension =
  fun
    { From.Outcometree.otyext_name = otyext_name;
      From.Outcometree.otyext_params = otyext_params;
      From.Outcometree.otyext_constructors = otyext_constructors;
      From.Outcometree.otyext_private = otyext_private }
     ->
    {
      To.Outcometree.otyext_name = otyext_name;
      To.Outcometree.otyext_params =
        (List.map (fun x  -> x) otyext_params);
      To.Outcometree.otyext_constructors =
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (List.map copy_out_type x1),
                (copy_option copy_out_type x2)))
           otyext_constructors);
      To.Outcometree.otyext_private =
        (copy_private_flag otyext_private)
    }

let copy_cases x = List.map copy_case x
let copy_pat = copy_pattern
let copy_expr = copy_expression
let copy_typ = copy_core_type

end
module Migrate_parsetree_402_403
= struct
#1 "migrate_parsetree_402_403.ml"
# 1 "src/migrate_parsetree_402_403.ml"
# 1 "src/migrate_parsetree_402_403.ml"
# 1 "src/migrate_parsetree_402_403.ml"
# 1 "src/migrate_parsetree_402_403.ml"
# 1 "src/migrate_parsetree_402_403.ml"
# 1 "src/migrate_parsetree_402_403.ml"
# 1 "src/migrate_parsetree_402_403.ml"
# 1 "src/migrate_parsetree_402_403.ml"
# 1 "src/migrate_parsetree_402_403.ml"
# 1 "src/migrate_parsetree_402_403.ml"
# 1 "src/migrate_parsetree_402_403.ml"
# 1 "src/migrate_parsetree_402_403.ml"
# 1 "src/migrate_parsetree_402_403.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

include Migrate_parsetree_402_403_migrate

(*$ open Printf
    let fields = [
      "attribute"; "attributes"; "case"; "cases"; "class_declaration";
      "class_description"; "class_expr"; "class_field"; "class_signature";
      "class_structure"; "class_type"; "class_type_declaration";
      "class_type_field"; "constructor_declaration"; "expr"; "extension";
      "extension_constructor"; "include_declaration"; "include_description";
      "label_declaration"; "location"; "module_binding"; "module_declaration";
      "module_expr"; "module_type"; "module_type_declaration";
      "open_description"; "pat"; "signature"; "signature_item"; "structure";
      "structure_item"; "typ"; "type_declaration"; "type_extension";
      "type_kind"; "value_binding"; "value_description";
      "with_constraint"
    ]
  let foreach_field f =
    printf "\n";
    List.iter f fields
*)(*$*)

let copy_mapper = fun
  ({ From.Ast_mapper.
     (*$ foreach_field (printf "%s;\n")*)
     attribute;
     attributes;
     case;
     cases;
     class_declaration;
     class_description;
     class_expr;
     class_field;
     class_signature;
     class_structure;
     class_type;
     class_type_declaration;
     class_type_field;
     constructor_declaration;
     expr;
     extension;
     extension_constructor;
     include_declaration;
     include_description;
     label_declaration;
     location;
     module_binding;
     module_declaration;
     module_expr;
     module_type;
     module_type_declaration;
     open_description;
     pat;
     signature;
     signature_item;
     structure;
     structure_item;
     typ;
     type_declaration;
     type_extension;
     type_kind;
     value_binding;
     value_description;
     with_constraint;
     (*$*)
     payload
   } as mapper) ->
  let module R = Migrate_parsetree_403_402_migrate in
  {
    To.Ast_mapper.
    (*$ foreach_field (fun s ->
          printf
          "%s = (fun _ x -> copy_%s (%s mapper (R.copy_%s x)));\n" s s s s)
    *)
    attribute = (fun _ x -> copy_attribute (attribute mapper (R.copy_attribute x)));
    attributes = (fun _ x -> copy_attributes (attributes mapper (R.copy_attributes x)));
    case = (fun _ x -> copy_case (case mapper (R.copy_case x)));
    cases = (fun _ x -> copy_cases (cases mapper (R.copy_cases x)));
    class_declaration = (fun _ x -> copy_class_declaration (class_declaration mapper (R.copy_class_declaration x)));
    class_description = (fun _ x -> copy_class_description (class_description mapper (R.copy_class_description x)));
    class_expr = (fun _ x -> copy_class_expr (class_expr mapper (R.copy_class_expr x)));
    class_field = (fun _ x -> copy_class_field (class_field mapper (R.copy_class_field x)));
    class_signature = (fun _ x -> copy_class_signature (class_signature mapper (R.copy_class_signature x)));
    class_structure = (fun _ x -> copy_class_structure (class_structure mapper (R.copy_class_structure x)));
    class_type = (fun _ x -> copy_class_type (class_type mapper (R.copy_class_type x)));
    class_type_declaration = (fun _ x -> copy_class_type_declaration (class_type_declaration mapper (R.copy_class_type_declaration x)));
    class_type_field = (fun _ x -> copy_class_type_field (class_type_field mapper (R.copy_class_type_field x)));
    constructor_declaration = (fun _ x -> copy_constructor_declaration (constructor_declaration mapper (R.copy_constructor_declaration x)));
    expr = (fun _ x -> copy_expr (expr mapper (R.copy_expr x)));
    extension = (fun _ x -> copy_extension (extension mapper (R.copy_extension x)));
    extension_constructor = (fun _ x -> copy_extension_constructor (extension_constructor mapper (R.copy_extension_constructor x)));
    include_declaration = (fun _ x -> copy_include_declaration (include_declaration mapper (R.copy_include_declaration x)));
    include_description = (fun _ x -> copy_include_description (include_description mapper (R.copy_include_description x)));
    label_declaration = (fun _ x -> copy_label_declaration (label_declaration mapper (R.copy_label_declaration x)));
    location = (fun _ x -> copy_location (location mapper (R.copy_location x)));
    module_binding = (fun _ x -> copy_module_binding (module_binding mapper (R.copy_module_binding x)));
    module_declaration = (fun _ x -> copy_module_declaration (module_declaration mapper (R.copy_module_declaration x)));
    module_expr = (fun _ x -> copy_module_expr (module_expr mapper (R.copy_module_expr x)));
    module_type = (fun _ x -> copy_module_type (module_type mapper (R.copy_module_type x)));
    module_type_declaration = (fun _ x -> copy_module_type_declaration (module_type_declaration mapper (R.copy_module_type_declaration x)));
    open_description = (fun _ x -> copy_open_description (open_description mapper (R.copy_open_description x)));
    pat = (fun _ x -> copy_pat (pat mapper (R.copy_pat x)));
    signature = (fun _ x -> copy_signature (signature mapper (R.copy_signature x)));
    signature_item = (fun _ x -> copy_signature_item (signature_item mapper (R.copy_signature_item x)));
    structure = (fun _ x -> copy_structure (structure mapper (R.copy_structure x)));
    structure_item = (fun _ x -> copy_structure_item (structure_item mapper (R.copy_structure_item x)));
    typ = (fun _ x -> copy_typ (typ mapper (R.copy_typ x)));
    type_declaration = (fun _ x -> copy_type_declaration (type_declaration mapper (R.copy_type_declaration x)));
    type_extension = (fun _ x -> copy_type_extension (type_extension mapper (R.copy_type_extension x)));
    type_kind = (fun _ x -> copy_type_kind (type_kind mapper (R.copy_type_kind x)));
    value_binding = (fun _ x -> copy_value_binding (value_binding mapper (R.copy_value_binding x)));
    value_description = (fun _ x -> copy_value_description (value_description mapper (R.copy_value_description x)));
    with_constraint = (fun _ x -> copy_with_constraint (with_constraint mapper (R.copy_with_constraint x)));
    (*$*)
    payload = (fun _ x -> copy_payload (payload mapper (R.copy_payload Location.none x)))
  }

end
module Migrate_parsetree_403_402
= struct
#1 "migrate_parsetree_403_402.ml"
# 1 "src/migrate_parsetree_403_402.ml"
# 1 "src/migrate_parsetree_403_402.ml"
# 1 "src/migrate_parsetree_403_402.ml"
# 1 "src/migrate_parsetree_403_402.ml"
# 1 "src/migrate_parsetree_403_402.ml"
# 1 "src/migrate_parsetree_403_402.ml"
# 1 "src/migrate_parsetree_403_402.ml"
# 1 "src/migrate_parsetree_403_402.ml"
# 1 "src/migrate_parsetree_403_402.ml"
# 1 "src/migrate_parsetree_403_402.ml"
# 1 "src/migrate_parsetree_403_402.ml"
# 1 "src/migrate_parsetree_403_402.ml"
# 1 "src/migrate_parsetree_403_402.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

include Migrate_parsetree_403_402_migrate

(*$ open Printf
    let fields = [
      "attribute"; "attributes"; "case"; "cases"; "class_declaration";
      "class_description"; "class_expr"; "class_field"; "class_signature";
      "class_structure"; "class_type"; "class_type_declaration";
      "class_type_field"; "constructor_declaration"; "expr"; "extension";
      "extension_constructor"; "include_declaration"; "include_description";
      "label_declaration"; "location"; "module_binding"; "module_declaration";
      "module_expr"; "module_type"; "module_type_declaration";
      "open_description"; "pat"; "signature"; "signature_item"; "structure";
      "structure_item"; "typ"; "type_declaration"; "type_extension";
      "type_kind"; "value_binding"; "value_description";
      "with_constraint"
    ]
  let foreach_field f =
    printf "\n";
    List.iter f fields
*)(*$*)

let copy_mapper = fun
  ({ From.Ast_mapper.
     (*$ foreach_field (printf "%s;\n")*)
     attribute;
     attributes;
     case;
     cases;
     class_declaration;
     class_description;
     class_expr;
     class_field;
     class_signature;
     class_structure;
     class_type;
     class_type_declaration;
     class_type_field;
     constructor_declaration;
     expr;
     extension;
     extension_constructor;
     include_declaration;
     include_description;
     label_declaration;
     location;
     module_binding;
     module_declaration;
     module_expr;
     module_type;
     module_type_declaration;
     open_description;
     pat;
     signature;
     signature_item;
     structure;
     structure_item;
     typ;
     type_declaration;
     type_extension;
     type_kind;
     value_binding;
     value_description;
     with_constraint;
     (*$*)
     payload
   } as mapper) ->
  let module R = Migrate_parsetree_402_403_migrate in
  {
    To.Ast_mapper.
    (*$ foreach_field (fun s ->
          printf
          "%s = (fun _ x -> copy_%s (%s mapper (R.copy_%s x)));\n" s s s s)
    *)
    attribute = (fun _ x -> copy_attribute (attribute mapper (R.copy_attribute x)));
    attributes = (fun _ x -> copy_attributes (attributes mapper (R.copy_attributes x)));
    case = (fun _ x -> copy_case (case mapper (R.copy_case x)));
    cases = (fun _ x -> copy_cases (cases mapper (R.copy_cases x)));
    class_declaration = (fun _ x -> copy_class_declaration (class_declaration mapper (R.copy_class_declaration x)));
    class_description = (fun _ x -> copy_class_description (class_description mapper (R.copy_class_description x)));
    class_expr = (fun _ x -> copy_class_expr (class_expr mapper (R.copy_class_expr x)));
    class_field = (fun _ x -> copy_class_field (class_field mapper (R.copy_class_field x)));
    class_signature = (fun _ x -> copy_class_signature (class_signature mapper (R.copy_class_signature x)));
    class_structure = (fun _ x -> copy_class_structure (class_structure mapper (R.copy_class_structure x)));
    class_type = (fun _ x -> copy_class_type (class_type mapper (R.copy_class_type x)));
    class_type_declaration = (fun _ x -> copy_class_type_declaration (class_type_declaration mapper (R.copy_class_type_declaration x)));
    class_type_field = (fun _ x -> copy_class_type_field (class_type_field mapper (R.copy_class_type_field x)));
    constructor_declaration = (fun _ x -> copy_constructor_declaration (constructor_declaration mapper (R.copy_constructor_declaration x)));
    expr = (fun _ x -> copy_expr (expr mapper (R.copy_expr x)));
    extension = (fun _ x -> copy_extension (extension mapper (R.copy_extension x)));
    extension_constructor = (fun _ x -> copy_extension_constructor (extension_constructor mapper (R.copy_extension_constructor x)));
    include_declaration = (fun _ x -> copy_include_declaration (include_declaration mapper (R.copy_include_declaration x)));
    include_description = (fun _ x -> copy_include_description (include_description mapper (R.copy_include_description x)));
    label_declaration = (fun _ x -> copy_label_declaration (label_declaration mapper (R.copy_label_declaration x)));
    location = (fun _ x -> copy_location (location mapper (R.copy_location x)));
    module_binding = (fun _ x -> copy_module_binding (module_binding mapper (R.copy_module_binding x)));
    module_declaration = (fun _ x -> copy_module_declaration (module_declaration mapper (R.copy_module_declaration x)));
    module_expr = (fun _ x -> copy_module_expr (module_expr mapper (R.copy_module_expr x)));
    module_type = (fun _ x -> copy_module_type (module_type mapper (R.copy_module_type x)));
    module_type_declaration = (fun _ x -> copy_module_type_declaration (module_type_declaration mapper (R.copy_module_type_declaration x)));
    open_description = (fun _ x -> copy_open_description (open_description mapper (R.copy_open_description x)));
    pat = (fun _ x -> copy_pat (pat mapper (R.copy_pat x)));
    signature = (fun _ x -> copy_signature (signature mapper (R.copy_signature x)));
    signature_item = (fun _ x -> copy_signature_item (signature_item mapper (R.copy_signature_item x)));
    structure = (fun _ x -> copy_structure (structure mapper (R.copy_structure x)));
    structure_item = (fun _ x -> copy_structure_item (structure_item mapper (R.copy_structure_item x)));
    typ = (fun _ x -> copy_typ (typ mapper (R.copy_typ x)));
    type_declaration = (fun _ x -> copy_type_declaration (type_declaration mapper (R.copy_type_declaration x)));
    type_extension = (fun _ x -> copy_type_extension (type_extension mapper (R.copy_type_extension x)));
    type_kind = (fun _ x -> copy_type_kind (type_kind mapper (R.copy_type_kind x)));
    value_binding = (fun _ x -> copy_value_binding (value_binding mapper (R.copy_value_binding x)));
    value_description = (fun _ x -> copy_value_description (value_description mapper (R.copy_value_description x)));
    with_constraint = (fun _ x -> copy_with_constraint (with_constraint mapper (R.copy_with_constraint x)));
    (*$*)
    payload = (fun _ x -> copy_payload Location.none (payload mapper (R.copy_payload x)))
  }

end
module Migrate_parsetree_403_404_migrate
= struct
#1 "migrate_parsetree_403_404_migrate.ml"
# 1 "src/migrate_parsetree_403_404_migrate.ml"
# 1 "src/migrate_parsetree_403_404_migrate.ml"
# 1 "src/migrate_parsetree_403_404_migrate.ml"
# 1 "src/migrate_parsetree_403_404_migrate.ml"
# 1 "src/migrate_parsetree_403_404_migrate.ml"
# 1 "src/migrate_parsetree_403_404_migrate.ml"
# 1 "src/migrate_parsetree_403_404_migrate.ml"
# 1 "src/migrate_parsetree_403_404_migrate.ml"
# 1 "src/migrate_parsetree_403_404_migrate.ml"
# 1 "src/migrate_parsetree_403_404_migrate.ml"
# 1 "src/migrate_parsetree_403_404_migrate.ml"
# 1 "src/migrate_parsetree_403_404_migrate.ml"
# 1 "src/migrate_parsetree_403_404_migrate.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*                         Alain Frisch, LexiFi                           *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

module From = Ast_403
module To = Ast_404

let rec copy_expression :
  From.Parsetree.expression ->
    To.Parsetree.expression
  =
  fun
    { From.Parsetree.pexp_desc = pexp_desc;
      From.Parsetree.pexp_loc = pexp_loc;
      From.Parsetree.pexp_attributes = pexp_attributes }
     ->
    {
      To.Parsetree.pexp_desc =
        (copy_expression_desc pexp_desc);
      To.Parsetree.pexp_loc =
        (copy_location pexp_loc);
      To.Parsetree.pexp_attributes =
        (copy_attributes pexp_attributes)
    }

and copy_expression_desc :
  From.Parsetree.expression_desc ->
    To.Parsetree.expression_desc
  =
  function
  | From.Parsetree.Pexp_ident x0 ->
      To.Parsetree.Pexp_ident
        (copy_loc copy_longident
           x0)
  | From.Parsetree.Pexp_constant x0 ->
      To.Parsetree.Pexp_constant
        (copy_constant x0)
  | From.Parsetree.Pexp_let (x0,x1,x2) ->
      To.Parsetree.Pexp_let
        ((copy_rec_flag x0),
          (List.map copy_value_binding x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_function x0 ->
      To.Parsetree.Pexp_function
        (List.map copy_case x0)
  | From.Parsetree.Pexp_fun (x0,x1,x2,x3) ->
      To.Parsetree.Pexp_fun
        ((copy_arg_label x0),
          (copy_option copy_expression x1),
          (copy_pattern x2),
          (copy_expression x3))
  | From.Parsetree.Pexp_apply (x0,x1) ->
      To.Parsetree.Pexp_apply
        ((copy_expression x0),
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                ((copy_arg_label x0),
                  (copy_expression x1))) x1))
  | From.Parsetree.Pexp_match (x0,x1) ->
      To.Parsetree.Pexp_match
        ((copy_expression x0),
          (List.map copy_case x1))
  | From.Parsetree.Pexp_try (x0,x1) ->
      To.Parsetree.Pexp_try
        ((copy_expression x0),
          (List.map copy_case x1))
  | From.Parsetree.Pexp_tuple x0 ->
      To.Parsetree.Pexp_tuple
        (List.map copy_expression x0)
  | From.Parsetree.Pexp_construct (x0,x1) ->
      To.Parsetree.Pexp_construct
        ((copy_loc
            copy_longident x0),
          (copy_option copy_expression x1))
  | From.Parsetree.Pexp_variant (x0,x1) ->
      To.Parsetree.Pexp_variant
        ((copy_label x0),
          (copy_option copy_expression x1))
  | From.Parsetree.Pexp_record (x0,x1) ->
      To.Parsetree.Pexp_record
        ((List.map
            (fun x  ->
               let (x0,x1) = x  in
               ((copy_loc
                   copy_longident x0),
                 (copy_expression x1))) x0),
          (copy_option copy_expression x1))
  | From.Parsetree.Pexp_field (x0,x1) ->
      To.Parsetree.Pexp_field
        ((copy_expression x0),
          (copy_loc
             copy_longident x1))
  | From.Parsetree.Pexp_setfield (x0,x1,x2) ->
      To.Parsetree.Pexp_setfield
        ((copy_expression x0),
          (copy_loc
             copy_longident x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_array x0 ->
      To.Parsetree.Pexp_array
        (List.map copy_expression x0)
  | From.Parsetree.Pexp_ifthenelse (x0,x1,x2) ->
      To.Parsetree.Pexp_ifthenelse
        ((copy_expression x0),
          (copy_expression x1),
          (copy_option copy_expression x2))
  | From.Parsetree.Pexp_sequence (x0,x1) ->
      To.Parsetree.Pexp_sequence
        ((copy_expression x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_while (x0,x1) ->
      To.Parsetree.Pexp_while
        ((copy_expression x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_for (x0,x1,x2,x3,x4) ->
      To.Parsetree.Pexp_for
        ((copy_pattern x0),
          (copy_expression x1),
          (copy_expression x2),
          (copy_direction_flag x3),
          (copy_expression x4))
  | From.Parsetree.Pexp_constraint (x0,x1) ->
      To.Parsetree.Pexp_constraint
        ((copy_expression x0),
          (copy_core_type x1))
  | From.Parsetree.Pexp_coerce (x0,x1,x2) ->
      To.Parsetree.Pexp_coerce
        ((copy_expression x0),
          (copy_option copy_core_type x1),
          (copy_core_type x2))
  | From.Parsetree.Pexp_send (x0,x1) ->
      To.Parsetree.Pexp_send
        ((copy_expression x0), x1)
  | From.Parsetree.Pexp_new x0 ->
      To.Parsetree.Pexp_new
        (copy_loc copy_longident
           x0)
  | From.Parsetree.Pexp_setinstvar (x0,x1) ->
      To.Parsetree.Pexp_setinstvar
        ((copy_loc (fun x  -> x) x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_override x0 ->
      To.Parsetree.Pexp_override
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_loc (fun x  -> x) x0),
                (copy_expression x1))) x0)
  | From.Parsetree.Pexp_letmodule (x0,x1,x2) ->
      To.Parsetree.Pexp_letmodule
        ((copy_loc (fun x  -> x) x0),
          (copy_module_expr x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_assert x0 ->
      To.Parsetree.Pexp_assert
        (copy_expression x0)
  | From.Parsetree.Pexp_lazy x0 ->
      To.Parsetree.Pexp_lazy
        (copy_expression x0)
  | From.Parsetree.Pexp_poly (x0,x1) ->
      To.Parsetree.Pexp_poly
        ((copy_expression x0),
          (copy_option copy_core_type x1))
  | From.Parsetree.Pexp_object x0 ->
      To.Parsetree.Pexp_object
        (copy_class_structure x0)
  | From.Parsetree.Pexp_newtype (x0,x1) ->
      To.Parsetree.Pexp_newtype
        (x0, (copy_expression x1))
  | From.Parsetree.Pexp_pack x0 ->
      To.Parsetree.Pexp_pack
        (copy_module_expr x0)
  | From.Parsetree.Pexp_open (x0,x1,x2) ->
      To.Parsetree.Pexp_open
        ((copy_override_flag x0),
          (copy_loc
             copy_longident x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_extension x0 ->
      To.Parsetree.Pexp_extension
        (copy_extension x0)
  | From.Parsetree.Pexp_unreachable  ->
      To.Parsetree.Pexp_unreachable

and copy_direction_flag :
  From.Asttypes.direction_flag ->
    To.Asttypes.direction_flag
  =
  function
  | From.Asttypes.Upto  -> To.Asttypes.Upto
  | From.Asttypes.Downto  -> To.Asttypes.Downto

and copy_case :
  From.Parsetree.case -> To.Parsetree.case =
  fun
    { From.Parsetree.pc_lhs = pc_lhs;
      From.Parsetree.pc_guard = pc_guard;
      From.Parsetree.pc_rhs = pc_rhs }
     ->
    {
      To.Parsetree.pc_lhs =
        (copy_pattern pc_lhs);
      To.Parsetree.pc_guard =
        (copy_option copy_expression pc_guard);
      To.Parsetree.pc_rhs =
        (copy_expression pc_rhs)
    }

and copy_value_binding :
  From.Parsetree.value_binding ->
    To.Parsetree.value_binding
  =
  fun
    { From.Parsetree.pvb_pat = pvb_pat;
      From.Parsetree.pvb_expr = pvb_expr;
      From.Parsetree.pvb_attributes = pvb_attributes;
      From.Parsetree.pvb_loc = pvb_loc }
     ->
    {
      To.Parsetree.pvb_pat =
        (copy_pattern pvb_pat);
      To.Parsetree.pvb_expr =
        (copy_expression pvb_expr);
      To.Parsetree.pvb_attributes =
        (copy_attributes pvb_attributes);
      To.Parsetree.pvb_loc =
        (copy_location pvb_loc)
    }

and copy_pattern :
  From.Parsetree.pattern -> To.Parsetree.pattern =
  fun
    { From.Parsetree.ppat_desc = ppat_desc;
      From.Parsetree.ppat_loc = ppat_loc;
      From.Parsetree.ppat_attributes = ppat_attributes }
     ->
    {
      To.Parsetree.ppat_desc =
        (copy_pattern_desc ppat_desc);
      To.Parsetree.ppat_loc =
        (copy_location ppat_loc);
      To.Parsetree.ppat_attributes =
        (copy_attributes ppat_attributes)
    }

and copy_pattern_desc :
  From.Parsetree.pattern_desc ->
    To.Parsetree.pattern_desc
  =
  function
  | From.Parsetree.Ppat_any  ->
      To.Parsetree.Ppat_any
  | From.Parsetree.Ppat_var x0 ->
      To.Parsetree.Ppat_var
        (copy_loc (fun x  -> x) x0)
  | From.Parsetree.Ppat_alias (x0,x1) ->
      To.Parsetree.Ppat_alias
        ((copy_pattern x0),
          (copy_loc (fun x  -> x) x1))
  | From.Parsetree.Ppat_constant x0 ->
      To.Parsetree.Ppat_constant
        (copy_constant x0)
  | From.Parsetree.Ppat_interval (x0,x1) ->
      To.Parsetree.Ppat_interval
        ((copy_constant x0),
          (copy_constant x1))
  | From.Parsetree.Ppat_tuple x0 ->
      To.Parsetree.Ppat_tuple
        (List.map copy_pattern x0)
  | From.Parsetree.Ppat_construct (x0,x1) ->
      To.Parsetree.Ppat_construct
        ((copy_loc
            copy_longident x0),
          (copy_option copy_pattern x1))
  | From.Parsetree.Ppat_variant (x0,x1) ->
      To.Parsetree.Ppat_variant
        ((copy_label x0),
          (copy_option copy_pattern x1))
  | From.Parsetree.Ppat_record (x0,x1) ->
      To.Parsetree.Ppat_record
        ((List.map
            (fun x  ->
               let (x0,x1) = x  in
               ((copy_loc
                   copy_longident x0),
                 (copy_pattern x1))) x0),
          (copy_closed_flag x1))
  | From.Parsetree.Ppat_array x0 ->
      To.Parsetree.Ppat_array
        (List.map copy_pattern x0)
  | From.Parsetree.Ppat_or (x0,x1) ->
      To.Parsetree.Ppat_or
        ((copy_pattern x0),
          (copy_pattern x1))
  | From.Parsetree.Ppat_constraint (x0,x1) ->
      To.Parsetree.Ppat_constraint
        ((copy_pattern x0),
          (copy_core_type x1))
  | From.Parsetree.Ppat_type x0 ->
      To.Parsetree.Ppat_type
        (copy_loc copy_longident
           x0)
  | From.Parsetree.Ppat_lazy x0 ->
      To.Parsetree.Ppat_lazy
        (copy_pattern x0)
  | From.Parsetree.Ppat_unpack x0 ->
      To.Parsetree.Ppat_unpack
        (copy_loc (fun x  -> x) x0)
  | From.Parsetree.Ppat_exception x0 ->
      To.Parsetree.Ppat_exception
        (copy_pattern x0)
  | From.Parsetree.Ppat_extension x0 ->
      To.Parsetree.Ppat_extension
        (copy_extension x0)

and copy_core_type :
  From.Parsetree.core_type ->
    To.Parsetree.core_type
  =
  fun
    { From.Parsetree.ptyp_desc = ptyp_desc;
      From.Parsetree.ptyp_loc = ptyp_loc;
      From.Parsetree.ptyp_attributes = ptyp_attributes }
     ->
    {
      To.Parsetree.ptyp_desc =
        (copy_core_type_desc ptyp_desc);
      To.Parsetree.ptyp_loc =
        (copy_location ptyp_loc);
      To.Parsetree.ptyp_attributes =
        (copy_attributes ptyp_attributes)
    }

and copy_core_type_desc :
  From.Parsetree.core_type_desc ->
    To.Parsetree.core_type_desc
  =
  function
  | From.Parsetree.Ptyp_any  ->
      To.Parsetree.Ptyp_any
  | From.Parsetree.Ptyp_var x0 ->
      To.Parsetree.Ptyp_var x0
  | From.Parsetree.Ptyp_arrow (x0,x1,x2) ->
      To.Parsetree.Ptyp_arrow
        ((copy_arg_label x0),
          (copy_core_type x1),
          (copy_core_type x2))
  | From.Parsetree.Ptyp_tuple x0 ->
      To.Parsetree.Ptyp_tuple
        (List.map copy_core_type x0)
  | From.Parsetree.Ptyp_constr (x0,x1) ->
      To.Parsetree.Ptyp_constr
        ((copy_loc
            copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Ptyp_object (x0,x1) ->
      To.Parsetree.Ptyp_object
        ((List.map
            (fun x  ->
               let (x0,x1,x2) = x  in
               (x0, (copy_attributes x1),
                 (copy_core_type x2))) x0),
          (copy_closed_flag x1))
  | From.Parsetree.Ptyp_class (x0,x1) ->
      To.Parsetree.Ptyp_class
        ((copy_loc
            copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Ptyp_alias (x0,x1) ->
      To.Parsetree.Ptyp_alias
        ((copy_core_type x0), x1)
  | From.Parsetree.Ptyp_variant (x0,x1,x2) ->
      To.Parsetree.Ptyp_variant
        ((List.map copy_row_field x0),
          (copy_closed_flag x1),
          (copy_option
             (fun x  -> List.map copy_label x) x2))
  | From.Parsetree.Ptyp_poly (x0,x1) ->
      To.Parsetree.Ptyp_poly
        ((List.map (fun x  -> x) x0),
          (copy_core_type x1))
  | From.Parsetree.Ptyp_package x0 ->
      To.Parsetree.Ptyp_package
        (copy_package_type x0)
  | From.Parsetree.Ptyp_extension x0 ->
      To.Parsetree.Ptyp_extension
        (copy_extension x0)

and copy_package_type :
  From.Parsetree.package_type ->
    To.Parsetree.package_type
  =
  fun x  ->
    let (x0,x1) = x  in
    ((copy_loc copy_longident x0),
      (List.map
         (fun x  ->
            let (x0,x1) = x  in
            ((copy_loc
                copy_longident x0),
              (copy_core_type x1))) x1))

and copy_row_field :
  From.Parsetree.row_field ->
    To.Parsetree.row_field
  =
  function
  | From.Parsetree.Rtag (x0,x1,x2,x3) ->
      To.Parsetree.Rtag
        ((copy_label x0),
          (copy_attributes x1), (copy_bool x2),
          (List.map copy_core_type x3))
  | From.Parsetree.Rinherit x0 ->
      To.Parsetree.Rinherit
        (copy_core_type x0)

and copy_attributes :
  From.Parsetree.attributes ->
    To.Parsetree.attributes
  = fun x  -> List.map copy_attribute x

and copy_attribute :
  From.Parsetree.attribute ->
    To.Parsetree.attribute
  =
  fun x  ->
    let (x0,x1) = x  in
    ((copy_loc (fun x  -> x) x0),
      (copy_payload x1))

and copy_payload :
  From.Parsetree.payload -> To.Parsetree.payload =
  function
  | From.Parsetree.PStr x0 ->
      To.Parsetree.PStr
        (copy_structure x0)
  | From.Parsetree.PSig x0 ->
      To.Parsetree.PSig
        (copy_signature x0)
  | From.Parsetree.PTyp x0 ->
      To.Parsetree.PTyp
        (copy_core_type x0)
  | From.Parsetree.PPat (x0,x1) ->
      To.Parsetree.PPat
        ((copy_pattern x0),
          (copy_option copy_expression x1))

and copy_structure :
  From.Parsetree.structure ->
    To.Parsetree.structure
  = fun x  -> List.map copy_structure_item x

and copy_structure_item :
  From.Parsetree.structure_item ->
    To.Parsetree.structure_item
  =
  fun
    { From.Parsetree.pstr_desc = pstr_desc;
      From.Parsetree.pstr_loc = pstr_loc }
     ->
    {
      To.Parsetree.pstr_desc =
        (copy_structure_item_desc pstr_desc);
      To.Parsetree.pstr_loc =
        (copy_location pstr_loc)
    }

and copy_structure_item_desc :
  From.Parsetree.structure_item_desc ->
    To.Parsetree.structure_item_desc
  =
  function
  | From.Parsetree.Pstr_eval (x0,x1) ->
      To.Parsetree.Pstr_eval
        ((copy_expression x0),
          (copy_attributes x1))
  | From.Parsetree.Pstr_value (x0,x1) ->
      To.Parsetree.Pstr_value
        ((copy_rec_flag x0),
          (List.map copy_value_binding x1))
  | From.Parsetree.Pstr_primitive x0 ->
      To.Parsetree.Pstr_primitive
        (copy_value_description x0)
  | From.Parsetree.Pstr_type (x0,x1) ->
      To.Parsetree.Pstr_type
        ((copy_rec_flag x0),
          (List.map copy_type_declaration x1))
  | From.Parsetree.Pstr_typext x0 ->
      To.Parsetree.Pstr_typext
        (copy_type_extension x0)
  | From.Parsetree.Pstr_exception x0 ->
      To.Parsetree.Pstr_exception
        (copy_extension_constructor x0)
  | From.Parsetree.Pstr_module x0 ->
      To.Parsetree.Pstr_module
        (copy_module_binding x0)
  | From.Parsetree.Pstr_recmodule x0 ->
      To.Parsetree.Pstr_recmodule
        (List.map copy_module_binding x0)
  | From.Parsetree.Pstr_modtype x0 ->
      To.Parsetree.Pstr_modtype
        (copy_module_type_declaration x0)
  | From.Parsetree.Pstr_open x0 ->
      To.Parsetree.Pstr_open
        (copy_open_description x0)
  | From.Parsetree.Pstr_class x0 ->
      To.Parsetree.Pstr_class
        (List.map copy_class_declaration x0)
  | From.Parsetree.Pstr_class_type x0 ->
      To.Parsetree.Pstr_class_type
        (List.map copy_class_type_declaration x0)
  | From.Parsetree.Pstr_include x0 ->
      To.Parsetree.Pstr_include
        (copy_include_declaration x0)
  | From.Parsetree.Pstr_attribute x0 ->
      To.Parsetree.Pstr_attribute
        (copy_attribute x0)
  | From.Parsetree.Pstr_extension (x0,x1) ->
      To.Parsetree.Pstr_extension
        ((copy_extension x0),
          (copy_attributes x1))

and copy_include_declaration :
  From.Parsetree.include_declaration ->
    To.Parsetree.include_declaration
  =
  fun x  ->
    copy_include_infos
      copy_module_expr x

and copy_class_declaration :
  From.Parsetree.class_declaration ->
    To.Parsetree.class_declaration
  =
  fun x  ->
    copy_class_infos
      copy_class_expr x

and copy_class_expr :
  From.Parsetree.class_expr ->
    To.Parsetree.class_expr
  =
  fun
    { From.Parsetree.pcl_desc = pcl_desc;
      From.Parsetree.pcl_loc = pcl_loc;
      From.Parsetree.pcl_attributes = pcl_attributes }
     ->
    {
      To.Parsetree.pcl_desc =
        (copy_class_expr_desc pcl_desc);
      To.Parsetree.pcl_loc =
        (copy_location pcl_loc);
      To.Parsetree.pcl_attributes =
        (copy_attributes pcl_attributes)
    }

and copy_class_expr_desc :
  From.Parsetree.class_expr_desc ->
    To.Parsetree.class_expr_desc
  =
  function
  | From.Parsetree.Pcl_constr (x0,x1) ->
      To.Parsetree.Pcl_constr
        ((copy_loc
            copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Pcl_structure x0 ->
      To.Parsetree.Pcl_structure
        (copy_class_structure x0)
  | From.Parsetree.Pcl_fun (x0,x1,x2,x3) ->
      To.Parsetree.Pcl_fun
        ((copy_arg_label x0),
          (copy_option copy_expression x1),
          (copy_pattern x2),
          (copy_class_expr x3))
  | From.Parsetree.Pcl_apply (x0,x1) ->
      To.Parsetree.Pcl_apply
        ((copy_class_expr x0),
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                ((copy_arg_label x0),
                  (copy_expression x1))) x1))
  | From.Parsetree.Pcl_let (x0,x1,x2) ->
      To.Parsetree.Pcl_let
        ((copy_rec_flag x0),
          (List.map copy_value_binding x1),
          (copy_class_expr x2))
  | From.Parsetree.Pcl_constraint (x0,x1) ->
      To.Parsetree.Pcl_constraint
        ((copy_class_expr x0),
          (copy_class_type x1))
  | From.Parsetree.Pcl_extension x0 ->
      To.Parsetree.Pcl_extension
        (copy_extension x0)

and copy_class_structure :
  From.Parsetree.class_structure ->
    To.Parsetree.class_structure
  =
  fun
    { From.Parsetree.pcstr_self = pcstr_self;
      From.Parsetree.pcstr_fields = pcstr_fields }
     ->
    {
      To.Parsetree.pcstr_self =
        (copy_pattern pcstr_self);
      To.Parsetree.pcstr_fields =
        (List.map copy_class_field pcstr_fields)
    }

and copy_class_field :
  From.Parsetree.class_field ->
    To.Parsetree.class_field
  =
  fun
    { From.Parsetree.pcf_desc = pcf_desc;
      From.Parsetree.pcf_loc = pcf_loc;
      From.Parsetree.pcf_attributes = pcf_attributes }
     ->
    {
      To.Parsetree.pcf_desc =
        (copy_class_field_desc pcf_desc);
      To.Parsetree.pcf_loc =
        (copy_location pcf_loc);
      To.Parsetree.pcf_attributes =
        (copy_attributes pcf_attributes)
    }

and copy_class_field_desc :
  From.Parsetree.class_field_desc ->
    To.Parsetree.class_field_desc
  =
  function
  | From.Parsetree.Pcf_inherit (x0,x1,x2) ->
      To.Parsetree.Pcf_inherit
        ((copy_override_flag x0),
          (copy_class_expr x1),
          (copy_option (fun x  -> x) x2))
  | From.Parsetree.Pcf_val x0 ->
      To.Parsetree.Pcf_val
        (let (x0,x1,x2) = x0  in
         ((copy_loc (fun x  -> x) x0),
           (copy_mutable_flag x1),
           (copy_class_field_kind x2)))
  | From.Parsetree.Pcf_method x0 ->
      To.Parsetree.Pcf_method
        (let (x0,x1,x2) = x0  in
         ((copy_loc (fun x  -> x) x0),
           (copy_private_flag x1),
           (copy_class_field_kind x2)))
  | From.Parsetree.Pcf_constraint x0 ->
      To.Parsetree.Pcf_constraint
        (let (x0,x1) = x0  in
         ((copy_core_type x0),
           (copy_core_type x1)))
  | From.Parsetree.Pcf_initializer x0 ->
      To.Parsetree.Pcf_initializer
        (copy_expression x0)
  | From.Parsetree.Pcf_attribute x0 ->
      To.Parsetree.Pcf_attribute
        (copy_attribute x0)
  | From.Parsetree.Pcf_extension x0 ->
      To.Parsetree.Pcf_extension
        (copy_extension x0)

and copy_class_field_kind :
  From.Parsetree.class_field_kind ->
    To.Parsetree.class_field_kind
  =
  function
  | From.Parsetree.Cfk_virtual x0 ->
      To.Parsetree.Cfk_virtual
        (copy_core_type x0)
  | From.Parsetree.Cfk_concrete (x0,x1) ->
      To.Parsetree.Cfk_concrete
        ((copy_override_flag x0),
          (copy_expression x1))

and copy_module_binding :
  From.Parsetree.module_binding ->
    To.Parsetree.module_binding
  =
  fun
    { From.Parsetree.pmb_name = pmb_name;
      From.Parsetree.pmb_expr = pmb_expr;
      From.Parsetree.pmb_attributes = pmb_attributes;
      From.Parsetree.pmb_loc = pmb_loc }
     ->
    {
      To.Parsetree.pmb_name =
        (copy_loc (fun x  -> x) pmb_name);
      To.Parsetree.pmb_expr =
        (copy_module_expr pmb_expr);
      To.Parsetree.pmb_attributes =
        (copy_attributes pmb_attributes);
      To.Parsetree.pmb_loc =
        (copy_location pmb_loc)
    }

and copy_module_expr :
  From.Parsetree.module_expr ->
    To.Parsetree.module_expr
  =
  fun
    { From.Parsetree.pmod_desc = pmod_desc;
      From.Parsetree.pmod_loc = pmod_loc;
      From.Parsetree.pmod_attributes = pmod_attributes }
     ->
    {
      To.Parsetree.pmod_desc =
        (copy_module_expr_desc pmod_desc);
      To.Parsetree.pmod_loc =
        (copy_location pmod_loc);
      To.Parsetree.pmod_attributes =
        (copy_attributes pmod_attributes)
    }

and copy_module_expr_desc :
  From.Parsetree.module_expr_desc ->
    To.Parsetree.module_expr_desc
  =
  function
  | From.Parsetree.Pmod_ident x0 ->
      To.Parsetree.Pmod_ident
        (copy_loc copy_longident
           x0)
  | From.Parsetree.Pmod_structure x0 ->
      To.Parsetree.Pmod_structure
        (copy_structure x0)
  | From.Parsetree.Pmod_functor (x0,x1,x2) ->
      To.Parsetree.Pmod_functor
        ((copy_loc (fun x  -> x) x0),
          (copy_option copy_module_type x1),
          (copy_module_expr x2))
  | From.Parsetree.Pmod_apply (x0,x1) ->
      To.Parsetree.Pmod_apply
        ((copy_module_expr x0),
          (copy_module_expr x1))
  | From.Parsetree.Pmod_constraint (x0,x1) ->
      To.Parsetree.Pmod_constraint
        ((copy_module_expr x0),
          (copy_module_type x1))
  | From.Parsetree.Pmod_unpack x0 ->
      To.Parsetree.Pmod_unpack
        (copy_expression x0)
  | From.Parsetree.Pmod_extension x0 ->
      To.Parsetree.Pmod_extension
        (copy_extension x0)

and copy_module_type :
  From.Parsetree.module_type ->
    To.Parsetree.module_type
  =
  fun
    { From.Parsetree.pmty_desc = pmty_desc;
      From.Parsetree.pmty_loc = pmty_loc;
      From.Parsetree.pmty_attributes = pmty_attributes }
     ->
    {
      To.Parsetree.pmty_desc =
        (copy_module_type_desc pmty_desc);
      To.Parsetree.pmty_loc =
        (copy_location pmty_loc);
      To.Parsetree.pmty_attributes =
        (copy_attributes pmty_attributes)
    }

and copy_module_type_desc :
  From.Parsetree.module_type_desc ->
    To.Parsetree.module_type_desc
  =
  function
  | From.Parsetree.Pmty_ident x0 ->
      To.Parsetree.Pmty_ident
        (copy_loc copy_longident
           x0)
  | From.Parsetree.Pmty_signature x0 ->
      To.Parsetree.Pmty_signature
        (copy_signature x0)
  | From.Parsetree.Pmty_functor (x0,x1,x2) ->
      To.Parsetree.Pmty_functor
        ((copy_loc (fun x  -> x) x0),
          (copy_option copy_module_type x1),
          (copy_module_type x2))
  | From.Parsetree.Pmty_with (x0,x1) ->
      To.Parsetree.Pmty_with
        ((copy_module_type x0),
          (List.map copy_with_constraint x1))
  | From.Parsetree.Pmty_typeof x0 ->
      To.Parsetree.Pmty_typeof
        (copy_module_expr x0)
  | From.Parsetree.Pmty_extension x0 ->
      To.Parsetree.Pmty_extension
        (copy_extension x0)
  | From.Parsetree.Pmty_alias x0 ->
      To.Parsetree.Pmty_alias
        (copy_loc copy_longident
           x0)

and copy_with_constraint :
  From.Parsetree.with_constraint ->
    To.Parsetree.with_constraint
  =
  function
  | From.Parsetree.Pwith_type (x0,x1) ->
      To.Parsetree.Pwith_type
        ((copy_loc
            copy_longident x0),
          (copy_type_declaration x1))
  | From.Parsetree.Pwith_module (x0,x1) ->
      To.Parsetree.Pwith_module
        ((copy_loc
            copy_longident x0),
          (copy_loc
             copy_longident x1))
  | From.Parsetree.Pwith_typesubst x0 ->
      To.Parsetree.Pwith_typesubst
        (copy_type_declaration x0)
  | From.Parsetree.Pwith_modsubst (x0,x1) ->
      To.Parsetree.Pwith_modsubst
        ((copy_loc (fun x  -> x) x0),
          (copy_loc
             copy_longident x1))

and copy_signature :
  From.Parsetree.signature ->
    To.Parsetree.signature
  = fun x  -> List.map copy_signature_item x

and copy_signature_item :
  From.Parsetree.signature_item ->
    To.Parsetree.signature_item
  =
  fun
    { From.Parsetree.psig_desc = psig_desc;
      From.Parsetree.psig_loc = psig_loc }
     ->
    {
      To.Parsetree.psig_desc =
        (copy_signature_item_desc psig_desc);
      To.Parsetree.psig_loc =
        (copy_location psig_loc)
    }

and copy_signature_item_desc :
  From.Parsetree.signature_item_desc ->
    To.Parsetree.signature_item_desc
  =
  function
  | From.Parsetree.Psig_value x0 ->
      To.Parsetree.Psig_value
        (copy_value_description x0)
  | From.Parsetree.Psig_type (x0,x1) ->
      To.Parsetree.Psig_type
        ((copy_rec_flag x0),
          (List.map copy_type_declaration x1))
  | From.Parsetree.Psig_typext x0 ->
      To.Parsetree.Psig_typext
        (copy_type_extension x0)
  | From.Parsetree.Psig_exception x0 ->
      To.Parsetree.Psig_exception
        (copy_extension_constructor x0)
  | From.Parsetree.Psig_module x0 ->
      To.Parsetree.Psig_module
        (copy_module_declaration x0)
  | From.Parsetree.Psig_recmodule x0 ->
      To.Parsetree.Psig_recmodule
        (List.map copy_module_declaration x0)
  | From.Parsetree.Psig_modtype x0 ->
      To.Parsetree.Psig_modtype
        (copy_module_type_declaration x0)
  | From.Parsetree.Psig_open x0 ->
      To.Parsetree.Psig_open
        (copy_open_description x0)
  | From.Parsetree.Psig_include x0 ->
      To.Parsetree.Psig_include
        (copy_include_description x0)
  | From.Parsetree.Psig_class x0 ->
      To.Parsetree.Psig_class
        (List.map copy_class_description x0)
  | From.Parsetree.Psig_class_type x0 ->
      To.Parsetree.Psig_class_type
        (List.map copy_class_type_declaration x0)
  | From.Parsetree.Psig_attribute x0 ->
      To.Parsetree.Psig_attribute
        (copy_attribute x0)
  | From.Parsetree.Psig_extension (x0,x1) ->
      To.Parsetree.Psig_extension
        ((copy_extension x0),
          (copy_attributes x1))

and copy_class_type_declaration :
  From.Parsetree.class_type_declaration ->
    To.Parsetree.class_type_declaration
  =
  fun x  ->
    copy_class_infos
      copy_class_type x

and copy_class_description :
  From.Parsetree.class_description ->
    To.Parsetree.class_description
  =
  fun x  ->
    copy_class_infos
      copy_class_type x

and copy_class_type :
  From.Parsetree.class_type ->
    To.Parsetree.class_type
  =
  fun
    { From.Parsetree.pcty_desc = pcty_desc;
      From.Parsetree.pcty_loc = pcty_loc;
      From.Parsetree.pcty_attributes = pcty_attributes }
     ->
    {
      To.Parsetree.pcty_desc =
        (copy_class_type_desc pcty_desc);
      To.Parsetree.pcty_loc =
        (copy_location pcty_loc);
      To.Parsetree.pcty_attributes =
        (copy_attributes pcty_attributes)
    }

and copy_class_type_desc :
  From.Parsetree.class_type_desc ->
    To.Parsetree.class_type_desc
  =
  function
  | From.Parsetree.Pcty_constr (x0,x1) ->
      To.Parsetree.Pcty_constr
        ((copy_loc
            copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Pcty_signature x0 ->
      To.Parsetree.Pcty_signature
        (copy_class_signature x0)
  | From.Parsetree.Pcty_arrow (x0,x1,x2) ->
      To.Parsetree.Pcty_arrow
        ((copy_arg_label x0),
          (copy_core_type x1),
          (copy_class_type x2))
  | From.Parsetree.Pcty_extension x0 ->
      To.Parsetree.Pcty_extension
        (copy_extension x0)

and copy_class_signature :
  From.Parsetree.class_signature ->
    To.Parsetree.class_signature
  =
  fun
    { From.Parsetree.pcsig_self = pcsig_self;
      From.Parsetree.pcsig_fields = pcsig_fields }
     ->
    {
      To.Parsetree.pcsig_self =
        (copy_core_type pcsig_self);
      To.Parsetree.pcsig_fields =
        (List.map copy_class_type_field
           pcsig_fields)
    }

and copy_class_type_field :
  From.Parsetree.class_type_field ->
    To.Parsetree.class_type_field
  =
  fun
    { From.Parsetree.pctf_desc = pctf_desc;
      From.Parsetree.pctf_loc = pctf_loc;
      From.Parsetree.pctf_attributes = pctf_attributes }
     ->
    {
      To.Parsetree.pctf_desc =
        (copy_class_type_field_desc pctf_desc);
      To.Parsetree.pctf_loc =
        (copy_location pctf_loc);
      To.Parsetree.pctf_attributes =
        (copy_attributes pctf_attributes)
    }

and copy_class_type_field_desc :
  From.Parsetree.class_type_field_desc ->
    To.Parsetree.class_type_field_desc
  =
  function
  | From.Parsetree.Pctf_inherit x0 ->
      To.Parsetree.Pctf_inherit
        (copy_class_type x0)
  | From.Parsetree.Pctf_val x0 ->
      To.Parsetree.Pctf_val
        (let (x0,x1,x2,x3) = x0  in
         (x0, (copy_mutable_flag x1),
           (copy_virtual_flag x2),
           (copy_core_type x3)))
  | From.Parsetree.Pctf_method x0 ->
      To.Parsetree.Pctf_method
        (let (x0,x1,x2,x3) = x0  in
         (x0, (copy_private_flag x1),
           (copy_virtual_flag x2),
           (copy_core_type x3)))
  | From.Parsetree.Pctf_constraint x0 ->
      To.Parsetree.Pctf_constraint
        (let (x0,x1) = x0  in
         ((copy_core_type x0),
           (copy_core_type x1)))
  | From.Parsetree.Pctf_attribute x0 ->
      To.Parsetree.Pctf_attribute
        (copy_attribute x0)
  | From.Parsetree.Pctf_extension x0 ->
      To.Parsetree.Pctf_extension
        (copy_extension x0)

and copy_extension :
  From.Parsetree.extension ->
    To.Parsetree.extension
  =
  fun x  ->
    let (x0,x1) = x  in
    ((copy_loc (fun x  -> x) x0),
      (copy_payload x1))

and copy_class_infos :
  'f0 'g0 .
    ('f0 -> 'g0) ->
      'f0 From.Parsetree.class_infos ->
        'g0 To.Parsetree.class_infos
  =
  fun f0  ->
    fun
      { From.Parsetree.pci_virt = pci_virt;
        From.Parsetree.pci_params = pci_params;
        From.Parsetree.pci_name = pci_name;
        From.Parsetree.pci_expr = pci_expr;
        From.Parsetree.pci_loc = pci_loc;
        From.Parsetree.pci_attributes = pci_attributes }
       ->
      {
        To.Parsetree.pci_virt =
          (copy_virtual_flag pci_virt);
        To.Parsetree.pci_params =
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                ((copy_core_type x0),
                  (copy_variance x1))) pci_params);
        To.Parsetree.pci_name =
          (copy_loc (fun x  -> x) pci_name);
        To.Parsetree.pci_expr = (f0 pci_expr);
        To.Parsetree.pci_loc =
          (copy_location pci_loc);
        To.Parsetree.pci_attributes =
          (copy_attributes pci_attributes)
      }

and copy_virtual_flag :
  From.Asttypes.virtual_flag ->
    To.Asttypes.virtual_flag
  =
  function
  | From.Asttypes.Virtual  -> To.Asttypes.Virtual
  | From.Asttypes.Concrete  -> To.Asttypes.Concrete

and copy_include_description :
  From.Parsetree.include_description ->
    To.Parsetree.include_description
  =
  fun x  ->
    copy_include_infos
      copy_module_type x

and copy_include_infos :
  'f0 'g0 .
    ('f0 -> 'g0) ->
      'f0 From.Parsetree.include_infos ->
        'g0 To.Parsetree.include_infos
  =
  fun f0  ->
    fun
      { From.Parsetree.pincl_mod = pincl_mod;
        From.Parsetree.pincl_loc = pincl_loc;
        From.Parsetree.pincl_attributes = pincl_attributes }
       ->
      {
        To.Parsetree.pincl_mod = (f0 pincl_mod);
        To.Parsetree.pincl_loc =
          (copy_location pincl_loc);
        To.Parsetree.pincl_attributes =
          (copy_attributes pincl_attributes)
      }

and copy_open_description :
  From.Parsetree.open_description ->
    To.Parsetree.open_description
  =
  fun
    { From.Parsetree.popen_lid = popen_lid;
      From.Parsetree.popen_override = popen_override;
      From.Parsetree.popen_loc = popen_loc;
      From.Parsetree.popen_attributes = popen_attributes }
     ->
    {
      To.Parsetree.popen_lid =
        (copy_loc copy_longident
           popen_lid);
      To.Parsetree.popen_override =
        (copy_override_flag popen_override);
      To.Parsetree.popen_loc =
        (copy_location popen_loc);
      To.Parsetree.popen_attributes =
        (copy_attributes popen_attributes)
    }

and copy_override_flag :
  From.Asttypes.override_flag ->
    To.Asttypes.override_flag
  =
  function
  | From.Asttypes.Override  -> To.Asttypes.Override
  | From.Asttypes.Fresh  -> To.Asttypes.Fresh

and copy_module_type_declaration :
  From.Parsetree.module_type_declaration ->
    To.Parsetree.module_type_declaration
  =
  fun
    { From.Parsetree.pmtd_name = pmtd_name;
      From.Parsetree.pmtd_type = pmtd_type;
      From.Parsetree.pmtd_attributes = pmtd_attributes;
      From.Parsetree.pmtd_loc = pmtd_loc }
     ->
    {
      To.Parsetree.pmtd_name =
        (copy_loc (fun x  -> x) pmtd_name);
      To.Parsetree.pmtd_type =
        (copy_option copy_module_type pmtd_type);
      To.Parsetree.pmtd_attributes =
        (copy_attributes pmtd_attributes);
      To.Parsetree.pmtd_loc =
        (copy_location pmtd_loc)
    }

and copy_module_declaration :
  From.Parsetree.module_declaration ->
    To.Parsetree.module_declaration
  =
  fun
    { From.Parsetree.pmd_name = pmd_name;
      From.Parsetree.pmd_type = pmd_type;
      From.Parsetree.pmd_attributes = pmd_attributes;
      From.Parsetree.pmd_loc = pmd_loc }
     ->
    {
      To.Parsetree.pmd_name =
        (copy_loc (fun x  -> x) pmd_name);
      To.Parsetree.pmd_type =
        (copy_module_type pmd_type);
      To.Parsetree.pmd_attributes =
        (copy_attributes pmd_attributes);
      To.Parsetree.pmd_loc =
        (copy_location pmd_loc)
    }

and copy_type_extension :
  From.Parsetree.type_extension ->
    To.Parsetree.type_extension
  =
  fun
    { From.Parsetree.ptyext_path = ptyext_path;
      From.Parsetree.ptyext_params = ptyext_params;
      From.Parsetree.ptyext_constructors = ptyext_constructors;
      From.Parsetree.ptyext_private = ptyext_private;
      From.Parsetree.ptyext_attributes = ptyext_attributes }
     ->
    {
      To.Parsetree.ptyext_path =
        (copy_loc copy_longident
           ptyext_path);
      To.Parsetree.ptyext_params =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_core_type x0),
                (copy_variance x1))) ptyext_params);
      To.Parsetree.ptyext_constructors =
        (List.map copy_extension_constructor
           ptyext_constructors);
      To.Parsetree.ptyext_private =
        (copy_private_flag ptyext_private);
      To.Parsetree.ptyext_attributes =
        (copy_attributes ptyext_attributes)
    }

and copy_extension_constructor :
  From.Parsetree.extension_constructor ->
    To.Parsetree.extension_constructor
  =
  fun
    { From.Parsetree.pext_name = pext_name;
      From.Parsetree.pext_kind = pext_kind;
      From.Parsetree.pext_loc = pext_loc;
      From.Parsetree.pext_attributes = pext_attributes }
     ->
    {
      To.Parsetree.pext_name =
        (copy_loc (fun x  -> x) pext_name);
      To.Parsetree.pext_kind =
        (copy_extension_constructor_kind pext_kind);
      To.Parsetree.pext_loc =
        (copy_location pext_loc);
      To.Parsetree.pext_attributes =
        (copy_attributes pext_attributes)
    }

and copy_extension_constructor_kind :
  From.Parsetree.extension_constructor_kind ->
    To.Parsetree.extension_constructor_kind
  =
  function
  | From.Parsetree.Pext_decl (x0,x1) ->
      To.Parsetree.Pext_decl
        ((copy_constructor_arguments x0),
          (copy_option copy_core_type x1))
  | From.Parsetree.Pext_rebind x0 ->
      To.Parsetree.Pext_rebind
        (copy_loc copy_longident
           x0)

and copy_type_declaration :
  From.Parsetree.type_declaration ->
    To.Parsetree.type_declaration
  =
  fun
    { From.Parsetree.ptype_name = ptype_name;
      From.Parsetree.ptype_params = ptype_params;
      From.Parsetree.ptype_cstrs = ptype_cstrs;
      From.Parsetree.ptype_kind = ptype_kind;
      From.Parsetree.ptype_private = ptype_private;
      From.Parsetree.ptype_manifest = ptype_manifest;
      From.Parsetree.ptype_attributes = ptype_attributes;
      From.Parsetree.ptype_loc = ptype_loc }
     ->
    {
      To.Parsetree.ptype_name =
        (copy_loc (fun x  -> x) ptype_name);
      To.Parsetree.ptype_params =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_core_type x0),
                (copy_variance x1))) ptype_params);
      To.Parsetree.ptype_cstrs =
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              ((copy_core_type x0),
                (copy_core_type x1),
                (copy_location x2))) ptype_cstrs);
      To.Parsetree.ptype_kind =
        (copy_type_kind ptype_kind);
      To.Parsetree.ptype_private =
        (copy_private_flag ptype_private);
      To.Parsetree.ptype_manifest =
        (copy_option copy_core_type ptype_manifest);
      To.Parsetree.ptype_attributes =
        (copy_attributes ptype_attributes);
      To.Parsetree.ptype_loc =
        (copy_location ptype_loc)
    }

and copy_private_flag :
  From.Asttypes.private_flag ->
    To.Asttypes.private_flag
  =
  function
  | From.Asttypes.Private  -> To.Asttypes.Private
  | From.Asttypes.Public  -> To.Asttypes.Public

and copy_type_kind :
  From.Parsetree.type_kind ->
    To.Parsetree.type_kind
  =
  function
  | From.Parsetree.Ptype_abstract  ->
      To.Parsetree.Ptype_abstract
  | From.Parsetree.Ptype_variant x0 ->
      To.Parsetree.Ptype_variant
        (List.map copy_constructor_declaration x0)
  | From.Parsetree.Ptype_record x0 ->
      To.Parsetree.Ptype_record
        (List.map copy_label_declaration x0)
  | From.Parsetree.Ptype_open  ->
      To.Parsetree.Ptype_open

and copy_constructor_declaration :
  From.Parsetree.constructor_declaration ->
    To.Parsetree.constructor_declaration
  =
  fun
    { From.Parsetree.pcd_name = pcd_name;
      From.Parsetree.pcd_args = pcd_args;
      From.Parsetree.pcd_res = pcd_res;
      From.Parsetree.pcd_loc = pcd_loc;
      From.Parsetree.pcd_attributes = pcd_attributes }
     ->
    {
      To.Parsetree.pcd_name =
        (copy_loc (fun x  -> x) pcd_name);
      To.Parsetree.pcd_args =
        (copy_constructor_arguments pcd_args);
      To.Parsetree.pcd_res =
        (copy_option copy_core_type pcd_res);
      To.Parsetree.pcd_loc =
        (copy_location pcd_loc);
      To.Parsetree.pcd_attributes =
        (copy_attributes pcd_attributes)
    }

and copy_constructor_arguments :
  From.Parsetree.constructor_arguments ->
    To.Parsetree.constructor_arguments
  =
  function
  | From.Parsetree.Pcstr_tuple x0 ->
      To.Parsetree.Pcstr_tuple
        (List.map copy_core_type x0)
  | From.Parsetree.Pcstr_record x0 ->
      To.Parsetree.Pcstr_record
        (List.map copy_label_declaration x0)

and copy_label_declaration :
  From.Parsetree.label_declaration ->
    To.Parsetree.label_declaration
  =
  fun
    { From.Parsetree.pld_name = pld_name;
      From.Parsetree.pld_mutable = pld_mutable;
      From.Parsetree.pld_type = pld_type;
      From.Parsetree.pld_loc = pld_loc;
      From.Parsetree.pld_attributes = pld_attributes }
     ->
    {
      To.Parsetree.pld_name =
        (copy_loc (fun x  -> x) pld_name);
      To.Parsetree.pld_mutable =
        (copy_mutable_flag pld_mutable);
      To.Parsetree.pld_type =
        (copy_core_type pld_type);
      To.Parsetree.pld_loc =
        (copy_location pld_loc);
      To.Parsetree.pld_attributes =
        (copy_attributes pld_attributes)
    }

and copy_mutable_flag :
  From.Asttypes.mutable_flag ->
    To.Asttypes.mutable_flag
  =
  function
  | From.Asttypes.Immutable  ->
      To.Asttypes.Immutable
  | From.Asttypes.Mutable  -> To.Asttypes.Mutable

and copy_variance :
  From.Asttypes.variance -> To.Asttypes.variance =
  function
  | From.Asttypes.Covariant  ->
      To.Asttypes.Covariant
  | From.Asttypes.Contravariant  ->
      To.Asttypes.Contravariant
  | From.Asttypes.Invariant  ->
      To.Asttypes.Invariant

and copy_value_description :
  From.Parsetree.value_description ->
    To.Parsetree.value_description
  =
  fun
    { From.Parsetree.pval_name = pval_name;
      From.Parsetree.pval_type = pval_type;
      From.Parsetree.pval_prim = pval_prim;
      From.Parsetree.pval_attributes = pval_attributes;
      From.Parsetree.pval_loc = pval_loc }
     ->
    {
      To.Parsetree.pval_name =
        (copy_loc (fun x  -> x) pval_name);
      To.Parsetree.pval_type =
        (copy_core_type pval_type);
      To.Parsetree.pval_prim =
        (List.map (fun x  -> x) pval_prim);
      To.Parsetree.pval_attributes =
        (copy_attributes pval_attributes);
      To.Parsetree.pval_loc =
        (copy_location pval_loc)
    }

and copy_arg_label :
  From.Asttypes.arg_label -> To.Asttypes.arg_label
  =
  function
  | From.Asttypes.Nolabel  -> To.Asttypes.Nolabel
  | From.Asttypes.Labelled x0 ->
      To.Asttypes.Labelled x0
  | From.Asttypes.Optional x0 ->
      To.Asttypes.Optional x0

and copy_closed_flag :
  From.Asttypes.closed_flag ->
    To.Asttypes.closed_flag
  =
  function
  | From.Asttypes.Closed  -> To.Asttypes.Closed
  | From.Asttypes.Open  -> To.Asttypes.Open

and copy_label :
  From.Asttypes.label -> To.Asttypes.label =
  fun x  -> x

and copy_rec_flag :
  From.Asttypes.rec_flag -> To.Asttypes.rec_flag =
  function
  | From.Asttypes.Nonrecursive  ->
      To.Asttypes.Nonrecursive
  | From.Asttypes.Recursive  ->
      To.Asttypes.Recursive

and copy_constant :
  From.Parsetree.constant -> To.Parsetree.constant
  =
  function
  | From.Parsetree.Pconst_integer (x0,x1) ->
      To.Parsetree.Pconst_integer
        (x0, (copy_option (fun x  -> x) x1))
  | From.Parsetree.Pconst_char x0 ->
      To.Parsetree.Pconst_char x0
  | From.Parsetree.Pconst_string (x0,x1) ->
      To.Parsetree.Pconst_string
        (x0, (copy_option (fun x  -> x) x1))
  | From.Parsetree.Pconst_float (x0,x1) ->
      To.Parsetree.Pconst_float
        (x0, (copy_option (fun x  -> x) x1))

and copy_option : 'f0 'g0 . ('f0 -> 'g0) -> 'f0 option -> 'g0 option =
  fun f0  -> function | None  -> None | Some x0 -> Some (f0 x0)

and copy_longident :
  From.Longident.t -> To.Longident.t =
  function
  | From.Longident.Lident x0 ->
      To.Longident.Lident x0
  | From.Longident.Ldot (x0,x1) ->
      To.Longident.Ldot
        ((copy_longident x0), x1)
  | From.Longident.Lapply (x0,x1) ->
      To.Longident.Lapply
        ((copy_longident x0), (copy_longident x1))

and copy_loc :
  'f0 'g0 .
    ('f0 -> 'g0) ->
      'f0 From.Asttypes.loc -> 'g0 To.Asttypes.loc
  =
  fun f0  ->
    fun
      { From.Asttypes.txt = txt;
        From.Asttypes.loc = loc }
       ->
      {
        To.Asttypes.txt = (f0 txt);
        To.Asttypes.loc = (copy_location loc)
      }

and copy_location :
  From.Location.t -> To.Location.t =
  fun
    { From.Location.loc_start = loc_start;
      From.Location.loc_end = loc_end;
      From.Location.loc_ghost = loc_ghost }
     ->
    {
      To.Location.loc_start = (copy_Lexing_position loc_start);
      To.Location.loc_end = (copy_Lexing_position loc_end);
      To.Location.loc_ghost = (copy_bool loc_ghost)
    }

and copy_bool : bool -> bool = function | false  -> false | true  -> true

and copy_Lexing_position : Lexing.position -> Lexing.position =
  fun
    { Lexing.pos_fname = pos_fname; Lexing.pos_lnum = pos_lnum;
      Lexing.pos_bol = pos_bol; Lexing.pos_cnum = pos_cnum }
     ->
    {
      Lexing.pos_fname = pos_fname;
      Lexing.pos_lnum = pos_lnum;
      Lexing.pos_bol = pos_bol;
      Lexing.pos_cnum = pos_cnum
    }

let rec copy_out_phrase :
  From.Outcometree.out_phrase -> To.Outcometree.out_phrase =
  function
  | From.Outcometree.Ophr_eval (x0,x1) ->
      To.Outcometree.Ophr_eval
        ((copy_out_value x0),
          (copy_out_type x1))
  | From.Outcometree.Ophr_signature x0 ->
      To.Outcometree.Ophr_signature
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_out_sig_item x0),
                (copy_option copy_out_value x1))) x0)
  | From.Outcometree.Ophr_exception x0 ->
      To.Outcometree.Ophr_exception
        (let (x0,x1) = x0  in
         ((copy_exn x0), (copy_out_value x1)))

and copy_exn : exn -> exn = fun x  -> x

and copy_out_sig_item :
  From.Outcometree.out_sig_item -> To.Outcometree.out_sig_item =
  function
  | From.Outcometree.Osig_class (x0,x1,x2,x3,x4) ->
      To.Outcometree.Osig_class
        ((copy_bool x0), x1,
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))
             x2), (copy_out_class_type x3),
          (copy_out_rec_status x4))
  | From.Outcometree.Osig_class_type (x0,x1,x2,x3,x4) ->
      To.Outcometree.Osig_class_type
        ((copy_bool x0), x1,
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))
             x2), (copy_out_class_type x3),
          (copy_out_rec_status x4))
  | From.Outcometree.Osig_typext (x0,x1) ->
      To.Outcometree.Osig_typext
        ((copy_out_extension_constructor x0),
          (copy_out_ext_status x1))
  | From.Outcometree.Osig_modtype (x0,x1) ->
      To.Outcometree.Osig_modtype
        (x0, (copy_out_module_type x1))
  | From.Outcometree.Osig_module (x0,x1,x2) ->
      To.Outcometree.Osig_module
        (x0, (copy_out_module_type x1),
          (copy_out_rec_status x2))
  | From.Outcometree.Osig_type (x0,x1) ->
      To.Outcometree.Osig_type
        ((copy_out_type_decl x0),
          (copy_out_rec_status x1))
  | From.Outcometree.Osig_value x0 ->
      To.Outcometree.Osig_value
        (copy_out_val_decl x0)
  | From.Outcometree.Osig_ellipsis  -> To.Outcometree.Osig_ellipsis

and copy_out_val_decl :
  From.Outcometree.out_val_decl -> To.Outcometree.out_val_decl =
  fun
    { From.Outcometree.oval_name = oval_name;
      From.Outcometree.oval_type = oval_type;
      From.Outcometree.oval_prims = oval_prims;
      From.Outcometree.oval_attributes = oval_attributes }
     ->
    {
      To.Outcometree.oval_name = oval_name;
      To.Outcometree.oval_type =
        (copy_out_type oval_type);
      To.Outcometree.oval_prims = (List.map (fun x  -> x) oval_prims);
      To.Outcometree.oval_attributes =
        (List.map copy_out_attribute oval_attributes)
    }

and copy_out_type_decl :
  From.Outcometree.out_type_decl -> To.Outcometree.out_type_decl =
  fun
    { From.Outcometree.otype_name = otype_name;
      From.Outcometree.otype_params = otype_params;
      From.Outcometree.otype_type = otype_type;
      From.Outcometree.otype_private = otype_private;
      From.Outcometree.otype_immediate = otype_immediate;
      From.Outcometree.otype_cstrs = otype_cstrs }
     ->
    {
      To.Outcometree.otype_name = otype_name;
      To.Outcometree.otype_params =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))
           otype_params);
      To.Outcometree.otype_type =
        (copy_out_type otype_type);
      To.Outcometree.otype_private =
        (copy_From_Asttypes_private_flag otype_private);
      To.Outcometree.otype_immediate = (copy_bool otype_immediate);
      To.Outcometree.otype_unboxed = false;
      To.Outcometree.otype_cstrs =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_out_type x0),
                (copy_out_type x1))) otype_cstrs)
    }

and copy_out_module_type :
  From.Outcometree.out_module_type -> To.Outcometree.out_module_type
  =
  function
  | From.Outcometree.Omty_abstract  -> To.Outcometree.Omty_abstract
  | From.Outcometree.Omty_functor (x0,x1,x2) ->
      To.Outcometree.Omty_functor
        (x0, (copy_option copy_out_module_type x1),
          (copy_out_module_type x2))
  | From.Outcometree.Omty_ident x0 ->
      To.Outcometree.Omty_ident (copy_out_ident x0)
  | From.Outcometree.Omty_signature x0 ->
      To.Outcometree.Omty_signature
        (List.map copy_out_sig_item x0)
  | From.Outcometree.Omty_alias x0 ->
      To.Outcometree.Omty_alias (copy_out_ident x0)

and copy_out_ext_status :
  From.Outcometree.out_ext_status -> To.Outcometree.out_ext_status =
  function
  | From.Outcometree.Oext_first  -> To.Outcometree.Oext_first
  | From.Outcometree.Oext_next  -> To.Outcometree.Oext_next
  | From.Outcometree.Oext_exception  -> To.Outcometree.Oext_exception

and copy_out_extension_constructor :
  From.Outcometree.out_extension_constructor ->
    To.Outcometree.out_extension_constructor
  =
  fun
    { From.Outcometree.oext_name = oext_name;
      From.Outcometree.oext_type_name = oext_type_name;
      From.Outcometree.oext_type_params = oext_type_params;
      From.Outcometree.oext_args = oext_args;
      From.Outcometree.oext_ret_type = oext_ret_type;
      From.Outcometree.oext_private = oext_private }
     ->
    {
      To.Outcometree.oext_name = oext_name;
      To.Outcometree.oext_type_name = oext_type_name;
      To.Outcometree.oext_type_params =
        (List.map (fun x  -> x) oext_type_params);
      To.Outcometree.oext_args =
        (List.map copy_out_type oext_args);
      To.Outcometree.oext_ret_type =
        (copy_option copy_out_type oext_ret_type);
      To.Outcometree.oext_private =
        (copy_From_Asttypes_private_flag oext_private)
    }

and copy_From_Asttypes_private_flag :
  From.Asttypes.private_flag -> To.Asttypes.private_flag =
  function
  | From.Asttypes.Private  -> To.Asttypes.Private
  | From.Asttypes.Public  -> To.Asttypes.Public

and copy_out_rec_status :
  From.Outcometree.out_rec_status -> To.Outcometree.out_rec_status =
  function
  | From.Outcometree.Orec_not  -> To.Outcometree.Orec_not
  | From.Outcometree.Orec_first  -> To.Outcometree.Orec_first
  | From.Outcometree.Orec_next  -> To.Outcometree.Orec_next

and copy_out_class_type :
  From.Outcometree.out_class_type -> To.Outcometree.out_class_type =
  function
  | From.Outcometree.Octy_constr (x0,x1) ->
      To.Outcometree.Octy_constr
        ((copy_out_ident x0),
          (List.map copy_out_type x1))
  | From.Outcometree.Octy_arrow (x0,x1,x2) ->
      To.Outcometree.Octy_arrow
        (x0, (copy_out_type x1),
          (copy_out_class_type x2))
  | From.Outcometree.Octy_signature (x0,x1) ->
      To.Outcometree.Octy_signature
        ((copy_option copy_out_type x0),
          (List.map copy_out_class_sig_item x1))

and copy_out_class_sig_item :
  From.Outcometree.out_class_sig_item ->
    To.Outcometree.out_class_sig_item
  =
  function
  | From.Outcometree.Ocsg_constraint (x0,x1) ->
      To.Outcometree.Ocsg_constraint
        ((copy_out_type x0),
          (copy_out_type x1))
  | From.Outcometree.Ocsg_method (x0,x1,x2,x3) ->
      To.Outcometree.Ocsg_method
        (x0, (copy_bool x1), (copy_bool x2),
          (copy_out_type x3))
  | From.Outcometree.Ocsg_value (x0,x1,x2,x3) ->
      To.Outcometree.Ocsg_value
        (x0, (copy_bool x1), (copy_bool x2),
          (copy_out_type x3))

and copy_out_type :
  From.Outcometree.out_type -> To.Outcometree.out_type =
  function
  | From.Outcometree.Otyp_abstract  -> To.Outcometree.Otyp_abstract
  | From.Outcometree.Otyp_open  -> To.Outcometree.Otyp_open
  | From.Outcometree.Otyp_alias (x0,x1) ->
      To.Outcometree.Otyp_alias
        ((copy_out_type x0), x1)
  | From.Outcometree.Otyp_arrow (x0,x1,x2) ->
      To.Outcometree.Otyp_arrow
        (x0, (copy_out_type x1),
          (copy_out_type x2))
  | From.Outcometree.Otyp_class (x0,x1,x2) ->
      To.Outcometree.Otyp_class
        ((copy_bool x0), (copy_out_ident x1),
          (List.map copy_out_type x2))
  | From.Outcometree.Otyp_constr (x0,x1) ->
      To.Outcometree.Otyp_constr
        ((copy_out_ident x0),
          (List.map copy_out_type x1))
  | From.Outcometree.Otyp_manifest (x0,x1) ->
      To.Outcometree.Otyp_manifest
        ((copy_out_type x0),
          (copy_out_type x1))
  | From.Outcometree.Otyp_object (x0,x1) ->
      To.Outcometree.Otyp_object
        ((List.map
            (fun x  ->
               let (x0,x1) = x  in
               (x0, (copy_out_type x1))) x0),
          (copy_option copy_bool x1))
  | From.Outcometree.Otyp_record x0 ->
      To.Outcometree.Otyp_record
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (copy_bool x1), (copy_out_type x2)))
           x0)
  | From.Outcometree.Otyp_stuff x0 -> To.Outcometree.Otyp_stuff x0
  | From.Outcometree.Otyp_sum x0 ->
      To.Outcometree.Otyp_sum
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (List.map copy_out_type x1),
                (copy_option copy_out_type x2))) x0)
  | From.Outcometree.Otyp_tuple x0 ->
      To.Outcometree.Otyp_tuple
        (List.map copy_out_type x0)
  | From.Outcometree.Otyp_var (x0,x1) ->
      To.Outcometree.Otyp_var ((copy_bool x0), x1)
  | From.Outcometree.Otyp_variant (x0,x1,x2,x3) ->
      To.Outcometree.Otyp_variant
        ((copy_bool x0), (copy_out_variant x1),
          (copy_bool x2),
          (copy_option (fun x  -> List.map (fun x  -> x) x) x3))
  | From.Outcometree.Otyp_poly (x0,x1) ->
      To.Outcometree.Otyp_poly
        ((List.map (fun x  -> x) x0), (copy_out_type x1))
  | From.Outcometree.Otyp_module (x0,x1,x2) ->
      To.Outcometree.Otyp_module
        (x0, (List.map (fun x  -> x) x1),
          (List.map copy_out_type x2))
  | From.Outcometree.Otyp_attribute (x0,x1) ->
      To.Outcometree.Otyp_attribute
        ((copy_out_type x0),
          (copy_out_attribute x1))

and copy_out_attribute :
  From.Outcometree.out_attribute -> To.Outcometree.out_attribute =
  fun { From.Outcometree.oattr_name = oattr_name }  ->
    { To.Outcometree.oattr_name = oattr_name }

and copy_out_variant :
  From.Outcometree.out_variant -> To.Outcometree.out_variant =
  function
  | From.Outcometree.Ovar_fields x0 ->
      To.Outcometree.Ovar_fields
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (copy_bool x1),
                (List.map copy_out_type x2))) x0)
  | From.Outcometree.Ovar_name (x0,x1) ->
      To.Outcometree.Ovar_name
        ((copy_out_ident x0),
          (List.map copy_out_type x1))

and copy_out_value :
  From.Outcometree.out_value -> To.Outcometree.out_value =
  function
  | From.Outcometree.Oval_array x0 ->
      To.Outcometree.Oval_array
        (List.map copy_out_value x0)
  | From.Outcometree.Oval_char x0 -> To.Outcometree.Oval_char x0
  | From.Outcometree.Oval_constr (x0,x1) ->
      To.Outcometree.Oval_constr
        ((copy_out_ident x0),
          (List.map copy_out_value x1))
  | From.Outcometree.Oval_ellipsis  -> To.Outcometree.Oval_ellipsis
  | From.Outcometree.Oval_float x0 ->
      To.Outcometree.Oval_float (copy_float x0)
  | From.Outcometree.Oval_int x0 -> To.Outcometree.Oval_int x0
  | From.Outcometree.Oval_int32 x0 -> To.Outcometree.Oval_int32 x0
  | From.Outcometree.Oval_int64 x0 -> To.Outcometree.Oval_int64 x0
  | From.Outcometree.Oval_nativeint x0 ->
      To.Outcometree.Oval_nativeint x0
  | From.Outcometree.Oval_list x0 ->
      To.Outcometree.Oval_list
        (List.map copy_out_value x0)
  | From.Outcometree.Oval_printer x0 ->
      To.Outcometree.Oval_printer x0
  | From.Outcometree.Oval_record x0 ->
      To.Outcometree.Oval_record
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_out_ident x0),
                (copy_out_value x1))) x0)
  | From.Outcometree.Oval_string x0 -> To.Outcometree.Oval_string x0
  | From.Outcometree.Oval_stuff x0 -> To.Outcometree.Oval_stuff x0
  | From.Outcometree.Oval_tuple x0 ->
      To.Outcometree.Oval_tuple
        (List.map copy_out_value x0)
  | From.Outcometree.Oval_variant (x0,x1) ->
      To.Outcometree.Oval_variant
        (x0, (copy_option copy_out_value x1))

and copy_float : float -> float = fun x  -> x

and copy_out_ident :
  From.Outcometree.out_ident -> To.Outcometree.out_ident =
  function
  | From.Outcometree.Oide_apply (x0,x1) ->
      To.Outcometree.Oide_apply ((copy_out_ident x0), (copy_out_ident x1))
  | From.Outcometree.Oide_dot (x0,x1) ->
      To.Outcometree.Oide_dot ((copy_out_ident x0), x1)
  | From.Outcometree.Oide_ident x0 -> To.Outcometree.Oide_ident x0

let rec copy_toplevel_phrase :
  From.Parsetree.toplevel_phrase -> To.Parsetree.toplevel_phrase =
  function
  | From.Parsetree.Ptop_def x0 ->
      To.Parsetree.Ptop_def (copy_structure x0)
  | From.Parsetree.Ptop_dir (x0,x1) ->
      To.Parsetree.Ptop_dir (x0, copy_directive_argument x1)

and copy_directive_argument :
  From.Parsetree.directive_argument -> To.Parsetree.directive_argument =
  function
  | From.Parsetree.Pdir_none  -> To.Parsetree.Pdir_none
  | From.Parsetree.Pdir_string x0 -> To.Parsetree.Pdir_string x0
  | From.Parsetree.Pdir_int (x0,x1) ->
      To.Parsetree.Pdir_int (x0, copy_option (fun x  -> x) x1)
  | From.Parsetree.Pdir_ident x0 ->
      To.Parsetree.Pdir_ident (copy_longident x0)
  | From.Parsetree.Pdir_bool x0 ->
      To.Parsetree.Pdir_bool (copy_bool x0)

let copy_out_type_extension :
  From.Outcometree.out_type_extension -> To.Outcometree.out_type_extension =
  fun
    { From.Outcometree.otyext_name = otyext_name;
      From.Outcometree.otyext_params = otyext_params;
      From.Outcometree.otyext_constructors = otyext_constructors;
      From.Outcometree.otyext_private = otyext_private }
     ->
    {
      To.Outcometree.otyext_name = otyext_name;
      To.Outcometree.otyext_params =
        (List.map (fun x  -> x) otyext_params);
      To.Outcometree.otyext_constructors =
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (List.map copy_out_type x1),
                (copy_option copy_out_type x2)))
           otyext_constructors);
      To.Outcometree.otyext_private =
        (copy_private_flag otyext_private)
    }

let copy_cases x = List.map copy_case x
let copy_pat = copy_pattern
let copy_expr = copy_expression
let copy_typ = copy_core_type

end
module Migrate_parsetree_404_403_migrate
= struct
#1 "migrate_parsetree_404_403_migrate.ml"
# 1 "src/migrate_parsetree_404_403_migrate.ml"
# 1 "src/migrate_parsetree_404_403_migrate.ml"
# 1 "src/migrate_parsetree_404_403_migrate.ml"
# 1 "src/migrate_parsetree_404_403_migrate.ml"
# 1 "src/migrate_parsetree_404_403_migrate.ml"
# 1 "src/migrate_parsetree_404_403_migrate.ml"
# 1 "src/migrate_parsetree_404_403_migrate.ml"
# 1 "src/migrate_parsetree_404_403_migrate.ml"
# 1 "src/migrate_parsetree_404_403_migrate.ml"
# 1 "src/migrate_parsetree_404_403_migrate.ml"
# 1 "src/migrate_parsetree_404_403_migrate.ml"
# 1 "src/migrate_parsetree_404_403_migrate.ml"
# 1 "src/migrate_parsetree_404_403_migrate.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*                         Alain Frisch, LexiFi                           *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

module Def = Migrate_parsetree_def
module From = Ast_404
module To = Ast_403

let from_loc {From.Location. txt = _; loc} = loc

let migration_error location feature =
  raise (Def.Migration_error (feature, location))

let rec copy_expression :
  From.Parsetree.expression ->
    To.Parsetree.expression
  =
  fun
    { From.Parsetree.pexp_desc = pexp_desc;
      From.Parsetree.pexp_loc = pexp_loc;
      From.Parsetree.pexp_attributes = pexp_attributes }
     ->
    {
      To.Parsetree.pexp_desc =
        (copy_expression_desc pexp_loc pexp_desc);
      To.Parsetree.pexp_loc =
        (copy_location pexp_loc);
      To.Parsetree.pexp_attributes =
        (copy_attributes pexp_attributes)
    }

and copy_expression_desc loc :
  From.Parsetree.expression_desc ->
    To.Parsetree.expression_desc
  =
  function
  | From.Parsetree.Pexp_ident x0 ->
      To.Parsetree.Pexp_ident
        (copy_loc copy_longident
           x0)
  | From.Parsetree.Pexp_constant x0 ->
      To.Parsetree.Pexp_constant
        (copy_constant x0)
  | From.Parsetree.Pexp_let (x0,x1,x2) ->
      To.Parsetree.Pexp_let
        ((copy_rec_flag x0),
          (List.map copy_value_binding x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_function x0 ->
      To.Parsetree.Pexp_function
        (List.map copy_case x0)
  | From.Parsetree.Pexp_fun (x0,x1,x2,x3) ->
      To.Parsetree.Pexp_fun
        ((copy_arg_label x0),
          (copy_option copy_expression x1),
          (copy_pattern x2),
          (copy_expression x3))
  | From.Parsetree.Pexp_apply (x0,x1) ->
      To.Parsetree.Pexp_apply
        ((copy_expression x0),
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                ((copy_arg_label x0),
                  (copy_expression x1))) x1))
  | From.Parsetree.Pexp_match (x0,x1) ->
      To.Parsetree.Pexp_match
        ((copy_expression x0),
          (List.map copy_case x1))
  | From.Parsetree.Pexp_try (x0,x1) ->
      To.Parsetree.Pexp_try
        ((copy_expression x0),
          (List.map copy_case x1))
  | From.Parsetree.Pexp_tuple x0 ->
      To.Parsetree.Pexp_tuple
        (List.map copy_expression x0)
  | From.Parsetree.Pexp_construct (x0,x1) ->
      To.Parsetree.Pexp_construct
        ((copy_loc
            copy_longident x0),
          (copy_option copy_expression x1))
  | From.Parsetree.Pexp_variant (x0,x1) ->
      To.Parsetree.Pexp_variant
        ((copy_label x0),
          (copy_option copy_expression x1))
  | From.Parsetree.Pexp_record (x0,x1) ->
      To.Parsetree.Pexp_record
        ((List.map
            (fun x  ->
               let (x0,x1) = x  in
               ((copy_loc
                   copy_longident x0),
                 (copy_expression x1))) x0),
          (copy_option copy_expression x1))
  | From.Parsetree.Pexp_field (x0,x1) ->
      To.Parsetree.Pexp_field
        ((copy_expression x0),
          (copy_loc
             copy_longident x1))
  | From.Parsetree.Pexp_setfield (x0,x1,x2) ->
      To.Parsetree.Pexp_setfield
        ((copy_expression x0),
          (copy_loc
             copy_longident x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_array x0 ->
      To.Parsetree.Pexp_array
        (List.map copy_expression x0)
  | From.Parsetree.Pexp_ifthenelse (x0,x1,x2) ->
      To.Parsetree.Pexp_ifthenelse
        ((copy_expression x0),
          (copy_expression x1),
          (copy_option copy_expression x2))
  | From.Parsetree.Pexp_sequence (x0,x1) ->
      To.Parsetree.Pexp_sequence
        ((copy_expression x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_while (x0,x1) ->
      To.Parsetree.Pexp_while
        ((copy_expression x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_for (x0,x1,x2,x3,x4) ->
      To.Parsetree.Pexp_for
        ((copy_pattern x0),
          (copy_expression x1),
          (copy_expression x2),
          (copy_direction_flag x3),
          (copy_expression x4))
  | From.Parsetree.Pexp_constraint (x0,x1) ->
      To.Parsetree.Pexp_constraint
        ((copy_expression x0),
          (copy_core_type x1))
  | From.Parsetree.Pexp_coerce (x0,x1,x2) ->
      To.Parsetree.Pexp_coerce
        ((copy_expression x0),
          (copy_option copy_core_type x1),
          (copy_core_type x2))
  | From.Parsetree.Pexp_send (x0,x1) ->
      To.Parsetree.Pexp_send
        ((copy_expression x0), x1)
  | From.Parsetree.Pexp_new x0 ->
      To.Parsetree.Pexp_new
        (copy_loc copy_longident
           x0)
  | From.Parsetree.Pexp_setinstvar (x0,x1) ->
      To.Parsetree.Pexp_setinstvar
        ((copy_loc (fun x  -> x) x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_override x0 ->
      To.Parsetree.Pexp_override
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_loc (fun x  -> x) x0),
                (copy_expression x1))) x0)
  | From.Parsetree.Pexp_letmodule (x0,x1,x2) ->
      To.Parsetree.Pexp_letmodule
        ((copy_loc (fun x  -> x) x0),
          (copy_module_expr x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_letexception _ ->
      migration_error loc Def.Pexp_letexception
  | From.Parsetree.Pexp_assert x0 ->
      To.Parsetree.Pexp_assert
        (copy_expression x0)
  | From.Parsetree.Pexp_lazy x0 ->
      To.Parsetree.Pexp_lazy
        (copy_expression x0)
  | From.Parsetree.Pexp_poly (x0,x1) ->
      To.Parsetree.Pexp_poly
        ((copy_expression x0),
          (copy_option copy_core_type x1))
  | From.Parsetree.Pexp_object x0 ->
      To.Parsetree.Pexp_object
        (copy_class_structure x0)
  | From.Parsetree.Pexp_newtype (x0,x1) ->
      To.Parsetree.Pexp_newtype
        (x0, (copy_expression x1))
  | From.Parsetree.Pexp_pack x0 ->
      To.Parsetree.Pexp_pack
        (copy_module_expr x0)
  | From.Parsetree.Pexp_open (x0,x1,x2) ->
      To.Parsetree.Pexp_open
        ((copy_override_flag x0),
          (copy_loc
             copy_longident x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_extension x0 ->
      To.Parsetree.Pexp_extension
        (copy_extension x0)
  | From.Parsetree.Pexp_unreachable  ->
      To.Parsetree.Pexp_unreachable

and copy_direction_flag :
  From.Asttypes.direction_flag ->
    To.Asttypes.direction_flag
  =
  function
  | From.Asttypes.Upto  -> To.Asttypes.Upto
  | From.Asttypes.Downto  -> To.Asttypes.Downto

and copy_case :
  From.Parsetree.case -> To.Parsetree.case =
  fun
    { From.Parsetree.pc_lhs = pc_lhs;
      From.Parsetree.pc_guard = pc_guard;
      From.Parsetree.pc_rhs = pc_rhs }
     ->
    {
      To.Parsetree.pc_lhs =
        (copy_pattern pc_lhs);
      To.Parsetree.pc_guard =
        (copy_option copy_expression pc_guard);
      To.Parsetree.pc_rhs =
        (copy_expression pc_rhs)
    }

and copy_value_binding :
  From.Parsetree.value_binding ->
    To.Parsetree.value_binding
  =
  fun
    { From.Parsetree.pvb_pat = pvb_pat;
      From.Parsetree.pvb_expr = pvb_expr;
      From.Parsetree.pvb_attributes = pvb_attributes;
      From.Parsetree.pvb_loc = pvb_loc }
     ->
    {
      To.Parsetree.pvb_pat =
        (copy_pattern pvb_pat);
      To.Parsetree.pvb_expr =
        (copy_expression pvb_expr);
      To.Parsetree.pvb_attributes =
        (copy_attributes pvb_attributes);
      To.Parsetree.pvb_loc =
        (copy_location pvb_loc)
    }

and copy_pattern :
  From.Parsetree.pattern -> To.Parsetree.pattern =
  fun
    { From.Parsetree.ppat_desc = ppat_desc;
      From.Parsetree.ppat_loc = ppat_loc;
      From.Parsetree.ppat_attributes = ppat_attributes }
     ->
    {
      To.Parsetree.ppat_desc =
        (copy_pattern_desc ppat_loc ppat_desc);
      To.Parsetree.ppat_loc =
        (copy_location ppat_loc);
      To.Parsetree.ppat_attributes =
        (copy_attributes ppat_attributes)
    }

and copy_pattern_desc loc :
  From.Parsetree.pattern_desc ->
    To.Parsetree.pattern_desc
  =
  function
  | From.Parsetree.Ppat_any  ->
      To.Parsetree.Ppat_any
  | From.Parsetree.Ppat_var x0 ->
      To.Parsetree.Ppat_var
        (copy_loc (fun x  -> x) x0)
  | From.Parsetree.Ppat_alias (x0,x1) ->
      To.Parsetree.Ppat_alias
        ((copy_pattern x0),
          (copy_loc (fun x  -> x) x1))
  | From.Parsetree.Ppat_constant x0 ->
      To.Parsetree.Ppat_constant
        (copy_constant x0)
  | From.Parsetree.Ppat_interval (x0,x1) ->
      To.Parsetree.Ppat_interval
        ((copy_constant x0),
          (copy_constant x1))
  | From.Parsetree.Ppat_tuple x0 ->
      To.Parsetree.Ppat_tuple
        (List.map copy_pattern x0)
  | From.Parsetree.Ppat_construct (x0,x1) ->
      To.Parsetree.Ppat_construct
        ((copy_loc
            copy_longident x0),
          (copy_option copy_pattern x1))
  | From.Parsetree.Ppat_variant (x0,x1) ->
      To.Parsetree.Ppat_variant
        ((copy_label x0),
          (copy_option copy_pattern x1))
  | From.Parsetree.Ppat_record (x0,x1) ->
      To.Parsetree.Ppat_record
        ((List.map
            (fun x  ->
               let (x0,x1) = x  in
               ((copy_loc
                   copy_longident x0),
                 (copy_pattern x1))) x0),
          (copy_closed_flag x1))
  | From.Parsetree.Ppat_array x0 ->
      To.Parsetree.Ppat_array
        (List.map copy_pattern x0)
  | From.Parsetree.Ppat_or (x0,x1) ->
      To.Parsetree.Ppat_or
        ((copy_pattern x0),
          (copy_pattern x1))
  | From.Parsetree.Ppat_constraint (x0,x1) ->
      To.Parsetree.Ppat_constraint
        ((copy_pattern x0),
          (copy_core_type x1))
  | From.Parsetree.Ppat_type x0 ->
      To.Parsetree.Ppat_type
        (copy_loc copy_longident
           x0)
  | From.Parsetree.Ppat_lazy x0 ->
      To.Parsetree.Ppat_lazy
        (copy_pattern x0)
  | From.Parsetree.Ppat_unpack x0 ->
      To.Parsetree.Ppat_unpack
        (copy_loc (fun x  -> x) x0)
  | From.Parsetree.Ppat_exception x0 ->
      To.Parsetree.Ppat_exception
        (copy_pattern x0)
  | From.Parsetree.Ppat_extension x0 ->
      To.Parsetree.Ppat_extension
        (copy_extension x0)
  | From.Parsetree.Ppat_open _ ->
      migration_error loc Def.Ppat_open
and copy_core_type :
  From.Parsetree.core_type ->
    To.Parsetree.core_type
  =
  fun
    { From.Parsetree.ptyp_desc = ptyp_desc;
      From.Parsetree.ptyp_loc = ptyp_loc;
      From.Parsetree.ptyp_attributes = ptyp_attributes }
     ->
    {
      To.Parsetree.ptyp_desc =
        (copy_core_type_desc ptyp_desc);
      To.Parsetree.ptyp_loc =
        (copy_location ptyp_loc);
      To.Parsetree.ptyp_attributes =
        (copy_attributes ptyp_attributes)
    }

and copy_core_type_desc :
  From.Parsetree.core_type_desc ->
    To.Parsetree.core_type_desc
  =
  function
  | From.Parsetree.Ptyp_any  ->
      To.Parsetree.Ptyp_any
  | From.Parsetree.Ptyp_var x0 ->
      To.Parsetree.Ptyp_var x0
  | From.Parsetree.Ptyp_arrow (x0,x1,x2) ->
      To.Parsetree.Ptyp_arrow
        ((copy_arg_label x0),
          (copy_core_type x1),
          (copy_core_type x2))
  | From.Parsetree.Ptyp_tuple x0 ->
      To.Parsetree.Ptyp_tuple
        (List.map copy_core_type x0)
  | From.Parsetree.Ptyp_constr (x0,x1) ->
      To.Parsetree.Ptyp_constr
        ((copy_loc
            copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Ptyp_object (x0,x1) ->
      To.Parsetree.Ptyp_object
        ((List.map
            (fun x  ->
               let (x0,x1,x2) = x  in
               (x0, (copy_attributes x1),
                 (copy_core_type x2))) x0),
          (copy_closed_flag x1))
  | From.Parsetree.Ptyp_class (x0,x1) ->
      To.Parsetree.Ptyp_class
        ((copy_loc
            copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Ptyp_alias (x0,x1) ->
      To.Parsetree.Ptyp_alias
        ((copy_core_type x0), x1)
  | From.Parsetree.Ptyp_variant (x0,x1,x2) ->
      To.Parsetree.Ptyp_variant
        ((List.map copy_row_field x0),
          (copy_closed_flag x1),
          (copy_option
             (fun x  -> List.map copy_label x) x2))
  | From.Parsetree.Ptyp_poly (x0,x1) ->
      To.Parsetree.Ptyp_poly
        ((List.map (fun x  -> x) x0),
          (copy_core_type x1))
  | From.Parsetree.Ptyp_package x0 ->
      To.Parsetree.Ptyp_package
        (copy_package_type x0)
  | From.Parsetree.Ptyp_extension x0 ->
      To.Parsetree.Ptyp_extension
        (copy_extension x0)

and copy_package_type :
  From.Parsetree.package_type ->
    To.Parsetree.package_type
  =
  fun x  ->
    let (x0,x1) = x  in
    ((copy_loc copy_longident x0),
      (List.map
         (fun x  ->
            let (x0,x1) = x  in
            ((copy_loc
                copy_longident x0),
              (copy_core_type x1))) x1))

and copy_row_field :
  From.Parsetree.row_field ->
    To.Parsetree.row_field
  =
  function
  | From.Parsetree.Rtag (x0,x1,x2,x3) ->
      To.Parsetree.Rtag
        ((copy_label x0),
          (copy_attributes x1), (copy_bool x2),
          (List.map copy_core_type x3))
  | From.Parsetree.Rinherit x0 ->
      To.Parsetree.Rinherit
        (copy_core_type x0)

and copy_attributes :
  From.Parsetree.attributes ->
    To.Parsetree.attributes
  = fun x  -> List.map copy_attribute x

and copy_attribute :
  From.Parsetree.attribute ->
    To.Parsetree.attribute
  =
  fun x  ->
    let (x0,x1) = x  in
    ((copy_loc (fun x  -> x) x0),
      (copy_payload x1))

and copy_payload :
  From.Parsetree.payload -> To.Parsetree.payload =
  function
  | From.Parsetree.PStr x0 ->
      To.Parsetree.PStr
        (copy_structure x0)
  | From.Parsetree.PSig x0 ->
      To.Parsetree.PSig
        (copy_signature x0)
  | From.Parsetree.PTyp x0 ->
      To.Parsetree.PTyp
        (copy_core_type x0)
  | From.Parsetree.PPat (x0,x1) ->
      To.Parsetree.PPat
        ((copy_pattern x0),
          (copy_option copy_expression x1))

and copy_structure :
  From.Parsetree.structure ->
    To.Parsetree.structure
  = fun x  -> List.map copy_structure_item x

and copy_structure_item :
  From.Parsetree.structure_item ->
    To.Parsetree.structure_item
  =
  fun
    { From.Parsetree.pstr_desc = pstr_desc;
      From.Parsetree.pstr_loc = pstr_loc }
     ->
    {
      To.Parsetree.pstr_desc =
        (copy_structure_item_desc pstr_desc);
      To.Parsetree.pstr_loc =
        (copy_location pstr_loc)
    }

and copy_structure_item_desc :
  From.Parsetree.structure_item_desc ->
    To.Parsetree.structure_item_desc
  =
  function
  | From.Parsetree.Pstr_eval (x0,x1) ->
      To.Parsetree.Pstr_eval
        ((copy_expression x0),
          (copy_attributes x1))
  | From.Parsetree.Pstr_value (x0,x1) ->
      To.Parsetree.Pstr_value
        ((copy_rec_flag x0),
          (List.map copy_value_binding x1))
  | From.Parsetree.Pstr_primitive x0 ->
      To.Parsetree.Pstr_primitive
        (copy_value_description x0)
  | From.Parsetree.Pstr_type (x0,x1) ->
      To.Parsetree.Pstr_type
        ((copy_rec_flag x0),
          (List.map copy_type_declaration x1))
  | From.Parsetree.Pstr_typext x0 ->
      To.Parsetree.Pstr_typext
        (copy_type_extension x0)
  | From.Parsetree.Pstr_exception x0 ->
      To.Parsetree.Pstr_exception
        (copy_extension_constructor x0)
  | From.Parsetree.Pstr_module x0 ->
      To.Parsetree.Pstr_module
        (copy_module_binding x0)
  | From.Parsetree.Pstr_recmodule x0 ->
      To.Parsetree.Pstr_recmodule
        (List.map copy_module_binding x0)
  | From.Parsetree.Pstr_modtype x0 ->
      To.Parsetree.Pstr_modtype
        (copy_module_type_declaration x0)
  | From.Parsetree.Pstr_open x0 ->
      To.Parsetree.Pstr_open
        (copy_open_description x0)
  | From.Parsetree.Pstr_class x0 ->
      To.Parsetree.Pstr_class
        (List.map copy_class_declaration x0)
  | From.Parsetree.Pstr_class_type x0 ->
      To.Parsetree.Pstr_class_type
        (List.map copy_class_type_declaration x0)
  | From.Parsetree.Pstr_include x0 ->
      To.Parsetree.Pstr_include
        (copy_include_declaration x0)
  | From.Parsetree.Pstr_attribute x0 ->
      To.Parsetree.Pstr_attribute
        (copy_attribute x0)
  | From.Parsetree.Pstr_extension (x0,x1) ->
      To.Parsetree.Pstr_extension
        ((copy_extension x0),
          (copy_attributes x1))

and copy_include_declaration :
  From.Parsetree.include_declaration ->
    To.Parsetree.include_declaration
  =
  fun x  ->
    copy_include_infos
      copy_module_expr x

and copy_class_declaration :
  From.Parsetree.class_declaration ->
    To.Parsetree.class_declaration
  =
  fun x  ->
    copy_class_infos
      copy_class_expr x

and copy_class_expr :
  From.Parsetree.class_expr ->
    To.Parsetree.class_expr
  =
  fun
    { From.Parsetree.pcl_desc = pcl_desc;
      From.Parsetree.pcl_loc = pcl_loc;
      From.Parsetree.pcl_attributes = pcl_attributes }
     ->
    {
      To.Parsetree.pcl_desc =
        (copy_class_expr_desc pcl_desc);
      To.Parsetree.pcl_loc =
        (copy_location pcl_loc);
      To.Parsetree.pcl_attributes =
        (copy_attributes pcl_attributes)
    }

and copy_class_expr_desc :
  From.Parsetree.class_expr_desc ->
    To.Parsetree.class_expr_desc
  =
  function
  | From.Parsetree.Pcl_constr (x0,x1) ->
      To.Parsetree.Pcl_constr
        ((copy_loc
            copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Pcl_structure x0 ->
      To.Parsetree.Pcl_structure
        (copy_class_structure x0)
  | From.Parsetree.Pcl_fun (x0,x1,x2,x3) ->
      To.Parsetree.Pcl_fun
        ((copy_arg_label x0),
          (copy_option copy_expression x1),
          (copy_pattern x2),
          (copy_class_expr x3))
  | From.Parsetree.Pcl_apply (x0,x1) ->
      To.Parsetree.Pcl_apply
        ((copy_class_expr x0),
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                ((copy_arg_label x0),
                  (copy_expression x1))) x1))
  | From.Parsetree.Pcl_let (x0,x1,x2) ->
      To.Parsetree.Pcl_let
        ((copy_rec_flag x0),
          (List.map copy_value_binding x1),
          (copy_class_expr x2))
  | From.Parsetree.Pcl_constraint (x0,x1) ->
      To.Parsetree.Pcl_constraint
        ((copy_class_expr x0),
          (copy_class_type x1))
  | From.Parsetree.Pcl_extension x0 ->
      To.Parsetree.Pcl_extension
        (copy_extension x0)

and copy_class_structure :
  From.Parsetree.class_structure ->
    To.Parsetree.class_structure
  =
  fun
    { From.Parsetree.pcstr_self = pcstr_self;
      From.Parsetree.pcstr_fields = pcstr_fields }
     ->
    {
      To.Parsetree.pcstr_self =
        (copy_pattern pcstr_self);
      To.Parsetree.pcstr_fields =
        (List.map copy_class_field pcstr_fields)
    }

and copy_class_field :
  From.Parsetree.class_field ->
    To.Parsetree.class_field
  =
  fun
    { From.Parsetree.pcf_desc = pcf_desc;
      From.Parsetree.pcf_loc = pcf_loc;
      From.Parsetree.pcf_attributes = pcf_attributes }
     ->
    {
      To.Parsetree.pcf_desc =
        (copy_class_field_desc pcf_desc);
      To.Parsetree.pcf_loc =
        (copy_location pcf_loc);
      To.Parsetree.pcf_attributes =
        (copy_attributes pcf_attributes)
    }

and copy_class_field_desc :
  From.Parsetree.class_field_desc ->
    To.Parsetree.class_field_desc
  =
  function
  | From.Parsetree.Pcf_inherit (x0,x1,x2) ->
      To.Parsetree.Pcf_inherit
        ((copy_override_flag x0),
          (copy_class_expr x1),
          (copy_option (fun x  -> x) x2))
  | From.Parsetree.Pcf_val x0 ->
      To.Parsetree.Pcf_val
        (let (x0,x1,x2) = x0  in
         ((copy_loc (fun x  -> x) x0),
           (copy_mutable_flag x1),
           (copy_class_field_kind x2)))
  | From.Parsetree.Pcf_method x0 ->
      To.Parsetree.Pcf_method
        (let (x0,x1,x2) = x0  in
         ((copy_loc (fun x  -> x) x0),
           (copy_private_flag x1),
           (copy_class_field_kind x2)))
  | From.Parsetree.Pcf_constraint x0 ->
      To.Parsetree.Pcf_constraint
        (let (x0,x1) = x0  in
         ((copy_core_type x0),
           (copy_core_type x1)))
  | From.Parsetree.Pcf_initializer x0 ->
      To.Parsetree.Pcf_initializer
        (copy_expression x0)
  | From.Parsetree.Pcf_attribute x0 ->
      To.Parsetree.Pcf_attribute
        (copy_attribute x0)
  | From.Parsetree.Pcf_extension x0 ->
      To.Parsetree.Pcf_extension
        (copy_extension x0)

and copy_class_field_kind :
  From.Parsetree.class_field_kind ->
    To.Parsetree.class_field_kind
  =
  function
  | From.Parsetree.Cfk_virtual x0 ->
      To.Parsetree.Cfk_virtual
        (copy_core_type x0)
  | From.Parsetree.Cfk_concrete (x0,x1) ->
      To.Parsetree.Cfk_concrete
        ((copy_override_flag x0),
          (copy_expression x1))

and copy_module_binding :
  From.Parsetree.module_binding ->
    To.Parsetree.module_binding
  =
  fun
    { From.Parsetree.pmb_name = pmb_name;
      From.Parsetree.pmb_expr = pmb_expr;
      From.Parsetree.pmb_attributes = pmb_attributes;
      From.Parsetree.pmb_loc = pmb_loc }
     ->
    {
      To.Parsetree.pmb_name =
        (copy_loc (fun x  -> x) pmb_name);
      To.Parsetree.pmb_expr =
        (copy_module_expr pmb_expr);
      To.Parsetree.pmb_attributes =
        (copy_attributes pmb_attributes);
      To.Parsetree.pmb_loc =
        (copy_location pmb_loc)
    }

and copy_module_expr :
  From.Parsetree.module_expr ->
    To.Parsetree.module_expr
  =
  fun
    { From.Parsetree.pmod_desc = pmod_desc;
      From.Parsetree.pmod_loc = pmod_loc;
      From.Parsetree.pmod_attributes = pmod_attributes }
     ->
    {
      To.Parsetree.pmod_desc =
        (copy_module_expr_desc pmod_desc);
      To.Parsetree.pmod_loc =
        (copy_location pmod_loc);
      To.Parsetree.pmod_attributes =
        (copy_attributes pmod_attributes)
    }

and copy_module_expr_desc :
  From.Parsetree.module_expr_desc ->
    To.Parsetree.module_expr_desc
  =
  function
  | From.Parsetree.Pmod_ident x0 ->
      To.Parsetree.Pmod_ident
        (copy_loc copy_longident
           x0)
  | From.Parsetree.Pmod_structure x0 ->
      To.Parsetree.Pmod_structure
        (copy_structure x0)
  | From.Parsetree.Pmod_functor (x0,x1,x2) ->
      To.Parsetree.Pmod_functor
        ((copy_loc (fun x  -> x) x0),
          (copy_option copy_module_type x1),
          (copy_module_expr x2))
  | From.Parsetree.Pmod_apply (x0,x1) ->
      To.Parsetree.Pmod_apply
        ((copy_module_expr x0),
          (copy_module_expr x1))
  | From.Parsetree.Pmod_constraint (x0,x1) ->
      To.Parsetree.Pmod_constraint
        ((copy_module_expr x0),
          (copy_module_type x1))
  | From.Parsetree.Pmod_unpack x0 ->
      To.Parsetree.Pmod_unpack
        (copy_expression x0)
  | From.Parsetree.Pmod_extension x0 ->
      To.Parsetree.Pmod_extension
        (copy_extension x0)

and copy_module_type :
  From.Parsetree.module_type ->
    To.Parsetree.module_type
  =
  fun
    { From.Parsetree.pmty_desc = pmty_desc;
      From.Parsetree.pmty_loc = pmty_loc;
      From.Parsetree.pmty_attributes = pmty_attributes }
     ->
    {
      To.Parsetree.pmty_desc =
        (copy_module_type_desc pmty_desc);
      To.Parsetree.pmty_loc =
        (copy_location pmty_loc);
      To.Parsetree.pmty_attributes =
        (copy_attributes pmty_attributes)
    }

and copy_module_type_desc :
  From.Parsetree.module_type_desc ->
    To.Parsetree.module_type_desc
  =
  function
  | From.Parsetree.Pmty_ident x0 ->
      To.Parsetree.Pmty_ident
        (copy_loc copy_longident
           x0)
  | From.Parsetree.Pmty_signature x0 ->
      To.Parsetree.Pmty_signature
        (copy_signature x0)
  | From.Parsetree.Pmty_functor (x0,x1,x2) ->
      To.Parsetree.Pmty_functor
        ((copy_loc (fun x  -> x) x0),
          (copy_option copy_module_type x1),
          (copy_module_type x2))
  | From.Parsetree.Pmty_with (x0,x1) ->
      To.Parsetree.Pmty_with
        ((copy_module_type x0),
          (List.map copy_with_constraint x1))
  | From.Parsetree.Pmty_typeof x0 ->
      To.Parsetree.Pmty_typeof
        (copy_module_expr x0)
  | From.Parsetree.Pmty_extension x0 ->
      To.Parsetree.Pmty_extension
        (copy_extension x0)
  | From.Parsetree.Pmty_alias x0 ->
      To.Parsetree.Pmty_alias
        (copy_loc copy_longident
           x0)

and copy_with_constraint :
  From.Parsetree.with_constraint ->
    To.Parsetree.with_constraint
  =
  function
  | From.Parsetree.Pwith_type (x0,x1) ->
      To.Parsetree.Pwith_type
        ((copy_loc
            copy_longident x0),
          (copy_type_declaration x1))
  | From.Parsetree.Pwith_module (x0,x1) ->
      To.Parsetree.Pwith_module
        ((copy_loc
            copy_longident x0),
          (copy_loc
             copy_longident x1))
  | From.Parsetree.Pwith_typesubst x0 ->
      To.Parsetree.Pwith_typesubst
        (copy_type_declaration x0)
  | From.Parsetree.Pwith_modsubst (x0,x1) ->
      To.Parsetree.Pwith_modsubst
        ((copy_loc (fun x  -> x) x0),
          (copy_loc
             copy_longident x1))

and copy_signature :
  From.Parsetree.signature ->
    To.Parsetree.signature
  = fun x  -> List.map copy_signature_item x

and copy_signature_item :
  From.Parsetree.signature_item ->
    To.Parsetree.signature_item
  =
  fun
    { From.Parsetree.psig_desc = psig_desc;
      From.Parsetree.psig_loc = psig_loc }
     ->
    {
      To.Parsetree.psig_desc =
        (copy_signature_item_desc psig_desc);
      To.Parsetree.psig_loc =
        (copy_location psig_loc)
    }

and copy_signature_item_desc :
  From.Parsetree.signature_item_desc ->
    To.Parsetree.signature_item_desc
  =
  function
  | From.Parsetree.Psig_value x0 ->
      To.Parsetree.Psig_value
        (copy_value_description x0)
  | From.Parsetree.Psig_type (x0,x1) ->
      To.Parsetree.Psig_type
        ((copy_rec_flag x0),
          (List.map copy_type_declaration x1))
  | From.Parsetree.Psig_typext x0 ->
      To.Parsetree.Psig_typext
        (copy_type_extension x0)
  | From.Parsetree.Psig_exception x0 ->
      To.Parsetree.Psig_exception
        (copy_extension_constructor x0)
  | From.Parsetree.Psig_module x0 ->
      To.Parsetree.Psig_module
        (copy_module_declaration x0)
  | From.Parsetree.Psig_recmodule x0 ->
      To.Parsetree.Psig_recmodule
        (List.map copy_module_declaration x0)
  | From.Parsetree.Psig_modtype x0 ->
      To.Parsetree.Psig_modtype
        (copy_module_type_declaration x0)
  | From.Parsetree.Psig_open x0 ->
      To.Parsetree.Psig_open
        (copy_open_description x0)
  | From.Parsetree.Psig_include x0 ->
      To.Parsetree.Psig_include
        (copy_include_description x0)
  | From.Parsetree.Psig_class x0 ->
      To.Parsetree.Psig_class
        (List.map copy_class_description x0)
  | From.Parsetree.Psig_class_type x0 ->
      To.Parsetree.Psig_class_type
        (List.map copy_class_type_declaration x0)
  | From.Parsetree.Psig_attribute x0 ->
      To.Parsetree.Psig_attribute
        (copy_attribute x0)
  | From.Parsetree.Psig_extension (x0,x1) ->
      To.Parsetree.Psig_extension
        ((copy_extension x0),
          (copy_attributes x1))

and copy_class_type_declaration :
  From.Parsetree.class_type_declaration ->
    To.Parsetree.class_type_declaration
  =
  fun x  ->
    copy_class_infos
      copy_class_type x

and copy_class_description :
  From.Parsetree.class_description ->
    To.Parsetree.class_description
  =
  fun x  ->
    copy_class_infos
      copy_class_type x

and copy_class_type :
  From.Parsetree.class_type ->
    To.Parsetree.class_type
  =
  fun
    { From.Parsetree.pcty_desc = pcty_desc;
      From.Parsetree.pcty_loc = pcty_loc;
      From.Parsetree.pcty_attributes = pcty_attributes }
     ->
    {
      To.Parsetree.pcty_desc =
        (copy_class_type_desc pcty_desc);
      To.Parsetree.pcty_loc =
        (copy_location pcty_loc);
      To.Parsetree.pcty_attributes =
        (copy_attributes pcty_attributes)
    }

and copy_class_type_desc :
  From.Parsetree.class_type_desc ->
    To.Parsetree.class_type_desc
  =
  function
  | From.Parsetree.Pcty_constr (x0,x1) ->
      To.Parsetree.Pcty_constr
        ((copy_loc
            copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Pcty_signature x0 ->
      To.Parsetree.Pcty_signature
        (copy_class_signature x0)
  | From.Parsetree.Pcty_arrow (x0,x1,x2) ->
      To.Parsetree.Pcty_arrow
        ((copy_arg_label x0),
          (copy_core_type x1),
          (copy_class_type x2))
  | From.Parsetree.Pcty_extension x0 ->
      To.Parsetree.Pcty_extension
        (copy_extension x0)

and copy_class_signature :
  From.Parsetree.class_signature ->
    To.Parsetree.class_signature
  =
  fun
    { From.Parsetree.pcsig_self = pcsig_self;
      From.Parsetree.pcsig_fields = pcsig_fields }
     ->
    {
      To.Parsetree.pcsig_self =
        (copy_core_type pcsig_self);
      To.Parsetree.pcsig_fields =
        (List.map copy_class_type_field
           pcsig_fields)
    }

and copy_class_type_field :
  From.Parsetree.class_type_field ->
    To.Parsetree.class_type_field
  =
  fun
    { From.Parsetree.pctf_desc = pctf_desc;
      From.Parsetree.pctf_loc = pctf_loc;
      From.Parsetree.pctf_attributes = pctf_attributes }
     ->
    {
      To.Parsetree.pctf_desc =
        (copy_class_type_field_desc pctf_desc);
      To.Parsetree.pctf_loc =
        (copy_location pctf_loc);
      To.Parsetree.pctf_attributes =
        (copy_attributes pctf_attributes)
    }

and copy_class_type_field_desc :
  From.Parsetree.class_type_field_desc ->
    To.Parsetree.class_type_field_desc
  =
  function
  | From.Parsetree.Pctf_inherit x0 ->
      To.Parsetree.Pctf_inherit
        (copy_class_type x0)
  | From.Parsetree.Pctf_val x0 ->
      To.Parsetree.Pctf_val
        (let (x0,x1,x2,x3) = x0  in
         (x0, (copy_mutable_flag x1),
           (copy_virtual_flag x2),
           (copy_core_type x3)))
  | From.Parsetree.Pctf_method x0 ->
      To.Parsetree.Pctf_method
        (let (x0,x1,x2,x3) = x0  in
         (x0, (copy_private_flag x1),
           (copy_virtual_flag x2),
           (copy_core_type x3)))
  | From.Parsetree.Pctf_constraint x0 ->
      To.Parsetree.Pctf_constraint
        (let (x0,x1) = x0  in
         ((copy_core_type x0),
           (copy_core_type x1)))
  | From.Parsetree.Pctf_attribute x0 ->
      To.Parsetree.Pctf_attribute
        (copy_attribute x0)
  | From.Parsetree.Pctf_extension x0 ->
      To.Parsetree.Pctf_extension
        (copy_extension x0)

and copy_extension :
  From.Parsetree.extension ->
    To.Parsetree.extension
  =
  fun x  ->
    let (x0,x1) = x  in
    ((copy_loc (fun x  -> x) x0),
      (copy_payload x1))

and copy_class_infos :
  'f0 'g0 .
    ('f0 -> 'g0) ->
      'f0 From.Parsetree.class_infos ->
        'g0 To.Parsetree.class_infos
  =
  fun f0  ->
    fun
      { From.Parsetree.pci_virt = pci_virt;
        From.Parsetree.pci_params = pci_params;
        From.Parsetree.pci_name = pci_name;
        From.Parsetree.pci_expr = pci_expr;
        From.Parsetree.pci_loc = pci_loc;
        From.Parsetree.pci_attributes = pci_attributes }
       ->
      {
        To.Parsetree.pci_virt =
          (copy_virtual_flag pci_virt);
        To.Parsetree.pci_params =
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                ((copy_core_type x0),
                  (copy_variance x1))) pci_params);
        To.Parsetree.pci_name =
          (copy_loc (fun x  -> x) pci_name);
        To.Parsetree.pci_expr = (f0 pci_expr);
        To.Parsetree.pci_loc =
          (copy_location pci_loc);
        To.Parsetree.pci_attributes =
          (copy_attributes pci_attributes)
      }

and copy_virtual_flag :
  From.Asttypes.virtual_flag ->
    To.Asttypes.virtual_flag
  =
  function
  | From.Asttypes.Virtual  -> To.Asttypes.Virtual
  | From.Asttypes.Concrete  -> To.Asttypes.Concrete

and copy_include_description :
  From.Parsetree.include_description ->
    To.Parsetree.include_description
  =
  fun x  ->
    copy_include_infos
      copy_module_type x

and copy_include_infos :
  'f0 'g0 .
    ('f0 -> 'g0) ->
      'f0 From.Parsetree.include_infos ->
        'g0 To.Parsetree.include_infos
  =
  fun f0  ->
    fun
      { From.Parsetree.pincl_mod = pincl_mod;
        From.Parsetree.pincl_loc = pincl_loc;
        From.Parsetree.pincl_attributes = pincl_attributes }
       ->
      {
        To.Parsetree.pincl_mod = (f0 pincl_mod);
        To.Parsetree.pincl_loc =
          (copy_location pincl_loc);
        To.Parsetree.pincl_attributes =
          (copy_attributes pincl_attributes)
      }

and copy_open_description :
  From.Parsetree.open_description ->
    To.Parsetree.open_description
  =
  fun
    { From.Parsetree.popen_lid = popen_lid;
      From.Parsetree.popen_override = popen_override;
      From.Parsetree.popen_loc = popen_loc;
      From.Parsetree.popen_attributes = popen_attributes }
     ->
    {
      To.Parsetree.popen_lid =
        (copy_loc copy_longident
           popen_lid);
      To.Parsetree.popen_override =
        (copy_override_flag popen_override);
      To.Parsetree.popen_loc =
        (copy_location popen_loc);
      To.Parsetree.popen_attributes =
        (copy_attributes popen_attributes)
    }

and copy_override_flag :
  From.Asttypes.override_flag ->
    To.Asttypes.override_flag
  =
  function
  | From.Asttypes.Override  -> To.Asttypes.Override
  | From.Asttypes.Fresh  -> To.Asttypes.Fresh

and copy_module_type_declaration :
  From.Parsetree.module_type_declaration ->
    To.Parsetree.module_type_declaration
  =
  fun
    { From.Parsetree.pmtd_name = pmtd_name;
      From.Parsetree.pmtd_type = pmtd_type;
      From.Parsetree.pmtd_attributes = pmtd_attributes;
      From.Parsetree.pmtd_loc = pmtd_loc }
     ->
    {
      To.Parsetree.pmtd_name =
        (copy_loc (fun x  -> x) pmtd_name);
      To.Parsetree.pmtd_type =
        (copy_option copy_module_type pmtd_type);
      To.Parsetree.pmtd_attributes =
        (copy_attributes pmtd_attributes);
      To.Parsetree.pmtd_loc =
        (copy_location pmtd_loc)
    }

and copy_module_declaration :
  From.Parsetree.module_declaration ->
    To.Parsetree.module_declaration
  =
  fun
    { From.Parsetree.pmd_name = pmd_name;
      From.Parsetree.pmd_type = pmd_type;
      From.Parsetree.pmd_attributes = pmd_attributes;
      From.Parsetree.pmd_loc = pmd_loc }
     ->
    {
      To.Parsetree.pmd_name =
        (copy_loc (fun x  -> x) pmd_name);
      To.Parsetree.pmd_type =
        (copy_module_type pmd_type);
      To.Parsetree.pmd_attributes =
        (copy_attributes pmd_attributes);
      To.Parsetree.pmd_loc =
        (copy_location pmd_loc)
    }

and copy_type_extension :
  From.Parsetree.type_extension ->
    To.Parsetree.type_extension
  =
  fun
    { From.Parsetree.ptyext_path = ptyext_path;
      From.Parsetree.ptyext_params = ptyext_params;
      From.Parsetree.ptyext_constructors = ptyext_constructors;
      From.Parsetree.ptyext_private = ptyext_private;
      From.Parsetree.ptyext_attributes = ptyext_attributes }
     ->
    {
      To.Parsetree.ptyext_path =
        (copy_loc copy_longident
           ptyext_path);
      To.Parsetree.ptyext_params =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_core_type x0),
                (copy_variance x1))) ptyext_params);
      To.Parsetree.ptyext_constructors =
        (List.map copy_extension_constructor
           ptyext_constructors);
      To.Parsetree.ptyext_private =
        (copy_private_flag ptyext_private);
      To.Parsetree.ptyext_attributes =
        (copy_attributes ptyext_attributes)
    }

and copy_extension_constructor :
  From.Parsetree.extension_constructor ->
    To.Parsetree.extension_constructor
  =
  fun
    { From.Parsetree.pext_name = pext_name;
      From.Parsetree.pext_kind = pext_kind;
      From.Parsetree.pext_loc = pext_loc;
      From.Parsetree.pext_attributes = pext_attributes }
     ->
    {
      To.Parsetree.pext_name =
        (copy_loc (fun x  -> x) pext_name);
      To.Parsetree.pext_kind =
        (copy_extension_constructor_kind pext_kind);
      To.Parsetree.pext_loc =
        (copy_location pext_loc);
      To.Parsetree.pext_attributes =
        (copy_attributes pext_attributes)
    }

and copy_extension_constructor_kind :
  From.Parsetree.extension_constructor_kind ->
    To.Parsetree.extension_constructor_kind
  =
  function
  | From.Parsetree.Pext_decl (x0,x1) ->
      To.Parsetree.Pext_decl
        ((copy_constructor_arguments x0),
          (copy_option copy_core_type x1))
  | From.Parsetree.Pext_rebind x0 ->
      To.Parsetree.Pext_rebind
        (copy_loc copy_longident
           x0)

and copy_type_declaration :
  From.Parsetree.type_declaration ->
    To.Parsetree.type_declaration
  =
  fun
    { From.Parsetree.ptype_name = ptype_name;
      From.Parsetree.ptype_params = ptype_params;
      From.Parsetree.ptype_cstrs = ptype_cstrs;
      From.Parsetree.ptype_kind = ptype_kind;
      From.Parsetree.ptype_private = ptype_private;
      From.Parsetree.ptype_manifest = ptype_manifest;
      From.Parsetree.ptype_attributes = ptype_attributes;
      From.Parsetree.ptype_loc = ptype_loc }
     ->
    {
      To.Parsetree.ptype_name =
        (copy_loc (fun x  -> x) ptype_name);
      To.Parsetree.ptype_params =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_core_type x0),
                (copy_variance x1))) ptype_params);
      To.Parsetree.ptype_cstrs =
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              ((copy_core_type x0),
                (copy_core_type x1),
                (copy_location x2))) ptype_cstrs);
      To.Parsetree.ptype_kind =
        (copy_type_kind ptype_kind);
      To.Parsetree.ptype_private =
        (copy_private_flag ptype_private);
      To.Parsetree.ptype_manifest =
        (copy_option copy_core_type ptype_manifest);
      To.Parsetree.ptype_attributes =
        (copy_attributes ptype_attributes);
      To.Parsetree.ptype_loc =
        (copy_location ptype_loc)
    }

and copy_private_flag :
  From.Asttypes.private_flag ->
    To.Asttypes.private_flag
  =
  function
  | From.Asttypes.Private  -> To.Asttypes.Private
  | From.Asttypes.Public  -> To.Asttypes.Public

and copy_type_kind :
  From.Parsetree.type_kind ->
    To.Parsetree.type_kind
  =
  function
  | From.Parsetree.Ptype_abstract  ->
      To.Parsetree.Ptype_abstract
  | From.Parsetree.Ptype_variant x0 ->
      To.Parsetree.Ptype_variant
        (List.map copy_constructor_declaration x0)
  | From.Parsetree.Ptype_record x0 ->
      To.Parsetree.Ptype_record
        (List.map copy_label_declaration x0)
  | From.Parsetree.Ptype_open  ->
      To.Parsetree.Ptype_open

and copy_constructor_declaration :
  From.Parsetree.constructor_declaration ->
    To.Parsetree.constructor_declaration
  =
  fun
    { From.Parsetree.pcd_name = pcd_name;
      From.Parsetree.pcd_args = pcd_args;
      From.Parsetree.pcd_res = pcd_res;
      From.Parsetree.pcd_loc = pcd_loc;
      From.Parsetree.pcd_attributes = pcd_attributes }
     ->
    {
      To.Parsetree.pcd_name =
        (copy_loc (fun x  -> x) pcd_name);
      To.Parsetree.pcd_args =
        (copy_constructor_arguments pcd_args);
      To.Parsetree.pcd_res =
        (copy_option copy_core_type pcd_res);
      To.Parsetree.pcd_loc =
        (copy_location pcd_loc);
      To.Parsetree.pcd_attributes =
        (copy_attributes pcd_attributes)
    }

and copy_constructor_arguments :
  From.Parsetree.constructor_arguments ->
    To.Parsetree.constructor_arguments
  =
  function
  | From.Parsetree.Pcstr_tuple x0 ->
      To.Parsetree.Pcstr_tuple
        (List.map copy_core_type x0)
  | From.Parsetree.Pcstr_record x0 ->
      To.Parsetree.Pcstr_record
        (List.map copy_label_declaration x0)

and copy_label_declaration :
  From.Parsetree.label_declaration ->
    To.Parsetree.label_declaration
  =
  fun
    { From.Parsetree.pld_name = pld_name;
      From.Parsetree.pld_mutable = pld_mutable;
      From.Parsetree.pld_type = pld_type;
      From.Parsetree.pld_loc = pld_loc;
      From.Parsetree.pld_attributes = pld_attributes }
     ->
    {
      To.Parsetree.pld_name =
        (copy_loc (fun x  -> x) pld_name);
      To.Parsetree.pld_mutable =
        (copy_mutable_flag pld_mutable);
      To.Parsetree.pld_type =
        (copy_core_type pld_type);
      To.Parsetree.pld_loc =
        (copy_location pld_loc);
      To.Parsetree.pld_attributes =
        (copy_attributes pld_attributes)
    }

and copy_mutable_flag :
  From.Asttypes.mutable_flag ->
    To.Asttypes.mutable_flag
  =
  function
  | From.Asttypes.Immutable  ->
      To.Asttypes.Immutable
  | From.Asttypes.Mutable  -> To.Asttypes.Mutable

and copy_variance :
  From.Asttypes.variance -> To.Asttypes.variance =
  function
  | From.Asttypes.Covariant  ->
      To.Asttypes.Covariant
  | From.Asttypes.Contravariant  ->
      To.Asttypes.Contravariant
  | From.Asttypes.Invariant  ->
      To.Asttypes.Invariant

and copy_value_description :
  From.Parsetree.value_description ->
    To.Parsetree.value_description
  =
  fun
    { From.Parsetree.pval_name = pval_name;
      From.Parsetree.pval_type = pval_type;
      From.Parsetree.pval_prim = pval_prim;
      From.Parsetree.pval_attributes = pval_attributes;
      From.Parsetree.pval_loc = pval_loc }
     ->
    {
      To.Parsetree.pval_name =
        (copy_loc (fun x  -> x) pval_name);
      To.Parsetree.pval_type =
        (copy_core_type pval_type);
      To.Parsetree.pval_prim =
        (List.map (fun x  -> x) pval_prim);
      To.Parsetree.pval_attributes =
        (copy_attributes pval_attributes);
      To.Parsetree.pval_loc =
        (copy_location pval_loc)
    }

and copy_arg_label :
  From.Asttypes.arg_label -> To.Asttypes.arg_label
  =
  function
  | From.Asttypes.Nolabel  -> To.Asttypes.Nolabel
  | From.Asttypes.Labelled x0 ->
      To.Asttypes.Labelled x0
  | From.Asttypes.Optional x0 ->
      To.Asttypes.Optional x0

and copy_closed_flag :
  From.Asttypes.closed_flag ->
    To.Asttypes.closed_flag
  =
  function
  | From.Asttypes.Closed  -> To.Asttypes.Closed
  | From.Asttypes.Open  -> To.Asttypes.Open

and copy_label :
  From.Asttypes.label -> To.Asttypes.label =
  fun x  -> x

and copy_rec_flag :
  From.Asttypes.rec_flag -> To.Asttypes.rec_flag =
  function
  | From.Asttypes.Nonrecursive  ->
      To.Asttypes.Nonrecursive
  | From.Asttypes.Recursive  ->
      To.Asttypes.Recursive

and copy_constant :
  From.Parsetree.constant -> To.Parsetree.constant
  =
  function
  | From.Parsetree.Pconst_integer (x0,x1) ->
      To.Parsetree.Pconst_integer
        (x0, (copy_option (fun x  -> x) x1))
  | From.Parsetree.Pconst_char x0 ->
      To.Parsetree.Pconst_char x0
  | From.Parsetree.Pconst_string (x0,x1) ->
      To.Parsetree.Pconst_string
        (x0, (copy_option (fun x  -> x) x1))
  | From.Parsetree.Pconst_float (x0,x1) ->
      To.Parsetree.Pconst_float
        (x0, (copy_option (fun x  -> x) x1))

and copy_option : 'f0 'g0 . ('f0 -> 'g0) -> 'f0 option -> 'g0 option =
  fun f0  -> function | None  -> None | Some x0 -> Some (f0 x0)

and copy_longident :
  From.Longident.t -> To.Longident.t =
  function
  | From.Longident.Lident x0 ->
      To.Longident.Lident x0
  | From.Longident.Ldot (x0,x1) ->
      To.Longident.Ldot
        ((copy_longident x0), x1)
  | From.Longident.Lapply (x0,x1) ->
      To.Longident.Lapply
        ((copy_longident x0), (copy_longident x1))

and copy_loc :
  'f0 'g0 .
    ('f0 -> 'g0) ->
      'f0 From.Asttypes.loc -> 'g0 To.Asttypes.loc
  =
  fun f0  ->
    fun
      { From.Asttypes.txt = txt;
        From.Asttypes.loc = loc }
       ->
      {
        To.Asttypes.txt = (f0 txt);
        To.Asttypes.loc = (copy_location loc)
      }

and copy_location :
  From.Location.t -> To.Location.t =
  fun
    { From.Location.loc_start = loc_start;
      From.Location.loc_end = loc_end;
      From.Location.loc_ghost = loc_ghost }
     ->
    {
      To.Location.loc_start = (copy_Lexing_position loc_start);
      To.Location.loc_end = (copy_Lexing_position loc_end);
      To.Location.loc_ghost = (copy_bool loc_ghost)
    }

and copy_bool : bool -> bool = function | false  -> false | true  -> true

and copy_Lexing_position : Lexing.position -> Lexing.position =
  fun
    { Lexing.pos_fname = pos_fname; Lexing.pos_lnum = pos_lnum;
      Lexing.pos_bol = pos_bol; Lexing.pos_cnum = pos_cnum }
     ->
    {
      Lexing.pos_fname = pos_fname;
      Lexing.pos_lnum = pos_lnum;
      Lexing.pos_bol = pos_bol;
      Lexing.pos_cnum = pos_cnum
    }

let rec copy_out_phrase :
  From.Outcometree.out_phrase -> To.Outcometree.out_phrase =
  function
  | From.Outcometree.Ophr_eval (x0,x1) ->
      To.Outcometree.Ophr_eval
        ((copy_out_value x0),
          (copy_out_type x1))
  | From.Outcometree.Ophr_signature x0 ->
      To.Outcometree.Ophr_signature
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_out_sig_item x0),
                (copy_option copy_out_value x1))) x0)
  | From.Outcometree.Ophr_exception x0 ->
      To.Outcometree.Ophr_exception
        (let (x0,x1) = x0  in
         ((copy_exn x0), (copy_out_value x1)))

and copy_exn : exn -> exn = fun x  -> x

and copy_out_sig_item :
  From.Outcometree.out_sig_item -> To.Outcometree.out_sig_item =
  function
  | From.Outcometree.Osig_class (x0,x1,x2,x3,x4) ->
      To.Outcometree.Osig_class
        ((copy_bool x0), x1,
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))
             x2), (copy_out_class_type x3),
          (copy_out_rec_status x4))
  | From.Outcometree.Osig_class_type (x0,x1,x2,x3,x4) ->
      To.Outcometree.Osig_class_type
        ((copy_bool x0), x1,
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))
             x2), (copy_out_class_type x3),
          (copy_out_rec_status x4))
  | From.Outcometree.Osig_typext (x0,x1) ->
      To.Outcometree.Osig_typext
        ((copy_out_extension_constructor x0),
          (copy_out_ext_status x1))
  | From.Outcometree.Osig_modtype (x0,x1) ->
      To.Outcometree.Osig_modtype
        (x0, (copy_out_module_type x1))
  | From.Outcometree.Osig_module (x0,x1,x2) ->
      To.Outcometree.Osig_module
        (x0, (copy_out_module_type x1),
          (copy_out_rec_status x2))
  | From.Outcometree.Osig_type (x0,x1) ->
      To.Outcometree.Osig_type
        ((copy_out_type_decl x0),
          (copy_out_rec_status x1))
  | From.Outcometree.Osig_value x0 ->
      To.Outcometree.Osig_value
        (copy_out_val_decl x0)
  | From.Outcometree.Osig_ellipsis  -> To.Outcometree.Osig_ellipsis

and copy_out_val_decl :
  From.Outcometree.out_val_decl -> To.Outcometree.out_val_decl =
  fun
    { From.Outcometree.oval_name = oval_name;
      From.Outcometree.oval_type = oval_type;
      From.Outcometree.oval_prims = oval_prims;
      From.Outcometree.oval_attributes = oval_attributes }
     ->
    {
      To.Outcometree.oval_name = oval_name;
      To.Outcometree.oval_type =
        (copy_out_type oval_type);
      To.Outcometree.oval_prims = (List.map (fun x  -> x) oval_prims);
      To.Outcometree.oval_attributes =
        (List.map copy_out_attribute oval_attributes)
    }

and copy_out_type_decl :
  From.Outcometree.out_type_decl -> To.Outcometree.out_type_decl =
  fun
    { From.Outcometree.otype_name = otype_name;
      From.Outcometree.otype_params = otype_params;
      From.Outcometree.otype_type = otype_type;
      From.Outcometree.otype_private = otype_private;
      From.Outcometree.otype_immediate = otype_immediate;
      From.Outcometree.otype_unboxed = _otype_unboxed;
      From.Outcometree.otype_cstrs = otype_cstrs }
     ->
    {
      To.Outcometree.otype_name = otype_name;
      To.Outcometree.otype_params =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))
           otype_params);
      To.Outcometree.otype_type =
        (copy_out_type otype_type);
      To.Outcometree.otype_private =
        (copy_From_Asttypes_private_flag otype_private);
      To.Outcometree.otype_immediate = (copy_bool otype_immediate);
      To.Outcometree.otype_cstrs =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_out_type x0),
                (copy_out_type x1))) otype_cstrs)
    }

and copy_out_module_type :
  From.Outcometree.out_module_type -> To.Outcometree.out_module_type
  =
  function
  | From.Outcometree.Omty_abstract  -> To.Outcometree.Omty_abstract
  | From.Outcometree.Omty_functor (x0,x1,x2) ->
      To.Outcometree.Omty_functor
        (x0, (copy_option copy_out_module_type x1),
          (copy_out_module_type x2))
  | From.Outcometree.Omty_ident x0 ->
      To.Outcometree.Omty_ident (copy_out_ident x0)
  | From.Outcometree.Omty_signature x0 ->
      To.Outcometree.Omty_signature
        (List.map copy_out_sig_item x0)
  | From.Outcometree.Omty_alias x0 ->
      To.Outcometree.Omty_alias (copy_out_ident x0)

and copy_out_ext_status :
  From.Outcometree.out_ext_status -> To.Outcometree.out_ext_status =
  function
  | From.Outcometree.Oext_first  -> To.Outcometree.Oext_first
  | From.Outcometree.Oext_next  -> To.Outcometree.Oext_next
  | From.Outcometree.Oext_exception  -> To.Outcometree.Oext_exception

and copy_out_extension_constructor :
  From.Outcometree.out_extension_constructor ->
    To.Outcometree.out_extension_constructor
  =
  fun
    { From.Outcometree.oext_name = oext_name;
      From.Outcometree.oext_type_name = oext_type_name;
      From.Outcometree.oext_type_params = oext_type_params;
      From.Outcometree.oext_args = oext_args;
      From.Outcometree.oext_ret_type = oext_ret_type;
      From.Outcometree.oext_private = oext_private }
     ->
    {
      To.Outcometree.oext_name = oext_name;
      To.Outcometree.oext_type_name = oext_type_name;
      To.Outcometree.oext_type_params =
        (List.map (fun x  -> x) oext_type_params);
      To.Outcometree.oext_args =
        (List.map copy_out_type oext_args);
      To.Outcometree.oext_ret_type =
        (copy_option copy_out_type oext_ret_type);
      To.Outcometree.oext_private =
        (copy_From_Asttypes_private_flag oext_private)
    }

and copy_From_Asttypes_private_flag :
  From.Asttypes.private_flag -> To.Asttypes.private_flag =
  function
  | From.Asttypes.Private  -> To.Asttypes.Private
  | From.Asttypes.Public  -> To.Asttypes.Public

and copy_out_rec_status :
  From.Outcometree.out_rec_status -> To.Outcometree.out_rec_status =
  function
  | From.Outcometree.Orec_not  -> To.Outcometree.Orec_not
  | From.Outcometree.Orec_first  -> To.Outcometree.Orec_first
  | From.Outcometree.Orec_next  -> To.Outcometree.Orec_next

and copy_out_class_type :
  From.Outcometree.out_class_type -> To.Outcometree.out_class_type =
  function
  | From.Outcometree.Octy_constr (x0,x1) ->
      To.Outcometree.Octy_constr
        ((copy_out_ident x0),
          (List.map copy_out_type x1))
  | From.Outcometree.Octy_arrow (x0,x1,x2) ->
      To.Outcometree.Octy_arrow
        (x0, (copy_out_type x1),
          (copy_out_class_type x2))
  | From.Outcometree.Octy_signature (x0,x1) ->
      To.Outcometree.Octy_signature
        ((copy_option copy_out_type x0),
          (List.map copy_out_class_sig_item x1))

and copy_out_class_sig_item :
  From.Outcometree.out_class_sig_item ->
    To.Outcometree.out_class_sig_item
  =
  function
  | From.Outcometree.Ocsg_constraint (x0,x1) ->
      To.Outcometree.Ocsg_constraint
        ((copy_out_type x0),
          (copy_out_type x1))
  | From.Outcometree.Ocsg_method (x0,x1,x2,x3) ->
      To.Outcometree.Ocsg_method
        (x0, (copy_bool x1), (copy_bool x2),
          (copy_out_type x3))
  | From.Outcometree.Ocsg_value (x0,x1,x2,x3) ->
      To.Outcometree.Ocsg_value
        (x0, (copy_bool x1), (copy_bool x2),
          (copy_out_type x3))

and copy_out_type :
  From.Outcometree.out_type -> To.Outcometree.out_type =
  function
  | From.Outcometree.Otyp_abstract  -> To.Outcometree.Otyp_abstract
  | From.Outcometree.Otyp_open  -> To.Outcometree.Otyp_open
  | From.Outcometree.Otyp_alias (x0,x1) ->
      To.Outcometree.Otyp_alias
        ((copy_out_type x0), x1)
  | From.Outcometree.Otyp_arrow (x0,x1,x2) ->
      To.Outcometree.Otyp_arrow
        (x0, (copy_out_type x1),
          (copy_out_type x2))
  | From.Outcometree.Otyp_class (x0,x1,x2) ->
      To.Outcometree.Otyp_class
        ((copy_bool x0), (copy_out_ident x1),
          (List.map copy_out_type x2))
  | From.Outcometree.Otyp_constr (x0,x1) ->
      To.Outcometree.Otyp_constr
        ((copy_out_ident x0),
          (List.map copy_out_type x1))
  | From.Outcometree.Otyp_manifest (x0,x1) ->
      To.Outcometree.Otyp_manifest
        ((copy_out_type x0),
          (copy_out_type x1))
  | From.Outcometree.Otyp_object (x0,x1) ->
      To.Outcometree.Otyp_object
        ((List.map
            (fun x  ->
               let (x0,x1) = x  in
               (x0, (copy_out_type x1))) x0),
          (copy_option copy_bool x1))
  | From.Outcometree.Otyp_record x0 ->
      To.Outcometree.Otyp_record
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (copy_bool x1), (copy_out_type x2)))
           x0)
  | From.Outcometree.Otyp_stuff x0 -> To.Outcometree.Otyp_stuff x0
  | From.Outcometree.Otyp_sum x0 ->
      To.Outcometree.Otyp_sum
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (List.map copy_out_type x1),
                (copy_option copy_out_type x2))) x0)
  | From.Outcometree.Otyp_tuple x0 ->
      To.Outcometree.Otyp_tuple
        (List.map copy_out_type x0)
  | From.Outcometree.Otyp_var (x0,x1) ->
      To.Outcometree.Otyp_var ((copy_bool x0), x1)
  | From.Outcometree.Otyp_variant (x0,x1,x2,x3) ->
      To.Outcometree.Otyp_variant
        ((copy_bool x0), (copy_out_variant x1),
          (copy_bool x2),
          (copy_option (fun x  -> List.map (fun x  -> x) x) x3))
  | From.Outcometree.Otyp_poly (x0,x1) ->
      To.Outcometree.Otyp_poly
        ((List.map (fun x  -> x) x0), (copy_out_type x1))
  | From.Outcometree.Otyp_module (x0,x1,x2) ->
      To.Outcometree.Otyp_module
        (x0, (List.map (fun x  -> x) x1),
          (List.map copy_out_type x2))
  | From.Outcometree.Otyp_attribute (x0,x1) ->
      To.Outcometree.Otyp_attribute
        ((copy_out_type x0),
          (copy_out_attribute x1))

and copy_out_attribute :
  From.Outcometree.out_attribute -> To.Outcometree.out_attribute =
  fun { From.Outcometree.oattr_name = oattr_name }  ->
    { To.Outcometree.oattr_name = oattr_name }

and copy_out_variant :
  From.Outcometree.out_variant -> To.Outcometree.out_variant =
  function
  | From.Outcometree.Ovar_fields x0 ->
      To.Outcometree.Ovar_fields
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (copy_bool x1),
                (List.map copy_out_type x2))) x0)
  | From.Outcometree.Ovar_name (x0,x1) ->
      To.Outcometree.Ovar_name
        ((copy_out_ident x0),
          (List.map copy_out_type x1))

and copy_out_value :
  From.Outcometree.out_value -> To.Outcometree.out_value =
  function
  | From.Outcometree.Oval_array x0 ->
      To.Outcometree.Oval_array
        (List.map copy_out_value x0)
  | From.Outcometree.Oval_char x0 -> To.Outcometree.Oval_char x0
  | From.Outcometree.Oval_constr (x0,x1) ->
      To.Outcometree.Oval_constr
        ((copy_out_ident x0),
          (List.map copy_out_value x1))
  | From.Outcometree.Oval_ellipsis  -> To.Outcometree.Oval_ellipsis
  | From.Outcometree.Oval_float x0 ->
      To.Outcometree.Oval_float (copy_float x0)
  | From.Outcometree.Oval_int x0 -> To.Outcometree.Oval_int x0
  | From.Outcometree.Oval_int32 x0 -> To.Outcometree.Oval_int32 x0
  | From.Outcometree.Oval_int64 x0 -> To.Outcometree.Oval_int64 x0
  | From.Outcometree.Oval_nativeint x0 ->
      To.Outcometree.Oval_nativeint x0
  | From.Outcometree.Oval_list x0 ->
      To.Outcometree.Oval_list
        (List.map copy_out_value x0)
  | From.Outcometree.Oval_printer x0 ->
      To.Outcometree.Oval_printer x0
  | From.Outcometree.Oval_record x0 ->
      To.Outcometree.Oval_record
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_out_ident x0),
                (copy_out_value x1))) x0)
  | From.Outcometree.Oval_string x0 -> To.Outcometree.Oval_string x0
  | From.Outcometree.Oval_stuff x0 -> To.Outcometree.Oval_stuff x0
  | From.Outcometree.Oval_tuple x0 ->
      To.Outcometree.Oval_tuple
        (List.map copy_out_value x0)
  | From.Outcometree.Oval_variant (x0,x1) ->
      To.Outcometree.Oval_variant
        (x0, (copy_option copy_out_value x1))

and copy_float : float -> float = fun x  -> x

and copy_out_ident :
  From.Outcometree.out_ident -> To.Outcometree.out_ident =
  function
  | From.Outcometree.Oide_apply (x0,x1) ->
      To.Outcometree.Oide_apply ((copy_out_ident x0), (copy_out_ident x1))
  | From.Outcometree.Oide_dot (x0,x1) ->
      To.Outcometree.Oide_dot ((copy_out_ident x0), x1)
  | From.Outcometree.Oide_ident x0 -> To.Outcometree.Oide_ident x0

let rec copy_toplevel_phrase :
  From.Parsetree.toplevel_phrase -> To.Parsetree.toplevel_phrase =
  function
  | From.Parsetree.Ptop_def x0 ->
      To.Parsetree.Ptop_def (copy_structure x0)
  | From.Parsetree.Ptop_dir (x0,x1) ->
      To.Parsetree.Ptop_dir (x0, (copy_directive_argument x1))

and copy_directive_argument :
  From.Parsetree.directive_argument -> To.Parsetree.directive_argument =
  function
  | From.Parsetree.Pdir_none  -> To.Parsetree.Pdir_none
  | From.Parsetree.Pdir_string x0 -> To.Parsetree.Pdir_string x0
  | From.Parsetree.Pdir_int (x0,x1) ->
      To.Parsetree.Pdir_int (x0, (copy_option (fun x  -> x) x1))
  | From.Parsetree.Pdir_ident x0 ->
      To.Parsetree.Pdir_ident (copy_longident x0)
  | From.Parsetree.Pdir_bool x0 ->
      To.Parsetree.Pdir_bool (copy_bool x0)

let copy_out_type_extension :
  From.Outcometree.out_type_extension -> To.Outcometree.out_type_extension =
  fun
    { From.Outcometree.otyext_name = otyext_name;
      From.Outcometree.otyext_params = otyext_params;
      From.Outcometree.otyext_constructors = otyext_constructors;
      From.Outcometree.otyext_private = otyext_private }
     ->
    {
      To.Outcometree.otyext_name = otyext_name;
      To.Outcometree.otyext_params =
        (List.map (fun x  -> x) otyext_params);
      To.Outcometree.otyext_constructors =
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (List.map copy_out_type x1),
                (copy_option copy_out_type x2)))
           otyext_constructors);
      To.Outcometree.otyext_private =
        (copy_private_flag otyext_private)
    }

let copy_cases x = List.map copy_case x
let copy_pat = copy_pattern
let copy_expr = copy_expression
let copy_typ = copy_core_type

end
module Migrate_parsetree_403_404
= struct
#1 "migrate_parsetree_403_404.ml"
# 1 "src/migrate_parsetree_403_404.ml"
# 1 "src/migrate_parsetree_403_404.ml"
# 1 "src/migrate_parsetree_403_404.ml"
# 1 "src/migrate_parsetree_403_404.ml"
# 1 "src/migrate_parsetree_403_404.ml"
# 1 "src/migrate_parsetree_403_404.ml"
# 1 "src/migrate_parsetree_403_404.ml"
# 1 "src/migrate_parsetree_403_404.ml"
# 1 "src/migrate_parsetree_403_404.ml"
# 1 "src/migrate_parsetree_403_404.ml"
# 1 "src/migrate_parsetree_403_404.ml"
# 1 "src/migrate_parsetree_403_404.ml"
# 1 "src/migrate_parsetree_403_404.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

include Migrate_parsetree_403_404_migrate

(*$ open Printf
    let fields = [
      "attribute"; "attributes"; "case"; "cases"; "class_declaration";
      "class_description"; "class_expr"; "class_field"; "class_signature";
      "class_structure"; "class_type"; "class_type_declaration";
      "class_type_field"; "constructor_declaration"; "expr"; "extension";
      "extension_constructor"; "include_declaration"; "include_description";
      "label_declaration"; "location"; "module_binding"; "module_declaration";
      "module_expr"; "module_type"; "module_type_declaration";
      "open_description"; "pat"; "signature"; "signature_item"; "structure";
      "structure_item"; "typ"; "type_declaration"; "type_extension";
      "type_kind"; "value_binding"; "value_description";
      "with_constraint"; "payload"
    ]
  let foreach_field f =
    printf "\n";
    List.iter f fields
*)(*$*)

let copy_mapper = fun
  ({ From.Ast_mapper.
     (*$ foreach_field (printf "%s;\n")*)
     attribute;
     attributes;
     case;
     cases;
     class_declaration;
     class_description;
     class_expr;
     class_field;
     class_signature;
     class_structure;
     class_type;
     class_type_declaration;
     class_type_field;
     constructor_declaration;
     expr;
     extension;
     extension_constructor;
     include_declaration;
     include_description;
     label_declaration;
     location;
     module_binding;
     module_declaration;
     module_expr;
     module_type;
     module_type_declaration;
     open_description;
     pat;
     signature;
     signature_item;
     structure;
     structure_item;
     typ;
     type_declaration;
     type_extension;
     type_kind;
     value_binding;
     value_description;
     with_constraint;
     payload;
     (*$*)
   } as mapper) ->
  let module R = Migrate_parsetree_404_403_migrate in
  {
    To.Ast_mapper.
    (*$ foreach_field (fun s ->
          printf
          "%s = (fun _ x -> copy_%s (%s mapper (R.copy_%s x)));\n" s s s s)
    *)
    attribute = (fun _ x -> copy_attribute (attribute mapper (R.copy_attribute x)));
    attributes = (fun _ x -> copy_attributes (attributes mapper (R.copy_attributes x)));
    case = (fun _ x -> copy_case (case mapper (R.copy_case x)));
    cases = (fun _ x -> copy_cases (cases mapper (R.copy_cases x)));
    class_declaration = (fun _ x -> copy_class_declaration (class_declaration mapper (R.copy_class_declaration x)));
    class_description = (fun _ x -> copy_class_description (class_description mapper (R.copy_class_description x)));
    class_expr = (fun _ x -> copy_class_expr (class_expr mapper (R.copy_class_expr x)));
    class_field = (fun _ x -> copy_class_field (class_field mapper (R.copy_class_field x)));
    class_signature = (fun _ x -> copy_class_signature (class_signature mapper (R.copy_class_signature x)));
    class_structure = (fun _ x -> copy_class_structure (class_structure mapper (R.copy_class_structure x)));
    class_type = (fun _ x -> copy_class_type (class_type mapper (R.copy_class_type x)));
    class_type_declaration = (fun _ x -> copy_class_type_declaration (class_type_declaration mapper (R.copy_class_type_declaration x)));
    class_type_field = (fun _ x -> copy_class_type_field (class_type_field mapper (R.copy_class_type_field x)));
    constructor_declaration = (fun _ x -> copy_constructor_declaration (constructor_declaration mapper (R.copy_constructor_declaration x)));
    expr = (fun _ x -> copy_expr (expr mapper (R.copy_expr x)));
    extension = (fun _ x -> copy_extension (extension mapper (R.copy_extension x)));
    extension_constructor = (fun _ x -> copy_extension_constructor (extension_constructor mapper (R.copy_extension_constructor x)));
    include_declaration = (fun _ x -> copy_include_declaration (include_declaration mapper (R.copy_include_declaration x)));
    include_description = (fun _ x -> copy_include_description (include_description mapper (R.copy_include_description x)));
    label_declaration = (fun _ x -> copy_label_declaration (label_declaration mapper (R.copy_label_declaration x)));
    location = (fun _ x -> copy_location (location mapper (R.copy_location x)));
    module_binding = (fun _ x -> copy_module_binding (module_binding mapper (R.copy_module_binding x)));
    module_declaration = (fun _ x -> copy_module_declaration (module_declaration mapper (R.copy_module_declaration x)));
    module_expr = (fun _ x -> copy_module_expr (module_expr mapper (R.copy_module_expr x)));
    module_type = (fun _ x -> copy_module_type (module_type mapper (R.copy_module_type x)));
    module_type_declaration = (fun _ x -> copy_module_type_declaration (module_type_declaration mapper (R.copy_module_type_declaration x)));
    open_description = (fun _ x -> copy_open_description (open_description mapper (R.copy_open_description x)));
    pat = (fun _ x -> copy_pat (pat mapper (R.copy_pat x)));
    signature = (fun _ x -> copy_signature (signature mapper (R.copy_signature x)));
    signature_item = (fun _ x -> copy_signature_item (signature_item mapper (R.copy_signature_item x)));
    structure = (fun _ x -> copy_structure (structure mapper (R.copy_structure x)));
    structure_item = (fun _ x -> copy_structure_item (structure_item mapper (R.copy_structure_item x)));
    typ = (fun _ x -> copy_typ (typ mapper (R.copy_typ x)));
    type_declaration = (fun _ x -> copy_type_declaration (type_declaration mapper (R.copy_type_declaration x)));
    type_extension = (fun _ x -> copy_type_extension (type_extension mapper (R.copy_type_extension x)));
    type_kind = (fun _ x -> copy_type_kind (type_kind mapper (R.copy_type_kind x)));
    value_binding = (fun _ x -> copy_value_binding (value_binding mapper (R.copy_value_binding x)));
    value_description = (fun _ x -> copy_value_description (value_description mapper (R.copy_value_description x)));
    with_constraint = (fun _ x -> copy_with_constraint (with_constraint mapper (R.copy_with_constraint x)));
    payload = (fun _ x -> copy_payload (payload mapper (R.copy_payload x)));
    (*$*)
  }

end
module Migrate_parsetree_404_403
= struct
#1 "migrate_parsetree_404_403.ml"
# 1 "src/migrate_parsetree_404_403.ml"
# 1 "src/migrate_parsetree_404_403.ml"
# 1 "src/migrate_parsetree_404_403.ml"
# 1 "src/migrate_parsetree_404_403.ml"
# 1 "src/migrate_parsetree_404_403.ml"
# 1 "src/migrate_parsetree_404_403.ml"
# 1 "src/migrate_parsetree_404_403.ml"
# 1 "src/migrate_parsetree_404_403.ml"
# 1 "src/migrate_parsetree_404_403.ml"
# 1 "src/migrate_parsetree_404_403.ml"
# 1 "src/migrate_parsetree_404_403.ml"
# 1 "src/migrate_parsetree_404_403.ml"
# 1 "src/migrate_parsetree_404_403.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

include Migrate_parsetree_404_403_migrate

(*$ open Printf
    let fields = [
      "attribute"; "attributes"; "case"; "cases"; "class_declaration";
      "class_description"; "class_expr"; "class_field"; "class_signature";
      "class_structure"; "class_type"; "class_type_declaration";
      "class_type_field"; "constructor_declaration"; "expr"; "extension";
      "extension_constructor"; "include_declaration"; "include_description";
      "label_declaration"; "location"; "module_binding"; "module_declaration";
      "module_expr"; "module_type"; "module_type_declaration";
      "open_description"; "pat"; "signature"; "signature_item"; "structure";
      "structure_item"; "typ"; "type_declaration"; "type_extension";
      "type_kind"; "value_binding"; "value_description";
      "with_constraint"; "payload"
    ]
  let foreach_field f =
    printf "\n";
    List.iter f fields
*)(*$*)

let copy_mapper = fun
  ({ From.Ast_mapper.
     (*$ foreach_field (printf "%s;\n")*)
     attribute;
     attributes;
     case;
     cases;
     class_declaration;
     class_description;
     class_expr;
     class_field;
     class_signature;
     class_structure;
     class_type;
     class_type_declaration;
     class_type_field;
     constructor_declaration;
     expr;
     extension;
     extension_constructor;
     include_declaration;
     include_description;
     label_declaration;
     location;
     module_binding;
     module_declaration;
     module_expr;
     module_type;
     module_type_declaration;
     open_description;
     pat;
     signature;
     signature_item;
     structure;
     structure_item;
     typ;
     type_declaration;
     type_extension;
     type_kind;
     value_binding;
     value_description;
     with_constraint;
     payload;
     (*$*)
   } as mapper) ->
  let module R = Migrate_parsetree_403_404_migrate in
  {
    To.Ast_mapper.
    (*$ foreach_field (fun s ->
          printf
          "%s = (fun _ x -> copy_%s (%s mapper (R.copy_%s x)));\n" s s s s)
    *)
    attribute = (fun _ x -> copy_attribute (attribute mapper (R.copy_attribute x)));
    attributes = (fun _ x -> copy_attributes (attributes mapper (R.copy_attributes x)));
    case = (fun _ x -> copy_case (case mapper (R.copy_case x)));
    cases = (fun _ x -> copy_cases (cases mapper (R.copy_cases x)));
    class_declaration = (fun _ x -> copy_class_declaration (class_declaration mapper (R.copy_class_declaration x)));
    class_description = (fun _ x -> copy_class_description (class_description mapper (R.copy_class_description x)));
    class_expr = (fun _ x -> copy_class_expr (class_expr mapper (R.copy_class_expr x)));
    class_field = (fun _ x -> copy_class_field (class_field mapper (R.copy_class_field x)));
    class_signature = (fun _ x -> copy_class_signature (class_signature mapper (R.copy_class_signature x)));
    class_structure = (fun _ x -> copy_class_structure (class_structure mapper (R.copy_class_structure x)));
    class_type = (fun _ x -> copy_class_type (class_type mapper (R.copy_class_type x)));
    class_type_declaration = (fun _ x -> copy_class_type_declaration (class_type_declaration mapper (R.copy_class_type_declaration x)));
    class_type_field = (fun _ x -> copy_class_type_field (class_type_field mapper (R.copy_class_type_field x)));
    constructor_declaration = (fun _ x -> copy_constructor_declaration (constructor_declaration mapper (R.copy_constructor_declaration x)));
    expr = (fun _ x -> copy_expr (expr mapper (R.copy_expr x)));
    extension = (fun _ x -> copy_extension (extension mapper (R.copy_extension x)));
    extension_constructor = (fun _ x -> copy_extension_constructor (extension_constructor mapper (R.copy_extension_constructor x)));
    include_declaration = (fun _ x -> copy_include_declaration (include_declaration mapper (R.copy_include_declaration x)));
    include_description = (fun _ x -> copy_include_description (include_description mapper (R.copy_include_description x)));
    label_declaration = (fun _ x -> copy_label_declaration (label_declaration mapper (R.copy_label_declaration x)));
    location = (fun _ x -> copy_location (location mapper (R.copy_location x)));
    module_binding = (fun _ x -> copy_module_binding (module_binding mapper (R.copy_module_binding x)));
    module_declaration = (fun _ x -> copy_module_declaration (module_declaration mapper (R.copy_module_declaration x)));
    module_expr = (fun _ x -> copy_module_expr (module_expr mapper (R.copy_module_expr x)));
    module_type = (fun _ x -> copy_module_type (module_type mapper (R.copy_module_type x)));
    module_type_declaration = (fun _ x -> copy_module_type_declaration (module_type_declaration mapper (R.copy_module_type_declaration x)));
    open_description = (fun _ x -> copy_open_description (open_description mapper (R.copy_open_description x)));
    pat = (fun _ x -> copy_pat (pat mapper (R.copy_pat x)));
    signature = (fun _ x -> copy_signature (signature mapper (R.copy_signature x)));
    signature_item = (fun _ x -> copy_signature_item (signature_item mapper (R.copy_signature_item x)));
    structure = (fun _ x -> copy_structure (structure mapper (R.copy_structure x)));
    structure_item = (fun _ x -> copy_structure_item (structure_item mapper (R.copy_structure_item x)));
    typ = (fun _ x -> copy_typ (typ mapper (R.copy_typ x)));
    type_declaration = (fun _ x -> copy_type_declaration (type_declaration mapper (R.copy_type_declaration x)));
    type_extension = (fun _ x -> copy_type_extension (type_extension mapper (R.copy_type_extension x)));
    type_kind = (fun _ x -> copy_type_kind (type_kind mapper (R.copy_type_kind x)));
    value_binding = (fun _ x -> copy_value_binding (value_binding mapper (R.copy_value_binding x)));
    value_description = (fun _ x -> copy_value_description (value_description mapper (R.copy_value_description x)));
    with_constraint = (fun _ x -> copy_with_constraint (with_constraint mapper (R.copy_with_constraint x)));
    payload = (fun _ x -> copy_payload (payload mapper (R.copy_payload x)));
    (*$*)
  }

end
module Migrate_parsetree_404_405_migrate
= struct
#1 "migrate_parsetree_404_405_migrate.ml"
# 1 "src/migrate_parsetree_404_405_migrate.ml"
# 1 "src/migrate_parsetree_404_405_migrate.ml"
# 1 "src/migrate_parsetree_404_405_migrate.ml"
# 1 "src/migrate_parsetree_404_405_migrate.ml"
# 1 "src/migrate_parsetree_404_405_migrate.ml"
# 1 "src/migrate_parsetree_404_405_migrate.ml"
# 1 "src/migrate_parsetree_404_405_migrate.ml"
# 1 "src/migrate_parsetree_404_405_migrate.ml"
# 1 "src/migrate_parsetree_404_405_migrate.ml"
# 1 "src/migrate_parsetree_404_405_migrate.ml"
# 1 "src/migrate_parsetree_404_405_migrate.ml"
# 1 "src/migrate_parsetree_404_405_migrate.ml"
# 1 "src/migrate_parsetree_404_405_migrate.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*                         Alain Frisch, LexiFi                           *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

module From = Ast_404
module To = Ast_405

let noloc x = { Location. txt = x; loc = Location.none }

let rec copy_expression :
  From.Parsetree.expression -> To.Parsetree.expression =
  fun
    { From.Parsetree.pexp_desc = pexp_desc;
      From.Parsetree.pexp_loc = pexp_loc;
      From.Parsetree.pexp_attributes = pexp_attributes }
     ->
    {
      To.Parsetree.pexp_desc = (copy_expression_desc pexp_desc);
      To.Parsetree.pexp_loc = (copy_location pexp_loc);
      To.Parsetree.pexp_attributes = (copy_attributes pexp_attributes)
    }

and copy_expression_desc :
  From.Parsetree.expression_desc -> To.Parsetree.expression_desc =
  function
  | From.Parsetree.Pexp_ident x0 ->
      To.Parsetree.Pexp_ident
        (copy_loc copy_longident x0)
  | From.Parsetree.Pexp_constant x0 ->
      To.Parsetree.Pexp_constant (copy_constant x0)
  | From.Parsetree.Pexp_let (x0,x1,x2) ->
      To.Parsetree.Pexp_let
        ((copy_rec_flag x0),
          (List.map copy_value_binding x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_function x0 ->
      To.Parsetree.Pexp_function
        (List.map copy_case x0)
  | From.Parsetree.Pexp_fun (x0,x1,x2,x3) ->
      To.Parsetree.Pexp_fun
        ((copy_arg_label x0),
          (copy_option copy_expression x1),
          (copy_pattern x2),
          (copy_expression x3))
  | From.Parsetree.Pexp_apply (x0,x1) ->
      To.Parsetree.Pexp_apply
        ((copy_expression x0),
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                ((copy_arg_label x0),
                  (copy_expression x1))) x1))
  | From.Parsetree.Pexp_match (x0,x1) ->
      To.Parsetree.Pexp_match
        ((copy_expression x0),
          (List.map copy_case x1))
  | From.Parsetree.Pexp_try (x0,x1) ->
      To.Parsetree.Pexp_try
        ((copy_expression x0),
          (List.map copy_case x1))
  | From.Parsetree.Pexp_tuple x0 ->
      To.Parsetree.Pexp_tuple
        (List.map copy_expression x0)
  | From.Parsetree.Pexp_construct (x0,x1) ->
      To.Parsetree.Pexp_construct
        ((copy_loc copy_longident x0),
          (copy_option copy_expression x1))
  | From.Parsetree.Pexp_variant (x0,x1) ->
      To.Parsetree.Pexp_variant
        ((copy_label x0),
          (copy_option copy_expression x1))
  | From.Parsetree.Pexp_record (x0,x1) ->
      To.Parsetree.Pexp_record
        ((List.map
            (fun x  ->
               let (x0,x1) = x  in
               ((copy_loc copy_longident x0),
                 (copy_expression x1))) x0),
          (copy_option copy_expression x1))
  | From.Parsetree.Pexp_field (x0,x1) ->
      To.Parsetree.Pexp_field
        ((copy_expression x0),
          (copy_loc copy_longident x1))
  | From.Parsetree.Pexp_setfield (x0,x1,x2) ->
      To.Parsetree.Pexp_setfield
        ((copy_expression x0),
          (copy_loc copy_longident x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_array x0 ->
      To.Parsetree.Pexp_array
        (List.map copy_expression x0)
  | From.Parsetree.Pexp_ifthenelse (x0,x1,x2) ->
      To.Parsetree.Pexp_ifthenelse
        ((copy_expression x0),
          (copy_expression x1),
          (copy_option copy_expression x2))
  | From.Parsetree.Pexp_sequence (x0,x1) ->
      To.Parsetree.Pexp_sequence
        ((copy_expression x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_while (x0,x1) ->
      To.Parsetree.Pexp_while
        ((copy_expression x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_for (x0,x1,x2,x3,x4) ->
      To.Parsetree.Pexp_for
        ((copy_pattern x0),
          (copy_expression x1),
          (copy_expression x2),
          (copy_direction_flag x3),
          (copy_expression x4))
  | From.Parsetree.Pexp_constraint (x0,x1) ->
      To.Parsetree.Pexp_constraint
        ((copy_expression x0),
          (copy_core_type x1))
  | From.Parsetree.Pexp_coerce (x0,x1,x2) ->
      To.Parsetree.Pexp_coerce
        ((copy_expression x0),
          (copy_option copy_core_type x1),
          (copy_core_type x2))
  | From.Parsetree.Pexp_send (x0,x1) ->
      To.Parsetree.Pexp_send
        ((copy_expression x0), noloc x1)
  | From.Parsetree.Pexp_new x0 ->
      To.Parsetree.Pexp_new
        (copy_loc copy_longident x0)
  | From.Parsetree.Pexp_setinstvar (x0,x1) ->
      To.Parsetree.Pexp_setinstvar
        ((copy_loc (fun x  -> x) x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_override x0 ->
      To.Parsetree.Pexp_override
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_loc (fun x  -> x) x0),
                (copy_expression x1))) x0)
  | From.Parsetree.Pexp_letmodule (x0,x1,x2) ->
      To.Parsetree.Pexp_letmodule
        ((copy_loc (fun x  -> x) x0),
          (copy_module_expr x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_letexception (x0,x1) ->
      To.Parsetree.Pexp_letexception
        ((copy_extension_constructor x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_assert x0 ->
      To.Parsetree.Pexp_assert (copy_expression x0)
  | From.Parsetree.Pexp_lazy x0 ->
      To.Parsetree.Pexp_lazy (copy_expression x0)
  | From.Parsetree.Pexp_poly (x0,x1) ->
      To.Parsetree.Pexp_poly
        ((copy_expression x0),
          (copy_option copy_core_type x1))
  | From.Parsetree.Pexp_object x0 ->
      To.Parsetree.Pexp_object
        (copy_class_structure x0)
  | From.Parsetree.Pexp_newtype (x0,x1) ->
      To.Parsetree.Pexp_newtype
        (noloc x0, (copy_expression x1))
  | From.Parsetree.Pexp_pack x0 ->
      To.Parsetree.Pexp_pack (copy_module_expr x0)
  | From.Parsetree.Pexp_open (x0,x1,x2) ->
      To.Parsetree.Pexp_open
        ((copy_override_flag x0),
          (copy_loc copy_longident x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_extension x0 ->
      To.Parsetree.Pexp_extension (copy_extension x0)
  | From.Parsetree.Pexp_unreachable  -> To.Parsetree.Pexp_unreachable

and copy_direction_flag :
  From.Asttypes.direction_flag -> To.Asttypes.direction_flag =
  function
  | From.Asttypes.Upto  -> To.Asttypes.Upto
  | From.Asttypes.Downto  -> To.Asttypes.Downto

and copy_case :
  From.Parsetree.case -> To.Parsetree.case =
  fun
    { From.Parsetree.pc_lhs = pc_lhs;
      From.Parsetree.pc_guard = pc_guard;
      From.Parsetree.pc_rhs = pc_rhs }
     ->
    {
      To.Parsetree.pc_lhs = (copy_pattern pc_lhs);
      To.Parsetree.pc_guard =
        (copy_option copy_expression pc_guard);
      To.Parsetree.pc_rhs = (copy_expression pc_rhs)
    }

and copy_value_binding :
  From.Parsetree.value_binding -> To.Parsetree.value_binding =
  fun
    { From.Parsetree.pvb_pat = pvb_pat;
      From.Parsetree.pvb_expr = pvb_expr;
      From.Parsetree.pvb_attributes = pvb_attributes;
      From.Parsetree.pvb_loc = pvb_loc }
     ->
    {
      To.Parsetree.pvb_pat = (copy_pattern pvb_pat);
      To.Parsetree.pvb_expr =
        (copy_expression pvb_expr);
      To.Parsetree.pvb_attributes =
        (copy_attributes pvb_attributes);
      To.Parsetree.pvb_loc = (copy_location pvb_loc)
    }

and copy_pattern :
  From.Parsetree.pattern -> To.Parsetree.pattern =
  fun
    { From.Parsetree.ppat_desc = ppat_desc;
      From.Parsetree.ppat_loc = ppat_loc;
      From.Parsetree.ppat_attributes = ppat_attributes }
     ->
    {
      To.Parsetree.ppat_desc =
        (copy_pattern_desc ppat_desc);
      To.Parsetree.ppat_loc = (copy_location ppat_loc);
      To.Parsetree.ppat_attributes =
        (copy_attributes ppat_attributes)
    }

and copy_pattern_desc :
  From.Parsetree.pattern_desc -> To.Parsetree.pattern_desc =
  function
  | From.Parsetree.Ppat_any  -> To.Parsetree.Ppat_any
  | From.Parsetree.Ppat_var x0 ->
      To.Parsetree.Ppat_var (copy_loc (fun x  -> x) x0)
  | From.Parsetree.Ppat_alias (x0,x1) ->
      To.Parsetree.Ppat_alias
        ((copy_pattern x0),
          (copy_loc (fun x  -> x) x1))
  | From.Parsetree.Ppat_constant x0 ->
      To.Parsetree.Ppat_constant (copy_constant x0)
  | From.Parsetree.Ppat_interval (x0,x1) ->
      To.Parsetree.Ppat_interval
        ((copy_constant x0),
          (copy_constant x1))
  | From.Parsetree.Ppat_tuple x0 ->
      To.Parsetree.Ppat_tuple
        (List.map copy_pattern x0)
  | From.Parsetree.Ppat_construct (x0,x1) ->
      To.Parsetree.Ppat_construct
        ((copy_loc copy_longident x0),
          (copy_option copy_pattern x1))
  | From.Parsetree.Ppat_variant (x0,x1) ->
      To.Parsetree.Ppat_variant
        ((copy_label x0),
          (copy_option copy_pattern x1))
  | From.Parsetree.Ppat_record (x0,x1) ->
      To.Parsetree.Ppat_record
        ((List.map
            (fun x  ->
               let (x0,x1) = x  in
               ((copy_loc copy_longident x0),
                 (copy_pattern x1))) x0),
          (copy_closed_flag x1))
  | From.Parsetree.Ppat_array x0 ->
      To.Parsetree.Ppat_array
        (List.map copy_pattern x0)
  | From.Parsetree.Ppat_or (x0,x1) ->
      To.Parsetree.Ppat_or
        ((copy_pattern x0),
          (copy_pattern x1))
  | From.Parsetree.Ppat_constraint (x0,x1) ->
      To.Parsetree.Ppat_constraint
        ((copy_pattern x0),
          (copy_core_type x1))
  | From.Parsetree.Ppat_type x0 ->
      To.Parsetree.Ppat_type
        (copy_loc copy_longident x0)
  | From.Parsetree.Ppat_lazy x0 ->
      To.Parsetree.Ppat_lazy (copy_pattern x0)
  | From.Parsetree.Ppat_unpack x0 ->
      To.Parsetree.Ppat_unpack
        (copy_loc (fun x  -> x) x0)
  | From.Parsetree.Ppat_exception x0 ->
      To.Parsetree.Ppat_exception (copy_pattern x0)
  | From.Parsetree.Ppat_extension x0 ->
      To.Parsetree.Ppat_extension (copy_extension x0)
  | From.Parsetree.Ppat_open (x0,x1) ->
      To.Parsetree.Ppat_open
        ((copy_loc copy_longident x0),
          (copy_pattern x1))

and copy_core_type :
  From.Parsetree.core_type -> To.Parsetree.core_type =
  fun
    { From.Parsetree.ptyp_desc = ptyp_desc;
      From.Parsetree.ptyp_loc = ptyp_loc;
      From.Parsetree.ptyp_attributes = ptyp_attributes }
     ->
    {
      To.Parsetree.ptyp_desc =
        (copy_core_type_desc ptyp_desc);
      To.Parsetree.ptyp_loc = (copy_location ptyp_loc);
      To.Parsetree.ptyp_attributes =
        (copy_attributes ptyp_attributes)
    }

and copy_core_type_desc :
  From.Parsetree.core_type_desc -> To.Parsetree.core_type_desc =
  function
  | From.Parsetree.Ptyp_any  -> To.Parsetree.Ptyp_any
  | From.Parsetree.Ptyp_var x0 -> To.Parsetree.Ptyp_var x0
  | From.Parsetree.Ptyp_arrow (x0,x1,x2) ->
      To.Parsetree.Ptyp_arrow
        ((copy_arg_label x0),
          (copy_core_type x1),
          (copy_core_type x2))
  | From.Parsetree.Ptyp_tuple x0 ->
      To.Parsetree.Ptyp_tuple
        (List.map copy_core_type x0)
  | From.Parsetree.Ptyp_constr (x0,x1) ->
      To.Parsetree.Ptyp_constr
        ((copy_loc copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Ptyp_object (x0,x1) ->
      To.Parsetree.Ptyp_object
        ((List.map
            (fun x  ->
               let (x0,x1,x2) = x  in
               (noloc x0, (copy_attributes x1),
                 (copy_core_type x2))) x0),
          (copy_closed_flag x1))
  | From.Parsetree.Ptyp_class (x0,x1) ->
      To.Parsetree.Ptyp_class
        ((copy_loc copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Ptyp_alias (x0,x1) ->
      To.Parsetree.Ptyp_alias
        ((copy_core_type x0), x1)
  | From.Parsetree.Ptyp_variant (x0,x1,x2) ->
      To.Parsetree.Ptyp_variant
        ((List.map copy_row_field x0),
          (copy_closed_flag x1),
          (copy_option (fun x  -> List.map copy_label x) x2))
  | From.Parsetree.Ptyp_poly (x0,x1) ->
      To.Parsetree.Ptyp_poly
        ((List.map (fun x  -> noloc x) x0), (copy_core_type x1))
  | From.Parsetree.Ptyp_package x0 ->
      To.Parsetree.Ptyp_package (copy_package_type x0)
  | From.Parsetree.Ptyp_extension x0 ->
      To.Parsetree.Ptyp_extension (copy_extension x0)

and copy_package_type :
  From.Parsetree.package_type -> To.Parsetree.package_type =
  fun x  ->
    let (x0,x1) = x  in
    ((copy_loc copy_longident x0),
      (List.map
         (fun x  ->
            let (x0,x1) = x  in
            ((copy_loc copy_longident x0),
              (copy_core_type x1))) x1))

and copy_row_field :
  From.Parsetree.row_field -> To.Parsetree.row_field =
  function
  | From.Parsetree.Rtag (x0,x1,x2,x3) ->
      To.Parsetree.Rtag
        ((copy_label x0),
          (copy_attributes x1), (copy_bool x2),
          (List.map copy_core_type x3))
  | From.Parsetree.Rinherit x0 ->
      To.Parsetree.Rinherit (copy_core_type x0)

and copy_attributes :
  From.Parsetree.attributes -> To.Parsetree.attributes =
  fun x  -> List.map copy_attribute x

and copy_attribute :
  From.Parsetree.attribute -> To.Parsetree.attribute =
  fun x  ->
    let (x0,x1) = x  in
    ((copy_loc (fun x  -> x) x0),
      (copy_payload x1))

and copy_payload :
  From.Parsetree.payload -> To.Parsetree.payload =
  function
  | From.Parsetree.PStr x0 ->
      To.Parsetree.PStr (copy_structure x0)
  | From.Parsetree.PSig x0 ->
      To.Parsetree.PSig (copy_signature x0)
  | From.Parsetree.PTyp x0 ->
      To.Parsetree.PTyp (copy_core_type x0)
  | From.Parsetree.PPat (x0,x1) ->
      To.Parsetree.PPat
        ((copy_pattern x0),
          (copy_option copy_expression x1))

and copy_structure :
  From.Parsetree.structure -> To.Parsetree.structure =
  fun x  -> List.map copy_structure_item x

and copy_structure_item :
  From.Parsetree.structure_item -> To.Parsetree.structure_item =
  fun
    { From.Parsetree.pstr_desc = pstr_desc;
      From.Parsetree.pstr_loc = pstr_loc }
     ->
    {
      To.Parsetree.pstr_desc =
        (copy_structure_item_desc pstr_desc);
      To.Parsetree.pstr_loc = (copy_location pstr_loc)
    }

and copy_structure_item_desc :
  From.Parsetree.structure_item_desc ->
    To.Parsetree.structure_item_desc
  =
  function
  | From.Parsetree.Pstr_eval (x0,x1) ->
      To.Parsetree.Pstr_eval
        ((copy_expression x0),
          (copy_attributes x1))
  | From.Parsetree.Pstr_value (x0,x1) ->
      To.Parsetree.Pstr_value
        ((copy_rec_flag x0),
          (List.map copy_value_binding x1))
  | From.Parsetree.Pstr_primitive x0 ->
      To.Parsetree.Pstr_primitive
        (copy_value_description x0)
  | From.Parsetree.Pstr_type (x0,x1) ->
      To.Parsetree.Pstr_type
        ((copy_rec_flag x0),
          (List.map copy_type_declaration x1))
  | From.Parsetree.Pstr_typext x0 ->
      To.Parsetree.Pstr_typext
        (copy_type_extension x0)
  | From.Parsetree.Pstr_exception x0 ->
      To.Parsetree.Pstr_exception
        (copy_extension_constructor x0)
  | From.Parsetree.Pstr_module x0 ->
      To.Parsetree.Pstr_module
        (copy_module_binding x0)
  | From.Parsetree.Pstr_recmodule x0 ->
      To.Parsetree.Pstr_recmodule
        (List.map copy_module_binding x0)
  | From.Parsetree.Pstr_modtype x0 ->
      To.Parsetree.Pstr_modtype
        (copy_module_type_declaration x0)
  | From.Parsetree.Pstr_open x0 ->
      To.Parsetree.Pstr_open
        (copy_open_description x0)
  | From.Parsetree.Pstr_class x0 ->
      To.Parsetree.Pstr_class
        (List.map copy_class_declaration x0)
  | From.Parsetree.Pstr_class_type x0 ->
      To.Parsetree.Pstr_class_type
        (List.map copy_class_type_declaration x0)
  | From.Parsetree.Pstr_include x0 ->
      To.Parsetree.Pstr_include
        (copy_include_declaration x0)
  | From.Parsetree.Pstr_attribute x0 ->
      To.Parsetree.Pstr_attribute (copy_attribute x0)
  | From.Parsetree.Pstr_extension (x0,x1) ->
      To.Parsetree.Pstr_extension
        ((copy_extension x0),
          (copy_attributes x1))

and copy_include_declaration :
  From.Parsetree.include_declaration ->
    To.Parsetree.include_declaration
  =
  fun x  ->
    copy_include_infos copy_module_expr x

and copy_class_declaration :
  From.Parsetree.class_declaration -> To.Parsetree.class_declaration
  =
  fun x  ->
    copy_class_infos copy_class_expr x

and copy_class_expr :
  From.Parsetree.class_expr -> To.Parsetree.class_expr =
  fun
    { From.Parsetree.pcl_desc = pcl_desc;
      From.Parsetree.pcl_loc = pcl_loc;
      From.Parsetree.pcl_attributes = pcl_attributes }
     ->
    {
      To.Parsetree.pcl_desc =
        (copy_class_expr_desc pcl_desc);
      To.Parsetree.pcl_loc = (copy_location pcl_loc);
      To.Parsetree.pcl_attributes =
        (copy_attributes pcl_attributes)
    }

and copy_class_expr_desc :
  From.Parsetree.class_expr_desc -> To.Parsetree.class_expr_desc =
  function
  | From.Parsetree.Pcl_constr (x0,x1) ->
      To.Parsetree.Pcl_constr
        ((copy_loc copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Pcl_structure x0 ->
      To.Parsetree.Pcl_structure
        (copy_class_structure x0)
  | From.Parsetree.Pcl_fun (x0,x1,x2,x3) ->
      To.Parsetree.Pcl_fun
        ((copy_arg_label x0),
          (copy_option copy_expression x1),
          (copy_pattern x2),
          (copy_class_expr x3))
  | From.Parsetree.Pcl_apply (x0,x1) ->
      To.Parsetree.Pcl_apply
        ((copy_class_expr x0),
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                ((copy_arg_label x0),
                  (copy_expression x1))) x1))
  | From.Parsetree.Pcl_let (x0,x1,x2) ->
      To.Parsetree.Pcl_let
        ((copy_rec_flag x0),
          (List.map copy_value_binding x1),
          (copy_class_expr x2))
  | From.Parsetree.Pcl_constraint (x0,x1) ->
      To.Parsetree.Pcl_constraint
        ((copy_class_expr x0),
          (copy_class_type x1))
  | From.Parsetree.Pcl_extension x0 ->
      To.Parsetree.Pcl_extension (copy_extension x0)

and copy_class_structure :
  From.Parsetree.class_structure -> To.Parsetree.class_structure =
  fun
    { From.Parsetree.pcstr_self = pcstr_self;
      From.Parsetree.pcstr_fields = pcstr_fields }
     ->
    {
      To.Parsetree.pcstr_self =
        (copy_pattern pcstr_self);
      To.Parsetree.pcstr_fields =
        (List.map copy_class_field pcstr_fields)
    }

and copy_class_field :
  From.Parsetree.class_field -> To.Parsetree.class_field =
  fun
    { From.Parsetree.pcf_desc = pcf_desc;
      From.Parsetree.pcf_loc = pcf_loc;
      From.Parsetree.pcf_attributes = pcf_attributes }
     ->
    {
      To.Parsetree.pcf_desc =
        (copy_class_field_desc pcf_desc);
      To.Parsetree.pcf_loc = (copy_location pcf_loc);
      To.Parsetree.pcf_attributes =
        (copy_attributes pcf_attributes)
    }

and copy_class_field_desc :
  From.Parsetree.class_field_desc -> To.Parsetree.class_field_desc =
  function
  | From.Parsetree.Pcf_inherit (x0,x1,x2) ->
      To.Parsetree.Pcf_inherit
        ((copy_override_flag x0),
          (copy_class_expr x1),
          (copy_option (fun x  -> noloc x) x2))
  | From.Parsetree.Pcf_val x0 ->
      To.Parsetree.Pcf_val
        (let (x0,x1,x2) = x0  in
         ((copy_loc (fun x  -> x) x0),
           (copy_mutable_flag x1),
           (copy_class_field_kind x2)))
  | From.Parsetree.Pcf_method x0 ->
      To.Parsetree.Pcf_method
        (let (x0,x1,x2) = x0  in
         ((copy_loc (fun x  -> x) x0),
           (copy_private_flag x1),
           (copy_class_field_kind x2)))
  | From.Parsetree.Pcf_constraint x0 ->
      To.Parsetree.Pcf_constraint
        (let (x0,x1) = x0  in
         ((copy_core_type x0),
           (copy_core_type x1)))
  | From.Parsetree.Pcf_initializer x0 ->
      To.Parsetree.Pcf_initializer
        (copy_expression x0)
  | From.Parsetree.Pcf_attribute x0 ->
      To.Parsetree.Pcf_attribute (copy_attribute x0)
  | From.Parsetree.Pcf_extension x0 ->
      To.Parsetree.Pcf_extension (copy_extension x0)

and copy_class_field_kind :
  From.Parsetree.class_field_kind -> To.Parsetree.class_field_kind =
  function
  | From.Parsetree.Cfk_virtual x0 ->
      To.Parsetree.Cfk_virtual (copy_core_type x0)
  | From.Parsetree.Cfk_concrete (x0,x1) ->
      To.Parsetree.Cfk_concrete
        ((copy_override_flag x0),
          (copy_expression x1))

and copy_module_binding :
  From.Parsetree.module_binding -> To.Parsetree.module_binding =
  fun
    { From.Parsetree.pmb_name = pmb_name;
      From.Parsetree.pmb_expr = pmb_expr;
      From.Parsetree.pmb_attributes = pmb_attributes;
      From.Parsetree.pmb_loc = pmb_loc }
     ->
    {
      To.Parsetree.pmb_name =
        (copy_loc (fun x  -> x) pmb_name);
      To.Parsetree.pmb_expr =
        (copy_module_expr pmb_expr);
      To.Parsetree.pmb_attributes =
        (copy_attributes pmb_attributes);
      To.Parsetree.pmb_loc = (copy_location pmb_loc)
    }

and copy_module_expr :
  From.Parsetree.module_expr -> To.Parsetree.module_expr =
  fun
    { From.Parsetree.pmod_desc = pmod_desc;
      From.Parsetree.pmod_loc = pmod_loc;
      From.Parsetree.pmod_attributes = pmod_attributes }
     ->
    {
      To.Parsetree.pmod_desc =
        (copy_module_expr_desc pmod_desc);
      To.Parsetree.pmod_loc = (copy_location pmod_loc);
      To.Parsetree.pmod_attributes =
        (copy_attributes pmod_attributes)
    }

and copy_module_expr_desc :
  From.Parsetree.module_expr_desc -> To.Parsetree.module_expr_desc =
  function
  | From.Parsetree.Pmod_ident x0 ->
      To.Parsetree.Pmod_ident
        (copy_loc copy_longident x0)
  | From.Parsetree.Pmod_structure x0 ->
      To.Parsetree.Pmod_structure (copy_structure x0)
  | From.Parsetree.Pmod_functor (x0,x1,x2) ->
      To.Parsetree.Pmod_functor
        ((copy_loc (fun x  -> x) x0),
          (copy_option copy_module_type x1),
          (copy_module_expr x2))
  | From.Parsetree.Pmod_apply (x0,x1) ->
      To.Parsetree.Pmod_apply
        ((copy_module_expr x0),
          (copy_module_expr x1))
  | From.Parsetree.Pmod_constraint (x0,x1) ->
      To.Parsetree.Pmod_constraint
        ((copy_module_expr x0),
          (copy_module_type x1))
  | From.Parsetree.Pmod_unpack x0 ->
      To.Parsetree.Pmod_unpack (copy_expression x0)
  | From.Parsetree.Pmod_extension x0 ->
      To.Parsetree.Pmod_extension (copy_extension x0)

and copy_module_type :
  From.Parsetree.module_type -> To.Parsetree.module_type =
  fun
    { From.Parsetree.pmty_desc = pmty_desc;
      From.Parsetree.pmty_loc = pmty_loc;
      From.Parsetree.pmty_attributes = pmty_attributes }
     ->
    {
      To.Parsetree.pmty_desc =
        (copy_module_type_desc pmty_desc);
      To.Parsetree.pmty_loc = (copy_location pmty_loc);
      To.Parsetree.pmty_attributes =
        (copy_attributes pmty_attributes)
    }

and copy_module_type_desc :
  From.Parsetree.module_type_desc -> To.Parsetree.module_type_desc =
  function
  | From.Parsetree.Pmty_ident x0 ->
      To.Parsetree.Pmty_ident
        (copy_loc copy_longident x0)
  | From.Parsetree.Pmty_signature x0 ->
      To.Parsetree.Pmty_signature (copy_signature x0)
  | From.Parsetree.Pmty_functor (x0,x1,x2) ->
      To.Parsetree.Pmty_functor
        ((copy_loc (fun x  -> x) x0),
          (copy_option copy_module_type x1),
          (copy_module_type x2))
  | From.Parsetree.Pmty_with (x0,x1) ->
      To.Parsetree.Pmty_with
        ((copy_module_type x0),
          (List.map copy_with_constraint x1))
  | From.Parsetree.Pmty_typeof x0 ->
      To.Parsetree.Pmty_typeof (copy_module_expr x0)
  | From.Parsetree.Pmty_extension x0 ->
      To.Parsetree.Pmty_extension (copy_extension x0)
  | From.Parsetree.Pmty_alias x0 ->
      To.Parsetree.Pmty_alias
        (copy_loc copy_longident x0)

and copy_with_constraint :
  From.Parsetree.with_constraint -> To.Parsetree.with_constraint =
  function
  | From.Parsetree.Pwith_type (x0,x1) ->
      To.Parsetree.Pwith_type
        ((copy_loc copy_longident x0),
          (copy_type_declaration x1))
  | From.Parsetree.Pwith_module (x0,x1) ->
      To.Parsetree.Pwith_module
        ((copy_loc copy_longident x0),
          (copy_loc copy_longident x1))
  | From.Parsetree.Pwith_typesubst x0 ->
      To.Parsetree.Pwith_typesubst
        (copy_type_declaration x0)
  | From.Parsetree.Pwith_modsubst (x0,x1) ->
      To.Parsetree.Pwith_modsubst
        ((copy_loc (fun x  -> x) x0),
          (copy_loc copy_longident x1))

and copy_signature :
  From.Parsetree.signature -> To.Parsetree.signature =
  fun x  -> List.map copy_signature_item x

and copy_signature_item :
  From.Parsetree.signature_item -> To.Parsetree.signature_item =
  fun
    { From.Parsetree.psig_desc = psig_desc;
      From.Parsetree.psig_loc = psig_loc }
     ->
    {
      To.Parsetree.psig_desc =
        (copy_signature_item_desc psig_desc);
      To.Parsetree.psig_loc = (copy_location psig_loc)
    }

and copy_signature_item_desc :
  From.Parsetree.signature_item_desc ->
    To.Parsetree.signature_item_desc
  =
  function
  | From.Parsetree.Psig_value x0 ->
      To.Parsetree.Psig_value
        (copy_value_description x0)
  | From.Parsetree.Psig_type (x0,x1) ->
      To.Parsetree.Psig_type
        ((copy_rec_flag x0),
          (List.map copy_type_declaration x1))
  | From.Parsetree.Psig_typext x0 ->
      To.Parsetree.Psig_typext
        (copy_type_extension x0)
  | From.Parsetree.Psig_exception x0 ->
      To.Parsetree.Psig_exception
        (copy_extension_constructor x0)
  | From.Parsetree.Psig_module x0 ->
      To.Parsetree.Psig_module
        (copy_module_declaration x0)
  | From.Parsetree.Psig_recmodule x0 ->
      To.Parsetree.Psig_recmodule
        (List.map copy_module_declaration x0)
  | From.Parsetree.Psig_modtype x0 ->
      To.Parsetree.Psig_modtype
        (copy_module_type_declaration x0)
  | From.Parsetree.Psig_open x0 ->
      To.Parsetree.Psig_open
        (copy_open_description x0)
  | From.Parsetree.Psig_include x0 ->
      To.Parsetree.Psig_include
        (copy_include_description x0)
  | From.Parsetree.Psig_class x0 ->
      To.Parsetree.Psig_class
        (List.map copy_class_description x0)
  | From.Parsetree.Psig_class_type x0 ->
      To.Parsetree.Psig_class_type
        (List.map copy_class_type_declaration x0)
  | From.Parsetree.Psig_attribute x0 ->
      To.Parsetree.Psig_attribute (copy_attribute x0)
  | From.Parsetree.Psig_extension (x0,x1) ->
      To.Parsetree.Psig_extension
        ((copy_extension x0),
          (copy_attributes x1))

and copy_class_type_declaration :
  From.Parsetree.class_type_declaration ->
    To.Parsetree.class_type_declaration
  =
  fun x  ->
    copy_class_infos copy_class_type x

and copy_class_description :
  From.Parsetree.class_description -> To.Parsetree.class_description
  =
  fun x  ->
    copy_class_infos copy_class_type x

and copy_class_type :
  From.Parsetree.class_type -> To.Parsetree.class_type =
  fun
    { From.Parsetree.pcty_desc = pcty_desc;
      From.Parsetree.pcty_loc = pcty_loc;
      From.Parsetree.pcty_attributes = pcty_attributes }
     ->
    {
      To.Parsetree.pcty_desc =
        (copy_class_type_desc pcty_desc);
      To.Parsetree.pcty_loc = (copy_location pcty_loc);
      To.Parsetree.pcty_attributes =
        (copy_attributes pcty_attributes)
    }

and copy_class_type_desc :
  From.Parsetree.class_type_desc -> To.Parsetree.class_type_desc =
  function
  | From.Parsetree.Pcty_constr (x0,x1) ->
      To.Parsetree.Pcty_constr
        ((copy_loc copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Pcty_signature x0 ->
      To.Parsetree.Pcty_signature
        (copy_class_signature x0)
  | From.Parsetree.Pcty_arrow (x0,x1,x2) ->
      To.Parsetree.Pcty_arrow
        ((copy_arg_label x0),
          (copy_core_type x1),
          (copy_class_type x2))
  | From.Parsetree.Pcty_extension x0 ->
      To.Parsetree.Pcty_extension (copy_extension x0)

and copy_class_signature :
  From.Parsetree.class_signature -> To.Parsetree.class_signature =
  fun
    { From.Parsetree.pcsig_self = pcsig_self;
      From.Parsetree.pcsig_fields = pcsig_fields }
     ->
    {
      To.Parsetree.pcsig_self =
        (copy_core_type pcsig_self);
      To.Parsetree.pcsig_fields =
        (List.map copy_class_type_field pcsig_fields)
    }

and copy_class_type_field :
  From.Parsetree.class_type_field -> To.Parsetree.class_type_field =
  fun
    { From.Parsetree.pctf_desc = pctf_desc;
      From.Parsetree.pctf_loc = pctf_loc;
      From.Parsetree.pctf_attributes = pctf_attributes }
     ->
    {
      To.Parsetree.pctf_desc =
        (copy_class_type_field_desc pctf_desc);
      To.Parsetree.pctf_loc = (copy_location pctf_loc);
      To.Parsetree.pctf_attributes =
        (copy_attributes pctf_attributes)
    }

and copy_class_type_field_desc :
  From.Parsetree.class_type_field_desc ->
    To.Parsetree.class_type_field_desc
  =
  function
  | From.Parsetree.Pctf_inherit x0 ->
      To.Parsetree.Pctf_inherit (copy_class_type x0)
  | From.Parsetree.Pctf_val x0 ->
      To.Parsetree.Pctf_val
        (let (x0,x1,x2,x3) = x0  in
         (noloc x0, (copy_mutable_flag x1),
           (copy_virtual_flag x2),
           (copy_core_type x3)))
  | From.Parsetree.Pctf_method x0 ->
      To.Parsetree.Pctf_method
        (let (x0,x1,x2,x3) = x0  in
         (noloc x0, (copy_private_flag x1),
           (copy_virtual_flag x2),
           (copy_core_type x3)))
  | From.Parsetree.Pctf_constraint x0 ->
      To.Parsetree.Pctf_constraint
        (let (x0,x1) = x0  in
         ((copy_core_type x0),
           (copy_core_type x1)))
  | From.Parsetree.Pctf_attribute x0 ->
      To.Parsetree.Pctf_attribute (copy_attribute x0)
  | From.Parsetree.Pctf_extension x0 ->
      To.Parsetree.Pctf_extension (copy_extension x0)

and copy_extension :
  From.Parsetree.extension -> To.Parsetree.extension =
  fun x  ->
    let (x0,x1) = x  in
    ((copy_loc (fun x  -> x) x0),
      (copy_payload x1))

and copy_class_infos :
  'f0 'g0 .
    ('f0 -> 'g0) ->
      'f0 From.Parsetree.class_infos -> 'g0 To.Parsetree.class_infos
  =
  fun f0  ->
    fun
      { From.Parsetree.pci_virt = pci_virt;
        From.Parsetree.pci_params = pci_params;
        From.Parsetree.pci_name = pci_name;
        From.Parsetree.pci_expr = pci_expr;
        From.Parsetree.pci_loc = pci_loc;
        From.Parsetree.pci_attributes = pci_attributes }
       ->
      {
        To.Parsetree.pci_virt =
          (copy_virtual_flag pci_virt);
        To.Parsetree.pci_params =
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                ((copy_core_type x0),
                  (copy_variance x1))) pci_params);
        To.Parsetree.pci_name =
          (copy_loc (fun x  -> x) pci_name);
        To.Parsetree.pci_expr = (f0 pci_expr);
        To.Parsetree.pci_loc = (copy_location pci_loc);
        To.Parsetree.pci_attributes =
          (copy_attributes pci_attributes)
      }

and copy_virtual_flag :
  From.Asttypes.virtual_flag -> To.Asttypes.virtual_flag =
  function
  | From.Asttypes.Virtual  -> To.Asttypes.Virtual
  | From.Asttypes.Concrete  -> To.Asttypes.Concrete

and copy_include_description :
  From.Parsetree.include_description ->
    To.Parsetree.include_description
  =
  fun x  ->
    copy_include_infos copy_module_type x

and copy_include_infos :
  'f0 'g0 .
    ('f0 -> 'g0) ->
      'f0 From.Parsetree.include_infos ->
        'g0 To.Parsetree.include_infos
  =
  fun f0  ->
    fun
      { From.Parsetree.pincl_mod = pincl_mod;
        From.Parsetree.pincl_loc = pincl_loc;
        From.Parsetree.pincl_attributes = pincl_attributes }
       ->
      {
        To.Parsetree.pincl_mod = (f0 pincl_mod);
        To.Parsetree.pincl_loc = (copy_location pincl_loc);
        To.Parsetree.pincl_attributes =
          (copy_attributes pincl_attributes)
      }

and copy_open_description :
  From.Parsetree.open_description -> To.Parsetree.open_description =
  fun
    { From.Parsetree.popen_lid = popen_lid;
      From.Parsetree.popen_override = popen_override;
      From.Parsetree.popen_loc = popen_loc;
      From.Parsetree.popen_attributes = popen_attributes }
     ->
    {
      To.Parsetree.popen_lid =
        (copy_loc copy_longident popen_lid);
      To.Parsetree.popen_override =
        (copy_override_flag popen_override);
      To.Parsetree.popen_loc = (copy_location popen_loc);
      To.Parsetree.popen_attributes =
        (copy_attributes popen_attributes)
    }

and copy_override_flag :
  From.Asttypes.override_flag -> To.Asttypes.override_flag =
  function
  | From.Asttypes.Override  -> To.Asttypes.Override
  | From.Asttypes.Fresh  -> To.Asttypes.Fresh

and copy_module_type_declaration :
  From.Parsetree.module_type_declaration ->
    To.Parsetree.module_type_declaration
  =
  fun
    { From.Parsetree.pmtd_name = pmtd_name;
      From.Parsetree.pmtd_type = pmtd_type;
      From.Parsetree.pmtd_attributes = pmtd_attributes;
      From.Parsetree.pmtd_loc = pmtd_loc }
     ->
    {
      To.Parsetree.pmtd_name =
        (copy_loc (fun x  -> x) pmtd_name);
      To.Parsetree.pmtd_type =
        (copy_option copy_module_type pmtd_type);
      To.Parsetree.pmtd_attributes =
        (copy_attributes pmtd_attributes);
      To.Parsetree.pmtd_loc = (copy_location pmtd_loc)
    }

and copy_module_declaration :
  From.Parsetree.module_declaration ->
    To.Parsetree.module_declaration
  =
  fun
    { From.Parsetree.pmd_name = pmd_name;
      From.Parsetree.pmd_type = pmd_type;
      From.Parsetree.pmd_attributes = pmd_attributes;
      From.Parsetree.pmd_loc = pmd_loc }
     ->
    {
      To.Parsetree.pmd_name =
        (copy_loc (fun x  -> x) pmd_name);
      To.Parsetree.pmd_type =
        (copy_module_type pmd_type);
      To.Parsetree.pmd_attributes =
        (copy_attributes pmd_attributes);
      To.Parsetree.pmd_loc = (copy_location pmd_loc)
    }

and copy_type_extension :
  From.Parsetree.type_extension -> To.Parsetree.type_extension =
  fun
    { From.Parsetree.ptyext_path = ptyext_path;
      From.Parsetree.ptyext_params = ptyext_params;
      From.Parsetree.ptyext_constructors = ptyext_constructors;
      From.Parsetree.ptyext_private = ptyext_private;
      From.Parsetree.ptyext_attributes = ptyext_attributes }
     ->
    {
      To.Parsetree.ptyext_path =
        (copy_loc copy_longident ptyext_path);
      To.Parsetree.ptyext_params =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_core_type x0),
                (copy_variance x1))) ptyext_params);
      To.Parsetree.ptyext_constructors =
        (List.map copy_extension_constructor
           ptyext_constructors);
      To.Parsetree.ptyext_private =
        (copy_private_flag ptyext_private);
      To.Parsetree.ptyext_attributes =
        (copy_attributes ptyext_attributes)
    }

and copy_extension_constructor :
  From.Parsetree.extension_constructor ->
    To.Parsetree.extension_constructor
  =
  fun
    { From.Parsetree.pext_name = pext_name;
      From.Parsetree.pext_kind = pext_kind;
      From.Parsetree.pext_loc = pext_loc;
      From.Parsetree.pext_attributes = pext_attributes }
     ->
    {
      To.Parsetree.pext_name =
        (copy_loc (fun x  -> x) pext_name);
      To.Parsetree.pext_kind =
        (copy_extension_constructor_kind pext_kind);
      To.Parsetree.pext_loc = (copy_location pext_loc);
      To.Parsetree.pext_attributes =
        (copy_attributes pext_attributes)
    }

and copy_extension_constructor_kind :
  From.Parsetree.extension_constructor_kind ->
    To.Parsetree.extension_constructor_kind
  =
  function
  | From.Parsetree.Pext_decl (x0,x1) ->
      To.Parsetree.Pext_decl
        ((copy_constructor_arguments x0),
          (copy_option copy_core_type x1))
  | From.Parsetree.Pext_rebind x0 ->
      To.Parsetree.Pext_rebind
        (copy_loc copy_longident x0)

and copy_type_declaration :
  From.Parsetree.type_declaration -> To.Parsetree.type_declaration =
  fun
    { From.Parsetree.ptype_name = ptype_name;
      From.Parsetree.ptype_params = ptype_params;
      From.Parsetree.ptype_cstrs = ptype_cstrs;
      From.Parsetree.ptype_kind = ptype_kind;
      From.Parsetree.ptype_private = ptype_private;
      From.Parsetree.ptype_manifest = ptype_manifest;
      From.Parsetree.ptype_attributes = ptype_attributes;
      From.Parsetree.ptype_loc = ptype_loc }
     ->
    {
      To.Parsetree.ptype_name =
        (copy_loc (fun x  -> x) ptype_name);
      To.Parsetree.ptype_params =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_core_type x0),
                (copy_variance x1))) ptype_params);
      To.Parsetree.ptype_cstrs =
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              ((copy_core_type x0),
                (copy_core_type x1),
                (copy_location x2))) ptype_cstrs);
      To.Parsetree.ptype_kind =
        (copy_type_kind ptype_kind);
      To.Parsetree.ptype_private =
        (copy_private_flag ptype_private);
      To.Parsetree.ptype_manifest =
        (copy_option copy_core_type ptype_manifest);
      To.Parsetree.ptype_attributes =
        (copy_attributes ptype_attributes);
      To.Parsetree.ptype_loc = (copy_location ptype_loc)
    }

and copy_private_flag :
  From.Asttypes.private_flag -> To.Asttypes.private_flag =
  function
  | From.Asttypes.Private  -> To.Asttypes.Private
  | From.Asttypes.Public  -> To.Asttypes.Public

and copy_type_kind :
  From.Parsetree.type_kind -> To.Parsetree.type_kind =
  function
  | From.Parsetree.Ptype_abstract  -> To.Parsetree.Ptype_abstract
  | From.Parsetree.Ptype_variant x0 ->
      To.Parsetree.Ptype_variant
        (List.map copy_constructor_declaration x0)
  | From.Parsetree.Ptype_record x0 ->
      To.Parsetree.Ptype_record
        (List.map copy_label_declaration x0)
  | From.Parsetree.Ptype_open  -> To.Parsetree.Ptype_open

and copy_constructor_declaration :
  From.Parsetree.constructor_declaration ->
    To.Parsetree.constructor_declaration
  =
  fun
    { From.Parsetree.pcd_name = pcd_name;
      From.Parsetree.pcd_args = pcd_args;
      From.Parsetree.pcd_res = pcd_res;
      From.Parsetree.pcd_loc = pcd_loc;
      From.Parsetree.pcd_attributes = pcd_attributes }
     ->
    {
      To.Parsetree.pcd_name =
        (copy_loc (fun x  -> x) pcd_name);
      To.Parsetree.pcd_args =
        (copy_constructor_arguments pcd_args);
      To.Parsetree.pcd_res =
        (copy_option copy_core_type pcd_res);
      To.Parsetree.pcd_loc = (copy_location pcd_loc);
      To.Parsetree.pcd_attributes =
        (copy_attributes pcd_attributes)
    }

and copy_constructor_arguments :
  From.Parsetree.constructor_arguments ->
    To.Parsetree.constructor_arguments
  =
  function
  | From.Parsetree.Pcstr_tuple x0 ->
      To.Parsetree.Pcstr_tuple
        (List.map copy_core_type x0)
  | From.Parsetree.Pcstr_record x0 ->
      To.Parsetree.Pcstr_record
        (List.map copy_label_declaration x0)

and copy_label_declaration :
  From.Parsetree.label_declaration -> To.Parsetree.label_declaration
  =
  fun
    { From.Parsetree.pld_name = pld_name;
      From.Parsetree.pld_mutable = pld_mutable;
      From.Parsetree.pld_type = pld_type;
      From.Parsetree.pld_loc = pld_loc;
      From.Parsetree.pld_attributes = pld_attributes }
     ->
    {
      To.Parsetree.pld_name =
        (copy_loc (fun x  -> x) pld_name);
      To.Parsetree.pld_mutable =
        (copy_mutable_flag pld_mutable);
      To.Parsetree.pld_type =
        (copy_core_type pld_type);
      To.Parsetree.pld_loc = (copy_location pld_loc);
      To.Parsetree.pld_attributes =
        (copy_attributes pld_attributes)
    }

and copy_mutable_flag :
  From.Asttypes.mutable_flag -> To.Asttypes.mutable_flag =
  function
  | From.Asttypes.Immutable  -> To.Asttypes.Immutable
  | From.Asttypes.Mutable  -> To.Asttypes.Mutable

and copy_variance :
  From.Asttypes.variance -> To.Asttypes.variance =
  function
  | From.Asttypes.Covariant  -> To.Asttypes.Covariant
  | From.Asttypes.Contravariant  -> To.Asttypes.Contravariant
  | From.Asttypes.Invariant  -> To.Asttypes.Invariant

and copy_value_description :
  From.Parsetree.value_description -> To.Parsetree.value_description
  =
  fun
    { From.Parsetree.pval_name = pval_name;
      From.Parsetree.pval_type = pval_type;
      From.Parsetree.pval_prim = pval_prim;
      From.Parsetree.pval_attributes = pval_attributes;
      From.Parsetree.pval_loc = pval_loc }
     ->
    {
      To.Parsetree.pval_name =
        (copy_loc (fun x  -> x) pval_name);
      To.Parsetree.pval_type =
        (copy_core_type pval_type);
      To.Parsetree.pval_prim = (List.map (fun x  -> x) pval_prim);
      To.Parsetree.pval_attributes =
        (copy_attributes pval_attributes);
      To.Parsetree.pval_loc = (copy_location pval_loc)
    }

and copy_arg_label :
  From.Asttypes.arg_label -> To.Asttypes.arg_label =
  function
  | From.Asttypes.Nolabel  -> To.Asttypes.Nolabel
  | From.Asttypes.Labelled x0 -> To.Asttypes.Labelled x0
  | From.Asttypes.Optional x0 -> To.Asttypes.Optional x0

and copy_closed_flag :
  From.Asttypes.closed_flag -> To.Asttypes.closed_flag =
  function
  | From.Asttypes.Closed  -> To.Asttypes.Closed
  | From.Asttypes.Open  -> To.Asttypes.Open

and copy_label :
  From.Asttypes.label -> To.Asttypes.label = fun x  -> x

and copy_rec_flag :
  From.Asttypes.rec_flag -> To.Asttypes.rec_flag =
  function
  | From.Asttypes.Nonrecursive  -> To.Asttypes.Nonrecursive
  | From.Asttypes.Recursive  -> To.Asttypes.Recursive

and copy_constant :
  From.Parsetree.constant -> To.Parsetree.constant =
  function
  | From.Parsetree.Pconst_integer (x0,x1) ->
      To.Parsetree.Pconst_integer (x0, (copy_option (fun x  -> x) x1))
  | From.Parsetree.Pconst_char x0 -> To.Parsetree.Pconst_char x0
  | From.Parsetree.Pconst_string (x0,x1) ->
      To.Parsetree.Pconst_string (x0, (copy_option (fun x  -> x) x1))
  | From.Parsetree.Pconst_float (x0,x1) ->
      To.Parsetree.Pconst_float (x0, (copy_option (fun x  -> x) x1))

and copy_option : 'f0 'g0 . ('f0 -> 'g0) -> 'f0 option -> 'g0 option =
  fun f0  -> function | None  -> None | Some x0 -> Some (f0 x0)

and copy_longident : From.Longident.t -> To.Longident.t =
  function
  | From.Longident.Lident x0 -> To.Longident.Lident x0
  | From.Longident.Ldot (x0,x1) ->
      To.Longident.Ldot ((copy_longident x0), x1)
  | From.Longident.Lapply (x0,x1) ->
      To.Longident.Lapply
        ((copy_longident x0), (copy_longident x1))

and copy_loc :
  'f0 'g0 .
    ('f0 -> 'g0) -> 'f0 From.Asttypes.loc -> 'g0 To.Asttypes.loc
  =
  fun f0  ->
    fun { From.Asttypes.txt = txt; From.Asttypes.loc = loc }  ->
      {
        To.Asttypes.txt = (f0 txt);
        To.Asttypes.loc = (copy_location loc)
      }

and copy_location : From.Location.t -> To.Location.t =
  fun
    { From.Location.loc_start = loc_start;
      From.Location.loc_end = loc_end;
      From.Location.loc_ghost = loc_ghost }
     ->
    {
      To.Location.loc_start = (copy_Lexing_position loc_start);
      To.Location.loc_end = (copy_Lexing_position loc_end);
      To.Location.loc_ghost = (copy_bool loc_ghost)
    }

and copy_bool : bool -> bool = function | false  -> false | true  -> true

and copy_Lexing_position : Lexing.position -> Lexing.position =
  fun
    { Lexing.pos_fname = pos_fname; Lexing.pos_lnum = pos_lnum;
      Lexing.pos_bol = pos_bol; Lexing.pos_cnum = pos_cnum }
     ->
    {
      Lexing.pos_fname = pos_fname;
      Lexing.pos_lnum = pos_lnum;
      Lexing.pos_bol = pos_bol;
      Lexing.pos_cnum = pos_cnum
    }

let rec copy_out_phrase :
  From.Outcometree.out_phrase -> To.Outcometree.out_phrase =
  function
  | From.Outcometree.Ophr_eval (x0,x1) ->
      To.Outcometree.Ophr_eval
        ((copy_out_value x0),
          (copy_out_type x1))
  | From.Outcometree.Ophr_signature x0 ->
      To.Outcometree.Ophr_signature
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_out_sig_item x0),
                (copy_option copy_out_value x1))) x0)
  | From.Outcometree.Ophr_exception x0 ->
      To.Outcometree.Ophr_exception
        (let (x0,x1) = x0  in
         ((copy_exn x0), (copy_out_value x1)))

and copy_exn : exn -> exn = fun x  -> x

and copy_out_sig_item :
  From.Outcometree.out_sig_item -> To.Outcometree.out_sig_item =
  function
  | From.Outcometree.Osig_class (x0,x1,x2,x3,x4) ->
      To.Outcometree.Osig_class
        ((copy_bool x0), x1,
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))
             x2), (copy_out_class_type x3),
          (copy_out_rec_status x4))
  | From.Outcometree.Osig_class_type (x0,x1,x2,x3,x4) ->
      To.Outcometree.Osig_class_type
        ((copy_bool x0), x1,
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))
             x2), (copy_out_class_type x3),
          (copy_out_rec_status x4))
  | From.Outcometree.Osig_typext (x0,x1) ->
      To.Outcometree.Osig_typext
        ((copy_out_extension_constructor x0),
          (copy_out_ext_status x1))
  | From.Outcometree.Osig_modtype (x0,x1) ->
      To.Outcometree.Osig_modtype
        (x0, (copy_out_module_type x1))
  | From.Outcometree.Osig_module (x0,x1,x2) ->
      To.Outcometree.Osig_module
        (x0, (copy_out_module_type x1),
          (copy_out_rec_status x2))
  | From.Outcometree.Osig_type (x0,x1) ->
      To.Outcometree.Osig_type
        ((copy_out_type_decl x0),
          (copy_out_rec_status x1))
  | From.Outcometree.Osig_value x0 ->
      To.Outcometree.Osig_value
        (copy_out_val_decl x0)
  | From.Outcometree.Osig_ellipsis  -> To.Outcometree.Osig_ellipsis

and copy_out_val_decl :
  From.Outcometree.out_val_decl -> To.Outcometree.out_val_decl =
  fun
    { From.Outcometree.oval_name = oval_name;
      From.Outcometree.oval_type = oval_type;
      From.Outcometree.oval_prims = oval_prims;
      From.Outcometree.oval_attributes = oval_attributes }
     ->
    {
      To.Outcometree.oval_name = oval_name;
      To.Outcometree.oval_type =
        (copy_out_type oval_type);
      To.Outcometree.oval_prims = (List.map (fun x  -> x) oval_prims);
      To.Outcometree.oval_attributes =
        (List.map copy_out_attribute oval_attributes)
    }

and copy_out_type_decl :
  From.Outcometree.out_type_decl -> To.Outcometree.out_type_decl =
  fun
    { From.Outcometree.otype_name = otype_name;
      From.Outcometree.otype_params = otype_params;
      From.Outcometree.otype_type = otype_type;
      From.Outcometree.otype_private = otype_private;
      From.Outcometree.otype_immediate = otype_immediate;
      From.Outcometree.otype_unboxed = otype_unboxed;
      From.Outcometree.otype_cstrs = otype_cstrs }
     ->
    {
      To.Outcometree.otype_name = otype_name;
      To.Outcometree.otype_params =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))
           otype_params);
      To.Outcometree.otype_type =
        (copy_out_type otype_type);
      To.Outcometree.otype_private =
        (copy_From_Asttypes_private_flag otype_private);
      To.Outcometree.otype_immediate = (copy_bool otype_immediate);
      To.Outcometree.otype_unboxed = (copy_bool otype_unboxed);
      To.Outcometree.otype_cstrs =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_out_type x0),
                (copy_out_type x1))) otype_cstrs)
    }

and copy_out_module_type :
  From.Outcometree.out_module_type -> To.Outcometree.out_module_type
  =
  function
  | From.Outcometree.Omty_abstract  -> To.Outcometree.Omty_abstract
  | From.Outcometree.Omty_functor (x0,x1,x2) ->
      To.Outcometree.Omty_functor
        (x0, (copy_option copy_out_module_type x1),
          (copy_out_module_type x2))
  | From.Outcometree.Omty_ident x0 ->
      To.Outcometree.Omty_ident (copy_out_ident x0)
  | From.Outcometree.Omty_signature x0 ->
      To.Outcometree.Omty_signature
        (List.map copy_out_sig_item x0)
  | From.Outcometree.Omty_alias x0 ->
      To.Outcometree.Omty_alias (copy_out_ident x0)

and copy_out_ext_status :
  From.Outcometree.out_ext_status -> To.Outcometree.out_ext_status =
  function
  | From.Outcometree.Oext_first  -> To.Outcometree.Oext_first
  | From.Outcometree.Oext_next  -> To.Outcometree.Oext_next
  | From.Outcometree.Oext_exception  -> To.Outcometree.Oext_exception

and copy_out_extension_constructor :
  From.Outcometree.out_extension_constructor ->
    To.Outcometree.out_extension_constructor
  =
  fun
    { From.Outcometree.oext_name = oext_name;
      From.Outcometree.oext_type_name = oext_type_name;
      From.Outcometree.oext_type_params = oext_type_params;
      From.Outcometree.oext_args = oext_args;
      From.Outcometree.oext_ret_type = oext_ret_type;
      From.Outcometree.oext_private = oext_private }
     ->
    {
      To.Outcometree.oext_name = oext_name;
      To.Outcometree.oext_type_name = oext_type_name;
      To.Outcometree.oext_type_params =
        (List.map (fun x  -> x) oext_type_params);
      To.Outcometree.oext_args =
        (List.map copy_out_type oext_args);
      To.Outcometree.oext_ret_type =
        (copy_option copy_out_type oext_ret_type);
      To.Outcometree.oext_private =
        (copy_From_Asttypes_private_flag oext_private)
    }

and copy_From_Asttypes_private_flag :
  From.Asttypes.private_flag -> To.Asttypes.private_flag =
  function
  | From.Asttypes.Private  -> To.Asttypes.Private
  | From.Asttypes.Public  -> To.Asttypes.Public

and copy_out_rec_status :
  From.Outcometree.out_rec_status -> To.Outcometree.out_rec_status =
  function
  | From.Outcometree.Orec_not  -> To.Outcometree.Orec_not
  | From.Outcometree.Orec_first  -> To.Outcometree.Orec_first
  | From.Outcometree.Orec_next  -> To.Outcometree.Orec_next

and copy_out_class_type :
  From.Outcometree.out_class_type -> To.Outcometree.out_class_type =
  function
  | From.Outcometree.Octy_constr (x0,x1) ->
      To.Outcometree.Octy_constr
        ((copy_out_ident x0),
          (List.map copy_out_type x1))
  | From.Outcometree.Octy_arrow (x0,x1,x2) ->
      To.Outcometree.Octy_arrow
        (x0, (copy_out_type x1),
          (copy_out_class_type x2))
  | From.Outcometree.Octy_signature (x0,x1) ->
      To.Outcometree.Octy_signature
        ((copy_option copy_out_type x0),
          (List.map copy_out_class_sig_item x1))

and copy_out_class_sig_item :
  From.Outcometree.out_class_sig_item ->
    To.Outcometree.out_class_sig_item
  =
  function
  | From.Outcometree.Ocsg_constraint (x0,x1) ->
      To.Outcometree.Ocsg_constraint
        ((copy_out_type x0),
          (copy_out_type x1))
  | From.Outcometree.Ocsg_method (x0,x1,x2,x3) ->
      To.Outcometree.Ocsg_method
        (x0, (copy_bool x1), (copy_bool x2),
          (copy_out_type x3))
  | From.Outcometree.Ocsg_value (x0,x1,x2,x3) ->
      To.Outcometree.Ocsg_value
        (x0, (copy_bool x1), (copy_bool x2),
          (copy_out_type x3))

and copy_out_type :
  From.Outcometree.out_type -> To.Outcometree.out_type =
  function
  | From.Outcometree.Otyp_abstract  -> To.Outcometree.Otyp_abstract
  | From.Outcometree.Otyp_open  -> To.Outcometree.Otyp_open
  | From.Outcometree.Otyp_alias (x0,x1) ->
      To.Outcometree.Otyp_alias
        ((copy_out_type x0), x1)
  | From.Outcometree.Otyp_arrow (x0,x1,x2) ->
      To.Outcometree.Otyp_arrow
        (x0, (copy_out_type x1),
          (copy_out_type x2))
  | From.Outcometree.Otyp_class (x0,x1,x2) ->
      To.Outcometree.Otyp_class
        ((copy_bool x0), (copy_out_ident x1),
          (List.map copy_out_type x2))
  | From.Outcometree.Otyp_constr (x0,x1) ->
      To.Outcometree.Otyp_constr
        ((copy_out_ident x0),
          (List.map copy_out_type x1))
  | From.Outcometree.Otyp_manifest (x0,x1) ->
      To.Outcometree.Otyp_manifest
        ((copy_out_type x0),
          (copy_out_type x1))
  | From.Outcometree.Otyp_object (x0,x1) ->
      To.Outcometree.Otyp_object
        ((List.map
            (fun x  ->
               let (x0,x1) = x  in
               (x0, (copy_out_type x1))) x0),
          (copy_option copy_bool x1))
  | From.Outcometree.Otyp_record x0 ->
      To.Outcometree.Otyp_record
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (copy_bool x1), (copy_out_type x2)))
           x0)
  | From.Outcometree.Otyp_stuff x0 -> To.Outcometree.Otyp_stuff x0
  | From.Outcometree.Otyp_sum x0 ->
      To.Outcometree.Otyp_sum
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (List.map copy_out_type x1),
                (copy_option copy_out_type x2))) x0)
  | From.Outcometree.Otyp_tuple x0 ->
      To.Outcometree.Otyp_tuple
        (List.map copy_out_type x0)
  | From.Outcometree.Otyp_var (x0,x1) ->
      To.Outcometree.Otyp_var ((copy_bool x0), x1)
  | From.Outcometree.Otyp_variant (x0,x1,x2,x3) ->
      To.Outcometree.Otyp_variant
        ((copy_bool x0), (copy_out_variant x1),
          (copy_bool x2),
          (copy_option (fun x  -> List.map (fun x  -> x) x) x3))
  | From.Outcometree.Otyp_poly (x0,x1) ->
      To.Outcometree.Otyp_poly
        ((List.map (fun x  -> x) x0), (copy_out_type x1))
  | From.Outcometree.Otyp_module (x0,x1,x2) ->
      To.Outcometree.Otyp_module
        (x0, (List.map (fun x  -> x) x1),
          (List.map copy_out_type x2))
  | From.Outcometree.Otyp_attribute (x0,x1) ->
      To.Outcometree.Otyp_attribute
        ((copy_out_type x0),
          (copy_out_attribute x1))

and copy_out_attribute :
  From.Outcometree.out_attribute -> To.Outcometree.out_attribute =
  fun { From.Outcometree.oattr_name = oattr_name }  ->
    { To.Outcometree.oattr_name = oattr_name }

and copy_out_variant :
  From.Outcometree.out_variant -> To.Outcometree.out_variant =
  function
  | From.Outcometree.Ovar_fields x0 ->
      To.Outcometree.Ovar_fields
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (copy_bool x1),
                (List.map copy_out_type x2))) x0)
  | From.Outcometree.Ovar_name (x0,x1) ->
      To.Outcometree.Ovar_typ
        (To.Outcometree.Otyp_constr
           ((copy_out_ident x0),
            (List.map copy_out_type x1)))

and copy_out_value :
  From.Outcometree.out_value -> To.Outcometree.out_value =
  function
  | From.Outcometree.Oval_array x0 ->
      To.Outcometree.Oval_array
        (List.map copy_out_value x0)
  | From.Outcometree.Oval_char x0 -> To.Outcometree.Oval_char x0
  | From.Outcometree.Oval_constr (x0,x1) ->
      To.Outcometree.Oval_constr
        ((copy_out_ident x0),
          (List.map copy_out_value x1))
  | From.Outcometree.Oval_ellipsis  -> To.Outcometree.Oval_ellipsis
  | From.Outcometree.Oval_float x0 ->
      To.Outcometree.Oval_float (copy_float x0)
  | From.Outcometree.Oval_int x0 -> To.Outcometree.Oval_int x0
  | From.Outcometree.Oval_int32 x0 -> To.Outcometree.Oval_int32 x0
  | From.Outcometree.Oval_int64 x0 -> To.Outcometree.Oval_int64 x0
  | From.Outcometree.Oval_nativeint x0 ->
      To.Outcometree.Oval_nativeint x0
  | From.Outcometree.Oval_list x0 ->
      To.Outcometree.Oval_list
        (List.map copy_out_value x0)
  | From.Outcometree.Oval_printer x0 ->
      To.Outcometree.Oval_printer x0
  | From.Outcometree.Oval_record x0 ->
      To.Outcometree.Oval_record
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_out_ident x0),
                (copy_out_value x1))) x0)
  | From.Outcometree.Oval_string x0 -> To.Outcometree.Oval_string x0
  | From.Outcometree.Oval_stuff x0 -> To.Outcometree.Oval_stuff x0
  | From.Outcometree.Oval_tuple x0 ->
      To.Outcometree.Oval_tuple
        (List.map copy_out_value x0)
  | From.Outcometree.Oval_variant (x0,x1) ->
      To.Outcometree.Oval_variant
        (x0, (copy_option copy_out_value x1))

and copy_float : float -> float = fun x  -> x

and copy_out_ident :
  From.Outcometree.out_ident -> To.Outcometree.out_ident =
  function
  | From.Outcometree.Oide_apply (x0,x1) ->
      To.Outcometree.Oide_apply
        ((copy_out_ident x0),
          (copy_out_ident x1))
  | From.Outcometree.Oide_dot (x0,x1) ->
      To.Outcometree.Oide_dot
        ((copy_out_ident x0), x1)
  | From.Outcometree.Oide_ident x0 -> To.Outcometree.Oide_ident x0

let rec copy_toplevel_phrase :
  From.Parsetree.toplevel_phrase -> To.Parsetree.toplevel_phrase =
  function
  | From.Parsetree.Ptop_def x0 ->
      To.Parsetree.Ptop_def (copy_structure x0)
  | From.Parsetree.Ptop_dir (x0,x1) ->
      To.Parsetree.Ptop_dir
        (x0, (copy_directive_argument x1))

and copy_directive_argument :
  From.Parsetree.directive_argument -> To.Parsetree.directive_argument =
  function
  | From.Parsetree.Pdir_none  -> To.Parsetree.Pdir_none
  | From.Parsetree.Pdir_string x0 -> To.Parsetree.Pdir_string x0
  | From.Parsetree.Pdir_int (x0,x1) ->
      To.Parsetree.Pdir_int (x0, (copy_option (fun x  -> x) x1))
  | From.Parsetree.Pdir_ident x0 ->
      To.Parsetree.Pdir_ident (copy_longident x0)
  | From.Parsetree.Pdir_bool x0 ->
      To.Parsetree.Pdir_bool (copy_bool x0)

let copy_out_type_extension :
  From.Outcometree.out_type_extension -> To.Outcometree.out_type_extension =
  fun
    { From.Outcometree.otyext_name = otyext_name;
      From.Outcometree.otyext_params = otyext_params;
      From.Outcometree.otyext_constructors = otyext_constructors;
      From.Outcometree.otyext_private = otyext_private }
     ->
    {
      To.Outcometree.otyext_name = otyext_name;
      To.Outcometree.otyext_params =
        (List.map (fun x  -> x) otyext_params);
      To.Outcometree.otyext_constructors =
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (List.map copy_out_type x1),
                (copy_option copy_out_type x2)))
           otyext_constructors);
      To.Outcometree.otyext_private =
        (copy_private_flag otyext_private)
    }

let copy_cases x = List.map copy_case x
let copy_pat = copy_pattern
let copy_expr = copy_expression
let copy_typ = copy_core_type

end
module Migrate_parsetree_405_404_migrate
= struct
#1 "migrate_parsetree_405_404_migrate.ml"
# 1 "src/migrate_parsetree_405_404_migrate.ml"
# 1 "src/migrate_parsetree_405_404_migrate.ml"
# 1 "src/migrate_parsetree_405_404_migrate.ml"
# 1 "src/migrate_parsetree_405_404_migrate.ml"
# 1 "src/migrate_parsetree_405_404_migrate.ml"
# 1 "src/migrate_parsetree_405_404_migrate.ml"
# 1 "src/migrate_parsetree_405_404_migrate.ml"
# 1 "src/migrate_parsetree_405_404_migrate.ml"
# 1 "src/migrate_parsetree_405_404_migrate.ml"
# 1 "src/migrate_parsetree_405_404_migrate.ml"
# 1 "src/migrate_parsetree_405_404_migrate.ml"
# 1 "src/migrate_parsetree_405_404_migrate.ml"
# 1 "src/migrate_parsetree_405_404_migrate.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*                         Alain Frisch, LexiFi                           *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

module From = Ast_405
module To = Ast_404

let rec copy_expression :
  From.Parsetree.expression -> To.Parsetree.expression =
  fun
    { From.Parsetree.pexp_desc = pexp_desc;
      From.Parsetree.pexp_loc = pexp_loc;
      From.Parsetree.pexp_attributes = pexp_attributes }
     ->
    {
      To.Parsetree.pexp_desc =
        (copy_expression_desc pexp_desc);
      To.Parsetree.pexp_loc = (copy_location pexp_loc);
      To.Parsetree.pexp_attributes =
        (copy_attributes pexp_attributes)
    }

and copy_expression_desc :
  From.Parsetree.expression_desc -> To.Parsetree.expression_desc =
  function
  | From.Parsetree.Pexp_ident x0 ->
      To.Parsetree.Pexp_ident
        (copy_loc copy_longident x0)
  | From.Parsetree.Pexp_constant x0 ->
      To.Parsetree.Pexp_constant (copy_constant x0)
  | From.Parsetree.Pexp_let (x0,x1,x2) ->
      To.Parsetree.Pexp_let
        ((copy_rec_flag x0),
          (List.map copy_value_binding x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_function x0 ->
      To.Parsetree.Pexp_function
        (List.map copy_case x0)
  | From.Parsetree.Pexp_fun (x0,x1,x2,x3) ->
      To.Parsetree.Pexp_fun
        ((copy_arg_label x0),
          (copy_option copy_expression x1),
          (copy_pattern x2),
          (copy_expression x3))
  | From.Parsetree.Pexp_apply (x0,x1) ->
      To.Parsetree.Pexp_apply
        ((copy_expression x0),
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                ((copy_arg_label x0),
                  (copy_expression x1))) x1))
  | From.Parsetree.Pexp_match (x0,x1) ->
      To.Parsetree.Pexp_match
        ((copy_expression x0),
          (List.map copy_case x1))
  | From.Parsetree.Pexp_try (x0,x1) ->
      To.Parsetree.Pexp_try
        ((copy_expression x0),
          (List.map copy_case x1))
  | From.Parsetree.Pexp_tuple x0 ->
      To.Parsetree.Pexp_tuple
        (List.map copy_expression x0)
  | From.Parsetree.Pexp_construct (x0,x1) ->
      To.Parsetree.Pexp_construct
        ((copy_loc copy_longident x0),
          (copy_option copy_expression x1))
  | From.Parsetree.Pexp_variant (x0,x1) ->
      To.Parsetree.Pexp_variant
        ((copy_label x0),
          (copy_option copy_expression x1))
  | From.Parsetree.Pexp_record (x0,x1) ->
      To.Parsetree.Pexp_record
        ((List.map
            (fun x  ->
               let (x0,x1) = x  in
               ((copy_loc copy_longident x0),
                 (copy_expression x1))) x0),
          (copy_option copy_expression x1))
  | From.Parsetree.Pexp_field (x0,x1) ->
      To.Parsetree.Pexp_field
        ((copy_expression x0),
          (copy_loc copy_longident x1))
  | From.Parsetree.Pexp_setfield (x0,x1,x2) ->
      To.Parsetree.Pexp_setfield
        ((copy_expression x0),
          (copy_loc copy_longident x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_array x0 ->
      To.Parsetree.Pexp_array
        (List.map copy_expression x0)
  | From.Parsetree.Pexp_ifthenelse (x0,x1,x2) ->
      To.Parsetree.Pexp_ifthenelse
        ((copy_expression x0),
          (copy_expression x1),
          (copy_option copy_expression x2))
  | From.Parsetree.Pexp_sequence (x0,x1) ->
      To.Parsetree.Pexp_sequence
        ((copy_expression x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_while (x0,x1) ->
      To.Parsetree.Pexp_while
        ((copy_expression x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_for (x0,x1,x2,x3,x4) ->
      To.Parsetree.Pexp_for
        ((copy_pattern x0),
          (copy_expression x1),
          (copy_expression x2),
          (copy_direction_flag x3),
          (copy_expression x4))
  | From.Parsetree.Pexp_constraint (x0,x1) ->
      To.Parsetree.Pexp_constraint
        ((copy_expression x0),
          (copy_core_type x1))
  | From.Parsetree.Pexp_coerce (x0,x1,x2) ->
      To.Parsetree.Pexp_coerce
        ((copy_expression x0),
          (copy_option copy_core_type x1),
          (copy_core_type x2))
  | From.Parsetree.Pexp_send (x0,x1) ->
      To.Parsetree.Pexp_send
        ((copy_expression x0), x1.From.Asttypes.txt)
  | From.Parsetree.Pexp_new x0 ->
      To.Parsetree.Pexp_new
        (copy_loc copy_longident x0)
  | From.Parsetree.Pexp_setinstvar (x0,x1) ->
      To.Parsetree.Pexp_setinstvar
        ((copy_loc (fun x  -> x) x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_override x0 ->
      To.Parsetree.Pexp_override
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_loc (fun x  -> x) x0),
                (copy_expression x1))) x0)
  | From.Parsetree.Pexp_letmodule (x0,x1,x2) ->
      To.Parsetree.Pexp_letmodule
        ((copy_loc (fun x  -> x) x0),
          (copy_module_expr x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_letexception (x0,x1) ->
      To.Parsetree.Pexp_letexception
        ((copy_extension_constructor x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_assert x0 ->
      To.Parsetree.Pexp_assert (copy_expression x0)
  | From.Parsetree.Pexp_lazy x0 ->
      To.Parsetree.Pexp_lazy (copy_expression x0)
  | From.Parsetree.Pexp_poly (x0,x1) ->
      To.Parsetree.Pexp_poly
        ((copy_expression x0),
          (copy_option copy_core_type x1))
  | From.Parsetree.Pexp_object x0 ->
      To.Parsetree.Pexp_object
        (copy_class_structure x0)
  | From.Parsetree.Pexp_newtype (x0,x1) ->
      To.Parsetree.Pexp_newtype
        (x0.From.Asttypes.txt, (copy_expression x1))
  | From.Parsetree.Pexp_pack x0 ->
      To.Parsetree.Pexp_pack (copy_module_expr x0)
  | From.Parsetree.Pexp_open (x0,x1,x2) ->
      To.Parsetree.Pexp_open
        ((copy_override_flag x0),
          (copy_loc copy_longident x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_extension x0 ->
      To.Parsetree.Pexp_extension (copy_extension x0)
  | From.Parsetree.Pexp_unreachable  -> To.Parsetree.Pexp_unreachable

and copy_direction_flag :
  From.Asttypes.direction_flag -> To.Asttypes.direction_flag =
  function
  | From.Asttypes.Upto  -> To.Asttypes.Upto
  | From.Asttypes.Downto  -> To.Asttypes.Downto

and copy_case :
  From.Parsetree.case -> To.Parsetree.case =
  fun
    { From.Parsetree.pc_lhs = pc_lhs;
      From.Parsetree.pc_guard = pc_guard;
      From.Parsetree.pc_rhs = pc_rhs }
     ->
    {
      To.Parsetree.pc_lhs = (copy_pattern pc_lhs);
      To.Parsetree.pc_guard =
        (copy_option copy_expression pc_guard);
      To.Parsetree.pc_rhs = (copy_expression pc_rhs)
    }

and copy_value_binding :
  From.Parsetree.value_binding -> To.Parsetree.value_binding =
  fun
    { From.Parsetree.pvb_pat = pvb_pat;
      From.Parsetree.pvb_expr = pvb_expr;
      From.Parsetree.pvb_attributes = pvb_attributes;
      From.Parsetree.pvb_loc = pvb_loc }
     ->
    {
      To.Parsetree.pvb_pat = (copy_pattern pvb_pat);
      To.Parsetree.pvb_expr =
        (copy_expression pvb_expr);
      To.Parsetree.pvb_attributes =
        (copy_attributes pvb_attributes);
      To.Parsetree.pvb_loc = (copy_location pvb_loc)
    }

and copy_pattern :
  From.Parsetree.pattern -> To.Parsetree.pattern =
  fun
    { From.Parsetree.ppat_desc = ppat_desc;
      From.Parsetree.ppat_loc = ppat_loc;
      From.Parsetree.ppat_attributes = ppat_attributes }
     ->
    {
      To.Parsetree.ppat_desc =
        (copy_pattern_desc ppat_desc);
      To.Parsetree.ppat_loc = (copy_location ppat_loc);
      To.Parsetree.ppat_attributes =
        (copy_attributes ppat_attributes)
    }

and copy_pattern_desc :
  From.Parsetree.pattern_desc -> To.Parsetree.pattern_desc =
  function
  | From.Parsetree.Ppat_any  -> To.Parsetree.Ppat_any
  | From.Parsetree.Ppat_var x0 ->
      To.Parsetree.Ppat_var (copy_loc (fun x  -> x) x0)
  | From.Parsetree.Ppat_alias (x0,x1) ->
      To.Parsetree.Ppat_alias
        ((copy_pattern x0),
          (copy_loc (fun x  -> x) x1))
  | From.Parsetree.Ppat_constant x0 ->
      To.Parsetree.Ppat_constant (copy_constant x0)
  | From.Parsetree.Ppat_interval (x0,x1) ->
      To.Parsetree.Ppat_interval
        ((copy_constant x0),
          (copy_constant x1))
  | From.Parsetree.Ppat_tuple x0 ->
      To.Parsetree.Ppat_tuple
        (List.map copy_pattern x0)
  | From.Parsetree.Ppat_construct (x0,x1) ->
      To.Parsetree.Ppat_construct
        ((copy_loc copy_longident x0),
          (copy_option copy_pattern x1))
  | From.Parsetree.Ppat_variant (x0,x1) ->
      To.Parsetree.Ppat_variant
        ((copy_label x0),
          (copy_option copy_pattern x1))
  | From.Parsetree.Ppat_record (x0,x1) ->
      To.Parsetree.Ppat_record
        ((List.map
            (fun x  ->
               let (x0,x1) = x  in
               ((copy_loc copy_longident x0),
                 (copy_pattern x1))) x0),
          (copy_closed_flag x1))
  | From.Parsetree.Ppat_array x0 ->
      To.Parsetree.Ppat_array
        (List.map copy_pattern x0)
  | From.Parsetree.Ppat_or (x0,x1) ->
      To.Parsetree.Ppat_or
        ((copy_pattern x0),
          (copy_pattern x1))
  | From.Parsetree.Ppat_constraint (x0,x1) ->
      To.Parsetree.Ppat_constraint
        ((copy_pattern x0),
          (copy_core_type x1))
  | From.Parsetree.Ppat_type x0 ->
      To.Parsetree.Ppat_type
        (copy_loc copy_longident x0)
  | From.Parsetree.Ppat_lazy x0 ->
      To.Parsetree.Ppat_lazy (copy_pattern x0)
  | From.Parsetree.Ppat_unpack x0 ->
      To.Parsetree.Ppat_unpack
        (copy_loc (fun x  -> x) x0)
  | From.Parsetree.Ppat_exception x0 ->
      To.Parsetree.Ppat_exception (copy_pattern x0)
  | From.Parsetree.Ppat_extension x0 ->
      To.Parsetree.Ppat_extension (copy_extension x0)
  | From.Parsetree.Ppat_open (x0,x1) ->
      To.Parsetree.Ppat_open
        ((copy_loc copy_longident x0),
          (copy_pattern x1))

and copy_core_type :
  From.Parsetree.core_type -> To.Parsetree.core_type =
  fun
    { From.Parsetree.ptyp_desc = ptyp_desc;
      From.Parsetree.ptyp_loc = ptyp_loc;
      From.Parsetree.ptyp_attributes = ptyp_attributes }
     ->
    {
      To.Parsetree.ptyp_desc =
        (copy_core_type_desc ptyp_desc);
      To.Parsetree.ptyp_loc = (copy_location ptyp_loc);
      To.Parsetree.ptyp_attributes =
        (copy_attributes ptyp_attributes)
    }

and copy_core_type_desc :
  From.Parsetree.core_type_desc -> To.Parsetree.core_type_desc =
  function
  | From.Parsetree.Ptyp_any  -> To.Parsetree.Ptyp_any
  | From.Parsetree.Ptyp_var x0 -> To.Parsetree.Ptyp_var x0
  | From.Parsetree.Ptyp_arrow (x0,x1,x2) ->
      To.Parsetree.Ptyp_arrow
        ((copy_arg_label x0),
          (copy_core_type x1),
          (copy_core_type x2))
  | From.Parsetree.Ptyp_tuple x0 ->
      To.Parsetree.Ptyp_tuple
        (List.map copy_core_type x0)
  | From.Parsetree.Ptyp_constr (x0,x1) ->
      To.Parsetree.Ptyp_constr
        ((copy_loc copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Ptyp_object (x0,x1) ->
      To.Parsetree.Ptyp_object
        ((List.map
            (fun x  ->
               let (x0,x1,x2) = x  in
               (x0.From.Asttypes.txt, (copy_attributes x1),
                 (copy_core_type x2))) x0),
          (copy_closed_flag x1))
  | From.Parsetree.Ptyp_class (x0,x1) ->
      To.Parsetree.Ptyp_class
        ((copy_loc copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Ptyp_alias (x0,x1) ->
      To.Parsetree.Ptyp_alias
        ((copy_core_type x0), x1)
  | From.Parsetree.Ptyp_variant (x0,x1,x2) ->
      To.Parsetree.Ptyp_variant
        ((List.map copy_row_field x0),
          (copy_closed_flag x1),
          (copy_option (fun x  -> List.map copy_label x) x2))
  | From.Parsetree.Ptyp_poly (x0,x1) ->
      To.Parsetree.Ptyp_poly
        ((List.map (fun x  -> x.From.Asttypes.txt) x0), (copy_core_type x1))
  | From.Parsetree.Ptyp_package x0 ->
      To.Parsetree.Ptyp_package (copy_package_type x0)
  | From.Parsetree.Ptyp_extension x0 ->
      To.Parsetree.Ptyp_extension (copy_extension x0)

and copy_package_type :
  From.Parsetree.package_type -> To.Parsetree.package_type =
  fun x  ->
    let (x0,x1) = x  in
    ((copy_loc copy_longident x0),
      (List.map
         (fun x  ->
            let (x0,x1) = x  in
            ((copy_loc copy_longident x0),
              (copy_core_type x1))) x1))

and copy_row_field :
  From.Parsetree.row_field -> To.Parsetree.row_field =
  function
  | From.Parsetree.Rtag (x0,x1,x2,x3) ->
      To.Parsetree.Rtag
        ((copy_label x0),
          (copy_attributes x1), (copy_bool x2),
          (List.map copy_core_type x3))
  | From.Parsetree.Rinherit x0 ->
      To.Parsetree.Rinherit (copy_core_type x0)

and copy_attributes :
  From.Parsetree.attributes -> To.Parsetree.attributes =
  fun x  -> List.map copy_attribute x

and copy_attribute :
  From.Parsetree.attribute -> To.Parsetree.attribute =
  fun x  ->
    let (x0,x1) = x  in
    ((copy_loc (fun x  -> x) x0),
      (copy_payload x1))

and copy_payload :
  From.Parsetree.payload -> To.Parsetree.payload =
  function
  | From.Parsetree.PStr x0 ->
      To.Parsetree.PStr (copy_structure x0)
  | From.Parsetree.PSig x0 ->
      To.Parsetree.PSig (copy_signature x0)
  | From.Parsetree.PTyp x0 ->
      To.Parsetree.PTyp (copy_core_type x0)
  | From.Parsetree.PPat (x0,x1) ->
      To.Parsetree.PPat
        ((copy_pattern x0),
          (copy_option copy_expression x1))

and copy_structure :
  From.Parsetree.structure -> To.Parsetree.structure =
  fun x  -> List.map copy_structure_item x

and copy_structure_item :
  From.Parsetree.structure_item -> To.Parsetree.structure_item =
  fun
    { From.Parsetree.pstr_desc = pstr_desc;
      From.Parsetree.pstr_loc = pstr_loc }
     ->
    {
      To.Parsetree.pstr_desc =
        (copy_structure_item_desc pstr_desc);
      To.Parsetree.pstr_loc = (copy_location pstr_loc)
    }

and copy_structure_item_desc :
  From.Parsetree.structure_item_desc ->
    To.Parsetree.structure_item_desc
  =
  function
  | From.Parsetree.Pstr_eval (x0,x1) ->
      To.Parsetree.Pstr_eval
        ((copy_expression x0),
          (copy_attributes x1))
  | From.Parsetree.Pstr_value (x0,x1) ->
      To.Parsetree.Pstr_value
        ((copy_rec_flag x0),
          (List.map copy_value_binding x1))
  | From.Parsetree.Pstr_primitive x0 ->
      To.Parsetree.Pstr_primitive
        (copy_value_description x0)
  | From.Parsetree.Pstr_type (x0,x1) ->
      To.Parsetree.Pstr_type
        ((copy_rec_flag x0),
          (List.map copy_type_declaration x1))
  | From.Parsetree.Pstr_typext x0 ->
      To.Parsetree.Pstr_typext
        (copy_type_extension x0)
  | From.Parsetree.Pstr_exception x0 ->
      To.Parsetree.Pstr_exception
        (copy_extension_constructor x0)
  | From.Parsetree.Pstr_module x0 ->
      To.Parsetree.Pstr_module
        (copy_module_binding x0)
  | From.Parsetree.Pstr_recmodule x0 ->
      To.Parsetree.Pstr_recmodule
        (List.map copy_module_binding x0)
  | From.Parsetree.Pstr_modtype x0 ->
      To.Parsetree.Pstr_modtype
        (copy_module_type_declaration x0)
  | From.Parsetree.Pstr_open x0 ->
      To.Parsetree.Pstr_open
        (copy_open_description x0)
  | From.Parsetree.Pstr_class x0 ->
      To.Parsetree.Pstr_class
        (List.map copy_class_declaration x0)
  | From.Parsetree.Pstr_class_type x0 ->
      To.Parsetree.Pstr_class_type
        (List.map copy_class_type_declaration x0)
  | From.Parsetree.Pstr_include x0 ->
      To.Parsetree.Pstr_include
        (copy_include_declaration x0)
  | From.Parsetree.Pstr_attribute x0 ->
      To.Parsetree.Pstr_attribute (copy_attribute x0)
  | From.Parsetree.Pstr_extension (x0,x1) ->
      To.Parsetree.Pstr_extension
        ((copy_extension x0),
          (copy_attributes x1))

and copy_include_declaration :
  From.Parsetree.include_declaration ->
    To.Parsetree.include_declaration
  =
  fun x  ->
    copy_include_infos copy_module_expr x

and copy_class_declaration :
  From.Parsetree.class_declaration -> To.Parsetree.class_declaration
  =
  fun x  ->
    copy_class_infos copy_class_expr x

and copy_class_expr :
  From.Parsetree.class_expr -> To.Parsetree.class_expr =
  fun
    { From.Parsetree.pcl_desc = pcl_desc;
      From.Parsetree.pcl_loc = pcl_loc;
      From.Parsetree.pcl_attributes = pcl_attributes }
     ->
    {
      To.Parsetree.pcl_desc =
        (copy_class_expr_desc pcl_desc);
      To.Parsetree.pcl_loc = (copy_location pcl_loc);
      To.Parsetree.pcl_attributes =
        (copy_attributes pcl_attributes)
    }

and copy_class_expr_desc :
  From.Parsetree.class_expr_desc -> To.Parsetree.class_expr_desc =
  function
  | From.Parsetree.Pcl_constr (x0,x1) ->
      To.Parsetree.Pcl_constr
        ((copy_loc copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Pcl_structure x0 ->
      To.Parsetree.Pcl_structure
        (copy_class_structure x0)
  | From.Parsetree.Pcl_fun (x0,x1,x2,x3) ->
      To.Parsetree.Pcl_fun
        ((copy_arg_label x0),
          (copy_option copy_expression x1),
          (copy_pattern x2),
          (copy_class_expr x3))
  | From.Parsetree.Pcl_apply (x0,x1) ->
      To.Parsetree.Pcl_apply
        ((copy_class_expr x0),
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                ((copy_arg_label x0),
                  (copy_expression x1))) x1))
  | From.Parsetree.Pcl_let (x0,x1,x2) ->
      To.Parsetree.Pcl_let
        ((copy_rec_flag x0),
          (List.map copy_value_binding x1),
          (copy_class_expr x2))
  | From.Parsetree.Pcl_constraint (x0,x1) ->
      To.Parsetree.Pcl_constraint
        ((copy_class_expr x0),
          (copy_class_type x1))
  | From.Parsetree.Pcl_extension x0 ->
      To.Parsetree.Pcl_extension (copy_extension x0)

and copy_class_structure :
  From.Parsetree.class_structure -> To.Parsetree.class_structure =
  fun
    { From.Parsetree.pcstr_self = pcstr_self;
      From.Parsetree.pcstr_fields = pcstr_fields }
     ->
    {
      To.Parsetree.pcstr_self =
        (copy_pattern pcstr_self);
      To.Parsetree.pcstr_fields =
        (List.map copy_class_field pcstr_fields)
    }

and copy_class_field :
  From.Parsetree.class_field -> To.Parsetree.class_field =
  fun
    { From.Parsetree.pcf_desc = pcf_desc;
      From.Parsetree.pcf_loc = pcf_loc;
      From.Parsetree.pcf_attributes = pcf_attributes }
     ->
    {
      To.Parsetree.pcf_desc =
        (copy_class_field_desc pcf_desc);
      To.Parsetree.pcf_loc = (copy_location pcf_loc);
      To.Parsetree.pcf_attributes =
        (copy_attributes pcf_attributes)
    }

and copy_class_field_desc :
  From.Parsetree.class_field_desc -> To.Parsetree.class_field_desc =
  function
  | From.Parsetree.Pcf_inherit (x0,x1,x2) ->
      To.Parsetree.Pcf_inherit
        ((copy_override_flag x0),
          (copy_class_expr x1),
          (copy_option (fun x  -> x.From.Asttypes.txt) x2))
  | From.Parsetree.Pcf_val x0 ->
      To.Parsetree.Pcf_val
        (let (x0,x1,x2) = x0  in
         ((copy_loc (fun x  -> x) x0),
           (copy_mutable_flag x1),
           (copy_class_field_kind x2)))
  | From.Parsetree.Pcf_method x0 ->
      To.Parsetree.Pcf_method
        (let (x0,x1,x2) = x0  in
         ((copy_loc (fun x  -> x) x0),
           (copy_private_flag x1),
           (copy_class_field_kind x2)))
  | From.Parsetree.Pcf_constraint x0 ->
      To.Parsetree.Pcf_constraint
        (let (x0,x1) = x0  in
         ((copy_core_type x0),
           (copy_core_type x1)))
  | From.Parsetree.Pcf_initializer x0 ->
      To.Parsetree.Pcf_initializer
        (copy_expression x0)
  | From.Parsetree.Pcf_attribute x0 ->
      To.Parsetree.Pcf_attribute (copy_attribute x0)
  | From.Parsetree.Pcf_extension x0 ->
      To.Parsetree.Pcf_extension (copy_extension x0)

and copy_class_field_kind :
  From.Parsetree.class_field_kind -> To.Parsetree.class_field_kind =
  function
  | From.Parsetree.Cfk_virtual x0 ->
      To.Parsetree.Cfk_virtual (copy_core_type x0)
  | From.Parsetree.Cfk_concrete (x0,x1) ->
      To.Parsetree.Cfk_concrete
        ((copy_override_flag x0),
          (copy_expression x1))

and copy_module_binding :
  From.Parsetree.module_binding -> To.Parsetree.module_binding =
  fun
    { From.Parsetree.pmb_name = pmb_name;
      From.Parsetree.pmb_expr = pmb_expr;
      From.Parsetree.pmb_attributes = pmb_attributes;
      From.Parsetree.pmb_loc = pmb_loc }
     ->
    {
      To.Parsetree.pmb_name =
        (copy_loc (fun x  -> x) pmb_name);
      To.Parsetree.pmb_expr =
        (copy_module_expr pmb_expr);
      To.Parsetree.pmb_attributes =
        (copy_attributes pmb_attributes);
      To.Parsetree.pmb_loc = (copy_location pmb_loc)
    }

and copy_module_expr :
  From.Parsetree.module_expr -> To.Parsetree.module_expr =
  fun
    { From.Parsetree.pmod_desc = pmod_desc;
      From.Parsetree.pmod_loc = pmod_loc;
      From.Parsetree.pmod_attributes = pmod_attributes }
     ->
    {
      To.Parsetree.pmod_desc =
        (copy_module_expr_desc pmod_desc);
      To.Parsetree.pmod_loc = (copy_location pmod_loc);
      To.Parsetree.pmod_attributes =
        (copy_attributes pmod_attributes)
    }

and copy_module_expr_desc :
  From.Parsetree.module_expr_desc -> To.Parsetree.module_expr_desc =
  function
  | From.Parsetree.Pmod_ident x0 ->
      To.Parsetree.Pmod_ident
        (copy_loc copy_longident x0)
  | From.Parsetree.Pmod_structure x0 ->
      To.Parsetree.Pmod_structure (copy_structure x0)
  | From.Parsetree.Pmod_functor (x0,x1,x2) ->
      To.Parsetree.Pmod_functor
        ((copy_loc (fun x  -> x) x0),
          (copy_option copy_module_type x1),
          (copy_module_expr x2))
  | From.Parsetree.Pmod_apply (x0,x1) ->
      To.Parsetree.Pmod_apply
        ((copy_module_expr x0),
          (copy_module_expr x1))
  | From.Parsetree.Pmod_constraint (x0,x1) ->
      To.Parsetree.Pmod_constraint
        ((copy_module_expr x0),
          (copy_module_type x1))
  | From.Parsetree.Pmod_unpack x0 ->
      To.Parsetree.Pmod_unpack (copy_expression x0)
  | From.Parsetree.Pmod_extension x0 ->
      To.Parsetree.Pmod_extension (copy_extension x0)

and copy_module_type :
  From.Parsetree.module_type -> To.Parsetree.module_type =
  fun
    { From.Parsetree.pmty_desc = pmty_desc;
      From.Parsetree.pmty_loc = pmty_loc;
      From.Parsetree.pmty_attributes = pmty_attributes }
     ->
    {
      To.Parsetree.pmty_desc =
        (copy_module_type_desc pmty_desc);
      To.Parsetree.pmty_loc = (copy_location pmty_loc);
      To.Parsetree.pmty_attributes =
        (copy_attributes pmty_attributes)
    }

and copy_module_type_desc :
  From.Parsetree.module_type_desc -> To.Parsetree.module_type_desc =
  function
  | From.Parsetree.Pmty_ident x0 ->
      To.Parsetree.Pmty_ident
        (copy_loc copy_longident x0)
  | From.Parsetree.Pmty_signature x0 ->
      To.Parsetree.Pmty_signature (copy_signature x0)
  | From.Parsetree.Pmty_functor (x0,x1,x2) ->
      To.Parsetree.Pmty_functor
        ((copy_loc (fun x  -> x) x0),
          (copy_option copy_module_type x1),
          (copy_module_type x2))
  | From.Parsetree.Pmty_with (x0,x1) ->
      To.Parsetree.Pmty_with
        ((copy_module_type x0),
          (List.map copy_with_constraint x1))
  | From.Parsetree.Pmty_typeof x0 ->
      To.Parsetree.Pmty_typeof (copy_module_expr x0)
  | From.Parsetree.Pmty_extension x0 ->
      To.Parsetree.Pmty_extension (copy_extension x0)
  | From.Parsetree.Pmty_alias x0 ->
      To.Parsetree.Pmty_alias
        (copy_loc copy_longident x0)

and copy_with_constraint :
  From.Parsetree.with_constraint -> To.Parsetree.with_constraint =
  function
  | From.Parsetree.Pwith_type (x0,x1) ->
      To.Parsetree.Pwith_type
        ((copy_loc copy_longident x0),
          (copy_type_declaration x1))
  | From.Parsetree.Pwith_module (x0,x1) ->
      To.Parsetree.Pwith_module
        ((copy_loc copy_longident x0),
          (copy_loc copy_longident x1))
  | From.Parsetree.Pwith_typesubst x0 ->
      To.Parsetree.Pwith_typesubst
        (copy_type_declaration x0)
  | From.Parsetree.Pwith_modsubst (x0,x1) ->
      To.Parsetree.Pwith_modsubst
        ((copy_loc (fun x  -> x) x0),
          (copy_loc copy_longident x1))

and copy_signature :
  From.Parsetree.signature -> To.Parsetree.signature =
  fun x  -> List.map copy_signature_item x

and copy_signature_item :
  From.Parsetree.signature_item -> To.Parsetree.signature_item =
  fun
    { From.Parsetree.psig_desc = psig_desc;
      From.Parsetree.psig_loc = psig_loc }
     ->
    {
      To.Parsetree.psig_desc =
        (copy_signature_item_desc psig_desc);
      To.Parsetree.psig_loc = (copy_location psig_loc)
    }

and copy_signature_item_desc :
  From.Parsetree.signature_item_desc ->
    To.Parsetree.signature_item_desc
  =
  function
  | From.Parsetree.Psig_value x0 ->
      To.Parsetree.Psig_value
        (copy_value_description x0)
  | From.Parsetree.Psig_type (x0,x1) ->
      To.Parsetree.Psig_type
        ((copy_rec_flag x0),
          (List.map copy_type_declaration x1))
  | From.Parsetree.Psig_typext x0 ->
      To.Parsetree.Psig_typext
        (copy_type_extension x0)
  | From.Parsetree.Psig_exception x0 ->
      To.Parsetree.Psig_exception
        (copy_extension_constructor x0)
  | From.Parsetree.Psig_module x0 ->
      To.Parsetree.Psig_module
        (copy_module_declaration x0)
  | From.Parsetree.Psig_recmodule x0 ->
      To.Parsetree.Psig_recmodule
        (List.map copy_module_declaration x0)
  | From.Parsetree.Psig_modtype x0 ->
      To.Parsetree.Psig_modtype
        (copy_module_type_declaration x0)
  | From.Parsetree.Psig_open x0 ->
      To.Parsetree.Psig_open
        (copy_open_description x0)
  | From.Parsetree.Psig_include x0 ->
      To.Parsetree.Psig_include
        (copy_include_description x0)
  | From.Parsetree.Psig_class x0 ->
      To.Parsetree.Psig_class
        (List.map copy_class_description x0)
  | From.Parsetree.Psig_class_type x0 ->
      To.Parsetree.Psig_class_type
        (List.map copy_class_type_declaration x0)
  | From.Parsetree.Psig_attribute x0 ->
      To.Parsetree.Psig_attribute (copy_attribute x0)
  | From.Parsetree.Psig_extension (x0,x1) ->
      To.Parsetree.Psig_extension
        ((copy_extension x0),
          (copy_attributes x1))

and copy_class_type_declaration :
  From.Parsetree.class_type_declaration ->
    To.Parsetree.class_type_declaration
  =
  fun x  ->
    copy_class_infos copy_class_type x

and copy_class_description :
  From.Parsetree.class_description -> To.Parsetree.class_description
  =
  fun x  ->
    copy_class_infos copy_class_type x

and copy_class_type :
  From.Parsetree.class_type -> To.Parsetree.class_type =
  fun
    { From.Parsetree.pcty_desc = pcty_desc;
      From.Parsetree.pcty_loc = pcty_loc;
      From.Parsetree.pcty_attributes = pcty_attributes }
     ->
    {
      To.Parsetree.pcty_desc =
        (copy_class_type_desc pcty_desc);
      To.Parsetree.pcty_loc = (copy_location pcty_loc);
      To.Parsetree.pcty_attributes =
        (copy_attributes pcty_attributes)
    }

and copy_class_type_desc :
  From.Parsetree.class_type_desc -> To.Parsetree.class_type_desc =
  function
  | From.Parsetree.Pcty_constr (x0,x1) ->
      To.Parsetree.Pcty_constr
        ((copy_loc copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Pcty_signature x0 ->
      To.Parsetree.Pcty_signature
        (copy_class_signature x0)
  | From.Parsetree.Pcty_arrow (x0,x1,x2) ->
      To.Parsetree.Pcty_arrow
        ((copy_arg_label x0),
          (copy_core_type x1),
          (copy_class_type x2))
  | From.Parsetree.Pcty_extension x0 ->
      To.Parsetree.Pcty_extension (copy_extension x0)

and copy_class_signature :
  From.Parsetree.class_signature -> To.Parsetree.class_signature =
  fun
    { From.Parsetree.pcsig_self = pcsig_self;
      From.Parsetree.pcsig_fields = pcsig_fields }
     ->
    {
      To.Parsetree.pcsig_self =
        (copy_core_type pcsig_self);
      To.Parsetree.pcsig_fields =
        (List.map copy_class_type_field pcsig_fields)
    }

and copy_class_type_field :
  From.Parsetree.class_type_field -> To.Parsetree.class_type_field =
  fun
    { From.Parsetree.pctf_desc = pctf_desc;
      From.Parsetree.pctf_loc = pctf_loc;
      From.Parsetree.pctf_attributes = pctf_attributes }
     ->
    {
      To.Parsetree.pctf_desc =
        (copy_class_type_field_desc pctf_desc);
      To.Parsetree.pctf_loc = (copy_location pctf_loc);
      To.Parsetree.pctf_attributes =
        (copy_attributes pctf_attributes)
    }

and copy_class_type_field_desc :
  From.Parsetree.class_type_field_desc ->
    To.Parsetree.class_type_field_desc
  =
  function
  | From.Parsetree.Pctf_inherit x0 ->
      To.Parsetree.Pctf_inherit (copy_class_type x0)
  | From.Parsetree.Pctf_val x0 ->
      To.Parsetree.Pctf_val
        (let (x0,x1,x2,x3) = x0  in
         (x0.From.Asttypes.txt, (copy_mutable_flag x1),
           (copy_virtual_flag x2),
           (copy_core_type x3)))
  | From.Parsetree.Pctf_method x0 ->
      To.Parsetree.Pctf_method
        (let (x0,x1,x2,x3) = x0  in
         (x0.From.Asttypes.txt, (copy_private_flag x1),
           (copy_virtual_flag x2),
           (copy_core_type x3)))
  | From.Parsetree.Pctf_constraint x0 ->
      To.Parsetree.Pctf_constraint
        (let (x0,x1) = x0  in
         ((copy_core_type x0),
           (copy_core_type x1)))
  | From.Parsetree.Pctf_attribute x0 ->
      To.Parsetree.Pctf_attribute (copy_attribute x0)
  | From.Parsetree.Pctf_extension x0 ->
      To.Parsetree.Pctf_extension (copy_extension x0)

and copy_extension :
  From.Parsetree.extension -> To.Parsetree.extension =
  fun x  ->
    let (x0,x1) = x  in
    ((copy_loc (fun x  -> x) x0),
      (copy_payload x1))

and copy_class_infos :
  'f0 'g0 .
    ('f0 -> 'g0) ->
      'f0 From.Parsetree.class_infos -> 'g0 To.Parsetree.class_infos
  =
  fun f0  ->
    fun
      { From.Parsetree.pci_virt = pci_virt;
        From.Parsetree.pci_params = pci_params;
        From.Parsetree.pci_name = pci_name;
        From.Parsetree.pci_expr = pci_expr;
        From.Parsetree.pci_loc = pci_loc;
        From.Parsetree.pci_attributes = pci_attributes }
       ->
      {
        To.Parsetree.pci_virt =
          (copy_virtual_flag pci_virt);
        To.Parsetree.pci_params =
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                ((copy_core_type x0),
                  (copy_variance x1))) pci_params);
        To.Parsetree.pci_name =
          (copy_loc (fun x  -> x) pci_name);
        To.Parsetree.pci_expr = (f0 pci_expr);
        To.Parsetree.pci_loc = (copy_location pci_loc);
        To.Parsetree.pci_attributes =
          (copy_attributes pci_attributes)
      }

and copy_virtual_flag :
  From.Asttypes.virtual_flag -> To.Asttypes.virtual_flag =
  function
  | From.Asttypes.Virtual  -> To.Asttypes.Virtual
  | From.Asttypes.Concrete  -> To.Asttypes.Concrete

and copy_include_description :
  From.Parsetree.include_description ->
    To.Parsetree.include_description
  =
  fun x  ->
    copy_include_infos copy_module_type x

and copy_include_infos :
  'f0 'g0 .
    ('f0 -> 'g0) ->
      'f0 From.Parsetree.include_infos ->
        'g0 To.Parsetree.include_infos
  =
  fun f0  ->
    fun
      { From.Parsetree.pincl_mod = pincl_mod;
        From.Parsetree.pincl_loc = pincl_loc;
        From.Parsetree.pincl_attributes = pincl_attributes }
       ->
      {
        To.Parsetree.pincl_mod = (f0 pincl_mod);
        To.Parsetree.pincl_loc = (copy_location pincl_loc);
        To.Parsetree.pincl_attributes =
          (copy_attributes pincl_attributes)
      }

and copy_open_description :
  From.Parsetree.open_description -> To.Parsetree.open_description =
  fun
    { From.Parsetree.popen_lid = popen_lid;
      From.Parsetree.popen_override = popen_override;
      From.Parsetree.popen_loc = popen_loc;
      From.Parsetree.popen_attributes = popen_attributes }
     ->
    {
      To.Parsetree.popen_lid =
        (copy_loc copy_longident popen_lid);
      To.Parsetree.popen_override =
        (copy_override_flag popen_override);
      To.Parsetree.popen_loc = (copy_location popen_loc);
      To.Parsetree.popen_attributes =
        (copy_attributes popen_attributes)
    }

and copy_override_flag :
  From.Asttypes.override_flag -> To.Asttypes.override_flag =
  function
  | From.Asttypes.Override  -> To.Asttypes.Override
  | From.Asttypes.Fresh  -> To.Asttypes.Fresh

and copy_module_type_declaration :
  From.Parsetree.module_type_declaration ->
    To.Parsetree.module_type_declaration
  =
  fun
    { From.Parsetree.pmtd_name = pmtd_name;
      From.Parsetree.pmtd_type = pmtd_type;
      From.Parsetree.pmtd_attributes = pmtd_attributes;
      From.Parsetree.pmtd_loc = pmtd_loc }
     ->
    {
      To.Parsetree.pmtd_name =
        (copy_loc (fun x  -> x) pmtd_name);
      To.Parsetree.pmtd_type =
        (copy_option copy_module_type pmtd_type);
      To.Parsetree.pmtd_attributes =
        (copy_attributes pmtd_attributes);
      To.Parsetree.pmtd_loc = (copy_location pmtd_loc)
    }

and copy_module_declaration :
  From.Parsetree.module_declaration ->
    To.Parsetree.module_declaration
  =
  fun
    { From.Parsetree.pmd_name = pmd_name;
      From.Parsetree.pmd_type = pmd_type;
      From.Parsetree.pmd_attributes = pmd_attributes;
      From.Parsetree.pmd_loc = pmd_loc }
     ->
    {
      To.Parsetree.pmd_name =
        (copy_loc (fun x  -> x) pmd_name);
      To.Parsetree.pmd_type =
        (copy_module_type pmd_type);
      To.Parsetree.pmd_attributes =
        (copy_attributes pmd_attributes);
      To.Parsetree.pmd_loc = (copy_location pmd_loc)
    }

and copy_type_extension :
  From.Parsetree.type_extension -> To.Parsetree.type_extension =
  fun
    { From.Parsetree.ptyext_path = ptyext_path;
      From.Parsetree.ptyext_params = ptyext_params;
      From.Parsetree.ptyext_constructors = ptyext_constructors;
      From.Parsetree.ptyext_private = ptyext_private;
      From.Parsetree.ptyext_attributes = ptyext_attributes }
     ->
    {
      To.Parsetree.ptyext_path =
        (copy_loc copy_longident ptyext_path);
      To.Parsetree.ptyext_params =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_core_type x0),
                (copy_variance x1))) ptyext_params);
      To.Parsetree.ptyext_constructors =
        (List.map copy_extension_constructor
           ptyext_constructors);
      To.Parsetree.ptyext_private =
        (copy_private_flag ptyext_private);
      To.Parsetree.ptyext_attributes =
        (copy_attributes ptyext_attributes)
    }

and copy_extension_constructor :
  From.Parsetree.extension_constructor ->
    To.Parsetree.extension_constructor
  =
  fun
    { From.Parsetree.pext_name = pext_name;
      From.Parsetree.pext_kind = pext_kind;
      From.Parsetree.pext_loc = pext_loc;
      From.Parsetree.pext_attributes = pext_attributes }
     ->
    {
      To.Parsetree.pext_name =
        (copy_loc (fun x  -> x) pext_name);
      To.Parsetree.pext_kind =
        (copy_extension_constructor_kind pext_kind);
      To.Parsetree.pext_loc = (copy_location pext_loc);
      To.Parsetree.pext_attributes =
        (copy_attributes pext_attributes)
    }

and copy_extension_constructor_kind :
  From.Parsetree.extension_constructor_kind ->
    To.Parsetree.extension_constructor_kind
  =
  function
  | From.Parsetree.Pext_decl (x0,x1) ->
      To.Parsetree.Pext_decl
        ((copy_constructor_arguments x0),
          (copy_option copy_core_type x1))
  | From.Parsetree.Pext_rebind x0 ->
      To.Parsetree.Pext_rebind
        (copy_loc copy_longident x0)

and copy_type_declaration :
  From.Parsetree.type_declaration -> To.Parsetree.type_declaration =
  fun
    { From.Parsetree.ptype_name = ptype_name;
      From.Parsetree.ptype_params = ptype_params;
      From.Parsetree.ptype_cstrs = ptype_cstrs;
      From.Parsetree.ptype_kind = ptype_kind;
      From.Parsetree.ptype_private = ptype_private;
      From.Parsetree.ptype_manifest = ptype_manifest;
      From.Parsetree.ptype_attributes = ptype_attributes;
      From.Parsetree.ptype_loc = ptype_loc }
     ->
    {
      To.Parsetree.ptype_name =
        (copy_loc (fun x  -> x) ptype_name);
      To.Parsetree.ptype_params =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_core_type x0),
                (copy_variance x1))) ptype_params);
      To.Parsetree.ptype_cstrs =
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              ((copy_core_type x0),
                (copy_core_type x1),
                (copy_location x2))) ptype_cstrs);
      To.Parsetree.ptype_kind =
        (copy_type_kind ptype_kind);
      To.Parsetree.ptype_private =
        (copy_private_flag ptype_private);
      To.Parsetree.ptype_manifest =
        (copy_option copy_core_type ptype_manifest);
      To.Parsetree.ptype_attributes =
        (copy_attributes ptype_attributes);
      To.Parsetree.ptype_loc = (copy_location ptype_loc)
    }

and copy_private_flag :
  From.Asttypes.private_flag -> To.Asttypes.private_flag =
  function
  | From.Asttypes.Private  -> To.Asttypes.Private
  | From.Asttypes.Public  -> To.Asttypes.Public

and copy_type_kind :
  From.Parsetree.type_kind -> To.Parsetree.type_kind =
  function
  | From.Parsetree.Ptype_abstract  -> To.Parsetree.Ptype_abstract
  | From.Parsetree.Ptype_variant x0 ->
      To.Parsetree.Ptype_variant
        (List.map copy_constructor_declaration x0)
  | From.Parsetree.Ptype_record x0 ->
      To.Parsetree.Ptype_record
        (List.map copy_label_declaration x0)
  | From.Parsetree.Ptype_open  -> To.Parsetree.Ptype_open

and copy_constructor_declaration :
  From.Parsetree.constructor_declaration ->
    To.Parsetree.constructor_declaration
  =
  fun
    { From.Parsetree.pcd_name = pcd_name;
      From.Parsetree.pcd_args = pcd_args;
      From.Parsetree.pcd_res = pcd_res;
      From.Parsetree.pcd_loc = pcd_loc;
      From.Parsetree.pcd_attributes = pcd_attributes }
     ->
    {
      To.Parsetree.pcd_name =
        (copy_loc (fun x  -> x) pcd_name);
      To.Parsetree.pcd_args =
        (copy_constructor_arguments pcd_args);
      To.Parsetree.pcd_res =
        (copy_option copy_core_type pcd_res);
      To.Parsetree.pcd_loc = (copy_location pcd_loc);
      To.Parsetree.pcd_attributes =
        (copy_attributes pcd_attributes)
    }

and copy_constructor_arguments :
  From.Parsetree.constructor_arguments ->
    To.Parsetree.constructor_arguments
  =
  function
  | From.Parsetree.Pcstr_tuple x0 ->
      To.Parsetree.Pcstr_tuple
        (List.map copy_core_type x0)
  | From.Parsetree.Pcstr_record x0 ->
      To.Parsetree.Pcstr_record
        (List.map copy_label_declaration x0)

and copy_label_declaration :
  From.Parsetree.label_declaration -> To.Parsetree.label_declaration
  =
  fun
    { From.Parsetree.pld_name = pld_name;
      From.Parsetree.pld_mutable = pld_mutable;
      From.Parsetree.pld_type = pld_type;
      From.Parsetree.pld_loc = pld_loc;
      From.Parsetree.pld_attributes = pld_attributes }
     ->
    {
      To.Parsetree.pld_name =
        (copy_loc (fun x  -> x) pld_name);
      To.Parsetree.pld_mutable =
        (copy_mutable_flag pld_mutable);
      To.Parsetree.pld_type =
        (copy_core_type pld_type);
      To.Parsetree.pld_loc = (copy_location pld_loc);
      To.Parsetree.pld_attributes =
        (copy_attributes pld_attributes)
    }

and copy_mutable_flag :
  From.Asttypes.mutable_flag -> To.Asttypes.mutable_flag =
  function
  | From.Asttypes.Immutable  -> To.Asttypes.Immutable
  | From.Asttypes.Mutable  -> To.Asttypes.Mutable

and copy_variance :
  From.Asttypes.variance -> To.Asttypes.variance =
  function
  | From.Asttypes.Covariant  -> To.Asttypes.Covariant
  | From.Asttypes.Contravariant  -> To.Asttypes.Contravariant
  | From.Asttypes.Invariant  -> To.Asttypes.Invariant

and copy_value_description :
  From.Parsetree.value_description -> To.Parsetree.value_description
  =
  fun
    { From.Parsetree.pval_name = pval_name;
      From.Parsetree.pval_type = pval_type;
      From.Parsetree.pval_prim = pval_prim;
      From.Parsetree.pval_attributes = pval_attributes;
      From.Parsetree.pval_loc = pval_loc }
     ->
    {
      To.Parsetree.pval_name =
        (copy_loc (fun x  -> x) pval_name);
      To.Parsetree.pval_type =
        (copy_core_type pval_type);
      To.Parsetree.pval_prim = (List.map (fun x  -> x) pval_prim);
      To.Parsetree.pval_attributes =
        (copy_attributes pval_attributes);
      To.Parsetree.pval_loc = (copy_location pval_loc)
    }

and copy_arg_label :
  From.Asttypes.arg_label -> To.Asttypes.arg_label =
  function
  | From.Asttypes.Nolabel  -> To.Asttypes.Nolabel
  | From.Asttypes.Labelled x0 -> To.Asttypes.Labelled x0
  | From.Asttypes.Optional x0 -> To.Asttypes.Optional x0

and copy_closed_flag :
  From.Asttypes.closed_flag -> To.Asttypes.closed_flag =
  function
  | From.Asttypes.Closed  -> To.Asttypes.Closed
  | From.Asttypes.Open  -> To.Asttypes.Open

and copy_label :
  From.Asttypes.label -> To.Asttypes.label = fun x  -> x

and copy_rec_flag :
  From.Asttypes.rec_flag -> To.Asttypes.rec_flag =
  function
  | From.Asttypes.Nonrecursive  -> To.Asttypes.Nonrecursive
  | From.Asttypes.Recursive  -> To.Asttypes.Recursive

and copy_constant :
  From.Parsetree.constant -> To.Parsetree.constant =
  function
  | From.Parsetree.Pconst_integer (x0,x1) ->
      To.Parsetree.Pconst_integer (x0, (copy_option (fun x  -> x) x1))
  | From.Parsetree.Pconst_char x0 -> To.Parsetree.Pconst_char x0
  | From.Parsetree.Pconst_string (x0,x1) ->
      To.Parsetree.Pconst_string (x0, (copy_option (fun x  -> x) x1))
  | From.Parsetree.Pconst_float (x0,x1) ->
      To.Parsetree.Pconst_float (x0, (copy_option (fun x  -> x) x1))

and copy_option : 'f0 'g0 . ('f0 -> 'g0) -> 'f0 option -> 'g0 option =
  fun f0  -> function | None  -> None | Some x0 -> Some (f0 x0)

and copy_longident : From.Longident.t -> To.Longident.t =
  function
  | From.Longident.Lident x0 -> To.Longident.Lident x0
  | From.Longident.Ldot (x0,x1) ->
      To.Longident.Ldot ((copy_longident x0), x1)
  | From.Longident.Lapply (x0,x1) ->
      To.Longident.Lapply
        ((copy_longident x0), (copy_longident x1))

and copy_loc :
  'f0 'g0 .
    ('f0 -> 'g0) -> 'f0 From.Asttypes.loc -> 'g0 To.Asttypes.loc
  =
  fun f0  ->
    fun { From.Asttypes.txt = txt; From.Asttypes.loc = loc }  ->
      {
        To.Asttypes.txt = (f0 txt);
        To.Asttypes.loc = (copy_location loc)
      }

and copy_location : From.Location.t -> To.Location.t =
  fun
    { From.Location.loc_start = loc_start;
      From.Location.loc_end = loc_end;
      From.Location.loc_ghost = loc_ghost }
     ->
    {
      To.Location.loc_start = (copy_Lexing_position loc_start);
      To.Location.loc_end = (copy_Lexing_position loc_end);
      To.Location.loc_ghost = (copy_bool loc_ghost)
    }

and copy_bool : bool -> bool = function | false  -> false | true  -> true

and copy_Lexing_position : Lexing.position -> Lexing.position =
  fun
    { Lexing.pos_fname = pos_fname; Lexing.pos_lnum = pos_lnum;
      Lexing.pos_bol = pos_bol; Lexing.pos_cnum = pos_cnum }
     ->
    {
      Lexing.pos_fname = pos_fname;
      Lexing.pos_lnum = pos_lnum;
      Lexing.pos_bol = pos_bol;
      Lexing.pos_cnum = pos_cnum
    }

let rec copy_out_phrase :
  From.Outcometree.out_phrase -> To.Outcometree.out_phrase =
  function
  | From.Outcometree.Ophr_eval (x0,x1) ->
      To.Outcometree.Ophr_eval
        ((copy_out_value x0),
          (copy_out_type x1))
  | From.Outcometree.Ophr_signature x0 ->
      To.Outcometree.Ophr_signature
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_out_sig_item x0),
                (copy_option copy_out_value x1))) x0)
  | From.Outcometree.Ophr_exception x0 ->
      To.Outcometree.Ophr_exception
        (let (x0,x1) = x0  in
         ((copy_exn x0), (copy_out_value x1)))

and copy_exn : exn -> exn = fun x  -> x

and copy_out_sig_item :
  From.Outcometree.out_sig_item -> To.Outcometree.out_sig_item =
  function
  | From.Outcometree.Osig_class (x0,x1,x2,x3,x4) ->
      To.Outcometree.Osig_class
        ((copy_bool x0), x1,
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))
             x2), (copy_out_class_type x3),
          (copy_out_rec_status x4))
  | From.Outcometree.Osig_class_type (x0,x1,x2,x3,x4) ->
      To.Outcometree.Osig_class_type
        ((copy_bool x0), x1,
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))
             x2), (copy_out_class_type x3),
          (copy_out_rec_status x4))
  | From.Outcometree.Osig_typext (x0,x1) ->
      To.Outcometree.Osig_typext
        ((copy_out_extension_constructor x0),
          (copy_out_ext_status x1))
  | From.Outcometree.Osig_modtype (x0,x1) ->
      To.Outcometree.Osig_modtype
        (x0, (copy_out_module_type x1))
  | From.Outcometree.Osig_module (x0,x1,x2) ->
      To.Outcometree.Osig_module
        (x0, (copy_out_module_type x1),
          (copy_out_rec_status x2))
  | From.Outcometree.Osig_type (x0,x1) ->
      To.Outcometree.Osig_type
        ((copy_out_type_decl x0),
          (copy_out_rec_status x1))
  | From.Outcometree.Osig_value x0 ->
      To.Outcometree.Osig_value
        (copy_out_val_decl x0)
  | From.Outcometree.Osig_ellipsis  -> To.Outcometree.Osig_ellipsis

and copy_out_val_decl :
  From.Outcometree.out_val_decl -> To.Outcometree.out_val_decl =
  fun
    { From.Outcometree.oval_name = oval_name;
      From.Outcometree.oval_type = oval_type;
      From.Outcometree.oval_prims = oval_prims;
      From.Outcometree.oval_attributes = oval_attributes }
     ->
    {
      To.Outcometree.oval_name = oval_name;
      To.Outcometree.oval_type =
        (copy_out_type oval_type);
      To.Outcometree.oval_prims = (List.map (fun x  -> x) oval_prims);
      To.Outcometree.oval_attributes =
        (List.map copy_out_attribute oval_attributes)
    }

and copy_out_type_decl :
  From.Outcometree.out_type_decl -> To.Outcometree.out_type_decl =
  fun
    { From.Outcometree.otype_name = otype_name;
      From.Outcometree.otype_params = otype_params;
      From.Outcometree.otype_type = otype_type;
      From.Outcometree.otype_private = otype_private;
      From.Outcometree.otype_immediate = otype_immediate;
      From.Outcometree.otype_unboxed = otype_unboxed;
      From.Outcometree.otype_cstrs = otype_cstrs }
     ->
    {
      To.Outcometree.otype_name = otype_name;
      To.Outcometree.otype_params =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))
           otype_params);
      To.Outcometree.otype_type =
        (copy_out_type otype_type);
      To.Outcometree.otype_private =
        (copy_From_Asttypes_private_flag otype_private);
      To.Outcometree.otype_immediate = (copy_bool otype_immediate);
      To.Outcometree.otype_unboxed = (copy_bool otype_unboxed);
      To.Outcometree.otype_cstrs =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_out_type x0),
                (copy_out_type x1))) otype_cstrs)
    }

and copy_out_module_type :
  From.Outcometree.out_module_type -> To.Outcometree.out_module_type
  =
  function
  | From.Outcometree.Omty_abstract  -> To.Outcometree.Omty_abstract
  | From.Outcometree.Omty_functor (x0,x1,x2) ->
      To.Outcometree.Omty_functor
        (x0, (copy_option copy_out_module_type x1),
          (copy_out_module_type x2))
  | From.Outcometree.Omty_ident x0 ->
      To.Outcometree.Omty_ident (copy_out_ident x0)
  | From.Outcometree.Omty_signature x0 ->
      To.Outcometree.Omty_signature
        (List.map copy_out_sig_item x0)
  | From.Outcometree.Omty_alias x0 ->
      To.Outcometree.Omty_alias (copy_out_ident x0)

and copy_out_ext_status :
  From.Outcometree.out_ext_status -> To.Outcometree.out_ext_status =
  function
  | From.Outcometree.Oext_first  -> To.Outcometree.Oext_first
  | From.Outcometree.Oext_next  -> To.Outcometree.Oext_next
  | From.Outcometree.Oext_exception  -> To.Outcometree.Oext_exception

and copy_out_extension_constructor :
  From.Outcometree.out_extension_constructor ->
    To.Outcometree.out_extension_constructor
  =
  fun
    { From.Outcometree.oext_name = oext_name;
      From.Outcometree.oext_type_name = oext_type_name;
      From.Outcometree.oext_type_params = oext_type_params;
      From.Outcometree.oext_args = oext_args;
      From.Outcometree.oext_ret_type = oext_ret_type;
      From.Outcometree.oext_private = oext_private }
     ->
    {
      To.Outcometree.oext_name = oext_name;
      To.Outcometree.oext_type_name = oext_type_name;
      To.Outcometree.oext_type_params =
        (List.map (fun x  -> x) oext_type_params);
      To.Outcometree.oext_args =
        (List.map copy_out_type oext_args);
      To.Outcometree.oext_ret_type =
        (copy_option copy_out_type oext_ret_type);
      To.Outcometree.oext_private =
        (copy_From_Asttypes_private_flag oext_private)
    }

and copy_From_Asttypes_private_flag :
  From.Asttypes.private_flag -> To.Asttypes.private_flag =
  function
  | From.Asttypes.Private  -> To.Asttypes.Private
  | From.Asttypes.Public  -> To.Asttypes.Public

and copy_out_rec_status :
  From.Outcometree.out_rec_status -> To.Outcometree.out_rec_status =
  function
  | From.Outcometree.Orec_not  -> To.Outcometree.Orec_not
  | From.Outcometree.Orec_first  -> To.Outcometree.Orec_first
  | From.Outcometree.Orec_next  -> To.Outcometree.Orec_next

and copy_out_class_type :
  From.Outcometree.out_class_type -> To.Outcometree.out_class_type =
  function
  | From.Outcometree.Octy_constr (x0,x1) ->
      To.Outcometree.Octy_constr
        ((copy_out_ident x0),
          (List.map copy_out_type x1))
  | From.Outcometree.Octy_arrow (x0,x1,x2) ->
      To.Outcometree.Octy_arrow
        (x0, (copy_out_type x1),
          (copy_out_class_type x2))
  | From.Outcometree.Octy_signature (x0,x1) ->
      To.Outcometree.Octy_signature
        ((copy_option copy_out_type x0),
          (List.map copy_out_class_sig_item x1))

and copy_out_class_sig_item :
  From.Outcometree.out_class_sig_item ->
    To.Outcometree.out_class_sig_item
  =
  function
  | From.Outcometree.Ocsg_constraint (x0,x1) ->
      To.Outcometree.Ocsg_constraint
        ((copy_out_type x0),
          (copy_out_type x1))
  | From.Outcometree.Ocsg_method (x0,x1,x2,x3) ->
      To.Outcometree.Ocsg_method
        (x0, (copy_bool x1), (copy_bool x2),
          (copy_out_type x3))
  | From.Outcometree.Ocsg_value (x0,x1,x2,x3) ->
      To.Outcometree.Ocsg_value
        (x0, (copy_bool x1), (copy_bool x2),
          (copy_out_type x3))

and copy_out_type :
  From.Outcometree.out_type -> To.Outcometree.out_type =
  function
  | From.Outcometree.Otyp_abstract  -> To.Outcometree.Otyp_abstract
  | From.Outcometree.Otyp_open  -> To.Outcometree.Otyp_open
  | From.Outcometree.Otyp_alias (x0,x1) ->
      To.Outcometree.Otyp_alias
        ((copy_out_type x0), x1)
  | From.Outcometree.Otyp_arrow (x0,x1,x2) ->
      To.Outcometree.Otyp_arrow
        (x0, (copy_out_type x1),
          (copy_out_type x2))
  | From.Outcometree.Otyp_class (x0,x1,x2) ->
      To.Outcometree.Otyp_class
        ((copy_bool x0), (copy_out_ident x1),
          (List.map copy_out_type x2))
  | From.Outcometree.Otyp_constr (x0,x1) ->
      To.Outcometree.Otyp_constr
        ((copy_out_ident x0),
          (List.map copy_out_type x1))
  | From.Outcometree.Otyp_manifest (x0,x1) ->
      To.Outcometree.Otyp_manifest
        ((copy_out_type x0),
          (copy_out_type x1))
  | From.Outcometree.Otyp_object (x0,x1) ->
      To.Outcometree.Otyp_object
        ((List.map
            (fun x  ->
               let (x0,x1) = x  in
               (x0, (copy_out_type x1))) x0),
          (copy_option copy_bool x1))
  | From.Outcometree.Otyp_record x0 ->
      To.Outcometree.Otyp_record
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (copy_bool x1), (copy_out_type x2)))
           x0)
  | From.Outcometree.Otyp_stuff x0 -> To.Outcometree.Otyp_stuff x0
  | From.Outcometree.Otyp_sum x0 ->
      To.Outcometree.Otyp_sum
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (List.map copy_out_type x1),
                (copy_option copy_out_type x2))) x0)
  | From.Outcometree.Otyp_tuple x0 ->
      To.Outcometree.Otyp_tuple
        (List.map copy_out_type x0)
  | From.Outcometree.Otyp_var (x0,x1) ->
      To.Outcometree.Otyp_var ((copy_bool x0), x1)
  | From.Outcometree.Otyp_variant (x0,x1,x2,x3) ->
      To.Outcometree.Otyp_variant
        ((copy_bool x0), (copy_out_variant x1),
          (copy_bool x2),
          (copy_option (fun x  -> List.map (fun x  -> x) x) x3))
  | From.Outcometree.Otyp_poly (x0,x1) ->
      To.Outcometree.Otyp_poly
        ((List.map (fun x  -> x) x0), (copy_out_type x1))
  | From.Outcometree.Otyp_module (x0,x1,x2) ->
      To.Outcometree.Otyp_module
        (x0, (List.map (fun x  -> x) x1),
          (List.map copy_out_type x2))
  | From.Outcometree.Otyp_attribute (x0,x1) ->
      To.Outcometree.Otyp_attribute
        ((copy_out_type x0),
          (copy_out_attribute x1))

and copy_out_attribute :
  From.Outcometree.out_attribute -> To.Outcometree.out_attribute =
  fun { From.Outcometree.oattr_name = oattr_name }  ->
    { To.Outcometree.oattr_name = oattr_name }

and copy_out_variant :
  From.Outcometree.out_variant -> To.Outcometree.out_variant =
  function
  | From.Outcometree.Ovar_fields x0 ->
      To.Outcometree.Ovar_fields
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (copy_bool x1),
                (List.map copy_out_type x2))) x0)
  | From.Outcometree.Ovar_typ (From.Outcometree.Otyp_constr (id,tyl)) ->
      To.Outcometree.Ovar_name (copy_out_ident id, List.map copy_out_type tyl)
  | From.Outcometree.Ovar_typ x0 ->
      To.Outcometree.Ovar_name
        (To.Outcometree.Oide_ident "", [copy_out_type x0])

and copy_out_value :
  From.Outcometree.out_value -> To.Outcometree.out_value =
  function
  | From.Outcometree.Oval_array x0 ->
      To.Outcometree.Oval_array
        (List.map copy_out_value x0)
  | From.Outcometree.Oval_char x0 -> To.Outcometree.Oval_char x0
  | From.Outcometree.Oval_constr (x0,x1) ->
      To.Outcometree.Oval_constr
        ((copy_out_ident x0),
          (List.map copy_out_value x1))
  | From.Outcometree.Oval_ellipsis  -> To.Outcometree.Oval_ellipsis
  | From.Outcometree.Oval_float x0 ->
      To.Outcometree.Oval_float (copy_float x0)
  | From.Outcometree.Oval_int x0 -> To.Outcometree.Oval_int x0
  | From.Outcometree.Oval_int32 x0 -> To.Outcometree.Oval_int32 x0
  | From.Outcometree.Oval_int64 x0 -> To.Outcometree.Oval_int64 x0
  | From.Outcometree.Oval_nativeint x0 ->
      To.Outcometree.Oval_nativeint x0
  | From.Outcometree.Oval_list x0 ->
      To.Outcometree.Oval_list
        (List.map copy_out_value x0)
  | From.Outcometree.Oval_printer x0 ->
      To.Outcometree.Oval_printer x0
  | From.Outcometree.Oval_record x0 ->
      To.Outcometree.Oval_record
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_out_ident x0),
                (copy_out_value x1))) x0)
  | From.Outcometree.Oval_string x0 -> To.Outcometree.Oval_string x0
  | From.Outcometree.Oval_stuff x0 -> To.Outcometree.Oval_stuff x0
  | From.Outcometree.Oval_tuple x0 ->
      To.Outcometree.Oval_tuple
        (List.map copy_out_value x0)
  | From.Outcometree.Oval_variant (x0,x1) ->
      To.Outcometree.Oval_variant
        (x0, (copy_option copy_out_value x1))

and copy_float : float -> float = fun x  -> x

and copy_out_ident :
  From.Outcometree.out_ident -> To.Outcometree.out_ident =
  function
  | From.Outcometree.Oide_apply (x0,x1) ->
      To.Outcometree.Oide_apply
        ((copy_out_ident x0),
          (copy_out_ident x1))
  | From.Outcometree.Oide_dot (x0,x1) ->
      To.Outcometree.Oide_dot
        ((copy_out_ident x0), x1)
  | From.Outcometree.Oide_ident x0 -> To.Outcometree.Oide_ident x0

let rec copy_toplevel_phrase :
  From.Parsetree.toplevel_phrase -> To.Parsetree.toplevel_phrase =
  function
  | From.Parsetree.Ptop_def x0 ->
      To.Parsetree.Ptop_def (copy_structure x0)
  | From.Parsetree.Ptop_dir (x0,x1) ->
      To.Parsetree.Ptop_dir
        (x0, (copy_directive_argument x1))

and copy_directive_argument :
  From.Parsetree.directive_argument -> To.Parsetree.directive_argument =
  function
  | From.Parsetree.Pdir_none  -> To.Parsetree.Pdir_none
  | From.Parsetree.Pdir_string x0 -> To.Parsetree.Pdir_string x0
  | From.Parsetree.Pdir_int (x0,x1) ->
      To.Parsetree.Pdir_int (x0, (copy_option (fun x  -> x) x1))
  | From.Parsetree.Pdir_ident x0 ->
      To.Parsetree.Pdir_ident (copy_longident x0)
  | From.Parsetree.Pdir_bool x0 ->
      To.Parsetree.Pdir_bool (copy_bool x0)

let copy_out_type_extension :
  From.Outcometree.out_type_extension -> To.Outcometree.out_type_extension =
  fun
    { From.Outcometree.otyext_name = otyext_name;
      From.Outcometree.otyext_params = otyext_params;
      From.Outcometree.otyext_constructors = otyext_constructors;
      From.Outcometree.otyext_private = otyext_private }
     ->
    {
      To.Outcometree.otyext_name = otyext_name;
      To.Outcometree.otyext_params =
        (List.map (fun x  -> x) otyext_params);
      To.Outcometree.otyext_constructors =
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (List.map copy_out_type x1),
                (copy_option copy_out_type x2)))
           otyext_constructors);
      To.Outcometree.otyext_private =
        (copy_private_flag otyext_private)
    }

let copy_cases x = List.map copy_case x
let copy_pat = copy_pattern
let copy_expr = copy_expression
let copy_typ = copy_core_type

end
module Migrate_parsetree_404_405
= struct
#1 "migrate_parsetree_404_405.ml"
# 1 "src/migrate_parsetree_404_405.ml"
# 1 "src/migrate_parsetree_404_405.ml"
# 1 "src/migrate_parsetree_404_405.ml"
# 1 "src/migrate_parsetree_404_405.ml"
# 1 "src/migrate_parsetree_404_405.ml"
# 1 "src/migrate_parsetree_404_405.ml"
# 1 "src/migrate_parsetree_404_405.ml"
# 1 "src/migrate_parsetree_404_405.ml"
# 1 "src/migrate_parsetree_404_405.ml"
# 1 "src/migrate_parsetree_404_405.ml"
# 1 "src/migrate_parsetree_404_405.ml"
# 1 "src/migrate_parsetree_404_405.ml"
# 1 "src/migrate_parsetree_404_405.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

include Migrate_parsetree_404_405_migrate

(*$ open Printf
    let fields = [
      "attribute"; "attributes"; "case"; "cases"; "class_declaration";
      "class_description"; "class_expr"; "class_field"; "class_signature";
      "class_structure"; "class_type"; "class_type_declaration";
      "class_type_field"; "constructor_declaration"; "expr"; "extension";
      "extension_constructor"; "include_declaration"; "include_description";
      "label_declaration"; "location"; "module_binding"; "module_declaration";
      "module_expr"; "module_type"; "module_type_declaration";
      "open_description"; "pat"; "signature"; "signature_item"; "structure";
      "structure_item"; "typ"; "type_declaration"; "type_extension";
      "type_kind"; "value_binding"; "value_description";
      "with_constraint"; "payload"
    ]
  let foreach_field f =
    printf "\n";
    List.iter f fields
*)(*$*)

let copy_mapper = fun
  ({ From.Ast_mapper.
     (*$ foreach_field (printf "%s;\n")*)
     attribute;
     attributes;
     case;
     cases;
     class_declaration;
     class_description;
     class_expr;
     class_field;
     class_signature;
     class_structure;
     class_type;
     class_type_declaration;
     class_type_field;
     constructor_declaration;
     expr;
     extension;
     extension_constructor;
     include_declaration;
     include_description;
     label_declaration;
     location;
     module_binding;
     module_declaration;
     module_expr;
     module_type;
     module_type_declaration;
     open_description;
     pat;
     signature;
     signature_item;
     structure;
     structure_item;
     typ;
     type_declaration;
     type_extension;
     type_kind;
     value_binding;
     value_description;
     with_constraint;
     payload;
     (*$*)
   } as mapper) ->
  let module R = Migrate_parsetree_405_404_migrate in
  {
    To.Ast_mapper.
    (*$ foreach_field (fun s ->
          printf
          "%s = (fun _ x -> copy_%s (%s mapper (R.copy_%s x)));\n" s s s s)
    *)
    attribute = (fun _ x -> copy_attribute (attribute mapper (R.copy_attribute x)));
    attributes = (fun _ x -> copy_attributes (attributes mapper (R.copy_attributes x)));
    case = (fun _ x -> copy_case (case mapper (R.copy_case x)));
    cases = (fun _ x -> copy_cases (cases mapper (R.copy_cases x)));
    class_declaration = (fun _ x -> copy_class_declaration (class_declaration mapper (R.copy_class_declaration x)));
    class_description = (fun _ x -> copy_class_description (class_description mapper (R.copy_class_description x)));
    class_expr = (fun _ x -> copy_class_expr (class_expr mapper (R.copy_class_expr x)));
    class_field = (fun _ x -> copy_class_field (class_field mapper (R.copy_class_field x)));
    class_signature = (fun _ x -> copy_class_signature (class_signature mapper (R.copy_class_signature x)));
    class_structure = (fun _ x -> copy_class_structure (class_structure mapper (R.copy_class_structure x)));
    class_type = (fun _ x -> copy_class_type (class_type mapper (R.copy_class_type x)));
    class_type_declaration = (fun _ x -> copy_class_type_declaration (class_type_declaration mapper (R.copy_class_type_declaration x)));
    class_type_field = (fun _ x -> copy_class_type_field (class_type_field mapper (R.copy_class_type_field x)));
    constructor_declaration = (fun _ x -> copy_constructor_declaration (constructor_declaration mapper (R.copy_constructor_declaration x)));
    expr = (fun _ x -> copy_expr (expr mapper (R.copy_expr x)));
    extension = (fun _ x -> copy_extension (extension mapper (R.copy_extension x)));
    extension_constructor = (fun _ x -> copy_extension_constructor (extension_constructor mapper (R.copy_extension_constructor x)));
    include_declaration = (fun _ x -> copy_include_declaration (include_declaration mapper (R.copy_include_declaration x)));
    include_description = (fun _ x -> copy_include_description (include_description mapper (R.copy_include_description x)));
    label_declaration = (fun _ x -> copy_label_declaration (label_declaration mapper (R.copy_label_declaration x)));
    location = (fun _ x -> copy_location (location mapper (R.copy_location x)));
    module_binding = (fun _ x -> copy_module_binding (module_binding mapper (R.copy_module_binding x)));
    module_declaration = (fun _ x -> copy_module_declaration (module_declaration mapper (R.copy_module_declaration x)));
    module_expr = (fun _ x -> copy_module_expr (module_expr mapper (R.copy_module_expr x)));
    module_type = (fun _ x -> copy_module_type (module_type mapper (R.copy_module_type x)));
    module_type_declaration = (fun _ x -> copy_module_type_declaration (module_type_declaration mapper (R.copy_module_type_declaration x)));
    open_description = (fun _ x -> copy_open_description (open_description mapper (R.copy_open_description x)));
    pat = (fun _ x -> copy_pat (pat mapper (R.copy_pat x)));
    signature = (fun _ x -> copy_signature (signature mapper (R.copy_signature x)));
    signature_item = (fun _ x -> copy_signature_item (signature_item mapper (R.copy_signature_item x)));
    structure = (fun _ x -> copy_structure (structure mapper (R.copy_structure x)));
    structure_item = (fun _ x -> copy_structure_item (structure_item mapper (R.copy_structure_item x)));
    typ = (fun _ x -> copy_typ (typ mapper (R.copy_typ x)));
    type_declaration = (fun _ x -> copy_type_declaration (type_declaration mapper (R.copy_type_declaration x)));
    type_extension = (fun _ x -> copy_type_extension (type_extension mapper (R.copy_type_extension x)));
    type_kind = (fun _ x -> copy_type_kind (type_kind mapper (R.copy_type_kind x)));
    value_binding = (fun _ x -> copy_value_binding (value_binding mapper (R.copy_value_binding x)));
    value_description = (fun _ x -> copy_value_description (value_description mapper (R.copy_value_description x)));
    with_constraint = (fun _ x -> copy_with_constraint (with_constraint mapper (R.copy_with_constraint x)));
    payload = (fun _ x -> copy_payload (payload mapper (R.copy_payload x)));
    (*$*)
  }

end
module Migrate_parsetree_405_404
= struct
#1 "migrate_parsetree_405_404.ml"
# 1 "src/migrate_parsetree_405_404.ml"
# 1 "src/migrate_parsetree_405_404.ml"
# 1 "src/migrate_parsetree_405_404.ml"
# 1 "src/migrate_parsetree_405_404.ml"
# 1 "src/migrate_parsetree_405_404.ml"
# 1 "src/migrate_parsetree_405_404.ml"
# 1 "src/migrate_parsetree_405_404.ml"
# 1 "src/migrate_parsetree_405_404.ml"
# 1 "src/migrate_parsetree_405_404.ml"
# 1 "src/migrate_parsetree_405_404.ml"
# 1 "src/migrate_parsetree_405_404.ml"
# 1 "src/migrate_parsetree_405_404.ml"
# 1 "src/migrate_parsetree_405_404.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

include Migrate_parsetree_405_404_migrate

(*$ open Printf
    let fields = [
      "attribute"; "attributes"; "case"; "cases"; "class_declaration";
      "class_description"; "class_expr"; "class_field"; "class_signature";
      "class_structure"; "class_type"; "class_type_declaration";
      "class_type_field"; "constructor_declaration"; "expr"; "extension";
      "extension_constructor"; "include_declaration"; "include_description";
      "label_declaration"; "location"; "module_binding"; "module_declaration";
      "module_expr"; "module_type"; "module_type_declaration";
      "open_description"; "pat"; "signature"; "signature_item"; "structure";
      "structure_item"; "typ"; "type_declaration"; "type_extension";
      "type_kind"; "value_binding"; "value_description";
      "with_constraint"; "payload"
    ]
  let foreach_field f =
    printf "\n";
    List.iter f fields
*)(*$*)

let copy_mapper = fun
  ({ From.Ast_mapper.
     (*$ foreach_field (printf "%s;\n")*)
     attribute;
     attributes;
     case;
     cases;
     class_declaration;
     class_description;
     class_expr;
     class_field;
     class_signature;
     class_structure;
     class_type;
     class_type_declaration;
     class_type_field;
     constructor_declaration;
     expr;
     extension;
     extension_constructor;
     include_declaration;
     include_description;
     label_declaration;
     location;
     module_binding;
     module_declaration;
     module_expr;
     module_type;
     module_type_declaration;
     open_description;
     pat;
     signature;
     signature_item;
     structure;
     structure_item;
     typ;
     type_declaration;
     type_extension;
     type_kind;
     value_binding;
     value_description;
     with_constraint;
     payload;
     (*$*)
   } as mapper) ->
  let module R = Migrate_parsetree_404_405_migrate in
  {
    To.Ast_mapper.
    (*$ foreach_field (fun s ->
          printf
          "%s = (fun _ x -> copy_%s (%s mapper (R.copy_%s x)));\n" s s s s)
    *)
    attribute = (fun _ x -> copy_attribute (attribute mapper (R.copy_attribute x)));
    attributes = (fun _ x -> copy_attributes (attributes mapper (R.copy_attributes x)));
    case = (fun _ x -> copy_case (case mapper (R.copy_case x)));
    cases = (fun _ x -> copy_cases (cases mapper (R.copy_cases x)));
    class_declaration = (fun _ x -> copy_class_declaration (class_declaration mapper (R.copy_class_declaration x)));
    class_description = (fun _ x -> copy_class_description (class_description mapper (R.copy_class_description x)));
    class_expr = (fun _ x -> copy_class_expr (class_expr mapper (R.copy_class_expr x)));
    class_field = (fun _ x -> copy_class_field (class_field mapper (R.copy_class_field x)));
    class_signature = (fun _ x -> copy_class_signature (class_signature mapper (R.copy_class_signature x)));
    class_structure = (fun _ x -> copy_class_structure (class_structure mapper (R.copy_class_structure x)));
    class_type = (fun _ x -> copy_class_type (class_type mapper (R.copy_class_type x)));
    class_type_declaration = (fun _ x -> copy_class_type_declaration (class_type_declaration mapper (R.copy_class_type_declaration x)));
    class_type_field = (fun _ x -> copy_class_type_field (class_type_field mapper (R.copy_class_type_field x)));
    constructor_declaration = (fun _ x -> copy_constructor_declaration (constructor_declaration mapper (R.copy_constructor_declaration x)));
    expr = (fun _ x -> copy_expr (expr mapper (R.copy_expr x)));
    extension = (fun _ x -> copy_extension (extension mapper (R.copy_extension x)));
    extension_constructor = (fun _ x -> copy_extension_constructor (extension_constructor mapper (R.copy_extension_constructor x)));
    include_declaration = (fun _ x -> copy_include_declaration (include_declaration mapper (R.copy_include_declaration x)));
    include_description = (fun _ x -> copy_include_description (include_description mapper (R.copy_include_description x)));
    label_declaration = (fun _ x -> copy_label_declaration (label_declaration mapper (R.copy_label_declaration x)));
    location = (fun _ x -> copy_location (location mapper (R.copy_location x)));
    module_binding = (fun _ x -> copy_module_binding (module_binding mapper (R.copy_module_binding x)));
    module_declaration = (fun _ x -> copy_module_declaration (module_declaration mapper (R.copy_module_declaration x)));
    module_expr = (fun _ x -> copy_module_expr (module_expr mapper (R.copy_module_expr x)));
    module_type = (fun _ x -> copy_module_type (module_type mapper (R.copy_module_type x)));
    module_type_declaration = (fun _ x -> copy_module_type_declaration (module_type_declaration mapper (R.copy_module_type_declaration x)));
    open_description = (fun _ x -> copy_open_description (open_description mapper (R.copy_open_description x)));
    pat = (fun _ x -> copy_pat (pat mapper (R.copy_pat x)));
    signature = (fun _ x -> copy_signature (signature mapper (R.copy_signature x)));
    signature_item = (fun _ x -> copy_signature_item (signature_item mapper (R.copy_signature_item x)));
    structure = (fun _ x -> copy_structure (structure mapper (R.copy_structure x)));
    structure_item = (fun _ x -> copy_structure_item (structure_item mapper (R.copy_structure_item x)));
    typ = (fun _ x -> copy_typ (typ mapper (R.copy_typ x)));
    type_declaration = (fun _ x -> copy_type_declaration (type_declaration mapper (R.copy_type_declaration x)));
    type_extension = (fun _ x -> copy_type_extension (type_extension mapper (R.copy_type_extension x)));
    type_kind = (fun _ x -> copy_type_kind (type_kind mapper (R.copy_type_kind x)));
    value_binding = (fun _ x -> copy_value_binding (value_binding mapper (R.copy_value_binding x)));
    value_description = (fun _ x -> copy_value_description (value_description mapper (R.copy_value_description x)));
    with_constraint = (fun _ x -> copy_with_constraint (with_constraint mapper (R.copy_with_constraint x)));
    payload = (fun _ x -> copy_payload (payload mapper (R.copy_payload x)));
    (*$*)
  }

end
module Ast_406
= struct
#1 "ast_406.ml"
# 1 "src/ast_406.ml"
# 1 "src/ast_406.ml"
# 1 "src/ast_406.ml"
# 1 "src/ast_406.ml"
# 1 "src/ast_406.ml"
# 1 "src/ast_406.ml"
# 1 "src/ast_406.ml"
# 1 "src/ast_406.ml"
# 1 "src/ast_406.ml"
# 1 "src/ast_406.ml"
# 1 "src/ast_406.ml"
# 1 "src/ast_406.ml"
# 1 "src/ast_406.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*            Jérémie Dimino and Leo White, Jane Street Europe            *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt            *)
(*                         Alain Frisch, LexiFi                           *)
(*       Daniel de Rauglaudre, projet Cristal, INRIA Rocquencourt         *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(* Ast ported on Wed May 31 10:28:52 BST 2017
   OCaml trunk was:
     commit 3186c9cd3d8e21ba7fdcb757ad736a1ac5b54ebc
     Merge: 39518272d 0f642e6ac
     Author: Gabriel Scherer <gabriel.scherer@gmail.com>
     Date:   Wed May 31 01:12:09 2017 -0400

         Merge pull request #1184 from gasche/use-dash-in-travis

         Use dash instead of bash on the Travis CI machines. *)

module Location = Location
module Longident = Longident

module Asttypes = struct
  (** Auxiliary AST types used by parsetree and typedtree. *)

  type constant (*IF_CURRENT = Asttypes.constant *) =
      Const_int of int
    | Const_char of char
    | Const_string of string * string option
    | Const_float of string
    | Const_int32 of int32
    | Const_int64 of int64
    | Const_nativeint of nativeint

  type rec_flag (*IF_CURRENT = Asttypes.rec_flag *) = Nonrecursive | Recursive

  type direction_flag (*IF_CURRENT = Asttypes.direction_flag *) = Upto | Downto

  (* Order matters, used in polymorphic comparison *)
  type private_flag (*IF_CURRENT = Asttypes.private_flag *) = Private | Public

  type mutable_flag (*IF_CURRENT = Asttypes.mutable_flag *) = Immutable | Mutable

  type virtual_flag (*IF_CURRENT = Asttypes.virtual_flag *) = Virtual | Concrete

  type override_flag (*IF_CURRENT = Asttypes.override_flag *) = Override | Fresh

  type closed_flag (*IF_CURRENT = Asttypes.closed_flag *) = Closed | Open

  type label = string

  type arg_label (*IF_CURRENT = Asttypes.arg_label *) =
      Nolabel
    | Labelled of string (*  label:T -> ... *)
    | Optional of string (* ?label:T -> ... *)

  type 'a loc = 'a Location.loc = {
    txt : 'a;
    loc : Location.t;
  }


  type variance (*IF_CURRENT = Asttypes.variance *) =
    | Covariant
    | Contravariant
    | Invariant
end

module Parsetree = struct
  (** Abstract syntax tree produced by parsing *)

  open Asttypes

  type constant (*IF_CURRENT = Parsetree.constant *) =
      Pconst_integer of string * char option
    (* 3 3l 3L 3n

       Suffixes [g-z][G-Z] are accepted by the parser.
       Suffixes except 'l', 'L' and 'n' are rejected by the typechecker
    *)
    | Pconst_char of char
    (* 'c' *)
    | Pconst_string of string * string option
    (* "constant"
       {delim|other constant|delim}
    *)
    | Pconst_float of string * char option
    (* 3.4 2e5 1.4e-4

       Suffixes [g-z][G-Z] are accepted by the parser.
       Suffixes are rejected by the typechecker.
    *)

  (** {2 Extension points} *)

  type attribute = string loc * payload
         (* [@id ARG]
            [@@id ARG]

            Metadata containers passed around within the AST.
            The compiler ignores unknown attributes.
         *)

  and extension = string loc * payload
        (* [%id ARG]
           [%%id ARG]

           Sub-language placeholder -- rejected by the typechecker.
        *)

  and attributes = attribute list

  and payload (*IF_CURRENT = Parsetree.payload *) =
    | PStr of structure
    | PSig of signature (* : SIG *)
    | PTyp of core_type  (* : T *)
    | PPat of pattern * expression option  (* ? P  or  ? P when E *)

  (** {2 Core language} *)

  (* Type expressions *)

  and core_type (*IF_CURRENT = Parsetree.core_type *) =
      {
       ptyp_desc: core_type_desc;
       ptyp_loc: Location.t;
       ptyp_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and core_type_desc (*IF_CURRENT = Parsetree.core_type_desc *) =
    | Ptyp_any
          (*  _ *)
    | Ptyp_var of string
          (* 'a *)
    | Ptyp_arrow of arg_label * core_type * core_type
          (* T1 -> T2       Simple
             ~l:T1 -> T2    Labelled
             ?l:T1 -> T2    Otional
           *)
    | Ptyp_tuple of core_type list
          (* T1 * ... * Tn

             Invariant: n >= 2
          *)
    | Ptyp_constr of Longident.t loc * core_type list
          (* tconstr
             T tconstr
             (T1, ..., Tn) tconstr
           *)
    | Ptyp_object of (string loc * attributes * core_type) list * closed_flag
          (* < l1:T1; ...; ln:Tn >     (flag = Closed)
             < l1:T1; ...; ln:Tn; .. > (flag = Open)
           *)
    | Ptyp_class of Longident.t loc * core_type list
          (* #tconstr
             T #tconstr
             (T1, ..., Tn) #tconstr
           *)
    | Ptyp_alias of core_type * string
          (* T as 'a *)
    | Ptyp_variant of row_field list * closed_flag * label list option
          (* [ `A|`B ]         (flag = Closed; labels = None)
             [> `A|`B ]        (flag = Open;   labels = None)
             [< `A|`B ]        (flag = Closed; labels = Some [])
             [< `A|`B > `X `Y ](flag = Closed; labels = Some ["X";"Y"])
           *)
    | Ptyp_poly of string loc list * core_type
          (* 'a1 ... 'an. T

             Can only appear in the following context:

             - As the core_type of a Ppat_constraint node corresponding
               to a constraint on a let-binding: let x : 'a1 ... 'an. T
               = e ...

             - Under Cfk_virtual for methods (not values).

             - As the core_type of a Pctf_method node.

             - As the core_type of a Pexp_poly node.

             - As the pld_type field of a label_declaration.

             - As a core_type of a Ptyp_object node.
           *)

    | Ptyp_package of package_type
          (* (module S) *)
    | Ptyp_extension of extension
          (* [%id] *)

  and package_type = Longident.t loc * (Longident.t loc * core_type) list
        (*
          (module S)
          (module S with type t1 = T1 and ... and tn = Tn)
         *)

  and row_field (*IF_CURRENT = Parsetree.row_field *) =
    | Rtag of label * attributes * bool * core_type list
          (* [`A]                   ( true,  [] )
             [`A of T]              ( false, [T] )
             [`A of T1 & .. & Tn]   ( false, [T1;...Tn] )
             [`A of & T1 & .. & Tn] ( true,  [T1;...Tn] )

            - The 2nd field is true if the tag contains a
              constant (empty) constructor.
            - '&' occurs when several types are used for the same constructor
              (see 4.2 in the manual)

            - TODO: switch to a record representation, and keep location
          *)
    | Rinherit of core_type
          (* [ T ] *)

  (* Patterns *)

  and pattern (*IF_CURRENT = Parsetree.pattern *) =
      {
       ppat_desc: pattern_desc;
       ppat_loc: Location.t;
       ppat_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and pattern_desc (*IF_CURRENT = Parsetree.pattern_desc *) =
    | Ppat_any
          (* _ *)
    | Ppat_var of string loc
          (* x *)
    | Ppat_alias of pattern * string loc
          (* P as 'a *)
    | Ppat_constant of constant
          (* 1, 'a', "true", 1.0, 1l, 1L, 1n *)
    | Ppat_interval of constant * constant
          (* 'a'..'z'

             Other forms of interval are recognized by the parser
             but rejected by the type-checker. *)
    | Ppat_tuple of pattern list
          (* (P1, ..., Pn)

             Invariant: n >= 2
          *)
    | Ppat_construct of Longident.t loc * pattern option
          (* C                None
             C P              Some P
             C (P1, ..., Pn)  Some (Ppat_tuple [P1; ...; Pn])
           *)
    | Ppat_variant of label * pattern option
          (* `A             (None)
             `A P           (Some P)
           *)
    | Ppat_record of (Longident.t loc * pattern) list * closed_flag
          (* { l1=P1; ...; ln=Pn }     (flag = Closed)
             { l1=P1; ...; ln=Pn; _}   (flag = Open)

             Invariant: n > 0
           *)
    | Ppat_array of pattern list
          (* [| P1; ...; Pn |] *)
    | Ppat_or of pattern * pattern
          (* P1 | P2 *)
    | Ppat_constraint of pattern * core_type
          (* (P : T) *)
    | Ppat_type of Longident.t loc
          (* #tconst *)
    | Ppat_lazy of pattern
          (* lazy P *)
    | Ppat_unpack of string loc
          (* (module P)
             Note: (module P : S) is represented as
             Ppat_constraint(Ppat_unpack, Ptyp_package)
           *)
    | Ppat_exception of pattern
          (* exception P *)
    | Ppat_extension of extension
          (* [%id] *)
    | Ppat_open of Longident.t loc * pattern
          (* M.(P) *)

  (* Value expressions *)

  and expression (*IF_CURRENT = Parsetree.expression *) =
      {
       pexp_desc: expression_desc;
       pexp_loc: Location.t;
       pexp_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and expression_desc (*IF_CURRENT = Parsetree.expression_desc *) =
    | Pexp_ident of Longident.t loc
          (* x
             M.x
           *)
    | Pexp_constant of constant
          (* 1, 'a', "true", 1.0, 1l, 1L, 1n *)
    | Pexp_let of rec_flag * value_binding list * expression
          (* let P1 = E1 and ... and Pn = EN in E       (flag = Nonrecursive)
             let rec P1 = E1 and ... and Pn = EN in E   (flag = Recursive)
           *)
    | Pexp_function of case list
          (* function P1 -> E1 | ... | Pn -> En *)
    | Pexp_fun of arg_label * expression option * pattern * expression
          (* fun P -> E1                          (Simple, None)
             fun ~l:P -> E1                       (Labelled l, None)
             fun ?l:P -> E1                       (Optional l, None)
             fun ?l:(P = E0) -> E1                (Optional l, Some E0)

             Notes:
             - If E0 is provided, only Optional is allowed.
             - "fun P1 P2 .. Pn -> E1" is represented as nested Pexp_fun.
             - "let f P = E" is represented using Pexp_fun.
           *)
    | Pexp_apply of expression * (arg_label * expression) list
          (* E0 ~l1:E1 ... ~ln:En
             li can be empty (non labeled argument) or start with '?'
             (optional argument).

             Invariant: n > 0
           *)
    | Pexp_match of expression * case list
          (* match E0 with P1 -> E1 | ... | Pn -> En *)
    | Pexp_try of expression * case list
          (* try E0 with P1 -> E1 | ... | Pn -> En *)
    | Pexp_tuple of expression list
          (* (E1, ..., En)

             Invariant: n >= 2
          *)
    | Pexp_construct of Longident.t loc * expression option
          (* C                None
             C E              Some E
             C (E1, ..., En)  Some (Pexp_tuple[E1;...;En])
          *)
    | Pexp_variant of label * expression option
          (* `A             (None)
             `A E           (Some E)
           *)
    | Pexp_record of (Longident.t loc * expression) list * expression option
          (* { l1=P1; ...; ln=Pn }     (None)
             { E0 with l1=P1; ...; ln=Pn }   (Some E0)

             Invariant: n > 0
           *)
    | Pexp_field of expression * Longident.t loc
          (* E.l *)
    | Pexp_setfield of expression * Longident.t loc * expression
          (* E1.l <- E2 *)
    | Pexp_array of expression list
          (* [| E1; ...; En |] *)
    | Pexp_ifthenelse of expression * expression * expression option
          (* if E1 then E2 else E3 *)
    | Pexp_sequence of expression * expression
          (* E1; E2 *)
    | Pexp_while of expression * expression
          (* while E1 do E2 done *)
    | Pexp_for of
        pattern *  expression * expression * direction_flag * expression
          (* for i = E1 to E2 do E3 done      (flag = Upto)
             for i = E1 downto E2 do E3 done  (flag = Downto)
           *)
    | Pexp_constraint of expression * core_type
          (* (E : T) *)
    | Pexp_coerce of expression * core_type option * core_type
          (* (E :> T)        (None, T)
             (E : T0 :> T)   (Some T0, T)
           *)
    | Pexp_send of expression * string loc
          (*  E # m *)
    | Pexp_new of Longident.t loc
          (* new M.c *)
    | Pexp_setinstvar of string loc * expression
          (* x <- 2 *)
    | Pexp_override of (string loc * expression) list
          (* {< x1 = E1; ...; Xn = En >} *)
    | Pexp_letmodule of string loc * module_expr * expression
          (* let module M = ME in E *)
    | Pexp_letexception of extension_constructor * expression
          (* let exception C in E *)
    | Pexp_assert of expression
          (* assert E
             Note: "assert false" is treated in a special way by the
             type-checker. *)
    | Pexp_lazy of expression
          (* lazy E *)
    | Pexp_poly of expression * core_type option
          (* Used for method bodies.

             Can only be used as the expression under Cfk_concrete
             for methods (not values). *)
    | Pexp_object of class_structure
          (* object ... end *)
    | Pexp_newtype of string loc * expression
          (* fun (type t) -> E *)
    | Pexp_pack of module_expr
          (* (module ME)

             (module ME : S) is represented as
             Pexp_constraint(Pexp_pack, Ptyp_package S) *)
    | Pexp_open of override_flag * Longident.t loc * expression
          (* M.(E)
             let open M in E
             let! open M in E *)
    | Pexp_extension of extension
          (* [%id] *)
    | Pexp_unreachable
          (* . *)

  and case (*IF_CURRENT = Parsetree.case *) =   (* (P -> E) or (P when E0 -> E) *)
      {
       pc_lhs: pattern;
       pc_guard: expression option;
       pc_rhs: expression;
      }

  (* Value descriptions *)

  and value_description (*IF_CURRENT = Parsetree.value_description *) =
      {
       pval_name: string loc;
       pval_type: core_type;
       pval_prim: string list;
       pval_attributes: attributes;  (* ... [@@id1] [@@id2] *)
       pval_loc: Location.t;
      }

  (*
    val x: T                            (prim = [])
    external x: T = "s1" ... "sn"       (prim = ["s1";..."sn"])
  *)

  (* Type declarations *)

  and type_declaration (*IF_CURRENT = Parsetree.type_declaration *) =
      {
       ptype_name: string loc;
       ptype_params: (core_type * variance) list;
             (* ('a1,...'an) t; None represents  _*)
       ptype_cstrs: (core_type * core_type * Location.t) list;
             (* ... constraint T1=T1'  ... constraint Tn=Tn' *)
       ptype_kind: type_kind;
       ptype_private: private_flag;   (* = private ... *)
       ptype_manifest: core_type option;  (* = T *)
       ptype_attributes: attributes;   (* ... [@@id1] [@@id2] *)
       ptype_loc: Location.t;
      }

  (*
    type t                     (abstract, no manifest)
    type t = T0                (abstract, manifest=T0)
    type t = C of T | ...      (variant,  no manifest)
    type t = T0 = C of T | ... (variant,  manifest=T0)
    type t = {l: T; ...}       (record,   no manifest)
    type t = T0 = {l : T; ...} (record,   manifest=T0)
    type t = ..                (open,     no manifest)
  *)

  and type_kind (*IF_CURRENT = Parsetree.type_kind *) =
    | Ptype_abstract
    | Ptype_variant of constructor_declaration list
          (* Invariant: non-empty list *)
    | Ptype_record of label_declaration list
          (* Invariant: non-empty list *)
    | Ptype_open

  and label_declaration (*IF_CURRENT = Parsetree.label_declaration *) =
      {
       pld_name: string loc;
       pld_mutable: mutable_flag;
       pld_type: core_type;
       pld_loc: Location.t;
       pld_attributes: attributes; (* l [@id1] [@id2] : T *)
      }

  (*  { ...; l: T; ... }            (mutable=Immutable)
      { ...; mutable l: T; ... }    (mutable=Mutable)

      Note: T can be a Ptyp_poly.
  *)

  and constructor_declaration (*IF_CURRENT = Parsetree.constructor_declaration *) =
      {
       pcd_name: string loc;
       pcd_args: constructor_arguments;
       pcd_res: core_type option;
       pcd_loc: Location.t;
       pcd_attributes: attributes; (* C [@id1] [@id2] of ... *)
      }

  and constructor_arguments (*IF_CURRENT = Parsetree.constructor_arguments *) =
    | Pcstr_tuple of core_type list
    | Pcstr_record of label_declaration list

  (*
    | C of T1 * ... * Tn     (res = None,    args = Pcstr_tuple [])
    | C: T0                  (res = Some T0, args = [])
    | C: T1 * ... * Tn -> T0 (res = Some T0, args = Pcstr_tuple)
    | C of {...}             (res = None,    args = Pcstr_record)
    | C: {...} -> T0         (res = Some T0, args = Pcstr_record)
    | C of {...} as t        (res = None,    args = Pcstr_record)
  *)

  and type_extension (*IF_CURRENT = Parsetree.type_extension *) =
      {
       ptyext_path: Longident.t loc;
       ptyext_params: (core_type * variance) list;
       ptyext_constructors: extension_constructor list;
       ptyext_private: private_flag;
       ptyext_attributes: attributes;   (* ... [@@id1] [@@id2] *)
      }
  (*
    type t += ...
  *)

  and extension_constructor (*IF_CURRENT = Parsetree.extension_constructor *) =
      {
       pext_name: string loc;
       pext_kind : extension_constructor_kind;
       pext_loc : Location.t;
       pext_attributes: attributes; (* C [@id1] [@id2] of ... *)
      }

  and extension_constructor_kind (*IF_CURRENT = Parsetree.extension_constructor_kind *) =
      Pext_decl of constructor_arguments * core_type option
        (*
           | C of T1 * ... * Tn     ([T1; ...; Tn], None)
           | C: T0                  ([], Some T0)
           | C: T1 * ... * Tn -> T0 ([T1; ...; Tn], Some T0)
         *)
    | Pext_rebind of Longident.t loc
        (*
           | C = D
         *)

  (** {2 Class language} *)

  (* Type expressions for the class language *)

  and class_type (*IF_CURRENT = Parsetree.class_type *) =
      {
       pcty_desc: class_type_desc;
       pcty_loc: Location.t;
       pcty_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and class_type_desc (*IF_CURRENT = Parsetree.class_type_desc *) =
    | Pcty_constr of Longident.t loc * core_type list
          (* c
             ['a1, ..., 'an] c *)
    | Pcty_signature of class_signature
          (* object ... end *)
    | Pcty_arrow of arg_label * core_type * class_type
          (* T -> CT       Simple
             ~l:T -> CT    Labelled l
             ?l:T -> CT    Optional l
           *)
    | Pcty_extension of extension
          (* [%id] *)
    | Pcty_open of override_flag * Longident.t loc * class_type
          (* let open M in CT *)


  and class_signature (*IF_CURRENT = Parsetree.class_signature *) =
      {
       pcsig_self: core_type;
       pcsig_fields: class_type_field list;
      }
  (* object('selfpat) ... end
     object ... end             (self = Ptyp_any)
   *)

  and class_type_field (*IF_CURRENT = Parsetree.class_type_field *) =
      {
       pctf_desc: class_type_field_desc;
       pctf_loc: Location.t;
       pctf_attributes: attributes; (* ... [@@id1] [@@id2] *)
      }

  and class_type_field_desc (*IF_CURRENT = Parsetree.class_type_field_desc *) =
    | Pctf_inherit of class_type
          (* inherit CT *)
    | Pctf_val of (string loc * mutable_flag * virtual_flag * core_type)
          (* val x: T *)
    | Pctf_method  of (string loc * private_flag * virtual_flag * core_type)
          (* method x: T

             Note: T can be a Ptyp_poly.
           *)
    | Pctf_constraint  of (core_type * core_type)
          (* constraint T1 = T2 *)
    | Pctf_attribute of attribute
          (* [@@@id] *)
    | Pctf_extension of extension
          (* [%%id] *)

  and 'a class_infos (*IF_CURRENT = 'a Parsetree.class_infos *) =
      {
       pci_virt: virtual_flag;
       pci_params: (core_type * variance) list;
       pci_name: string loc;
       pci_expr: 'a;
       pci_loc: Location.t;
       pci_attributes: attributes;  (* ... [@@id1] [@@id2] *)
      }
  (* class c = ...
     class ['a1,...,'an] c = ...
     class virtual c = ...

     Also used for "class type" declaration.
  *)

  and class_description = class_type class_infos

  and class_type_declaration = class_type class_infos

  (* Value expressions for the class language *)

  and class_expr (*IF_CURRENT = Parsetree.class_expr *) =
      {
       pcl_desc: class_expr_desc;
       pcl_loc: Location.t;
       pcl_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and class_expr_desc (*IF_CURRENT = Parsetree.class_expr_desc *) =
    | Pcl_constr of Longident.t loc * core_type list
          (* c
             ['a1, ..., 'an] c *)
    | Pcl_structure of class_structure
          (* object ... end *)
    | Pcl_fun of arg_label * expression option * pattern * class_expr
          (* fun P -> CE                          (Simple, None)
             fun ~l:P -> CE                       (Labelled l, None)
             fun ?l:P -> CE                       (Optional l, None)
             fun ?l:(P = E0) -> CE                (Optional l, Some E0)
           *)
    | Pcl_apply of class_expr * (arg_label * expression) list
          (* CE ~l1:E1 ... ~ln:En
             li can be empty (non labeled argument) or start with '?'
             (optional argument).

             Invariant: n > 0
           *)
    | Pcl_let of rec_flag * value_binding list * class_expr
          (* let P1 = E1 and ... and Pn = EN in CE      (flag = Nonrecursive)
             let rec P1 = E1 and ... and Pn = EN in CE  (flag = Recursive)
           *)
    | Pcl_constraint of class_expr * class_type
          (* (CE : CT) *)
    | Pcl_extension of extension
          (* [%id] *)
    | Pcl_open of override_flag * Longident.t loc * class_expr
          (* let open M in CE *)


  and class_structure (*IF_CURRENT = Parsetree.class_structure *) =
      {
       pcstr_self: pattern;
       pcstr_fields: class_field list;
      }
  (* object(selfpat) ... end
     object ... end           (self = Ppat_any)
   *)

  and class_field (*IF_CURRENT = Parsetree.class_field *) =
      {
       pcf_desc: class_field_desc;
       pcf_loc: Location.t;
       pcf_attributes: attributes; (* ... [@@id1] [@@id2] *)
      }

  and class_field_desc (*IF_CURRENT = Parsetree.class_field_desc *) =
    | Pcf_inherit of override_flag * class_expr * string loc option
          (* inherit CE
             inherit CE as x
             inherit! CE
             inherit! CE as x
           *)
    | Pcf_val of (string loc * mutable_flag * class_field_kind)
          (* val x = E
             val virtual x: T
           *)
    | Pcf_method of (string loc * private_flag * class_field_kind)
          (* method x = E            (E can be a Pexp_poly)
             method virtual x: T     (T can be a Ptyp_poly)
           *)
    | Pcf_constraint of (core_type * core_type)
          (* constraint T1 = T2 *)
    | Pcf_initializer of expression
          (* initializer E *)
    | Pcf_attribute of attribute
          (* [@@@id] *)
    | Pcf_extension of extension
          (* [%%id] *)

  and class_field_kind (*IF_CURRENT = Parsetree.class_field_kind *) =
    | Cfk_virtual of core_type
    | Cfk_concrete of override_flag * expression

  and class_declaration = class_expr class_infos

  (** {2 Module language} *)

  (* Type expressions for the module language *)

  and module_type (*IF_CURRENT = Parsetree.module_type *) =
      {
       pmty_desc: module_type_desc;
       pmty_loc: Location.t;
       pmty_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and module_type_desc (*IF_CURRENT = Parsetree.module_type_desc *) =
    | Pmty_ident of Longident.t loc
          (* S *)
    | Pmty_signature of signature
          (* sig ... end *)
    | Pmty_functor of string loc * module_type option * module_type
          (* functor(X : MT1) -> MT2 *)
    | Pmty_with of module_type * with_constraint list
          (* MT with ... *)
    | Pmty_typeof of module_expr
          (* module type of ME *)
    | Pmty_extension of extension
          (* [%id] *)
    | Pmty_alias of Longident.t loc
          (* (module M) *)

  and signature = signature_item list

  and signature_item (*IF_CURRENT = Parsetree.signature_item *) =
      {
       psig_desc: signature_item_desc;
       psig_loc: Location.t;
      }

  and signature_item_desc (*IF_CURRENT = Parsetree.signature_item_desc *) =
    | Psig_value of value_description
          (*
            val x: T
            external x: T = "s1" ... "sn"
           *)
    | Psig_type of rec_flag * type_declaration list
          (* type t1 = ... and ... and tn = ... *)
    | Psig_typext of type_extension
          (* type t1 += ... *)
    | Psig_exception of extension_constructor
          (* exception C of T *)
    | Psig_module of module_declaration
          (* module X : MT *)
    | Psig_recmodule of module_declaration list
          (* module rec X1 : MT1 and ... and Xn : MTn *)
    | Psig_modtype of module_type_declaration
          (* module type S = MT
             module type S *)
    | Psig_open of open_description
          (* open X *)
    | Psig_include of include_description
          (* include MT *)
    | Psig_class of class_description list
          (* class c1 : ... and ... and cn : ... *)
    | Psig_class_type of class_type_declaration list
          (* class type ct1 = ... and ... and ctn = ... *)
    | Psig_attribute of attribute
          (* [@@@id] *)
    | Psig_extension of extension * attributes
          (* [%%id] *)

  and module_declaration (*IF_CURRENT = Parsetree.module_declaration *) =
      {
       pmd_name: string loc;
       pmd_type: module_type;
       pmd_attributes: attributes; (* ... [@@id1] [@@id2] *)
       pmd_loc: Location.t;
      }
  (* S : MT *)

  and module_type_declaration (*IF_CURRENT = Parsetree.module_type_declaration *) =
      {
       pmtd_name: string loc;
       pmtd_type: module_type option;
       pmtd_attributes: attributes; (* ... [@@id1] [@@id2] *)
       pmtd_loc: Location.t;
      }
  (* S = MT
     S       (abstract module type declaration, pmtd_type = None)
  *)

  and open_description (*IF_CURRENT = Parsetree.open_description *) =
      {
       popen_lid: Longident.t loc;
       popen_override: override_flag;
       popen_loc: Location.t;
       popen_attributes: attributes;
      }
  (* open! X - popen_override = Override (silences the 'used identifier
                                shadowing' warning)
     open  X - popen_override = Fresh
   *)

  and 'a include_infos (*IF_CURRENT = 'a Parsetree.include_infos *) =
      {
       pincl_mod: 'a;
       pincl_loc: Location.t;
       pincl_attributes: attributes;
      }

  and include_description = module_type include_infos
  (* include MT *)

  and include_declaration = module_expr include_infos
  (* include ME *)

  and with_constraint (*IF_CURRENT = Parsetree.with_constraint *) =
    | Pwith_type of Longident.t loc * type_declaration
          (* with type X.t = ...

             Note: the last component of the longident must match
             the name of the type_declaration. *)
    | Pwith_module of Longident.t loc * Longident.t loc
          (* with module X.Y = Z *)
    | Pwith_typesubst of type_declaration
          (* with type t := ... *)
    | Pwith_modsubst of string loc * Longident.t loc
          (* with module X := Z *)

  (* Value expressions for the module language *)

  and module_expr (*IF_CURRENT = Parsetree.module_expr *) =
      {
       pmod_desc: module_expr_desc;
       pmod_loc: Location.t;
       pmod_attributes: attributes; (* ... [@id1] [@id2] *)
      }

  and module_expr_desc (*IF_CURRENT = Parsetree.module_expr_desc *) =
    | Pmod_ident of Longident.t loc
          (* X *)
    | Pmod_structure of structure
          (* struct ... end *)
    | Pmod_functor of string loc * module_type option * module_expr
          (* functor(X : MT1) -> ME *)
    | Pmod_apply of module_expr * module_expr
          (* ME1(ME2) *)
    | Pmod_constraint of module_expr * module_type
          (* (ME : MT) *)
    | Pmod_unpack of expression
          (* (val E) *)
    | Pmod_extension of extension
          (* [%id] *)

  and structure = structure_item list

  and structure_item (*IF_CURRENT = Parsetree.structure_item *) =
      {
       pstr_desc: structure_item_desc;
       pstr_loc: Location.t;
      }

  and structure_item_desc (*IF_CURRENT = Parsetree.structure_item_desc *) =
    | Pstr_eval of expression * attributes
          (* E *)
    | Pstr_value of rec_flag * value_binding list
          (* let P1 = E1 and ... and Pn = EN       (flag = Nonrecursive)
             let rec P1 = E1 and ... and Pn = EN   (flag = Recursive)
           *)
    | Pstr_primitive of value_description
          (*  val x: T
              external x: T = "s1" ... "sn" *)
    | Pstr_type of rec_flag * type_declaration list
          (* type t1 = ... and ... and tn = ... *)
    | Pstr_typext of type_extension
          (* type t1 += ... *)
    | Pstr_exception of extension_constructor
          (* exception C of T
             exception C = M.X *)
    | Pstr_module of module_binding
          (* module X = ME *)
    | Pstr_recmodule of module_binding list
          (* module rec X1 = ME1 and ... and Xn = MEn *)
    | Pstr_modtype of module_type_declaration
          (* module type S = MT *)
    | Pstr_open of open_description
          (* open X *)
    | Pstr_class of class_declaration list
          (* class c1 = ... and ... and cn = ... *)
    | Pstr_class_type of class_type_declaration list
          (* class type ct1 = ... and ... and ctn = ... *)
    | Pstr_include of include_declaration
          (* include ME *)
    | Pstr_attribute of attribute
          (* [@@@id] *)
    | Pstr_extension of extension * attributes
          (* [%%id] *)

  and value_binding (*IF_CURRENT = Parsetree.value_binding *) =
    {
      pvb_pat: pattern;
      pvb_expr: expression;
      pvb_attributes: attributes;
      pvb_loc: Location.t;
    }

  and module_binding (*IF_CURRENT = Parsetree.module_binding *) =
      {
       pmb_name: string loc;
       pmb_expr: module_expr;
       pmb_attributes: attributes;
       pmb_loc: Location.t;
      }
  (* X = ME *)

  (** {2 Toplevel} *)

  (* Toplevel phrases *)

  type toplevel_phrase (*IF_CURRENT = Parsetree.toplevel_phrase *) =
    | Ptop_def of structure
    | Ptop_dir of string * directive_argument
       (* #use, #load ... *)

  and directive_argument (*IF_CURRENT = Parsetree.directive_argument *) =
    | Pdir_none
    | Pdir_string of string
    | Pdir_int of string * char option
    | Pdir_ident of Longident.t
    | Pdir_bool of bool

end

module Docstrings : sig
  (** {3 Docstrings} *)

  (** Documentation comments *)
  type docstring

  (** Create a docstring *)
  val docstring : string -> Location.t -> docstring

  (** Get the text of a docstring *)
  val docstring_body : docstring -> string

  (** Get the location of a docstring *)
  val docstring_loc : docstring -> Location.t

  (** {3 Items}

      The {!docs} type represents documentation attached to an item. *)

  type docs =
    { docs_pre: docstring option;
      docs_post: docstring option; }

  val empty_docs : docs

  val docs_attr : docstring -> Parsetree.attribute

  (** Convert item documentation to attributes and add them to an
      attribute list *)
  val add_docs_attrs : docs -> Parsetree.attributes -> Parsetree.attributes

  (** {3 Fields and constructors}

      The {!info} type represents documentation attached to a field or
      constructor. *)

  type info = docstring option

  val empty_info : info

  val info_attr : docstring -> Parsetree.attribute

  (** Convert field info to attributes and add them to an
      attribute list *)
  val add_info_attrs : info -> Parsetree.attributes -> Parsetree.attributes

  (** {3 Unattached comments}

      The {!text} type represents documentation which is not attached to
      anything. *)

  type text = docstring list

  val empty_text : text

  val text_attr : docstring -> Parsetree.attribute

  (** Convert text to attributes and add them to an attribute list *)
  val add_text_attrs : text -> Parsetree.attributes -> Parsetree.attributes

end = struct
  open Location

  (* Docstrings *)

  type docstring =
    { ds_body: string;
      ds_loc: Location.t;
    }

  (* Docstring constructors and destructors *)

  let docstring body loc =
    let ds =
      { ds_body = body;
        ds_loc = loc;
      }
    in
    ds

  let docstring_body ds = ds.ds_body

  let docstring_loc ds = ds.ds_loc

  (* Docstrings attached to items *)

  type docs =
    { docs_pre: docstring option;
      docs_post: docstring option; }

  let empty_docs = { docs_pre = None; docs_post = None }

  let doc_loc = {txt = "ocaml.doc"; loc = Location.none}

  let docs_attr ds =
    let open Parsetree in
    let exp =
      { pexp_desc = Pexp_constant (Pconst_string(ds.ds_body, None));
        pexp_loc = ds.ds_loc;
        pexp_attributes = []; }
    in
    let item =
      { pstr_desc = Pstr_eval (exp, []); pstr_loc = exp.pexp_loc }
    in
      (doc_loc, PStr [item])

  let add_docs_attrs docs attrs =
    let attrs =
      match docs.docs_pre with
      | None | Some { ds_body=""; _ } -> attrs
      | Some ds -> docs_attr ds :: attrs
    in
    let attrs =
      match docs.docs_post with
      | None | Some { ds_body=""; _ } -> attrs
      | Some ds -> attrs @ [docs_attr ds]
    in
    attrs

  (* Docstrings attached to constructors or fields *)

  type info = docstring option

  let empty_info = None

  let info_attr = docs_attr

  let add_info_attrs info attrs =
    match info with
    | None | Some {ds_body=""; _} -> attrs
    | Some ds -> attrs @ [info_attr ds]

  (* Docstrings not attached to a specific item *)

  type text = docstring list

  let empty_text = []

  let text_loc = {txt = "ocaml.text"; loc = Location.none}

  let text_attr ds =
    let open Parsetree in
    let exp =
      { pexp_desc = Pexp_constant (Pconst_string(ds.ds_body, None));
        pexp_loc = ds.ds_loc;
        pexp_attributes = []; }
    in
    let item =
      { pstr_desc = Pstr_eval (exp, []); pstr_loc = exp.pexp_loc }
    in
      (text_loc, PStr [item])

  let add_text_attrs dsl attrs =
    let fdsl = List.filter (function {ds_body=""; _} -> false| _ ->true) dsl in
    (List.map text_attr fdsl) @ attrs

end

module Ast_helper : sig

  (** Helpers to produce Parsetree fragments *)

  open Asttypes
  open Docstrings
  open Parsetree

  type lid = Longident.t loc
  type str = string loc
  type loc = Location.t
  type attrs = attribute list

  (** {2 Default locations} *)

  val default_loc: loc ref
      (** Default value for all optional location arguments. *)

  val with_default_loc: loc -> (unit -> 'a) -> 'a
      (** Set the [default_loc] within the scope of the execution
          of the provided function. *)

  (** {2 Constants} *)

  module Const : sig
    val char : char -> constant
    val string : ?quotation_delimiter:string -> string -> constant
    val integer : ?suffix:char -> string -> constant
    val int : ?suffix:char -> int -> constant
    val int32 : ?suffix:char -> int32 -> constant
    val int64 : ?suffix:char -> int64 -> constant
    val nativeint : ?suffix:char -> nativeint -> constant
    val float : ?suffix:char -> string -> constant
  end

  (** {2 Core language} *)

  (** Type expressions *)
  module Typ :
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> core_type_desc -> core_type
      val attr: core_type -> attribute -> core_type

      val any: ?loc:loc -> ?attrs:attrs -> unit -> core_type
      val var: ?loc:loc -> ?attrs:attrs -> string -> core_type
      val arrow: ?loc:loc -> ?attrs:attrs -> arg_label -> core_type -> core_type
                 -> core_type
      val tuple: ?loc:loc -> ?attrs:attrs -> core_type list -> core_type
      val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> core_type
      val object_: ?loc:loc -> ?attrs:attrs ->
                    (str * attributes * core_type) list -> closed_flag ->
                    core_type
      val class_: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> core_type
      val alias: ?loc:loc -> ?attrs:attrs -> core_type -> string -> core_type
      val variant: ?loc:loc -> ?attrs:attrs -> row_field list -> closed_flag
                   -> label list option -> core_type
      val poly: ?loc:loc -> ?attrs:attrs -> str list -> core_type -> core_type
      val package: ?loc:loc -> ?attrs:attrs -> lid -> (lid * core_type) list
                   -> core_type
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> core_type

      val force_poly: core_type -> core_type

      val varify_constructors: str list -> core_type -> core_type
      (** [varify_constructors newtypes te] is type expression [te], of which
          any of nullary type constructor [tc] is replaced by type variable of
          the same name, if [tc]'s name appears in [newtypes].
          Raise [Syntaxerr.Variable_in_scope] if any type variable inside [te]
          appears in [newtypes].
          @since 4.05
       *)
    end

  (** Patterns *)
  module Pat:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> pattern_desc -> pattern
      val attr:pattern -> attribute -> pattern

      val any: ?loc:loc -> ?attrs:attrs -> unit -> pattern
      val var: ?loc:loc -> ?attrs:attrs -> str -> pattern
      val alias: ?loc:loc -> ?attrs:attrs -> pattern -> str -> pattern
      val constant: ?loc:loc -> ?attrs:attrs -> constant -> pattern
      val interval: ?loc:loc -> ?attrs:attrs -> constant -> constant -> pattern
      val tuple: ?loc:loc -> ?attrs:attrs -> pattern list -> pattern
      val construct: ?loc:loc -> ?attrs:attrs -> lid -> pattern option -> pattern
      val variant: ?loc:loc -> ?attrs:attrs -> label -> pattern option -> pattern
      val record: ?loc:loc -> ?attrs:attrs -> (lid * pattern) list -> closed_flag
                  -> pattern
      val array: ?loc:loc -> ?attrs:attrs -> pattern list -> pattern
      val or_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern -> pattern
      val constraint_: ?loc:loc -> ?attrs:attrs -> pattern -> core_type -> pattern
      val type_: ?loc:loc -> ?attrs:attrs -> lid -> pattern
      val lazy_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern
      val unpack: ?loc:loc -> ?attrs:attrs -> str -> pattern
      val open_: ?loc:loc -> ?attrs:attrs  -> lid -> pattern -> pattern
      val exception_: ?loc:loc -> ?attrs:attrs -> pattern -> pattern
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> pattern
    end

  (** Expressions *)
  module Exp:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> expression_desc -> expression
      val attr: expression -> attribute -> expression

      val ident: ?loc:loc -> ?attrs:attrs -> lid -> expression
      val constant: ?loc:loc -> ?attrs:attrs -> constant -> expression
      val let_: ?loc:loc -> ?attrs:attrs -> rec_flag -> value_binding list
                -> expression -> expression
      val fun_: ?loc:loc -> ?attrs:attrs -> arg_label -> expression option
                -> pattern -> expression -> expression
      val function_: ?loc:loc -> ?attrs:attrs -> case list -> expression
      val apply: ?loc:loc -> ?attrs:attrs -> expression
                 -> (arg_label * expression) list -> expression
      val match_: ?loc:loc -> ?attrs:attrs -> expression -> case list
                  -> expression
      val try_: ?loc:loc -> ?attrs:attrs -> expression -> case list -> expression
      val tuple: ?loc:loc -> ?attrs:attrs -> expression list -> expression
      val construct: ?loc:loc -> ?attrs:attrs -> lid -> expression option
                     -> expression
      val variant: ?loc:loc -> ?attrs:attrs -> label -> expression option
                   -> expression
      val record: ?loc:loc -> ?attrs:attrs -> (lid * expression) list
                  -> expression option -> expression
      val field: ?loc:loc -> ?attrs:attrs -> expression -> lid -> expression
      val setfield: ?loc:loc -> ?attrs:attrs -> expression -> lid -> expression
                    -> expression
      val array: ?loc:loc -> ?attrs:attrs -> expression list -> expression
      val ifthenelse: ?loc:loc -> ?attrs:attrs -> expression -> expression
                      -> expression option -> expression
      val sequence: ?loc:loc -> ?attrs:attrs -> expression -> expression
                    -> expression
      val while_: ?loc:loc -> ?attrs:attrs -> expression -> expression
                  -> expression
      val for_: ?loc:loc -> ?attrs:attrs -> pattern -> expression -> expression
                -> direction_flag -> expression -> expression
      val coerce: ?loc:loc -> ?attrs:attrs -> expression -> core_type option
                  -> core_type -> expression
      val constraint_: ?loc:loc -> ?attrs:attrs -> expression -> core_type
                       -> expression
      val send: ?loc:loc -> ?attrs:attrs -> expression -> str -> expression
      val new_: ?loc:loc -> ?attrs:attrs -> lid -> expression
      val setinstvar: ?loc:loc -> ?attrs:attrs -> str -> expression -> expression
      val override: ?loc:loc -> ?attrs:attrs -> (str * expression) list
                    -> expression
      val letmodule: ?loc:loc -> ?attrs:attrs -> str -> module_expr -> expression
                     -> expression
      val letexception:
        ?loc:loc -> ?attrs:attrs -> extension_constructor -> expression
        -> expression
      val assert_: ?loc:loc -> ?attrs:attrs -> expression -> expression
      val lazy_: ?loc:loc -> ?attrs:attrs -> expression -> expression
      val poly: ?loc:loc -> ?attrs:attrs -> expression -> core_type option
                -> expression
      val object_: ?loc:loc -> ?attrs:attrs -> class_structure -> expression
      val newtype: ?loc:loc -> ?attrs:attrs -> str -> expression -> expression
      val pack: ?loc:loc -> ?attrs:attrs -> module_expr -> expression
      val open_: ?loc:loc -> ?attrs:attrs -> override_flag -> lid -> expression
                 -> expression
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> expression
      val unreachable: ?loc:loc -> ?attrs:attrs -> unit -> expression

      val case: pattern -> ?guard:expression -> expression -> case
    end

  (** Value declarations *)
  module Val:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs ->
        ?prim:string list -> str -> core_type -> value_description
    end

  (** Type declarations *)
  module Type:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        ?params:(core_type * variance) list ->
        ?cstrs:(core_type * core_type * loc) list ->
        ?kind:type_kind -> ?priv:private_flag -> ?manifest:core_type -> str ->
        type_declaration

      val constructor: ?loc:loc -> ?attrs:attrs -> ?info:info ->
        ?args:constructor_arguments -> ?res:core_type -> str ->
        constructor_declaration
      val field: ?loc:loc -> ?attrs:attrs -> ?info:info ->
        ?mut:mutable_flag -> str -> core_type -> label_declaration
    end

  (** Type extensions *)
  module Te:
    sig
      val mk: ?attrs:attrs -> ?docs:docs ->
        ?params:(core_type * variance) list -> ?priv:private_flag ->
        lid -> extension_constructor list -> type_extension

      val constructor: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->
        str -> extension_constructor_kind -> extension_constructor

      val decl: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->
        ?args:constructor_arguments -> ?res:core_type -> str ->
        extension_constructor
      val rebind: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?info:info ->
        str -> lid -> extension_constructor
    end

  (** {2 Module language} *)

  (** Module type expressions *)
  module Mty:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> module_type_desc -> module_type
      val attr: module_type -> attribute -> module_type

      val ident: ?loc:loc -> ?attrs:attrs -> lid -> module_type
      val alias: ?loc:loc -> ?attrs:attrs -> lid -> module_type
      val signature: ?loc:loc -> ?attrs:attrs -> signature -> module_type
      val functor_: ?loc:loc -> ?attrs:attrs ->
        str -> module_type option -> module_type -> module_type
      val with_: ?loc:loc -> ?attrs:attrs -> module_type ->
        with_constraint list -> module_type
      val typeof_: ?loc:loc -> ?attrs:attrs -> module_expr -> module_type
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> module_type
    end

  (** Module expressions *)
  module Mod:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> module_expr_desc -> module_expr
      val attr: module_expr -> attribute -> module_expr

      val ident: ?loc:loc -> ?attrs:attrs -> lid -> module_expr
      val structure: ?loc:loc -> ?attrs:attrs -> structure -> module_expr
      val functor_: ?loc:loc -> ?attrs:attrs ->
        str -> module_type option -> module_expr -> module_expr
      val apply: ?loc:loc -> ?attrs:attrs -> module_expr -> module_expr ->
        module_expr
      val constraint_: ?loc:loc -> ?attrs:attrs -> module_expr -> module_type ->
        module_expr
      val unpack: ?loc:loc -> ?attrs:attrs -> expression -> module_expr
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> module_expr
    end

  (** Signature items *)
  module Sig:
    sig
      val mk: ?loc:loc -> signature_item_desc -> signature_item

      val value: ?loc:loc -> value_description -> signature_item
      val type_: ?loc:loc -> rec_flag -> type_declaration list -> signature_item
      val type_extension: ?loc:loc -> type_extension -> signature_item
      val exception_: ?loc:loc -> extension_constructor -> signature_item
      val module_: ?loc:loc -> module_declaration -> signature_item
      val rec_module: ?loc:loc -> module_declaration list -> signature_item
      val modtype: ?loc:loc -> module_type_declaration -> signature_item
      val open_: ?loc:loc -> open_description -> signature_item
      val include_: ?loc:loc -> include_description -> signature_item
      val class_: ?loc:loc -> class_description list -> signature_item
      val class_type: ?loc:loc -> class_type_declaration list -> signature_item
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> signature_item
      val attribute: ?loc:loc -> attribute -> signature_item
      val text: text -> signature_item list
    end

  (** Structure items *)
  module Str:
    sig
      val mk: ?loc:loc -> structure_item_desc -> structure_item

      val eval: ?loc:loc -> ?attrs:attributes -> expression -> structure_item
      val value: ?loc:loc -> rec_flag -> value_binding list -> structure_item
      val primitive: ?loc:loc -> value_description -> structure_item
      val type_: ?loc:loc -> rec_flag -> type_declaration list -> structure_item
      val type_extension: ?loc:loc -> type_extension -> structure_item
      val exception_: ?loc:loc -> extension_constructor -> structure_item
      val module_: ?loc:loc -> module_binding -> structure_item
      val rec_module: ?loc:loc -> module_binding list -> structure_item
      val modtype: ?loc:loc -> module_type_declaration -> structure_item
      val open_: ?loc:loc -> open_description -> structure_item
      val class_: ?loc:loc -> class_declaration list -> structure_item
      val class_type: ?loc:loc -> class_type_declaration list -> structure_item
      val include_: ?loc:loc -> include_declaration -> structure_item
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> structure_item
      val attribute: ?loc:loc -> attribute -> structure_item
      val text: text -> structure_item list
    end

  (** Module declarations *)
  module Md:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        str -> module_type -> module_declaration
    end

  (** Module type declarations *)
  module Mtd:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        ?typ:module_type -> str -> module_type_declaration
    end

  (** Module bindings *)
  module Mb:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        str -> module_expr -> module_binding
    end

  (** Opens *)
  module Opn:
    sig
      val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs ->
        ?override:override_flag -> lid -> open_description
    end

  (** Includes *)
  module Incl:
    sig
      val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs -> 'a -> 'a include_infos
    end

  (** Value bindings *)
  module Vb:
    sig
      val mk: ?loc: loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        pattern -> expression -> value_binding
    end


  (** {2 Class language} *)

  (** Class type expressions *)
  module Cty:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> class_type_desc -> class_type
      val attr: class_type -> attribute -> class_type

      val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> class_type
      val signature: ?loc:loc -> ?attrs:attrs -> class_signature -> class_type
      val arrow: ?loc:loc -> ?attrs:attrs -> arg_label -> core_type ->
        class_type -> class_type
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_type
      val open_: ?loc:loc -> ?attrs:attrs -> override_flag -> lid -> class_type
        -> class_type
    end

  (** Class type fields *)
  module Ctf:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs ->
        class_type_field_desc -> class_type_field
      val attr: class_type_field -> attribute -> class_type_field

      val inherit_: ?loc:loc -> ?attrs:attrs -> class_type -> class_type_field
      val val_: ?loc:loc -> ?attrs:attrs -> str -> mutable_flag ->
        virtual_flag -> core_type -> class_type_field
      val method_: ?loc:loc -> ?attrs:attrs -> str -> private_flag ->
        virtual_flag -> core_type -> class_type_field
      val constraint_: ?loc:loc -> ?attrs:attrs -> core_type -> core_type ->
        class_type_field
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_type_field
      val attribute: ?loc:loc -> attribute -> class_type_field
      val text: text -> class_type_field list
    end

  (** Class expressions *)
  module Cl:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> class_expr_desc -> class_expr
      val attr: class_expr -> attribute -> class_expr

      val constr: ?loc:loc -> ?attrs:attrs -> lid -> core_type list -> class_expr
      val structure: ?loc:loc -> ?attrs:attrs -> class_structure -> class_expr
      val fun_: ?loc:loc -> ?attrs:attrs -> arg_label -> expression option ->
        pattern -> class_expr -> class_expr
      val apply: ?loc:loc -> ?attrs:attrs -> class_expr ->
        (arg_label * expression) list -> class_expr
      val let_: ?loc:loc -> ?attrs:attrs -> rec_flag -> value_binding list ->
        class_expr -> class_expr
      val constraint_: ?loc:loc -> ?attrs:attrs -> class_expr -> class_type ->
        class_expr
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_expr
      val open_: ?loc:loc -> ?attrs:attrs -> override_flag -> lid -> class_expr
        -> class_expr
    end

  (** Class fields *)
  module Cf:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> class_field_desc ->
        class_field
      val attr: class_field -> attribute -> class_field

      val inherit_: ?loc:loc -> ?attrs:attrs -> override_flag -> class_expr ->
        str option -> class_field
      val val_: ?loc:loc -> ?attrs:attrs -> str -> mutable_flag ->
        class_field_kind -> class_field
      val method_: ?loc:loc -> ?attrs:attrs -> str -> private_flag ->
        class_field_kind -> class_field
      val constraint_: ?loc:loc -> ?attrs:attrs -> core_type -> core_type ->
        class_field
      val initializer_: ?loc:loc -> ?attrs:attrs -> expression -> class_field
      val extension: ?loc:loc -> ?attrs:attrs -> extension -> class_field
      val attribute: ?loc:loc -> attribute -> class_field
      val text: text -> class_field list

      val virtual_: core_type -> class_field_kind
      val concrete: override_flag -> expression -> class_field_kind

    end

  (** Classes *)
  module Ci:
    sig
      val mk: ?loc:loc -> ?attrs:attrs -> ?docs:docs -> ?text:text ->
        ?virt:virtual_flag -> ?params:(core_type * variance) list ->
        str -> 'a -> 'a class_infos
    end

  (** Class signatures *)
  module Csig:
    sig
      val mk: core_type -> class_type_field list -> class_signature
    end

  (** Class structures *)
  module Cstr:
    sig
      val mk: pattern -> class_field list -> class_structure
    end

end = struct
  (** Helpers to produce Parsetree fragments *)

  open Asttypes
  open Parsetree
  open Docstrings

  type lid = Longident.t loc
  type str = string loc
  type loc = Location.t
  type attrs = attribute list

  let default_loc = ref Location.none

  let with_default_loc l f =
    let old = !default_loc in
    default_loc := l;
    try let r = f () in default_loc := old; r
    with exn -> default_loc := old; raise exn

  module Const = struct
    let integer ?suffix i = Pconst_integer (i, suffix)
    let int ?suffix i = integer ?suffix (string_of_int i)
    let int32 ?(suffix='l') i = integer ~suffix (Int32.to_string i)
    let int64 ?(suffix='L') i = integer ~suffix (Int64.to_string i)
    let nativeint ?(suffix='n') i = integer ~suffix (Nativeint.to_string i)
    let float ?suffix f = Pconst_float (f, suffix)
    let char c = Pconst_char c
    let string ?quotation_delimiter s = Pconst_string (s, quotation_delimiter)
  end

  module Typ = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {ptyp_desc = d; ptyp_loc = loc; ptyp_attributes = attrs}
    let attr d a = {d with ptyp_attributes = d.ptyp_attributes @ [a]}

    let any ?loc ?attrs () = mk ?loc ?attrs Ptyp_any
    let var ?loc ?attrs a = mk ?loc ?attrs (Ptyp_var a)
    let arrow ?loc ?attrs a b c = mk ?loc ?attrs (Ptyp_arrow (a, b, c))
    let tuple ?loc ?attrs a = mk ?loc ?attrs (Ptyp_tuple a)
    let constr ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_constr (a, b))
    let object_ ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_object (a, b))
    let class_ ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_class (a, b))
    let alias ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_alias (a, b))
    let variant ?loc ?attrs a b c = mk ?loc ?attrs (Ptyp_variant (a, b, c))
    let poly ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_poly (a, b))
    let package ?loc ?attrs a b = mk ?loc ?attrs (Ptyp_package (a, b))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Ptyp_extension a)

    let force_poly t =
      match t.ptyp_desc with
      | Ptyp_poly _ -> t
      | _ -> poly ~loc:t.ptyp_loc [] t (* -> ghost? *)

    let varify_constructors var_names t =
      let check_variable vl loc v =
        if List.mem v vl then
          raise Syntaxerr.(Error(Variable_in_scope(loc,v))) in
      let var_names = List.map (fun v -> v.txt) var_names in
      let rec loop t =
        let desc =
          match t.ptyp_desc with
          | Ptyp_any -> Ptyp_any
          | Ptyp_var x ->
              check_variable var_names t.ptyp_loc x;
              Ptyp_var x
          | Ptyp_arrow (label,core_type,core_type') ->
              Ptyp_arrow(label, loop core_type, loop core_type')
          | Ptyp_tuple lst -> Ptyp_tuple (List.map loop lst)
          | Ptyp_constr( { txt = Longident.Lident s; _ }, [])
            when List.mem s var_names ->
              Ptyp_var s
          | Ptyp_constr(longident, lst) ->
              Ptyp_constr(longident, List.map loop lst)
          | Ptyp_object (lst, o) ->
              Ptyp_object
                (List.map (fun (s, attrs, t) -> (s, attrs, loop t)) lst, o)
          | Ptyp_class (longident, lst) ->
              Ptyp_class (longident, List.map loop lst)
          | Ptyp_alias(core_type, string) ->
              check_variable var_names t.ptyp_loc string;
              Ptyp_alias(loop core_type, string)
          | Ptyp_variant(row_field_list, flag, lbl_lst_option) ->
              Ptyp_variant(List.map loop_row_field row_field_list,
                           flag, lbl_lst_option)
          | Ptyp_poly(string_lst, core_type) ->
            List.iter (fun v ->
              check_variable var_names t.ptyp_loc v.txt) string_lst;
              Ptyp_poly(string_lst, loop core_type)
          | Ptyp_package(longident,lst) ->
              Ptyp_package(longident,List.map (fun (n,typ) -> (n,loop typ) ) lst)
          | Ptyp_extension (s, arg) ->
              Ptyp_extension (s, arg)
        in
        {t with ptyp_desc = desc}
      and loop_row_field  =
        function
          | Rtag(label,attrs,flag,lst) ->
              Rtag(label,attrs,flag,List.map loop lst)
          | Rinherit t ->
              Rinherit (loop t)
      in
      loop t

  end

  module Pat = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {ppat_desc = d; ppat_loc = loc; ppat_attributes = attrs}
    let attr d a = {d with ppat_attributes = d.ppat_attributes @ [a]}

    let any ?loc ?attrs () = mk ?loc ?attrs Ppat_any
    let var ?loc ?attrs a = mk ?loc ?attrs (Ppat_var a)
    let alias ?loc ?attrs a b = mk ?loc ?attrs (Ppat_alias (a, b))
    let constant ?loc ?attrs a = mk ?loc ?attrs (Ppat_constant a)
    let interval ?loc ?attrs a b = mk ?loc ?attrs (Ppat_interval (a, b))
    let tuple ?loc ?attrs a = mk ?loc ?attrs (Ppat_tuple a)
    let construct ?loc ?attrs a b = mk ?loc ?attrs (Ppat_construct (a, b))
    let variant ?loc ?attrs a b = mk ?loc ?attrs (Ppat_variant (a, b))
    let record ?loc ?attrs a b = mk ?loc ?attrs (Ppat_record (a, b))
    let array ?loc ?attrs a = mk ?loc ?attrs (Ppat_array a)
    let or_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_or (a, b))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_constraint (a, b))
    let type_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_type a)
    let lazy_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_lazy a)
    let unpack ?loc ?attrs a = mk ?loc ?attrs (Ppat_unpack a)
    let open_ ?loc ?attrs a b = mk ?loc ?attrs (Ppat_open (a, b))
    let exception_ ?loc ?attrs a = mk ?loc ?attrs (Ppat_exception a)
    let extension ?loc ?attrs a = mk ?loc ?attrs (Ppat_extension a)
  end

  module Exp = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {pexp_desc = d; pexp_loc = loc; pexp_attributes = attrs}
    let attr d a = {d with pexp_attributes = d.pexp_attributes @ [a]}

    let ident ?loc ?attrs a = mk ?loc ?attrs (Pexp_ident a)
    let constant ?loc ?attrs a = mk ?loc ?attrs (Pexp_constant a)
    let let_ ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_let (a, b, c))
    let fun_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pexp_fun (a, b, c, d))
    let function_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_function a)
    let apply ?loc ?attrs a b = mk ?loc ?attrs (Pexp_apply (a, b))
    let match_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_match (a, b))
    let try_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_try (a, b))
    let tuple ?loc ?attrs a = mk ?loc ?attrs (Pexp_tuple a)
    let construct ?loc ?attrs a b = mk ?loc ?attrs (Pexp_construct (a, b))
    let variant ?loc ?attrs a b = mk ?loc ?attrs (Pexp_variant (a, b))
    let record ?loc ?attrs a b = mk ?loc ?attrs (Pexp_record (a, b))
    let field ?loc ?attrs a b = mk ?loc ?attrs (Pexp_field (a, b))
    let setfield ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_setfield (a, b, c))
    let array ?loc ?attrs a = mk ?loc ?attrs (Pexp_array a)
    let ifthenelse ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_ifthenelse (a, b, c))
    let sequence ?loc ?attrs a b = mk ?loc ?attrs (Pexp_sequence (a, b))
    let while_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_while (a, b))
    let for_ ?loc ?attrs a b c d e = mk ?loc ?attrs (Pexp_for (a, b, c, d, e))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pexp_constraint (a, b))
    let coerce ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_coerce (a, b, c))
    let send ?loc ?attrs a b = mk ?loc ?attrs (Pexp_send (a, b))
    let new_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_new a)
    let setinstvar ?loc ?attrs a b = mk ?loc ?attrs (Pexp_setinstvar (a, b))
    let override ?loc ?attrs a = mk ?loc ?attrs (Pexp_override a)
    let letmodule ?loc ?attrs a b c= mk ?loc ?attrs (Pexp_letmodule (a, b, c))
    let letexception ?loc ?attrs a b = mk ?loc ?attrs (Pexp_letexception (a, b))
    let assert_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_assert a)
    let lazy_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_lazy a)
    let poly ?loc ?attrs a b = mk ?loc ?attrs (Pexp_poly (a, b))
    let object_ ?loc ?attrs a = mk ?loc ?attrs (Pexp_object a)
    let newtype ?loc ?attrs a b = mk ?loc ?attrs (Pexp_newtype (a, b))
    let pack ?loc ?attrs a = mk ?loc ?attrs (Pexp_pack a)
    let open_ ?loc ?attrs a b c = mk ?loc ?attrs (Pexp_open (a, b, c))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pexp_extension a)
    let unreachable ?loc ?attrs () = mk ?loc ?attrs Pexp_unreachable

    let case lhs ?guard rhs =
      {
       pc_lhs = lhs;
       pc_guard = guard;
       pc_rhs = rhs;
      }
  end

  module Mty = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {pmty_desc = d; pmty_loc = loc; pmty_attributes = attrs}
    let attr d a = {d with pmty_attributes = d.pmty_attributes @ [a]}

    let ident ?loc ?attrs a = mk ?loc ?attrs (Pmty_ident a)
    let alias ?loc ?attrs a = mk ?loc ?attrs (Pmty_alias a)
    let signature ?loc ?attrs a = mk ?loc ?attrs (Pmty_signature a)
    let functor_ ?loc ?attrs a b c = mk ?loc ?attrs (Pmty_functor (a, b, c))
    let with_ ?loc ?attrs a b = mk ?loc ?attrs (Pmty_with (a, b))
    let typeof_ ?loc ?attrs a = mk ?loc ?attrs (Pmty_typeof a)
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pmty_extension a)
  end

  module Mod = struct
  let mk ?(loc = !default_loc) ?(attrs = []) d =
    {pmod_desc = d; pmod_loc = loc; pmod_attributes = attrs}
    let attr d a = {d with pmod_attributes = d.pmod_attributes @ [a]}

    let ident ?loc ?attrs x = mk ?loc ?attrs (Pmod_ident x)
    let structure ?loc ?attrs x = mk ?loc ?attrs (Pmod_structure x)
    let functor_ ?loc ?attrs arg arg_ty body =
      mk ?loc ?attrs (Pmod_functor (arg, arg_ty, body))
    let apply ?loc ?attrs m1 m2 = mk ?loc ?attrs (Pmod_apply (m1, m2))
    let constraint_ ?loc ?attrs m mty = mk ?loc ?attrs (Pmod_constraint (m, mty))
    let unpack ?loc ?attrs e = mk ?loc ?attrs (Pmod_unpack e)
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pmod_extension a)
  end

  module Sig = struct
    let mk ?(loc = !default_loc) d = {psig_desc = d; psig_loc = loc}

    let value ?loc a = mk ?loc (Psig_value a)
    let type_ ?loc rec_flag a = mk ?loc (Psig_type (rec_flag, a))
    let type_extension ?loc a = mk ?loc (Psig_typext a)
    let exception_ ?loc a = mk ?loc (Psig_exception a)
    let module_ ?loc a = mk ?loc (Psig_module a)
    let rec_module ?loc a = mk ?loc (Psig_recmodule a)
    let modtype ?loc a = mk ?loc (Psig_modtype a)
    let open_ ?loc a = mk ?loc (Psig_open a)
    let include_ ?loc a = mk ?loc (Psig_include a)
    let class_ ?loc a = mk ?loc (Psig_class a)
    let class_type ?loc a = mk ?loc (Psig_class_type a)
    let extension ?loc ?(attrs = []) a = mk ?loc (Psig_extension (a, attrs))
    let attribute ?loc a = mk ?loc (Psig_attribute a)
    let text txt =
      let f_txt = List.filter (fun ds -> docstring_body ds <> "") txt in
      List.map
        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
        f_txt
  end

  module Str = struct
    let mk ?(loc = !default_loc) d = {pstr_desc = d; pstr_loc = loc}

    let eval ?loc ?(attrs = []) a = mk ?loc (Pstr_eval (a, attrs))
    let value ?loc a b = mk ?loc (Pstr_value (a, b))
    let primitive ?loc a = mk ?loc (Pstr_primitive a)
    let type_ ?loc rec_flag a = mk ?loc (Pstr_type (rec_flag, a))
    let type_extension ?loc a = mk ?loc (Pstr_typext a)
    let exception_ ?loc a = mk ?loc (Pstr_exception a)
    let module_ ?loc a = mk ?loc (Pstr_module a)
    let rec_module ?loc a = mk ?loc (Pstr_recmodule a)
    let modtype ?loc a = mk ?loc (Pstr_modtype a)
    let open_ ?loc a = mk ?loc (Pstr_open a)
    let class_ ?loc a = mk ?loc (Pstr_class a)
    let class_type ?loc a = mk ?loc (Pstr_class_type a)
    let include_ ?loc a = mk ?loc (Pstr_include a)
    let extension ?loc ?(attrs = []) a = mk ?loc (Pstr_extension (a, attrs))
    let attribute ?loc a = mk ?loc (Pstr_attribute a)
    let text txt =
      let f_txt = List.filter (fun ds -> docstring_body ds <> "") txt in
      List.map
        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
        f_txt
  end

  module Cl = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {
       pcl_desc = d;
       pcl_loc = loc;
       pcl_attributes = attrs;
      }
    let attr d a = {d with pcl_attributes = d.pcl_attributes @ [a]}

    let constr ?loc ?attrs a b = mk ?loc ?attrs (Pcl_constr (a, b))
    let structure ?loc ?attrs a = mk ?loc ?attrs (Pcl_structure a)
    let fun_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pcl_fun (a, b, c, d))
    let apply ?loc ?attrs a b = mk ?loc ?attrs (Pcl_apply (a, b))
    let let_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcl_let (a, b, c))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pcl_constraint (a, b))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pcl_extension a)
    let open_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcl_open (a, b, c))
  end

  module Cty = struct
    let mk ?(loc = !default_loc) ?(attrs = []) d =
      {
       pcty_desc = d;
       pcty_loc = loc;
       pcty_attributes = attrs;
      }
    let attr d a = {d with pcty_attributes = d.pcty_attributes @ [a]}

    let constr ?loc ?attrs a b = mk ?loc ?attrs (Pcty_constr (a, b))
    let signature ?loc ?attrs a = mk ?loc ?attrs (Pcty_signature a)
    let arrow ?loc ?attrs a b c = mk ?loc ?attrs (Pcty_arrow (a, b, c))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pcty_extension a)
    let open_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcty_open (a, b, c))
  end

  module Ctf = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
             ?(docs = empty_docs) d =
      {
       pctf_desc = d;
       pctf_loc = loc;
       pctf_attributes = add_docs_attrs docs attrs;
      }

    let inherit_ ?loc ?attrs a = mk ?loc ?attrs (Pctf_inherit a)
    let val_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pctf_val (a, b, c, d))
    let method_ ?loc ?attrs a b c d = mk ?loc ?attrs (Pctf_method (a, b, c, d))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pctf_constraint (a, b))
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pctf_extension a)
    let attribute ?loc a = mk ?loc (Pctf_attribute a)
    let text txt =
     let f_txt = List.filter (fun ds -> docstring_body ds <> "") txt in
       List.map
        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
        f_txt

    let attr d a = {d with pctf_attributes = d.pctf_attributes @ [a]}

  end

  module Cf = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) d =
      {
       pcf_desc = d;
       pcf_loc = loc;
       pcf_attributes = add_docs_attrs docs attrs;
      }

    let inherit_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_inherit (a, b, c))
    let val_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_val (a, b, c))
    let method_ ?loc ?attrs a b c = mk ?loc ?attrs (Pcf_method (a, b, c))
    let constraint_ ?loc ?attrs a b = mk ?loc ?attrs (Pcf_constraint (a, b))
    let initializer_ ?loc ?attrs a = mk ?loc ?attrs (Pcf_initializer a)
    let extension ?loc ?attrs a = mk ?loc ?attrs (Pcf_extension a)
    let attribute ?loc a = mk ?loc (Pcf_attribute a)
    let text txt =
      let f_txt = List.filter (fun ds -> docstring_body ds <> "") txt in
      List.map
        (fun ds -> attribute ~loc:(docstring_loc ds) (text_attr ds))
        f_txt

    let virtual_ ct = Cfk_virtual ct
    let concrete o e = Cfk_concrete (o, e)

    let attr d a = {d with pcf_attributes = d.pcf_attributes @ [a]}

  end

  module Val = struct
    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
          ?(prim = []) name typ =
      {
       pval_name = name;
       pval_type = typ;
       pval_attributes = add_docs_attrs docs attrs;
       pval_loc = loc;
       pval_prim = prim;
      }
  end

  module Md = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = []) name typ =
      {
       pmd_name = name;
       pmd_type = typ;
       pmd_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pmd_loc = loc;
      }
  end

  module Mtd = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = []) ?typ name =
      {
       pmtd_name = name;
       pmtd_type = typ;
       pmtd_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pmtd_loc = loc;
      }
  end

  module Mb = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = []) name expr =
      {
       pmb_name = name;
       pmb_expr = expr;
       pmb_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pmb_loc = loc;
      }
  end

  module Opn = struct
    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
          ?(override = Fresh) lid =
      {
       popen_lid = lid;
       popen_override = override;
       popen_loc = loc;
       popen_attributes = add_docs_attrs docs attrs;
      }
  end

  module Incl = struct
    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs) mexpr =
      {
       pincl_mod = mexpr;
       pincl_loc = loc;
       pincl_attributes = add_docs_attrs docs attrs;
      }

  end

  module Vb = struct
    let mk ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
          ?(text = []) pat expr =
      {
       pvb_pat = pat;
       pvb_expr = expr;
       pvb_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pvb_loc = loc;
      }
  end

  module Ci = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = [])
          ?(virt = Concrete) ?(params = []) name expr =
      {
       pci_virt = virt;
       pci_params = params;
       pci_name = name;
       pci_expr = expr;
       pci_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       pci_loc = loc;
      }
  end

  module Type = struct
    let mk ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(text = [])
        ?(params = [])
        ?(cstrs = [])
        ?(kind = Ptype_abstract)
        ?(priv = Public)
        ?manifest
        name =
      {
       ptype_name = name;
       ptype_params = params;
       ptype_cstrs = cstrs;
       ptype_kind = kind;
       ptype_private = priv;
       ptype_manifest = manifest;
       ptype_attributes =
         add_text_attrs text (add_docs_attrs docs attrs);
       ptype_loc = loc;
      }

    let constructor ?(loc = !default_loc) ?(attrs = []) ?(info = empty_info)
          ?(args = Pcstr_tuple []) ?res name =
      {
       pcd_name = name;
       pcd_args = args;
       pcd_res = res;
       pcd_loc = loc;
       pcd_attributes = add_info_attrs info attrs;
       }

    let field ?(loc = !default_loc) ?(attrs = []) ?(info = empty_info)
          ?(mut = Immutable) name typ =
      {
       pld_name = name;
       pld_mutable = mut;
       pld_type = typ;
       pld_loc = loc;
       pld_attributes = add_info_attrs info attrs;
      }

  end

  (** Type extensions *)
  module Te = struct
    let mk ?(attrs = []) ?(docs = empty_docs)
          ?(params = []) ?(priv = Public) path constructors =
      {
       ptyext_path = path;
       ptyext_params = params;
       ptyext_constructors = constructors;
       ptyext_private = priv;
       ptyext_attributes = add_docs_attrs docs attrs;
      }

    let constructor ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(info = empty_info) name kind =
      {
       pext_name = name;
       pext_kind = kind;
       pext_loc = loc;
       pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);
      }

    let decl ?(loc = !default_loc) ?(attrs = []) ?(docs = empty_docs)
               ?(info = empty_info) ?(args = Pcstr_tuple []) ?res name =
      {
       pext_name = name;
       pext_kind = Pext_decl(args, res);
       pext_loc = loc;
       pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);
      }

    let rebind ?(loc = !default_loc) ?(attrs = [])
          ?(docs = empty_docs) ?(info = empty_info) name lid =
      {
       pext_name = name;
       pext_kind = Pext_rebind lid;
       pext_loc = loc;
       pext_attributes = add_docs_attrs docs (add_info_attrs info attrs);
      }

  end

  module Csig = struct
    let mk self fields =
      {
       pcsig_self = self;
       pcsig_fields = fields;
      }
  end

  module Cstr = struct
    let mk self fields =
      {
       pcstr_self = self;
       pcstr_fields = fields;
      }
  end

end

module Ast_mapper : sig
  (** The interface of a -ppx rewriter

    A -ppx rewriter is a program that accepts a serialized abstract syntax
    tree and outputs another, possibly modified, abstract syntax tree.
    This module encapsulates the interface between the compiler and
    the -ppx rewriters, handling such details as the serialization format,
    forwarding of command-line flags, and storing state.

    {!mapper} allows to implement AST rewriting using open recursion.
    A typical mapper would be based on {!default_mapper}, a deep
    identity mapper, and will fall back on it for handling the syntax it
    does not modify. For example:

    {[
  open Asttypes
  open Parsetree
  open Ast_mapper

  let test_mapper argv =
    { default_mapper with
      expr = fun mapper expr ->
        match expr with
        | { pexp_desc = Pexp_extension ({ txt = "test" }, PStr [])} ->
          Ast_helper.Exp.constant (Const_int 42)
        | other -> default_mapper.expr mapper other; }

  let () =
    register "ppx_test" test_mapper]}

    This -ppx rewriter, which replaces [[%test]] in expressions with
    the constant [42], can be compiled using
    [ocamlc -o ppx_test -I +compiler-libs ocamlcommon.cma ppx_test.ml].

    *)

  open Parsetree

  (** {2 A generic Parsetree mapper} *)

  type mapper (*IF_CURRENT = Ast_mapper.mapper*) = {
    attribute: mapper -> attribute -> attribute;
    attributes: mapper -> attribute list -> attribute list;
    case: mapper -> case -> case;
    cases: mapper -> case list -> case list;
    class_declaration: mapper -> class_declaration -> class_declaration;
    class_description: mapper -> class_description -> class_description;
    class_expr: mapper -> class_expr -> class_expr;
    class_field: mapper -> class_field -> class_field;
    class_signature: mapper -> class_signature -> class_signature;
    class_structure: mapper -> class_structure -> class_structure;
    class_type: mapper -> class_type -> class_type;
    class_type_declaration: mapper -> class_type_declaration
                            -> class_type_declaration;
    class_type_field: mapper -> class_type_field -> class_type_field;
    constructor_declaration: mapper -> constructor_declaration
                             -> constructor_declaration;
    expr: mapper -> expression -> expression;
    extension: mapper -> extension -> extension;
    extension_constructor: mapper -> extension_constructor
                           -> extension_constructor;
    include_declaration: mapper -> include_declaration -> include_declaration;
    include_description: mapper -> include_description -> include_description;
    label_declaration: mapper -> label_declaration -> label_declaration;
    location: mapper -> Location.t -> Location.t;
    module_binding: mapper -> module_binding -> module_binding;
    module_declaration: mapper -> module_declaration -> module_declaration;
    module_expr: mapper -> module_expr -> module_expr;
    module_type: mapper -> module_type -> module_type;
    module_type_declaration: mapper -> module_type_declaration
                             -> module_type_declaration;
    open_description: mapper -> open_description -> open_description;
    pat: mapper -> pattern -> pattern;
    payload: mapper -> payload -> payload;
    signature: mapper -> signature -> signature;
    signature_item: mapper -> signature_item -> signature_item;
    structure: mapper -> structure -> structure;
    structure_item: mapper -> structure_item -> structure_item;
    typ: mapper -> core_type -> core_type;
    type_declaration: mapper -> type_declaration -> type_declaration;
    type_extension: mapper -> type_extension -> type_extension;
    type_kind: mapper -> type_kind -> type_kind;
    value_binding: mapper -> value_binding -> value_binding;
    value_description: mapper -> value_description -> value_description;
    with_constraint: mapper -> with_constraint -> with_constraint;
  }
  (** A mapper record implements one "method" per syntactic category,
      using an open recursion style: each method takes as its first
      argument the mapper to be applied to children in the syntax
      tree. *)

  val default_mapper: mapper
  (** A default mapper, which implements a "deep identity" mapping. *)

  (** {2 Convenience functions to write mappers} *)

  val map_opt: ('a -> 'b) -> 'a option -> 'b option

  val extension_of_error: Location.error -> extension
  (** Encode an error into an 'ocaml.error' extension node which can be
      inserted in a generated Parsetree.  The compiler will be
      responsible for reporting the error. *)

  val attribute_of_warning: Location.t -> string -> attribute
  (** Encode a warning message into an 'ocaml.ppwarning' attribute which can be
      inserted in a generated Parsetree.  The compiler will be
      responsible for reporting the warning. *)

end = struct
  (* A generic Parsetree mapping class *)

  (*
  [@@@ocaml.warning "+9"]
    (* Ensure that record patterns don't miss any field. *)
  *)


  open Parsetree
  open Ast_helper
  open Location

  type mapper (*IF_CURRENT = Ast_mapper.mapper*) = {
    attribute: mapper -> attribute -> attribute;
    attributes: mapper -> attribute list -> attribute list;
    case: mapper -> case -> case;
    cases: mapper -> case list -> case list;
    class_declaration: mapper -> class_declaration -> class_declaration;
    class_description: mapper -> class_description -> class_description;
    class_expr: mapper -> class_expr -> class_expr;
    class_field: mapper -> class_field -> class_field;
    class_signature: mapper -> class_signature -> class_signature;
    class_structure: mapper -> class_structure -> class_structure;
    class_type: mapper -> class_type -> class_type;
    class_type_declaration: mapper -> class_type_declaration
                            -> class_type_declaration;
    class_type_field: mapper -> class_type_field -> class_type_field;
    constructor_declaration: mapper -> constructor_declaration
                             -> constructor_declaration;
    expr: mapper -> expression -> expression;
    extension: mapper -> extension -> extension;
    extension_constructor: mapper -> extension_constructor
                           -> extension_constructor;
    include_declaration: mapper -> include_declaration -> include_declaration;
    include_description: mapper -> include_description -> include_description;
    label_declaration: mapper -> label_declaration -> label_declaration;
    location: mapper -> Location.t -> Location.t;
    module_binding: mapper -> module_binding -> module_binding;
    module_declaration: mapper -> module_declaration -> module_declaration;
    module_expr: mapper -> module_expr -> module_expr;
    module_type: mapper -> module_type -> module_type;
    module_type_declaration: mapper -> module_type_declaration
                             -> module_type_declaration;
    open_description: mapper -> open_description -> open_description;
    pat: mapper -> pattern -> pattern;
    payload: mapper -> payload -> payload;
    signature: mapper -> signature -> signature;
    signature_item: mapper -> signature_item -> signature_item;
    structure: mapper -> structure -> structure;
    structure_item: mapper -> structure_item -> structure_item;
    typ: mapper -> core_type -> core_type;
    type_declaration: mapper -> type_declaration -> type_declaration;
    type_extension: mapper -> type_extension -> type_extension;
    type_kind: mapper -> type_kind -> type_kind;
    value_binding: mapper -> value_binding -> value_binding;
    value_description: mapper -> value_description -> value_description;
    with_constraint: mapper -> with_constraint -> with_constraint;
  }

  let map_fst f (x, y) = (f x, y)
  let map_snd f (x, y) = (x, f y)
  let map_tuple f1 f2 (x, y) = (f1 x, f2 y)
  let map_tuple3 f1 f2 f3 (x, y, z) = (f1 x, f2 y, f3 z)
  let map_opt f = function None -> None | Some x -> Some (f x)

  let map_loc sub {loc; txt} = {loc = sub.location sub loc; txt}

  module T = struct
    (* Type expressions for the core language *)

    let row_field sub = function
      | Rtag (l, attrs, b, tl) ->
          Rtag (l, sub.attributes sub attrs, b, List.map (sub.typ sub) tl)
      | Rinherit t -> Rinherit (sub.typ sub t)

    let map sub {ptyp_desc = desc; ptyp_loc = loc; ptyp_attributes = attrs} =
      let open Typ in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Ptyp_any -> any ~loc ~attrs ()
      | Ptyp_var s -> var ~loc ~attrs s
      | Ptyp_arrow (lab, t1, t2) ->
          arrow ~loc ~attrs lab (sub.typ sub t1) (sub.typ sub t2)
      | Ptyp_tuple tyl -> tuple ~loc ~attrs (List.map (sub.typ sub) tyl)
      | Ptyp_constr (lid, tl) ->
          constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tl)
      | Ptyp_object (l, o) ->
          let f (s, a, t) =
            (map_loc sub s, sub.attributes sub a, sub.typ sub t) in
          object_ ~loc ~attrs (List.map f l) o
      | Ptyp_class (lid, tl) ->
          class_ ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tl)
      | Ptyp_alias (t, s) -> alias ~loc ~attrs (sub.typ sub t) s
      | Ptyp_variant (rl, b, ll) ->
          variant ~loc ~attrs (List.map (row_field sub) rl) b ll
      | Ptyp_poly (sl, t) -> poly ~loc ~attrs
                               (List.map (map_loc sub) sl) (sub.typ sub t)
      | Ptyp_package (lid, l) ->
          package ~loc ~attrs (map_loc sub lid)
            (List.map (map_tuple (map_loc sub) (sub.typ sub)) l)
      | Ptyp_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_type_declaration sub
        {ptype_name; ptype_params; ptype_cstrs;
         ptype_kind;
         ptype_private;
         ptype_manifest;
         ptype_attributes;
         ptype_loc} =
      Type.mk (map_loc sub ptype_name)
        ~params:(List.map (map_fst (sub.typ sub)) ptype_params)
        ~priv:ptype_private
        ~cstrs:(List.map
                  (map_tuple3 (sub.typ sub) (sub.typ sub) (sub.location sub))
                  ptype_cstrs)
        ~kind:(sub.type_kind sub ptype_kind)
        ?manifest:(map_opt (sub.typ sub) ptype_manifest)
        ~loc:(sub.location sub ptype_loc)
        ~attrs:(sub.attributes sub ptype_attributes)

    let map_type_kind sub = function
      | Ptype_abstract -> Ptype_abstract
      | Ptype_variant l ->
          Ptype_variant (List.map (sub.constructor_declaration sub) l)
      | Ptype_record l -> Ptype_record (List.map (sub.label_declaration sub) l)
      | Ptype_open -> Ptype_open

    let map_constructor_arguments sub = function
      | Pcstr_tuple l -> Pcstr_tuple (List.map (sub.typ sub) l)
      | Pcstr_record l ->
          Pcstr_record (List.map (sub.label_declaration sub) l)

    let map_type_extension sub
        {ptyext_path; ptyext_params;
         ptyext_constructors;
         ptyext_private;
         ptyext_attributes} =
      Te.mk
        (map_loc sub ptyext_path)
        (List.map (sub.extension_constructor sub) ptyext_constructors)
        ~params:(List.map (map_fst (sub.typ sub)) ptyext_params)
        ~priv:ptyext_private
        ~attrs:(sub.attributes sub ptyext_attributes)

    let map_extension_constructor_kind sub = function
        Pext_decl(ctl, cto) ->
          Pext_decl(map_constructor_arguments sub ctl, map_opt (sub.typ sub) cto)
      | Pext_rebind li ->
          Pext_rebind (map_loc sub li)

    let map_extension_constructor sub
        {pext_name;
         pext_kind;
         pext_loc;
         pext_attributes} =
      Te.constructor
        (map_loc sub pext_name)
        (map_extension_constructor_kind sub pext_kind)
        ~loc:(sub.location sub pext_loc)
        ~attrs:(sub.attributes sub pext_attributes)

  end

  module CT = struct
    (* Type expressions for the class language *)

    let map sub {pcty_loc = loc; pcty_desc = desc; pcty_attributes = attrs} =
      let open Cty in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pcty_constr (lid, tys) ->
          constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tys)
      | Pcty_signature x -> signature ~loc ~attrs (sub.class_signature sub x)
      | Pcty_arrow (lab, t, ct) ->
          arrow ~loc ~attrs lab (sub.typ sub t) (sub.class_type sub ct)
      | Pcty_extension x -> extension ~loc ~attrs (sub.extension sub x)
      | Pcty_open (ovf, lid, ct) ->
         open_ ~loc ~attrs ovf (map_loc sub lid) (sub.class_type sub ct)


    let map_field sub {pctf_desc = desc; pctf_loc = loc; pctf_attributes = attrs}
      =
      let open Ctf in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pctf_inherit ct -> inherit_ ~loc ~attrs (sub.class_type sub ct)
      | Pctf_val (s, m, v, t) ->
          val_ ~loc ~attrs (map_loc sub s) m v (sub.typ sub t)
      | Pctf_method (s, p, v, t) ->
          method_ ~loc ~attrs (map_loc sub s) p v (sub.typ sub t)
      | Pctf_constraint (t1, t2) ->
          constraint_ ~loc ~attrs (sub.typ sub t1) (sub.typ sub t2)
      | Pctf_attribute x -> attribute ~loc (sub.attribute sub x)
      | Pctf_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_signature sub {pcsig_self; pcsig_fields} =
      Csig.mk
        (sub.typ sub pcsig_self)
        (List.map (sub.class_type_field sub) pcsig_fields)
  end

  module MT = struct
    (* Type expressions for the module language *)

    let map sub {pmty_desc = desc; pmty_loc = loc; pmty_attributes = attrs} =
      let open Mty in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pmty_ident s -> ident ~loc ~attrs (map_loc sub s)
      | Pmty_alias s -> alias ~loc ~attrs (map_loc sub s)
      | Pmty_signature sg -> signature ~loc ~attrs (sub.signature sub sg)
      | Pmty_functor (s, mt1, mt2) ->
          functor_ ~loc ~attrs (map_loc sub s)
            (Misc.may_map (sub.module_type sub) mt1)
            (sub.module_type sub mt2)
      | Pmty_with (mt, l) ->
          with_ ~loc ~attrs (sub.module_type sub mt)
            (List.map (sub.with_constraint sub) l)
      | Pmty_typeof me -> typeof_ ~loc ~attrs (sub.module_expr sub me)
      | Pmty_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_with_constraint sub = function
      | Pwith_type (lid, d) ->
          Pwith_type (map_loc sub lid, sub.type_declaration sub d)
      | Pwith_module (lid, lid2) ->
          Pwith_module (map_loc sub lid, map_loc sub lid2)
      | Pwith_typesubst d -> Pwith_typesubst (sub.type_declaration sub d)
      | Pwith_modsubst (s, lid) ->
          Pwith_modsubst (map_loc sub s, map_loc sub lid)

    let map_signature_item sub {psig_desc = desc; psig_loc = loc} =
      let open Sig in
      let loc = sub.location sub loc in
      match desc with
      | Psig_value vd -> value ~loc (sub.value_description sub vd)
      | Psig_type (rf, l) -> type_ ~loc rf (List.map (sub.type_declaration sub) l)
      | Psig_typext te -> type_extension ~loc (sub.type_extension sub te)
      | Psig_exception ed -> exception_ ~loc (sub.extension_constructor sub ed)
      | Psig_module x -> module_ ~loc (sub.module_declaration sub x)
      | Psig_recmodule l ->
          rec_module ~loc (List.map (sub.module_declaration sub) l)
      | Psig_modtype x -> modtype ~loc (sub.module_type_declaration sub x)
      | Psig_open x -> open_ ~loc (sub.open_description sub x)
      | Psig_include x -> include_ ~loc (sub.include_description sub x)
      | Psig_class l -> class_ ~loc (List.map (sub.class_description sub) l)
      | Psig_class_type l ->
          class_type ~loc (List.map (sub.class_type_declaration sub) l)
      | Psig_extension (x, attrs) ->
          extension ~loc (sub.extension sub x) ~attrs:(sub.attributes sub attrs)
      | Psig_attribute x -> attribute ~loc (sub.attribute sub x)
  end


  module M = struct
    (* Value expressions for the module language *)

    let map sub {pmod_loc = loc; pmod_desc = desc; pmod_attributes = attrs} =
      let open Mod in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pmod_ident x -> ident ~loc ~attrs (map_loc sub x)
      | Pmod_structure str -> structure ~loc ~attrs (sub.structure sub str)
      | Pmod_functor (arg, arg_ty, body) ->
          functor_ ~loc ~attrs (map_loc sub arg)
            (Misc.may_map (sub.module_type sub) arg_ty)
            (sub.module_expr sub body)
      | Pmod_apply (m1, m2) ->
          apply ~loc ~attrs (sub.module_expr sub m1) (sub.module_expr sub m2)
      | Pmod_constraint (m, mty) ->
          constraint_ ~loc ~attrs (sub.module_expr sub m)
                      (sub.module_type sub mty)
      | Pmod_unpack e -> unpack ~loc ~attrs (sub.expr sub e)
      | Pmod_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_structure_item sub {pstr_loc = loc; pstr_desc = desc} =
      let open Str in
      let loc = sub.location sub loc in
      match desc with
      | Pstr_eval (x, attrs) ->
          eval ~loc ~attrs:(sub.attributes sub attrs) (sub.expr sub x)
      | Pstr_value (r, vbs) -> value ~loc r (List.map (sub.value_binding sub) vbs)
      | Pstr_primitive vd -> primitive ~loc (sub.value_description sub vd)
      | Pstr_type (rf, l) -> type_ ~loc rf (List.map (sub.type_declaration sub) l)
      | Pstr_typext te -> type_extension ~loc (sub.type_extension sub te)
      | Pstr_exception ed -> exception_ ~loc (sub.extension_constructor sub ed)
      | Pstr_module x -> module_ ~loc (sub.module_binding sub x)
      | Pstr_recmodule l -> rec_module ~loc (List.map (sub.module_binding sub) l)
      | Pstr_modtype x -> modtype ~loc (sub.module_type_declaration sub x)
      | Pstr_open x -> open_ ~loc (sub.open_description sub x)
      | Pstr_class l -> class_ ~loc (List.map (sub.class_declaration sub) l)
      | Pstr_class_type l ->
          class_type ~loc (List.map (sub.class_type_declaration sub) l)
      | Pstr_include x -> include_ ~loc (sub.include_declaration sub x)
      | Pstr_extension (x, attrs) ->
          extension ~loc (sub.extension sub x) ~attrs:(sub.attributes sub attrs)
      | Pstr_attribute x -> attribute ~loc (sub.attribute sub x)
  end

  module E = struct
    (* Value expressions for the core language *)

    let map sub {pexp_loc = loc; pexp_desc = desc; pexp_attributes = attrs} =
      let open Exp in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pexp_ident x -> ident ~loc ~attrs (map_loc sub x)
      | Pexp_constant x -> constant ~loc ~attrs x
      | Pexp_let (r, vbs, e) ->
          let_ ~loc ~attrs r (List.map (sub.value_binding sub) vbs)
            (sub.expr sub e)
      | Pexp_fun (lab, def, p, e) ->
          fun_ ~loc ~attrs lab (map_opt (sub.expr sub) def) (sub.pat sub p)
            (sub.expr sub e)
      | Pexp_function pel -> function_ ~loc ~attrs (sub.cases sub pel)
      | Pexp_apply (e, l) ->
          apply ~loc ~attrs (sub.expr sub e) (List.map (map_snd (sub.expr sub)) l)
      | Pexp_match (e, pel) ->
          match_ ~loc ~attrs (sub.expr sub e) (sub.cases sub pel)
      | Pexp_try (e, pel) -> try_ ~loc ~attrs (sub.expr sub e) (sub.cases sub pel)
      | Pexp_tuple el -> tuple ~loc ~attrs (List.map (sub.expr sub) el)
      | Pexp_construct (lid, arg) ->
          construct ~loc ~attrs (map_loc sub lid) (map_opt (sub.expr sub) arg)
      | Pexp_variant (lab, eo) ->
          variant ~loc ~attrs lab (map_opt (sub.expr sub) eo)
      | Pexp_record (l, eo) ->
          record ~loc ~attrs (List.map (map_tuple (map_loc sub) (sub.expr sub)) l)
            (map_opt (sub.expr sub) eo)
      | Pexp_field (e, lid) ->
          field ~loc ~attrs (sub.expr sub e) (map_loc sub lid)
      | Pexp_setfield (e1, lid, e2) ->
          setfield ~loc ~attrs (sub.expr sub e1) (map_loc sub lid)
            (sub.expr sub e2)
      | Pexp_array el -> array ~loc ~attrs (List.map (sub.expr sub) el)
      | Pexp_ifthenelse (e1, e2, e3) ->
          ifthenelse ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)
            (map_opt (sub.expr sub) e3)
      | Pexp_sequence (e1, e2) ->
          sequence ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)
      | Pexp_while (e1, e2) ->
          while_ ~loc ~attrs (sub.expr sub e1) (sub.expr sub e2)
      | Pexp_for (p, e1, e2, d, e3) ->
          for_ ~loc ~attrs (sub.pat sub p) (sub.expr sub e1) (sub.expr sub e2) d
            (sub.expr sub e3)
      | Pexp_coerce (e, t1, t2) ->
          coerce ~loc ~attrs (sub.expr sub e) (map_opt (sub.typ sub) t1)
            (sub.typ sub t2)
      | Pexp_constraint (e, t) ->
          constraint_ ~loc ~attrs (sub.expr sub e) (sub.typ sub t)
      | Pexp_send (e, s) ->
          send ~loc ~attrs (sub.expr sub e) (map_loc sub s)
      | Pexp_new lid -> new_ ~loc ~attrs (map_loc sub lid)
      | Pexp_setinstvar (s, e) ->
          setinstvar ~loc ~attrs (map_loc sub s) (sub.expr sub e)
      | Pexp_override sel ->
          override ~loc ~attrs
            (List.map (map_tuple (map_loc sub) (sub.expr sub)) sel)
      | Pexp_letmodule (s, me, e) ->
          letmodule ~loc ~attrs (map_loc sub s) (sub.module_expr sub me)
            (sub.expr sub e)
      | Pexp_letexception (cd, e) ->
          letexception ~loc ~attrs
            (sub.extension_constructor sub cd)
            (sub.expr sub e)
      | Pexp_assert e -> assert_ ~loc ~attrs (sub.expr sub e)
      | Pexp_lazy e -> lazy_ ~loc ~attrs (sub.expr sub e)
      | Pexp_poly (e, t) ->
          poly ~loc ~attrs (sub.expr sub e) (map_opt (sub.typ sub) t)
      | Pexp_object cls -> object_ ~loc ~attrs (sub.class_structure sub cls)
      | Pexp_newtype (s, e) ->
          newtype ~loc ~attrs (map_loc sub s) (sub.expr sub e)
      | Pexp_pack me -> pack ~loc ~attrs (sub.module_expr sub me)
      | Pexp_open (ovf, lid, e) ->
          open_ ~loc ~attrs ovf (map_loc sub lid) (sub.expr sub e)
      | Pexp_extension x -> extension ~loc ~attrs (sub.extension sub x)
      | Pexp_unreachable -> unreachable ~loc ~attrs ()
  end

  module P = struct
    (* Patterns *)

    let map sub {ppat_desc = desc; ppat_loc = loc; ppat_attributes = attrs} =
      let open Pat in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Ppat_any -> any ~loc ~attrs ()
      | Ppat_var s -> var ~loc ~attrs (map_loc sub s)
      | Ppat_alias (p, s) -> alias ~loc ~attrs (sub.pat sub p) (map_loc sub s)
      | Ppat_constant c -> constant ~loc ~attrs c
      | Ppat_interval (c1, c2) -> interval ~loc ~attrs c1 c2
      | Ppat_tuple pl -> tuple ~loc ~attrs (List.map (sub.pat sub) pl)
      | Ppat_construct (l, p) ->
          construct ~loc ~attrs (map_loc sub l) (map_opt (sub.pat sub) p)
      | Ppat_variant (l, p) -> variant ~loc ~attrs l (map_opt (sub.pat sub) p)
      | Ppat_record (lpl, cf) ->
          record ~loc ~attrs
                 (List.map (map_tuple (map_loc sub) (sub.pat sub)) lpl) cf
      | Ppat_array pl -> array ~loc ~attrs (List.map (sub.pat sub) pl)
      | Ppat_or (p1, p2) -> or_ ~loc ~attrs (sub.pat sub p1) (sub.pat sub p2)
      | Ppat_constraint (p, t) ->
          constraint_ ~loc ~attrs (sub.pat sub p) (sub.typ sub t)
      | Ppat_type s -> type_ ~loc ~attrs (map_loc sub s)
      | Ppat_lazy p -> lazy_ ~loc ~attrs (sub.pat sub p)
      | Ppat_unpack s -> unpack ~loc ~attrs (map_loc sub s)
      | Ppat_open (lid,p) -> open_ ~loc ~attrs (map_loc sub lid) (sub.pat sub p)
      | Ppat_exception p -> exception_ ~loc ~attrs (sub.pat sub p)
      | Ppat_extension x -> extension ~loc ~attrs (sub.extension sub x)
  end

  module CE = struct
    (* Value expressions for the class language *)

    let map sub {pcl_loc = loc; pcl_desc = desc; pcl_attributes = attrs} =
      let open Cl in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pcl_constr (lid, tys) ->
          constr ~loc ~attrs (map_loc sub lid) (List.map (sub.typ sub) tys)
      | Pcl_structure s ->
          structure ~loc ~attrs (sub.class_structure sub s)
      | Pcl_fun (lab, e, p, ce) ->
          fun_ ~loc ~attrs lab
            (map_opt (sub.expr sub) e)
            (sub.pat sub p)
            (sub.class_expr sub ce)
      | Pcl_apply (ce, l) ->
          apply ~loc ~attrs (sub.class_expr sub ce)
            (List.map (map_snd (sub.expr sub)) l)
      | Pcl_let (r, vbs, ce) ->
          let_ ~loc ~attrs r (List.map (sub.value_binding sub) vbs)
            (sub.class_expr sub ce)
      | Pcl_constraint (ce, ct) ->
          constraint_ ~loc ~attrs (sub.class_expr sub ce) (sub.class_type sub ct)
      | Pcl_extension x -> extension ~loc ~attrs (sub.extension sub x)
      | Pcl_open (ovf, lid, ce) ->
         open_ ~loc ~attrs ovf (map_loc sub lid) (sub.class_expr sub ce)


    let map_kind sub = function
      | Cfk_concrete (o, e) -> Cfk_concrete (o, sub.expr sub e)
      | Cfk_virtual t -> Cfk_virtual (sub.typ sub t)

    let map_field sub {pcf_desc = desc; pcf_loc = loc; pcf_attributes = attrs} =
      let open Cf in
      let loc = sub.location sub loc in
      let attrs = sub.attributes sub attrs in
      match desc with
      | Pcf_inherit (o, ce, s) ->
          inherit_ ~loc ~attrs o (sub.class_expr sub ce)
            (map_opt (map_loc sub) s)
      | Pcf_val (s, m, k) -> val_ ~loc ~attrs (map_loc sub s) m (map_kind sub k)
      | Pcf_method (s, p, k) ->
          method_ ~loc ~attrs (map_loc sub s) p (map_kind sub k)
      | Pcf_constraint (t1, t2) ->
          constraint_ ~loc ~attrs (sub.typ sub t1) (sub.typ sub t2)
      | Pcf_initializer e -> initializer_ ~loc ~attrs (sub.expr sub e)
      | Pcf_attribute x -> attribute ~loc (sub.attribute sub x)
      | Pcf_extension x -> extension ~loc ~attrs (sub.extension sub x)

    let map_structure sub {pcstr_self; pcstr_fields} =
      {
        pcstr_self = sub.pat sub pcstr_self;
        pcstr_fields = List.map (sub.class_field sub) pcstr_fields;
      }

    let class_infos sub f {pci_virt; pci_params = pl; pci_name; pci_expr;
                           pci_loc; pci_attributes} =
      Ci.mk
       ~virt:pci_virt
       ~params:(List.map (map_fst (sub.typ sub)) pl)
        (map_loc sub pci_name)
        (f pci_expr)
        ~loc:(sub.location sub pci_loc)
        ~attrs:(sub.attributes sub pci_attributes)
  end

  (* Now, a generic AST mapper, to be extended to cover all kinds and
     cases of the OCaml grammar.  The default behavior of the mapper is
     the identity. *)

  let default_mapper =
    {
      structure = (fun this l -> List.map (this.structure_item this) l);
      structure_item = M.map_structure_item;
      module_expr = M.map;
      signature = (fun this l -> List.map (this.signature_item this) l);
      signature_item = MT.map_signature_item;
      module_type = MT.map;
      with_constraint = MT.map_with_constraint;
      class_declaration =
        (fun this -> CE.class_infos this (this.class_expr this));
      class_expr = CE.map;
      class_field = CE.map_field;
      class_structure = CE.map_structure;
      class_type = CT.map;
      class_type_field = CT.map_field;
      class_signature = CT.map_signature;
      class_type_declaration =
        (fun this -> CE.class_infos this (this.class_type this));
      class_description =
        (fun this -> CE.class_infos this (this.class_type this));
      type_declaration = T.map_type_declaration;
      type_kind = T.map_type_kind;
      typ = T.map;
      type_extension = T.map_type_extension;
      extension_constructor = T.map_extension_constructor;
      value_description =
        (fun this {pval_name; pval_type; pval_prim; pval_loc;
                   pval_attributes} ->
          Val.mk
            (map_loc this pval_name)
            (this.typ this pval_type)
            ~attrs:(this.attributes this pval_attributes)
            ~loc:(this.location this pval_loc)
            ~prim:pval_prim
        );

      pat = P.map;
      expr = E.map;

      module_declaration =
        (fun this {pmd_name; pmd_type; pmd_attributes; pmd_loc} ->
           Md.mk
             (map_loc this pmd_name)
             (this.module_type this pmd_type)
             ~attrs:(this.attributes this pmd_attributes)
             ~loc:(this.location this pmd_loc)
        );

      module_type_declaration =
        (fun this {pmtd_name; pmtd_type; pmtd_attributes; pmtd_loc} ->
           Mtd.mk
             (map_loc this pmtd_name)
             ?typ:(map_opt (this.module_type this) pmtd_type)
             ~attrs:(this.attributes this pmtd_attributes)
             ~loc:(this.location this pmtd_loc)
        );

      module_binding =
        (fun this {pmb_name; pmb_expr; pmb_attributes; pmb_loc} ->
           Mb.mk (map_loc this pmb_name) (this.module_expr this pmb_expr)
             ~attrs:(this.attributes this pmb_attributes)
             ~loc:(this.location this pmb_loc)
        );


      open_description =
        (fun this {popen_lid; popen_override; popen_attributes; popen_loc} ->
           Opn.mk (map_loc this popen_lid)
             ~override:popen_override
             ~loc:(this.location this popen_loc)
             ~attrs:(this.attributes this popen_attributes)
        );


      include_description =
        (fun this {pincl_mod; pincl_attributes; pincl_loc} ->
           Incl.mk (this.module_type this pincl_mod)
             ~loc:(this.location this pincl_loc)
             ~attrs:(this.attributes this pincl_attributes)
        );

      include_declaration =
        (fun this {pincl_mod; pincl_attributes; pincl_loc} ->
           Incl.mk (this.module_expr this pincl_mod)
             ~loc:(this.location this pincl_loc)
             ~attrs:(this.attributes this pincl_attributes)
        );


      value_binding =
        (fun this {pvb_pat; pvb_expr; pvb_attributes; pvb_loc} ->
           Vb.mk
             (this.pat this pvb_pat)
             (this.expr this pvb_expr)
             ~loc:(this.location this pvb_loc)
             ~attrs:(this.attributes this pvb_attributes)
        );


      constructor_declaration =
        (fun this {pcd_name; pcd_args; pcd_res; pcd_loc; pcd_attributes} ->
          Type.constructor
            (map_loc this pcd_name)
            ~args:(T.map_constructor_arguments this pcd_args)
            ?res:(map_opt (this.typ this) pcd_res)
            ~loc:(this.location this pcd_loc)
            ~attrs:(this.attributes this pcd_attributes)
        );

      label_declaration =
        (fun this {pld_name; pld_type; pld_loc; pld_mutable; pld_attributes} ->
           Type.field
             (map_loc this pld_name)
             (this.typ this pld_type)
             ~mut:pld_mutable
             ~loc:(this.location this pld_loc)
             ~attrs:(this.attributes this pld_attributes)
        );

      cases = (fun this l -> List.map (this.case this) l);
      case =
        (fun this {pc_lhs; pc_guard; pc_rhs} ->
           {
             pc_lhs = this.pat this pc_lhs;
             pc_guard = map_opt (this.expr this) pc_guard;
             pc_rhs = this.expr this pc_rhs;
           }
        );



      location = (fun _this l -> l);

      extension = (fun this (s, e) -> (map_loc this s, this.payload this e));
      attribute = (fun this (s, e) -> (map_loc this s, this.payload this e));
      attributes = (fun this l -> List.map (this.attribute this) l);
      payload =
        (fun this -> function
           | PStr x -> PStr (this.structure this x)
           | PSig x -> PSig (this.signature this x)
           | PTyp x -> PTyp (this.typ this x)
           | PPat (x, g) -> PPat (this.pat this x, map_opt (this.expr this) g)
        );
    }

  let rec extension_of_error {loc; msg; if_highlight; sub} =
    { loc; txt = "ocaml.error" },
    PStr ([Str.eval (Exp.constant (Pconst_string (msg, None)));
           Str.eval (Exp.constant (Pconst_string (if_highlight, None)))] @
          (List.map (fun ext -> Str.extension (extension_of_error ext)) sub))

  let attribute_of_warning loc s =
    { loc; txt = "ocaml.ppwarning" },
    PStr ([Str.eval ~loc (Exp.constant (Pconst_string (s, None)))])

end

module Outcometree = struct
  (* Module [Outcometree]: results displayed by the toplevel *)

  (* These types represent messages that the toplevel displays as normal
     results or errors. The real displaying is customisable using the hooks:
        [Toploop.print_out_value]
        [Toploop.print_out_type]
        [Toploop.print_out_sig_item]
        [Toploop.print_out_phrase] *)

  type out_ident (*IF_CURRENT = Outcometree.out_ident *) =
    | Oide_apply of out_ident * out_ident
    | Oide_dot of out_ident * string
    | Oide_ident of string

  type out_string (*IF_CURRENT = Outcometree.out_string *) =
    | Ostr_string
    | Ostr_bytes

  type out_attribute (*IF_CURRENT = Outcometree.out_attribute *) =
    { oattr_name: string }

  type out_value (*IF_CURRENT = Outcometree.out_value *) =
    | Oval_array of out_value list
    | Oval_char of char
    | Oval_constr of out_ident * out_value list
    | Oval_ellipsis
    | Oval_float of float
    | Oval_int of int
    | Oval_int32 of int32
    | Oval_int64 of int64
    | Oval_nativeint of nativeint
    | Oval_list of out_value list
    | Oval_printer of (Format.formatter -> unit)
    | Oval_record of (out_ident * out_value) list
    | Oval_string of string * int * out_string (* string, size-to-print, kind *)
    | Oval_stuff of string
    | Oval_tuple of out_value list
    | Oval_variant of string * out_value option

  type out_type (*IF_CURRENT = Outcometree.out_type *) =
    | Otyp_abstract
    | Otyp_open
    | Otyp_alias of out_type * string
    | Otyp_arrow of string * out_type * out_type
    | Otyp_class of bool * out_ident * out_type list
    | Otyp_constr of out_ident * out_type list
    | Otyp_manifest of out_type * out_type
    | Otyp_object of (string * out_type) list * bool option
    | Otyp_record of (string * bool * out_type) list
    | Otyp_stuff of string
    | Otyp_sum of (string * out_type list * out_type option) list
    | Otyp_tuple of out_type list
    | Otyp_var of bool * string
    | Otyp_variant of
        bool * out_variant * bool * (string list) option
    | Otyp_poly of string list * out_type
    | Otyp_module of string * string list * out_type list
    | Otyp_attribute of out_type * out_attribute

  and out_variant (*IF_CURRENT = Outcometree.out_variant *) =
    | Ovar_fields of (string * bool * out_type list) list
    | Ovar_typ of out_type

  type out_class_type (*IF_CURRENT = Outcometree.out_class_type *) =
    | Octy_constr of out_ident * out_type list
    | Octy_arrow of string * out_type * out_class_type
    | Octy_signature of out_type option * out_class_sig_item list
  and out_class_sig_item (*IF_CURRENT = Outcometree.out_class_sig_item *) =
    | Ocsg_constraint of out_type * out_type
    | Ocsg_method of string * bool * bool * out_type
    | Ocsg_value of string * bool * bool * out_type

  type out_module_type (*IF_CURRENT = Outcometree.out_module_type *) =
    | Omty_abstract
    | Omty_functor of string * out_module_type option * out_module_type
    | Omty_ident of out_ident
    | Omty_signature of out_sig_item list
    | Omty_alias of out_ident
  and out_sig_item (*IF_CURRENT = Outcometree.out_sig_item *) =
    | Osig_class of
        bool * string * (string * (bool * bool)) list * out_class_type *
          out_rec_status
    | Osig_class_type of
        bool * string * (string * (bool * bool)) list * out_class_type *
          out_rec_status
    | Osig_typext of out_extension_constructor * out_ext_status
    | Osig_modtype of string * out_module_type
    | Osig_module of string * out_module_type * out_rec_status
    | Osig_type of out_type_decl * out_rec_status
    | Osig_value of out_val_decl
    | Osig_ellipsis
  and out_type_decl (*IF_CURRENT = Outcometree.out_type_decl *) =
    { otype_name: string;
      otype_params: (string * (bool * bool)) list;
      otype_type: out_type;
      otype_private: Asttypes.private_flag;
      otype_immediate: bool;
      otype_unboxed: bool;
      otype_cstrs: (out_type * out_type) list }
  and out_extension_constructor (*IF_CURRENT = Outcometree.out_extension_constructor *) =
    { oext_name: string;
      oext_type_name: string;
      oext_type_params: string list;
      oext_args: out_type list;
      oext_ret_type: out_type option;
      oext_private: Asttypes.private_flag }
  and out_type_extension (*IF_CURRENT = Outcometree.out_type_extension *) =
    { otyext_name: string;
      otyext_params: string list;
      otyext_constructors: (string * out_type list * out_type option) list;
      otyext_private: Asttypes.private_flag }
  and out_val_decl (*IF_CURRENT = Outcometree.out_val_decl *) =
    { oval_name: string;
      oval_type: out_type;
      oval_prims: string list;
      oval_attributes: out_attribute list }
  and out_rec_status (*IF_CURRENT = Outcometree.out_rec_status *) =
    | Orec_not
    | Orec_first
    | Orec_next
  and out_ext_status (*IF_CURRENT = Outcometree.out_ext_status *) =
    | Oext_first
    | Oext_next
    | Oext_exception

  type out_phrase (*IF_CURRENT = Outcometree.out_phrase *) =
    | Ophr_eval of out_value * out_type
    | Ophr_signature of (out_sig_item * out_value option) list
    | Ophr_exception of (exn * out_value)

end

module Config = struct
  let ast_impl_magic_number = "Caml1999M020"
  let ast_intf_magic_number = "Caml1999N018"
end

let map_signature mapper = mapper.Ast_mapper.signature mapper
let map_structure mapper = mapper.Ast_mapper.structure mapper

let shallow_identity =
  let id _ x = x in
  {
    Ast_mapper.
    structure               = id;
    structure_item          = id;
    module_expr             = id;
    signature               = id;
    signature_item          = id;
    module_type             = id;
    with_constraint         = id;
    class_declaration       = id;
    class_expr              = id;
    class_field             = id;
    class_structure         = id;
    class_type              = id;
    class_type_field        = id;
    class_signature         = id;
    class_type_declaration  = id;
    class_description       = id;
    type_declaration        = id;
    type_kind               = id;
    typ                     = id;
    type_extension          = id;
    extension_constructor   = id;
    value_description       = id;
    pat                     = id;
    expr                    = id;
    module_declaration      = id;
    module_type_declaration = id;
    module_binding          = id;
    open_description        = id;
    include_description     = id;
    include_declaration     = id;
    value_binding           = id;
    constructor_declaration = id;
    label_declaration       = id;
    cases                   = id;
    case                    = id;
    location                = id;
    extension               = id;
    attribute               = id;
    attributes              = id;
    payload                 = id;
  }

let failing_mapper =
  let fail _ _ =
    invalid_arg "failing_mapper: this mapper function should never get called"
  in
  {
    Ast_mapper.
    structure               = fail;
    structure_item          = fail;
    module_expr             = fail;
    signature               = fail;
    signature_item          = fail;
    module_type             = fail;
    with_constraint         = fail;
    class_declaration       = fail;
    class_expr              = fail;
    class_field             = fail;
    class_structure         = fail;
    class_type              = fail;
    class_type_field        = fail;
    class_signature         = fail;
    class_type_declaration  = fail;
    class_description       = fail;
    type_declaration        = fail;
    type_kind               = fail;
    typ                     = fail;
    type_extension          = fail;
    extension_constructor   = fail;
    value_description       = fail;
    pat                     = fail;
    expr                    = fail;
    module_declaration      = fail;
    module_type_declaration = fail;
    module_binding          = fail;
    open_description        = fail;
    include_description     = fail;
    include_declaration     = fail;
    value_binding           = fail;
    constructor_declaration = fail;
    label_declaration       = fail;
    cases                   = fail;
    case                    = fail;
    location                = fail;
    extension               = fail;
    attribute               = fail;
    attributes              = fail;
    payload                 = fail;
  }

let make_top_mapper ~signature ~structure =
  {failing_mapper with Ast_mapper.
                    signature = (fun _ x -> signature x);
                    structure = (fun _ x -> structure x) }

end
module Migrate_parsetree_405_406_migrate
= struct
#1 "migrate_parsetree_405_406_migrate.ml"
# 1 "src/migrate_parsetree_405_406_migrate.ml"
# 1 "src/migrate_parsetree_405_406_migrate.ml"
# 1 "src/migrate_parsetree_405_406_migrate.ml"
# 1 "src/migrate_parsetree_405_406_migrate.ml"
# 1 "src/migrate_parsetree_405_406_migrate.ml"
# 1 "src/migrate_parsetree_405_406_migrate.ml"
# 1 "src/migrate_parsetree_405_406_migrate.ml"
# 1 "src/migrate_parsetree_405_406_migrate.ml"
# 1 "src/migrate_parsetree_405_406_migrate.ml"
# 1 "src/migrate_parsetree_405_406_migrate.ml"
# 1 "src/migrate_parsetree_405_406_migrate.ml"
# 1 "src/migrate_parsetree_405_406_migrate.ml"
# 1 "src/migrate_parsetree_405_406_migrate.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*                         Alain Frisch, LexiFi                           *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

module From = Ast_405
module To = Ast_406

let rec copy_expression :
  From.Parsetree.expression -> To.Parsetree.expression =
  fun
    { From.Parsetree.pexp_desc = pexp_desc;
      From.Parsetree.pexp_loc = pexp_loc;
      From.Parsetree.pexp_attributes = pexp_attributes }
     ->
    {
      To.Parsetree.pexp_desc = (copy_expression_desc pexp_desc);
      To.Parsetree.pexp_loc = (copy_location pexp_loc);
      To.Parsetree.pexp_attributes = (copy_attributes pexp_attributes)
    }

and copy_expression_desc :
  From.Parsetree.expression_desc -> To.Parsetree.expression_desc =
  function
  | From.Parsetree.Pexp_ident x0 ->
      To.Parsetree.Pexp_ident
        (copy_loc copy_longident x0)
  | From.Parsetree.Pexp_constant x0 ->
      To.Parsetree.Pexp_constant (copy_constant x0)
  | From.Parsetree.Pexp_let (x0,x1,x2) ->
      To.Parsetree.Pexp_let
        ((copy_rec_flag x0),
          (List.map copy_value_binding x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_function x0 ->
      To.Parsetree.Pexp_function
        (List.map copy_case x0)
  | From.Parsetree.Pexp_fun (x0,x1,x2,x3) ->
      To.Parsetree.Pexp_fun
        ((copy_arg_label x0),
          (copy_option copy_expression x1),
          (copy_pattern x2),
          (copy_expression x3))
  | From.Parsetree.Pexp_apply (x0,x1) ->
      To.Parsetree.Pexp_apply
        ((copy_expression x0),
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                ((copy_arg_label x0),
                  (copy_expression x1))) x1))
  | From.Parsetree.Pexp_match (x0,x1) ->
      To.Parsetree.Pexp_match
        ((copy_expression x0),
          (List.map copy_case x1))
  | From.Parsetree.Pexp_try (x0,x1) ->
      To.Parsetree.Pexp_try
        ((copy_expression x0),
          (List.map copy_case x1))
  | From.Parsetree.Pexp_tuple x0 ->
      To.Parsetree.Pexp_tuple
        (List.map copy_expression x0)
  | From.Parsetree.Pexp_construct (x0,x1) ->
      To.Parsetree.Pexp_construct
        ((copy_loc copy_longident x0),
          (copy_option copy_expression x1))
  | From.Parsetree.Pexp_variant (x0,x1) ->
      To.Parsetree.Pexp_variant
        ((copy_label x0),
          (copy_option copy_expression x1))
  | From.Parsetree.Pexp_record (x0,x1) ->
      To.Parsetree.Pexp_record
        ((List.map
            (fun x  ->
               let (x0,x1) = x  in
               ((copy_loc copy_longident x0),
                 (copy_expression x1))) x0),
          (copy_option copy_expression x1))
  | From.Parsetree.Pexp_field (x0,x1) ->
      To.Parsetree.Pexp_field
        ((copy_expression x0),
          (copy_loc copy_longident x1))
  | From.Parsetree.Pexp_setfield (x0,x1,x2) ->
      To.Parsetree.Pexp_setfield
        ((copy_expression x0),
          (copy_loc copy_longident x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_array x0 ->
      To.Parsetree.Pexp_array
        (List.map copy_expression x0)
  | From.Parsetree.Pexp_ifthenelse (x0,x1,x2) ->
      To.Parsetree.Pexp_ifthenelse
        ((copy_expression x0),
          (copy_expression x1),
          (copy_option copy_expression x2))
  | From.Parsetree.Pexp_sequence (x0,x1) ->
      To.Parsetree.Pexp_sequence
        ((copy_expression x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_while (x0,x1) ->
      To.Parsetree.Pexp_while
        ((copy_expression x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_for (x0,x1,x2,x3,x4) ->
      To.Parsetree.Pexp_for
        ((copy_pattern x0),
          (copy_expression x1),
          (copy_expression x2),
          (copy_direction_flag x3),
          (copy_expression x4))
  | From.Parsetree.Pexp_constraint (x0,x1) ->
      To.Parsetree.Pexp_constraint
        ((copy_expression x0),
          (copy_core_type x1))
  | From.Parsetree.Pexp_coerce (x0,x1,x2) ->
      To.Parsetree.Pexp_coerce
        ((copy_expression x0),
          (copy_option copy_core_type x1),
          (copy_core_type x2))
  | From.Parsetree.Pexp_send (x0,x1) ->
      To.Parsetree.Pexp_send
        ((copy_expression x0), (copy_loc (fun x  -> x) x1))
  | From.Parsetree.Pexp_new x0 ->
      To.Parsetree.Pexp_new
        (copy_loc copy_longident x0)
  | From.Parsetree.Pexp_setinstvar (x0,x1) ->
      To.Parsetree.Pexp_setinstvar
        ((copy_loc (fun x  -> x) x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_override x0 ->
      To.Parsetree.Pexp_override
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_loc (fun x  -> x) x0),
                (copy_expression x1))) x0)
  | From.Parsetree.Pexp_letmodule (x0,x1,x2) ->
      To.Parsetree.Pexp_letmodule
        ((copy_loc (fun x  -> x) x0),
          (copy_module_expr x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_letexception (x0,x1) ->
      To.Parsetree.Pexp_letexception
        ((copy_extension_constructor x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_assert x0 ->
      To.Parsetree.Pexp_assert (copy_expression x0)
  | From.Parsetree.Pexp_lazy x0 ->
      To.Parsetree.Pexp_lazy (copy_expression x0)
  | From.Parsetree.Pexp_poly (x0,x1) ->
      To.Parsetree.Pexp_poly
        ((copy_expression x0),
          (copy_option copy_core_type x1))
  | From.Parsetree.Pexp_object x0 ->
      To.Parsetree.Pexp_object
        (copy_class_structure x0)
  | From.Parsetree.Pexp_newtype (x0,x1) ->
      To.Parsetree.Pexp_newtype
        ((copy_loc (fun x  -> x) x0), (copy_expression x1))
  | From.Parsetree.Pexp_pack x0 ->
      To.Parsetree.Pexp_pack (copy_module_expr x0)
  | From.Parsetree.Pexp_open (x0,x1,x2) ->
      To.Parsetree.Pexp_open
        ((copy_override_flag x0),
          (copy_loc copy_longident x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_extension x0 ->
      To.Parsetree.Pexp_extension (copy_extension x0)
  | From.Parsetree.Pexp_unreachable  -> To.Parsetree.Pexp_unreachable

and copy_direction_flag :
  From.Asttypes.direction_flag -> To.Asttypes.direction_flag =
  function
  | From.Asttypes.Upto  -> To.Asttypes.Upto
  | From.Asttypes.Downto  -> To.Asttypes.Downto

and copy_case :
  From.Parsetree.case -> To.Parsetree.case =
  fun
    { From.Parsetree.pc_lhs = pc_lhs;
      From.Parsetree.pc_guard = pc_guard;
      From.Parsetree.pc_rhs = pc_rhs }
     ->
    {
      To.Parsetree.pc_lhs = (copy_pattern pc_lhs);
      To.Parsetree.pc_guard =
        (copy_option copy_expression pc_guard);
      To.Parsetree.pc_rhs = (copy_expression pc_rhs)
    }

and copy_value_binding :
  From.Parsetree.value_binding -> To.Parsetree.value_binding =
  fun
    { From.Parsetree.pvb_pat = pvb_pat;
      From.Parsetree.pvb_expr = pvb_expr;
      From.Parsetree.pvb_attributes = pvb_attributes;
      From.Parsetree.pvb_loc = pvb_loc }
     ->
    {
      To.Parsetree.pvb_pat = (copy_pattern pvb_pat);
      To.Parsetree.pvb_expr =
        (copy_expression pvb_expr);
      To.Parsetree.pvb_attributes =
        (copy_attributes pvb_attributes);
      To.Parsetree.pvb_loc = (copy_location pvb_loc)
    }

and copy_pattern :
  From.Parsetree.pattern -> To.Parsetree.pattern =
  fun
    { From.Parsetree.ppat_desc = ppat_desc;
      From.Parsetree.ppat_loc = ppat_loc;
      From.Parsetree.ppat_attributes = ppat_attributes }
     ->
    {
      To.Parsetree.ppat_desc =
        (copy_pattern_desc ppat_desc);
      To.Parsetree.ppat_loc = (copy_location ppat_loc);
      To.Parsetree.ppat_attributes =
        (copy_attributes ppat_attributes)
    }

and copy_pattern_desc :
  From.Parsetree.pattern_desc -> To.Parsetree.pattern_desc =
  function
  | From.Parsetree.Ppat_any  -> To.Parsetree.Ppat_any
  | From.Parsetree.Ppat_var x0 ->
      To.Parsetree.Ppat_var (copy_loc (fun x  -> x) x0)
  | From.Parsetree.Ppat_alias (x0,x1) ->
      To.Parsetree.Ppat_alias
        ((copy_pattern x0),
          (copy_loc (fun x  -> x) x1))
  | From.Parsetree.Ppat_constant x0 ->
      To.Parsetree.Ppat_constant (copy_constant x0)
  | From.Parsetree.Ppat_interval (x0,x1) ->
      To.Parsetree.Ppat_interval
        ((copy_constant x0),
          (copy_constant x1))
  | From.Parsetree.Ppat_tuple x0 ->
      To.Parsetree.Ppat_tuple
        (List.map copy_pattern x0)
  | From.Parsetree.Ppat_construct (x0,x1) ->
      To.Parsetree.Ppat_construct
        ((copy_loc copy_longident x0),
          (copy_option copy_pattern x1))
  | From.Parsetree.Ppat_variant (x0,x1) ->
      To.Parsetree.Ppat_variant
        ((copy_label x0),
          (copy_option copy_pattern x1))
  | From.Parsetree.Ppat_record (x0,x1) ->
      To.Parsetree.Ppat_record
        ((List.map
            (fun x  ->
               let (x0,x1) = x  in
               ((copy_loc copy_longident x0),
                 (copy_pattern x1))) x0),
          (copy_closed_flag x1))
  | From.Parsetree.Ppat_array x0 ->
      To.Parsetree.Ppat_array
        (List.map copy_pattern x0)
  | From.Parsetree.Ppat_or (x0,x1) ->
      To.Parsetree.Ppat_or
        ((copy_pattern x0),
          (copy_pattern x1))
  | From.Parsetree.Ppat_constraint (x0,x1) ->
      To.Parsetree.Ppat_constraint
        ((copy_pattern x0),
          (copy_core_type x1))
  | From.Parsetree.Ppat_type x0 ->
      To.Parsetree.Ppat_type
        (copy_loc copy_longident x0)
  | From.Parsetree.Ppat_lazy x0 ->
      To.Parsetree.Ppat_lazy (copy_pattern x0)
  | From.Parsetree.Ppat_unpack x0 ->
      To.Parsetree.Ppat_unpack
        (copy_loc (fun x  -> x) x0)
  | From.Parsetree.Ppat_exception x0 ->
      To.Parsetree.Ppat_exception (copy_pattern x0)
  | From.Parsetree.Ppat_extension x0 ->
      To.Parsetree.Ppat_extension (copy_extension x0)
  | From.Parsetree.Ppat_open (x0,x1) ->
      To.Parsetree.Ppat_open
        ((copy_loc copy_longident x0),
          (copy_pattern x1))

and copy_core_type :
  From.Parsetree.core_type -> To.Parsetree.core_type =
  fun
    { From.Parsetree.ptyp_desc = ptyp_desc;
      From.Parsetree.ptyp_loc = ptyp_loc;
      From.Parsetree.ptyp_attributes = ptyp_attributes }
     ->
    {
      To.Parsetree.ptyp_desc =
        (copy_core_type_desc ptyp_desc);
      To.Parsetree.ptyp_loc = (copy_location ptyp_loc);
      To.Parsetree.ptyp_attributes =
        (copy_attributes ptyp_attributes)
    }

and copy_core_type_desc :
  From.Parsetree.core_type_desc -> To.Parsetree.core_type_desc =
  function
  | From.Parsetree.Ptyp_any  -> To.Parsetree.Ptyp_any
  | From.Parsetree.Ptyp_var x0 -> To.Parsetree.Ptyp_var x0
  | From.Parsetree.Ptyp_arrow (x0,x1,x2) ->
      To.Parsetree.Ptyp_arrow
        ((copy_arg_label x0),
          (copy_core_type x1),
          (copy_core_type x2))
  | From.Parsetree.Ptyp_tuple x0 ->
      To.Parsetree.Ptyp_tuple
        (List.map copy_core_type x0)
  | From.Parsetree.Ptyp_constr (x0,x1) ->
      To.Parsetree.Ptyp_constr
        ((copy_loc copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Ptyp_object (x0,x1) ->
      To.Parsetree.Ptyp_object
        ((List.map
            (fun x  ->
               let (x0,x1,x2) = x  in
               (copy_loc (fun x  -> x) x0, (copy_attributes x1),
                 (copy_core_type x2))) x0),
          (copy_closed_flag x1))
  | From.Parsetree.Ptyp_class (x0,x1) ->
      To.Parsetree.Ptyp_class
        ((copy_loc copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Ptyp_alias (x0,x1) ->
      To.Parsetree.Ptyp_alias
        ((copy_core_type x0), x1)
  | From.Parsetree.Ptyp_variant (x0,x1,x2) ->
      To.Parsetree.Ptyp_variant
        ((List.map copy_row_field x0),
          (copy_closed_flag x1),
          (copy_option (fun x  -> List.map copy_label x) x2))
  | From.Parsetree.Ptyp_poly (x0,x1) ->
      To.Parsetree.Ptyp_poly
        ((List.map (fun x  -> copy_loc (fun x  -> x) x) x0), (copy_core_type x1))
  | From.Parsetree.Ptyp_package x0 ->
      To.Parsetree.Ptyp_package (copy_package_type x0)
  | From.Parsetree.Ptyp_extension x0 ->
      To.Parsetree.Ptyp_extension (copy_extension x0)

and copy_package_type :
  From.Parsetree.package_type -> To.Parsetree.package_type =
  fun x  ->
    let (x0,x1) = x  in
    ((copy_loc copy_longident x0),
      (List.map
         (fun x  ->
            let (x0,x1) = x  in
            ((copy_loc copy_longident x0),
              (copy_core_type x1))) x1))

and copy_row_field :
  From.Parsetree.row_field -> To.Parsetree.row_field =
  function
  | From.Parsetree.Rtag (x0,x1,x2,x3) ->
      To.Parsetree.Rtag
        ((copy_label x0),
          (copy_attributes x1), (copy_bool x2),
          (List.map copy_core_type x3))
  | From.Parsetree.Rinherit x0 ->
      To.Parsetree.Rinherit (copy_core_type x0)

and copy_attributes :
  From.Parsetree.attributes -> To.Parsetree.attributes =
  fun x  -> List.map copy_attribute x

and copy_attribute :
  From.Parsetree.attribute -> To.Parsetree.attribute =
  fun x  ->
    let (x0,x1) = x  in
    ((copy_loc (fun x  -> x) x0),
      (copy_payload x1))

and copy_payload :
  From.Parsetree.payload -> To.Parsetree.payload =
  function
  | From.Parsetree.PStr x0 ->
      To.Parsetree.PStr (copy_structure x0)
  | From.Parsetree.PSig x0 ->
      To.Parsetree.PSig (copy_signature x0)
  | From.Parsetree.PTyp x0 ->
      To.Parsetree.PTyp (copy_core_type x0)
  | From.Parsetree.PPat (x0,x1) ->
      To.Parsetree.PPat
        ((copy_pattern x0),
          (copy_option copy_expression x1))

and copy_structure :
  From.Parsetree.structure -> To.Parsetree.structure =
  fun x  -> List.map copy_structure_item x

and copy_structure_item :
  From.Parsetree.structure_item -> To.Parsetree.structure_item =
  fun
    { From.Parsetree.pstr_desc = pstr_desc;
      From.Parsetree.pstr_loc = pstr_loc }
     ->
    {
      To.Parsetree.pstr_desc =
        (copy_structure_item_desc pstr_desc);
      To.Parsetree.pstr_loc = (copy_location pstr_loc)
    }

and copy_structure_item_desc :
  From.Parsetree.structure_item_desc ->
    To.Parsetree.structure_item_desc
  =
  function
  | From.Parsetree.Pstr_eval (x0,x1) ->
      To.Parsetree.Pstr_eval
        ((copy_expression x0),
          (copy_attributes x1))
  | From.Parsetree.Pstr_value (x0,x1) ->
      To.Parsetree.Pstr_value
        ((copy_rec_flag x0),
          (List.map copy_value_binding x1))
  | From.Parsetree.Pstr_primitive x0 ->
      To.Parsetree.Pstr_primitive
        (copy_value_description x0)
  | From.Parsetree.Pstr_type (x0,x1) ->
      To.Parsetree.Pstr_type
        ((copy_rec_flag x0),
          (List.map copy_type_declaration x1))
  | From.Parsetree.Pstr_typext x0 ->
      To.Parsetree.Pstr_typext
        (copy_type_extension x0)
  | From.Parsetree.Pstr_exception x0 ->
      To.Parsetree.Pstr_exception
        (copy_extension_constructor x0)
  | From.Parsetree.Pstr_module x0 ->
      To.Parsetree.Pstr_module
        (copy_module_binding x0)
  | From.Parsetree.Pstr_recmodule x0 ->
      To.Parsetree.Pstr_recmodule
        (List.map copy_module_binding x0)
  | From.Parsetree.Pstr_modtype x0 ->
      To.Parsetree.Pstr_modtype
        (copy_module_type_declaration x0)
  | From.Parsetree.Pstr_open x0 ->
      To.Parsetree.Pstr_open
        (copy_open_description x0)
  | From.Parsetree.Pstr_class x0 ->
      To.Parsetree.Pstr_class
        (List.map copy_class_declaration x0)
  | From.Parsetree.Pstr_class_type x0 ->
      To.Parsetree.Pstr_class_type
        (List.map copy_class_type_declaration x0)
  | From.Parsetree.Pstr_include x0 ->
      To.Parsetree.Pstr_include
        (copy_include_declaration x0)
  | From.Parsetree.Pstr_attribute x0 ->
      To.Parsetree.Pstr_attribute (copy_attribute x0)
  | From.Parsetree.Pstr_extension (x0,x1) ->
      To.Parsetree.Pstr_extension
        ((copy_extension x0),
          (copy_attributes x1))

and copy_include_declaration :
  From.Parsetree.include_declaration ->
    To.Parsetree.include_declaration
  =
  fun x  ->
    copy_include_infos copy_module_expr x

and copy_class_declaration :
  From.Parsetree.class_declaration -> To.Parsetree.class_declaration
  =
  fun x  ->
    copy_class_infos copy_class_expr x

and copy_class_expr :
  From.Parsetree.class_expr -> To.Parsetree.class_expr =
  fun
    { From.Parsetree.pcl_desc = pcl_desc;
      From.Parsetree.pcl_loc = pcl_loc;
      From.Parsetree.pcl_attributes = pcl_attributes }
     ->
    {
      To.Parsetree.pcl_desc =
        (copy_class_expr_desc pcl_desc);
      To.Parsetree.pcl_loc = (copy_location pcl_loc);
      To.Parsetree.pcl_attributes =
        (copy_attributes pcl_attributes)
    }

and copy_class_expr_desc :
  From.Parsetree.class_expr_desc -> To.Parsetree.class_expr_desc =
  function
  | From.Parsetree.Pcl_constr (x0,x1) ->
      To.Parsetree.Pcl_constr
        ((copy_loc copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Pcl_structure x0 ->
      To.Parsetree.Pcl_structure
        (copy_class_structure x0)
  | From.Parsetree.Pcl_fun (x0,x1,x2,x3) ->
      To.Parsetree.Pcl_fun
        ((copy_arg_label x0),
          (copy_option copy_expression x1),
          (copy_pattern x2),
          (copy_class_expr x3))
  | From.Parsetree.Pcl_apply (x0,x1) ->
      To.Parsetree.Pcl_apply
        ((copy_class_expr x0),
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                ((copy_arg_label x0),
                  (copy_expression x1))) x1))
  | From.Parsetree.Pcl_let (x0,x1,x2) ->
      To.Parsetree.Pcl_let
        ((copy_rec_flag x0),
          (List.map copy_value_binding x1),
          (copy_class_expr x2))
  | From.Parsetree.Pcl_constraint (x0,x1) ->
      To.Parsetree.Pcl_constraint
        ((copy_class_expr x0),
          (copy_class_type x1))
  | From.Parsetree.Pcl_extension x0 ->
      To.Parsetree.Pcl_extension (copy_extension x0)

and copy_class_structure :
  From.Parsetree.class_structure -> To.Parsetree.class_structure =
  fun
    { From.Parsetree.pcstr_self = pcstr_self;
      From.Parsetree.pcstr_fields = pcstr_fields }
     ->
    {
      To.Parsetree.pcstr_self =
        (copy_pattern pcstr_self);
      To.Parsetree.pcstr_fields =
        (List.map copy_class_field pcstr_fields)
    }

and copy_class_field :
  From.Parsetree.class_field -> To.Parsetree.class_field =
  fun
    { From.Parsetree.pcf_desc = pcf_desc;
      From.Parsetree.pcf_loc = pcf_loc;
      From.Parsetree.pcf_attributes = pcf_attributes }
     ->
    {
      To.Parsetree.pcf_desc =
        (copy_class_field_desc pcf_desc);
      To.Parsetree.pcf_loc = (copy_location pcf_loc);
      To.Parsetree.pcf_attributes =
        (copy_attributes pcf_attributes)
    }

and copy_class_field_desc :
  From.Parsetree.class_field_desc -> To.Parsetree.class_field_desc =
  function
  | From.Parsetree.Pcf_inherit (x0,x1,x2) ->
      To.Parsetree.Pcf_inherit
        ((copy_override_flag x0),
          (copy_class_expr x1),
          (copy_option (copy_loc (fun x  -> x)) x2))
  | From.Parsetree.Pcf_val x0 ->
      To.Parsetree.Pcf_val
        (let (x0,x1,x2) = x0  in
         ((copy_loc (fun x  -> x) x0),
           (copy_mutable_flag x1),
           (copy_class_field_kind x2)))
  | From.Parsetree.Pcf_method x0 ->
      To.Parsetree.Pcf_method
        (let (x0,x1,x2) = x0  in
         ((copy_loc (fun x  -> x) x0),
           (copy_private_flag x1),
           (copy_class_field_kind x2)))
  | From.Parsetree.Pcf_constraint x0 ->
      To.Parsetree.Pcf_constraint
        (let (x0,x1) = x0  in
         ((copy_core_type x0),
           (copy_core_type x1)))
  | From.Parsetree.Pcf_initializer x0 ->
      To.Parsetree.Pcf_initializer
        (copy_expression x0)
  | From.Parsetree.Pcf_attribute x0 ->
      To.Parsetree.Pcf_attribute (copy_attribute x0)
  | From.Parsetree.Pcf_extension x0 ->
      To.Parsetree.Pcf_extension (copy_extension x0)

and copy_class_field_kind :
  From.Parsetree.class_field_kind -> To.Parsetree.class_field_kind =
  function
  | From.Parsetree.Cfk_virtual x0 ->
      To.Parsetree.Cfk_virtual (copy_core_type x0)
  | From.Parsetree.Cfk_concrete (x0,x1) ->
      To.Parsetree.Cfk_concrete
        ((copy_override_flag x0),
          (copy_expression x1))

and copy_module_binding :
  From.Parsetree.module_binding -> To.Parsetree.module_binding =
  fun
    { From.Parsetree.pmb_name = pmb_name;
      From.Parsetree.pmb_expr = pmb_expr;
      From.Parsetree.pmb_attributes = pmb_attributes;
      From.Parsetree.pmb_loc = pmb_loc }
     ->
    {
      To.Parsetree.pmb_name =
        (copy_loc (fun x  -> x) pmb_name);
      To.Parsetree.pmb_expr =
        (copy_module_expr pmb_expr);
      To.Parsetree.pmb_attributes =
        (copy_attributes pmb_attributes);
      To.Parsetree.pmb_loc = (copy_location pmb_loc)
    }

and copy_module_expr :
  From.Parsetree.module_expr -> To.Parsetree.module_expr =
  fun
    { From.Parsetree.pmod_desc = pmod_desc;
      From.Parsetree.pmod_loc = pmod_loc;
      From.Parsetree.pmod_attributes = pmod_attributes }
     ->
    {
      To.Parsetree.pmod_desc =
        (copy_module_expr_desc pmod_desc);
      To.Parsetree.pmod_loc = (copy_location pmod_loc);
      To.Parsetree.pmod_attributes =
        (copy_attributes pmod_attributes)
    }

and copy_module_expr_desc :
  From.Parsetree.module_expr_desc -> To.Parsetree.module_expr_desc =
  function
  | From.Parsetree.Pmod_ident x0 ->
      To.Parsetree.Pmod_ident
        (copy_loc copy_longident x0)
  | From.Parsetree.Pmod_structure x0 ->
      To.Parsetree.Pmod_structure (copy_structure x0)
  | From.Parsetree.Pmod_functor (x0,x1,x2) ->
      To.Parsetree.Pmod_functor
        ((copy_loc (fun x  -> x) x0),
          (copy_option copy_module_type x1),
          (copy_module_expr x2))
  | From.Parsetree.Pmod_apply (x0,x1) ->
      To.Parsetree.Pmod_apply
        ((copy_module_expr x0),
          (copy_module_expr x1))
  | From.Parsetree.Pmod_constraint (x0,x1) ->
      To.Parsetree.Pmod_constraint
        ((copy_module_expr x0),
          (copy_module_type x1))
  | From.Parsetree.Pmod_unpack x0 ->
      To.Parsetree.Pmod_unpack (copy_expression x0)
  | From.Parsetree.Pmod_extension x0 ->
      To.Parsetree.Pmod_extension (copy_extension x0)

and copy_module_type :
  From.Parsetree.module_type -> To.Parsetree.module_type =
  fun
    { From.Parsetree.pmty_desc = pmty_desc;
      From.Parsetree.pmty_loc = pmty_loc;
      From.Parsetree.pmty_attributes = pmty_attributes }
     ->
    {
      To.Parsetree.pmty_desc =
        (copy_module_type_desc pmty_desc);
      To.Parsetree.pmty_loc = (copy_location pmty_loc);
      To.Parsetree.pmty_attributes =
        (copy_attributes pmty_attributes)
    }

and copy_module_type_desc :
  From.Parsetree.module_type_desc -> To.Parsetree.module_type_desc =
  function
  | From.Parsetree.Pmty_ident x0 ->
      To.Parsetree.Pmty_ident
        (copy_loc copy_longident x0)
  | From.Parsetree.Pmty_signature x0 ->
      To.Parsetree.Pmty_signature (copy_signature x0)
  | From.Parsetree.Pmty_functor (x0,x1,x2) ->
      To.Parsetree.Pmty_functor
        ((copy_loc (fun x  -> x) x0),
          (copy_option copy_module_type x1),
          (copy_module_type x2))
  | From.Parsetree.Pmty_with (x0,x1) ->
      To.Parsetree.Pmty_with
        ((copy_module_type x0),
          (List.map copy_with_constraint x1))
  | From.Parsetree.Pmty_typeof x0 ->
      To.Parsetree.Pmty_typeof (copy_module_expr x0)
  | From.Parsetree.Pmty_extension x0 ->
      To.Parsetree.Pmty_extension (copy_extension x0)
  | From.Parsetree.Pmty_alias x0 ->
      To.Parsetree.Pmty_alias
        (copy_loc copy_longident x0)

and copy_with_constraint :
  From.Parsetree.with_constraint -> To.Parsetree.with_constraint =
  function
  | From.Parsetree.Pwith_type (x0,x1) ->
      To.Parsetree.Pwith_type
        ((copy_loc copy_longident x0),
          (copy_type_declaration x1))
  | From.Parsetree.Pwith_module (x0,x1) ->
      To.Parsetree.Pwith_module
        ((copy_loc copy_longident x0),
          (copy_loc copy_longident x1))
  | From.Parsetree.Pwith_typesubst x0 ->
      To.Parsetree.Pwith_typesubst
        (copy_type_declaration x0)
  | From.Parsetree.Pwith_modsubst (x0,x1) ->
      To.Parsetree.Pwith_modsubst
        ((copy_loc (fun x  -> x) x0),
          (copy_loc copy_longident x1))

and copy_signature :
  From.Parsetree.signature -> To.Parsetree.signature =
  fun x  -> List.map copy_signature_item x

and copy_signature_item :
  From.Parsetree.signature_item -> To.Parsetree.signature_item =
  fun
    { From.Parsetree.psig_desc = psig_desc;
      From.Parsetree.psig_loc = psig_loc }
     ->
    {
      To.Parsetree.psig_desc =
        (copy_signature_item_desc psig_desc);
      To.Parsetree.psig_loc = (copy_location psig_loc)
    }

and copy_signature_item_desc :
  From.Parsetree.signature_item_desc ->
    To.Parsetree.signature_item_desc
  =
  function
  | From.Parsetree.Psig_value x0 ->
      To.Parsetree.Psig_value
        (copy_value_description x0)
  | From.Parsetree.Psig_type (x0,x1) ->
      To.Parsetree.Psig_type
        ((copy_rec_flag x0),
          (List.map copy_type_declaration x1))
  | From.Parsetree.Psig_typext x0 ->
      To.Parsetree.Psig_typext
        (copy_type_extension x0)
  | From.Parsetree.Psig_exception x0 ->
      To.Parsetree.Psig_exception
        (copy_extension_constructor x0)
  | From.Parsetree.Psig_module x0 ->
      To.Parsetree.Psig_module
        (copy_module_declaration x0)
  | From.Parsetree.Psig_recmodule x0 ->
      To.Parsetree.Psig_recmodule
        (List.map copy_module_declaration x0)
  | From.Parsetree.Psig_modtype x0 ->
      To.Parsetree.Psig_modtype
        (copy_module_type_declaration x0)
  | From.Parsetree.Psig_open x0 ->
      To.Parsetree.Psig_open
        (copy_open_description x0)
  | From.Parsetree.Psig_include x0 ->
      To.Parsetree.Psig_include
        (copy_include_description x0)
  | From.Parsetree.Psig_class x0 ->
      To.Parsetree.Psig_class
        (List.map copy_class_description x0)
  | From.Parsetree.Psig_class_type x0 ->
      To.Parsetree.Psig_class_type
        (List.map copy_class_type_declaration x0)
  | From.Parsetree.Psig_attribute x0 ->
      To.Parsetree.Psig_attribute (copy_attribute x0)
  | From.Parsetree.Psig_extension (x0,x1) ->
      To.Parsetree.Psig_extension
        ((copy_extension x0),
          (copy_attributes x1))

and copy_class_type_declaration :
  From.Parsetree.class_type_declaration ->
    To.Parsetree.class_type_declaration
  =
  fun x  ->
    copy_class_infos copy_class_type x

and copy_class_description :
  From.Parsetree.class_description -> To.Parsetree.class_description
  =
  fun x  ->
    copy_class_infos copy_class_type x

and copy_class_type :
  From.Parsetree.class_type -> To.Parsetree.class_type =
  fun
    { From.Parsetree.pcty_desc = pcty_desc;
      From.Parsetree.pcty_loc = pcty_loc;
      From.Parsetree.pcty_attributes = pcty_attributes }
     ->
    {
      To.Parsetree.pcty_desc =
        (copy_class_type_desc pcty_desc);
      To.Parsetree.pcty_loc = (copy_location pcty_loc);
      To.Parsetree.pcty_attributes =
        (copy_attributes pcty_attributes)
    }

and copy_class_type_desc :
  From.Parsetree.class_type_desc -> To.Parsetree.class_type_desc =
  function
  | From.Parsetree.Pcty_constr (x0,x1) ->
      To.Parsetree.Pcty_constr
        ((copy_loc copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Pcty_signature x0 ->
      To.Parsetree.Pcty_signature
        (copy_class_signature x0)
  | From.Parsetree.Pcty_arrow (x0,x1,x2) ->
      To.Parsetree.Pcty_arrow
        ((copy_arg_label x0),
          (copy_core_type x1),
          (copy_class_type x2))
  | From.Parsetree.Pcty_extension x0 ->
      To.Parsetree.Pcty_extension (copy_extension x0)

and copy_class_signature :
  From.Parsetree.class_signature -> To.Parsetree.class_signature =
  fun
    { From.Parsetree.pcsig_self = pcsig_self;
      From.Parsetree.pcsig_fields = pcsig_fields }
     ->
    {
      To.Parsetree.pcsig_self =
        (copy_core_type pcsig_self);
      To.Parsetree.pcsig_fields =
        (List.map copy_class_type_field pcsig_fields)
    }

and copy_class_type_field :
  From.Parsetree.class_type_field -> To.Parsetree.class_type_field =
  fun
    { From.Parsetree.pctf_desc = pctf_desc;
      From.Parsetree.pctf_loc = pctf_loc;
      From.Parsetree.pctf_attributes = pctf_attributes }
     ->
    {
      To.Parsetree.pctf_desc =
        (copy_class_type_field_desc pctf_desc);
      To.Parsetree.pctf_loc = (copy_location pctf_loc);
      To.Parsetree.pctf_attributes =
        (copy_attributes pctf_attributes)
    }

and copy_class_type_field_desc :
  From.Parsetree.class_type_field_desc ->
    To.Parsetree.class_type_field_desc
  =
  function
  | From.Parsetree.Pctf_inherit x0 ->
      To.Parsetree.Pctf_inherit (copy_class_type x0)
  | From.Parsetree.Pctf_val x0 ->
      To.Parsetree.Pctf_val
        (let (x0,x1,x2,x3) = x0  in
         (copy_loc (fun x  -> x) x0, (copy_mutable_flag x1),
           (copy_virtual_flag x2),
           (copy_core_type x3)))
  | From.Parsetree.Pctf_method x0 ->
      To.Parsetree.Pctf_method
        (let (x0,x1,x2,x3) = x0  in
         (copy_loc (fun x  -> x) x0, (copy_private_flag x1),
           (copy_virtual_flag x2),
           (copy_core_type x3)))
  | From.Parsetree.Pctf_constraint x0 ->
      To.Parsetree.Pctf_constraint
        (let (x0,x1) = x0  in
         ((copy_core_type x0),
           (copy_core_type x1)))
  | From.Parsetree.Pctf_attribute x0 ->
      To.Parsetree.Pctf_attribute (copy_attribute x0)
  | From.Parsetree.Pctf_extension x0 ->
      To.Parsetree.Pctf_extension (copy_extension x0)

and copy_extension :
  From.Parsetree.extension -> To.Parsetree.extension =
  fun x  ->
    let (x0,x1) = x  in
    ((copy_loc (fun x  -> x) x0),
      (copy_payload x1))

and copy_class_infos :
  'f0 'g0 .
    ('f0 -> 'g0) ->
      'f0 From.Parsetree.class_infos -> 'g0 To.Parsetree.class_infos
  =
  fun f0  ->
    fun
      { From.Parsetree.pci_virt = pci_virt;
        From.Parsetree.pci_params = pci_params;
        From.Parsetree.pci_name = pci_name;
        From.Parsetree.pci_expr = pci_expr;
        From.Parsetree.pci_loc = pci_loc;
        From.Parsetree.pci_attributes = pci_attributes }
       ->
      {
        To.Parsetree.pci_virt =
          (copy_virtual_flag pci_virt);
        To.Parsetree.pci_params =
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                ((copy_core_type x0),
                  (copy_variance x1))) pci_params);
        To.Parsetree.pci_name =
          (copy_loc (fun x  -> x) pci_name);
        To.Parsetree.pci_expr = (f0 pci_expr);
        To.Parsetree.pci_loc = (copy_location pci_loc);
        To.Parsetree.pci_attributes =
          (copy_attributes pci_attributes)
      }

and copy_virtual_flag :
  From.Asttypes.virtual_flag -> To.Asttypes.virtual_flag =
  function
  | From.Asttypes.Virtual  -> To.Asttypes.Virtual
  | From.Asttypes.Concrete  -> To.Asttypes.Concrete

and copy_include_description :
  From.Parsetree.include_description ->
    To.Parsetree.include_description
  =
  fun x  ->
    copy_include_infos copy_module_type x

and copy_include_infos :
  'f0 'g0 .
    ('f0 -> 'g0) ->
      'f0 From.Parsetree.include_infos ->
        'g0 To.Parsetree.include_infos
  =
  fun f0  ->
    fun
      { From.Parsetree.pincl_mod = pincl_mod;
        From.Parsetree.pincl_loc = pincl_loc;
        From.Parsetree.pincl_attributes = pincl_attributes }
       ->
      {
        To.Parsetree.pincl_mod = (f0 pincl_mod);
        To.Parsetree.pincl_loc = (copy_location pincl_loc);
        To.Parsetree.pincl_attributes =
          (copy_attributes pincl_attributes)
      }

and copy_open_description :
  From.Parsetree.open_description -> To.Parsetree.open_description =
  fun
    { From.Parsetree.popen_lid = popen_lid;
      From.Parsetree.popen_override = popen_override;
      From.Parsetree.popen_loc = popen_loc;
      From.Parsetree.popen_attributes = popen_attributes }
     ->
    {
      To.Parsetree.popen_lid =
        (copy_loc copy_longident popen_lid);
      To.Parsetree.popen_override =
        (copy_override_flag popen_override);
      To.Parsetree.popen_loc = (copy_location popen_loc);
      To.Parsetree.popen_attributes =
        (copy_attributes popen_attributes)
    }

and copy_override_flag :
  From.Asttypes.override_flag -> To.Asttypes.override_flag =
  function
  | From.Asttypes.Override  -> To.Asttypes.Override
  | From.Asttypes.Fresh  -> To.Asttypes.Fresh

and copy_module_type_declaration :
  From.Parsetree.module_type_declaration ->
    To.Parsetree.module_type_declaration
  =
  fun
    { From.Parsetree.pmtd_name = pmtd_name;
      From.Parsetree.pmtd_type = pmtd_type;
      From.Parsetree.pmtd_attributes = pmtd_attributes;
      From.Parsetree.pmtd_loc = pmtd_loc }
     ->
    {
      To.Parsetree.pmtd_name =
        (copy_loc (fun x  -> x) pmtd_name);
      To.Parsetree.pmtd_type =
        (copy_option copy_module_type pmtd_type);
      To.Parsetree.pmtd_attributes =
        (copy_attributes pmtd_attributes);
      To.Parsetree.pmtd_loc = (copy_location pmtd_loc)
    }

and copy_module_declaration :
  From.Parsetree.module_declaration ->
    To.Parsetree.module_declaration
  =
  fun
    { From.Parsetree.pmd_name = pmd_name;
      From.Parsetree.pmd_type = pmd_type;
      From.Parsetree.pmd_attributes = pmd_attributes;
      From.Parsetree.pmd_loc = pmd_loc }
     ->
    {
      To.Parsetree.pmd_name =
        (copy_loc (fun x  -> x) pmd_name);
      To.Parsetree.pmd_type =
        (copy_module_type pmd_type);
      To.Parsetree.pmd_attributes =
        (copy_attributes pmd_attributes);
      To.Parsetree.pmd_loc = (copy_location pmd_loc)
    }

and copy_type_extension :
  From.Parsetree.type_extension -> To.Parsetree.type_extension =
  fun
    { From.Parsetree.ptyext_path = ptyext_path;
      From.Parsetree.ptyext_params = ptyext_params;
      From.Parsetree.ptyext_constructors = ptyext_constructors;
      From.Parsetree.ptyext_private = ptyext_private;
      From.Parsetree.ptyext_attributes = ptyext_attributes }
     ->
    {
      To.Parsetree.ptyext_path =
        (copy_loc copy_longident ptyext_path);
      To.Parsetree.ptyext_params =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_core_type x0),
                (copy_variance x1))) ptyext_params);
      To.Parsetree.ptyext_constructors =
        (List.map copy_extension_constructor
           ptyext_constructors);
      To.Parsetree.ptyext_private =
        (copy_private_flag ptyext_private);
      To.Parsetree.ptyext_attributes =
        (copy_attributes ptyext_attributes)
    }

and copy_extension_constructor :
  From.Parsetree.extension_constructor ->
    To.Parsetree.extension_constructor
  =
  fun
    { From.Parsetree.pext_name = pext_name;
      From.Parsetree.pext_kind = pext_kind;
      From.Parsetree.pext_loc = pext_loc;
      From.Parsetree.pext_attributes = pext_attributes }
     ->
    {
      To.Parsetree.pext_name =
        (copy_loc (fun x  -> x) pext_name);
      To.Parsetree.pext_kind =
        (copy_extension_constructor_kind pext_kind);
      To.Parsetree.pext_loc = (copy_location pext_loc);
      To.Parsetree.pext_attributes =
        (copy_attributes pext_attributes)
    }

and copy_extension_constructor_kind :
  From.Parsetree.extension_constructor_kind ->
    To.Parsetree.extension_constructor_kind
  =
  function
  | From.Parsetree.Pext_decl (x0,x1) ->
      To.Parsetree.Pext_decl
        ((copy_constructor_arguments x0),
          (copy_option copy_core_type x1))
  | From.Parsetree.Pext_rebind x0 ->
      To.Parsetree.Pext_rebind
        (copy_loc copy_longident x0)

and copy_type_declaration :
  From.Parsetree.type_declaration -> To.Parsetree.type_declaration =
  fun
    { From.Parsetree.ptype_name = ptype_name;
      From.Parsetree.ptype_params = ptype_params;
      From.Parsetree.ptype_cstrs = ptype_cstrs;
      From.Parsetree.ptype_kind = ptype_kind;
      From.Parsetree.ptype_private = ptype_private;
      From.Parsetree.ptype_manifest = ptype_manifest;
      From.Parsetree.ptype_attributes = ptype_attributes;
      From.Parsetree.ptype_loc = ptype_loc }
     ->
    {
      To.Parsetree.ptype_name =
        (copy_loc (fun x  -> x) ptype_name);
      To.Parsetree.ptype_params =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_core_type x0),
                (copy_variance x1))) ptype_params);
      To.Parsetree.ptype_cstrs =
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              ((copy_core_type x0),
                (copy_core_type x1),
                (copy_location x2))) ptype_cstrs);
      To.Parsetree.ptype_kind =
        (copy_type_kind ptype_kind);
      To.Parsetree.ptype_private =
        (copy_private_flag ptype_private);
      To.Parsetree.ptype_manifest =
        (copy_option copy_core_type ptype_manifest);
      To.Parsetree.ptype_attributes =
        (copy_attributes ptype_attributes);
      To.Parsetree.ptype_loc = (copy_location ptype_loc)
    }

and copy_private_flag :
  From.Asttypes.private_flag -> To.Asttypes.private_flag =
  function
  | From.Asttypes.Private  -> To.Asttypes.Private
  | From.Asttypes.Public  -> To.Asttypes.Public

and copy_type_kind :
  From.Parsetree.type_kind -> To.Parsetree.type_kind =
  function
  | From.Parsetree.Ptype_abstract  -> To.Parsetree.Ptype_abstract
  | From.Parsetree.Ptype_variant x0 ->
      To.Parsetree.Ptype_variant
        (List.map copy_constructor_declaration x0)
  | From.Parsetree.Ptype_record x0 ->
      To.Parsetree.Ptype_record
        (List.map copy_label_declaration x0)
  | From.Parsetree.Ptype_open  -> To.Parsetree.Ptype_open

and copy_constructor_declaration :
  From.Parsetree.constructor_declaration ->
    To.Parsetree.constructor_declaration
  =
  fun
    { From.Parsetree.pcd_name = pcd_name;
      From.Parsetree.pcd_args = pcd_args;
      From.Parsetree.pcd_res = pcd_res;
      From.Parsetree.pcd_loc = pcd_loc;
      From.Parsetree.pcd_attributes = pcd_attributes }
     ->
    {
      To.Parsetree.pcd_name =
        (copy_loc (fun x  -> x) pcd_name);
      To.Parsetree.pcd_args =
        (copy_constructor_arguments pcd_args);
      To.Parsetree.pcd_res =
        (copy_option copy_core_type pcd_res);
      To.Parsetree.pcd_loc = (copy_location pcd_loc);
      To.Parsetree.pcd_attributes =
        (copy_attributes pcd_attributes)
    }

and copy_constructor_arguments :
  From.Parsetree.constructor_arguments ->
    To.Parsetree.constructor_arguments
  =
  function
  | From.Parsetree.Pcstr_tuple x0 ->
      To.Parsetree.Pcstr_tuple
        (List.map copy_core_type x0)
  | From.Parsetree.Pcstr_record x0 ->
      To.Parsetree.Pcstr_record
        (List.map copy_label_declaration x0)

and copy_label_declaration :
  From.Parsetree.label_declaration -> To.Parsetree.label_declaration
  =
  fun
    { From.Parsetree.pld_name = pld_name;
      From.Parsetree.pld_mutable = pld_mutable;
      From.Parsetree.pld_type = pld_type;
      From.Parsetree.pld_loc = pld_loc;
      From.Parsetree.pld_attributes = pld_attributes }
     ->
    {
      To.Parsetree.pld_name =
        (copy_loc (fun x  -> x) pld_name);
      To.Parsetree.pld_mutable =
        (copy_mutable_flag pld_mutable);
      To.Parsetree.pld_type =
        (copy_core_type pld_type);
      To.Parsetree.pld_loc = (copy_location pld_loc);
      To.Parsetree.pld_attributes =
        (copy_attributes pld_attributes)
    }

and copy_mutable_flag :
  From.Asttypes.mutable_flag -> To.Asttypes.mutable_flag =
  function
  | From.Asttypes.Immutable  -> To.Asttypes.Immutable
  | From.Asttypes.Mutable  -> To.Asttypes.Mutable

and copy_variance :
  From.Asttypes.variance -> To.Asttypes.variance =
  function
  | From.Asttypes.Covariant  -> To.Asttypes.Covariant
  | From.Asttypes.Contravariant  -> To.Asttypes.Contravariant
  | From.Asttypes.Invariant  -> To.Asttypes.Invariant

and copy_value_description :
  From.Parsetree.value_description -> To.Parsetree.value_description
  =
  fun
    { From.Parsetree.pval_name = pval_name;
      From.Parsetree.pval_type = pval_type;
      From.Parsetree.pval_prim = pval_prim;
      From.Parsetree.pval_attributes = pval_attributes;
      From.Parsetree.pval_loc = pval_loc }
     ->
    {
      To.Parsetree.pval_name =
        (copy_loc (fun x  -> x) pval_name);
      To.Parsetree.pval_type =
        (copy_core_type pval_type);
      To.Parsetree.pval_prim = (List.map (fun x  -> x) pval_prim);
      To.Parsetree.pval_attributes =
        (copy_attributes pval_attributes);
      To.Parsetree.pval_loc = (copy_location pval_loc)
    }

and copy_arg_label :
  From.Asttypes.arg_label -> To.Asttypes.arg_label =
  function
  | From.Asttypes.Nolabel  -> To.Asttypes.Nolabel
  | From.Asttypes.Labelled x0 -> To.Asttypes.Labelled x0
  | From.Asttypes.Optional x0 -> To.Asttypes.Optional x0

and copy_closed_flag :
  From.Asttypes.closed_flag -> To.Asttypes.closed_flag =
  function
  | From.Asttypes.Closed  -> To.Asttypes.Closed
  | From.Asttypes.Open  -> To.Asttypes.Open

and copy_label :
  From.Asttypes.label -> To.Asttypes.label = fun x  -> x

and copy_rec_flag :
  From.Asttypes.rec_flag -> To.Asttypes.rec_flag =
  function
  | From.Asttypes.Nonrecursive  -> To.Asttypes.Nonrecursive
  | From.Asttypes.Recursive  -> To.Asttypes.Recursive

and copy_constant :
  From.Parsetree.constant -> To.Parsetree.constant =
  function
  | From.Parsetree.Pconst_integer (x0,x1) ->
      To.Parsetree.Pconst_integer (x0, (copy_option (fun x  -> x) x1))
  | From.Parsetree.Pconst_char x0 -> To.Parsetree.Pconst_char x0
  | From.Parsetree.Pconst_string (x0,x1) ->
      To.Parsetree.Pconst_string (x0, (copy_option (fun x  -> x) x1))
  | From.Parsetree.Pconst_float (x0,x1) ->
      To.Parsetree.Pconst_float (x0, (copy_option (fun x  -> x) x1))

and copy_option : 'f0 'g0 . ('f0 -> 'g0) -> 'f0 option -> 'g0 option =
  fun f0  -> function | None  -> None | Some x0 -> Some (f0 x0)

and copy_longident : From.Longident.t -> To.Longident.t =
  function
  | From.Longident.Lident x0 -> To.Longident.Lident x0
  | From.Longident.Ldot (x0,x1) ->
      To.Longident.Ldot ((copy_longident x0), x1)
  | From.Longident.Lapply (x0,x1) ->
      To.Longident.Lapply
        ((copy_longident x0), (copy_longident x1))

and copy_loc :
  'f0 'g0 .
    ('f0 -> 'g0) -> 'f0 From.Asttypes.loc -> 'g0 To.Asttypes.loc
  =
  fun f0  ->
    fun { From.Asttypes.txt = txt; From.Asttypes.loc = loc }  ->
      {
        To.Asttypes.txt = (f0 txt);
        To.Asttypes.loc = (copy_location loc)
      }

and copy_location : From.Location.t -> To.Location.t =
  fun
    { From.Location.loc_start = loc_start;
      From.Location.loc_end = loc_end;
      From.Location.loc_ghost = loc_ghost }
     ->
    {
      To.Location.loc_start = (copy_Lexing_position loc_start);
      To.Location.loc_end = (copy_Lexing_position loc_end);
      To.Location.loc_ghost = (copy_bool loc_ghost)
    }

and copy_bool : bool -> bool = function | false  -> false | true  -> true

and copy_Lexing_position : Lexing.position -> Lexing.position =
  fun
    { Lexing.pos_fname = pos_fname; Lexing.pos_lnum = pos_lnum;
      Lexing.pos_bol = pos_bol; Lexing.pos_cnum = pos_cnum }
     ->
    {
      Lexing.pos_fname = pos_fname;
      Lexing.pos_lnum = pos_lnum;
      Lexing.pos_bol = pos_bol;
      Lexing.pos_cnum = pos_cnum
    }

let rec copy_out_phrase :
  From.Outcometree.out_phrase -> To.Outcometree.out_phrase =
  function
  | From.Outcometree.Ophr_eval (x0,x1) ->
      To.Outcometree.Ophr_eval
        ((copy_out_value x0),
          (copy_out_type x1))
  | From.Outcometree.Ophr_signature x0 ->
      To.Outcometree.Ophr_signature
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_out_sig_item x0),
                (copy_option copy_out_value x1))) x0)
  | From.Outcometree.Ophr_exception x0 ->
      To.Outcometree.Ophr_exception
        (let (x0,x1) = x0  in
         ((copy_exn x0), (copy_out_value x1)))

and copy_exn : exn -> exn = fun x  -> x

and copy_out_sig_item :
  From.Outcometree.out_sig_item -> To.Outcometree.out_sig_item =
  function
  | From.Outcometree.Osig_class (x0,x1,x2,x3,x4) ->
      To.Outcometree.Osig_class
        ((copy_bool x0), x1,
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))
             x2), (copy_out_class_type x3),
          (copy_out_rec_status x4))
  | From.Outcometree.Osig_class_type (x0,x1,x2,x3,x4) ->
      To.Outcometree.Osig_class_type
        ((copy_bool x0), x1,
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))
             x2), (copy_out_class_type x3),
          (copy_out_rec_status x4))
  | From.Outcometree.Osig_typext (x0,x1) ->
      To.Outcometree.Osig_typext
        ((copy_out_extension_constructor x0),
          (copy_out_ext_status x1))
  | From.Outcometree.Osig_modtype (x0,x1) ->
      To.Outcometree.Osig_modtype
        (x0, (copy_out_module_type x1))
  | From.Outcometree.Osig_module (x0,x1,x2) ->
      To.Outcometree.Osig_module
        (x0, (copy_out_module_type x1),
          (copy_out_rec_status x2))
  | From.Outcometree.Osig_type (x0,x1) ->
      To.Outcometree.Osig_type
        ((copy_out_type_decl x0),
          (copy_out_rec_status x1))
  | From.Outcometree.Osig_value x0 ->
      To.Outcometree.Osig_value
        (copy_out_val_decl x0)
  | From.Outcometree.Osig_ellipsis  -> To.Outcometree.Osig_ellipsis

and copy_out_val_decl :
  From.Outcometree.out_val_decl -> To.Outcometree.out_val_decl =
  fun
    { From.Outcometree.oval_name = oval_name;
      From.Outcometree.oval_type = oval_type;
      From.Outcometree.oval_prims = oval_prims;
      From.Outcometree.oval_attributes = oval_attributes }
     ->
    {
      To.Outcometree.oval_name = oval_name;
      To.Outcometree.oval_type =
        (copy_out_type oval_type);
      To.Outcometree.oval_prims = (List.map (fun x  -> x) oval_prims);
      To.Outcometree.oval_attributes =
        (List.map copy_out_attribute oval_attributes)
    }

and copy_out_type_decl :
  From.Outcometree.out_type_decl -> To.Outcometree.out_type_decl =
  fun
    { From.Outcometree.otype_name = otype_name;
      From.Outcometree.otype_params = otype_params;
      From.Outcometree.otype_type = otype_type;
      From.Outcometree.otype_private = otype_private;
      From.Outcometree.otype_immediate = otype_immediate;
      From.Outcometree.otype_unboxed = otype_unboxed;
      From.Outcometree.otype_cstrs = otype_cstrs }
     ->
    {
      To.Outcometree.otype_name = otype_name;
      To.Outcometree.otype_params =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))
           otype_params);
      To.Outcometree.otype_type =
        (copy_out_type otype_type);
      To.Outcometree.otype_private =
        (copy_From_Asttypes_private_flag otype_private);
      To.Outcometree.otype_immediate = (copy_bool otype_immediate);
      To.Outcometree.otype_unboxed = (copy_bool otype_unboxed);
      To.Outcometree.otype_cstrs =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_out_type x0),
                (copy_out_type x1))) otype_cstrs)
    }

and copy_out_module_type :
  From.Outcometree.out_module_type -> To.Outcometree.out_module_type
  =
  function
  | From.Outcometree.Omty_abstract  -> To.Outcometree.Omty_abstract
  | From.Outcometree.Omty_functor (x0,x1,x2) ->
      To.Outcometree.Omty_functor
        (x0, (copy_option copy_out_module_type x1),
          (copy_out_module_type x2))
  | From.Outcometree.Omty_ident x0 ->
      To.Outcometree.Omty_ident (copy_out_ident x0)
  | From.Outcometree.Omty_signature x0 ->
      To.Outcometree.Omty_signature
        (List.map copy_out_sig_item x0)
  | From.Outcometree.Omty_alias x0 ->
      To.Outcometree.Omty_alias (copy_out_ident x0)

and copy_out_ext_status :
  From.Outcometree.out_ext_status -> To.Outcometree.out_ext_status =
  function
  | From.Outcometree.Oext_first  -> To.Outcometree.Oext_first
  | From.Outcometree.Oext_next  -> To.Outcometree.Oext_next
  | From.Outcometree.Oext_exception  -> To.Outcometree.Oext_exception

and copy_out_extension_constructor :
  From.Outcometree.out_extension_constructor ->
    To.Outcometree.out_extension_constructor
  =
  fun
    { From.Outcometree.oext_name = oext_name;
      From.Outcometree.oext_type_name = oext_type_name;
      From.Outcometree.oext_type_params = oext_type_params;
      From.Outcometree.oext_args = oext_args;
      From.Outcometree.oext_ret_type = oext_ret_type;
      From.Outcometree.oext_private = oext_private }
     ->
    {
      To.Outcometree.oext_name = oext_name;
      To.Outcometree.oext_type_name = oext_type_name;
      To.Outcometree.oext_type_params =
        (List.map (fun x  -> x) oext_type_params);
      To.Outcometree.oext_args =
        (List.map copy_out_type oext_args);
      To.Outcometree.oext_ret_type =
        (copy_option copy_out_type oext_ret_type);
      To.Outcometree.oext_private =
        (copy_From_Asttypes_private_flag oext_private)
    }

and copy_From_Asttypes_private_flag :
  From.Asttypes.private_flag -> To.Asttypes.private_flag =
  function
  | From.Asttypes.Private  -> To.Asttypes.Private
  | From.Asttypes.Public  -> To.Asttypes.Public

and copy_out_rec_status :
  From.Outcometree.out_rec_status -> To.Outcometree.out_rec_status =
  function
  | From.Outcometree.Orec_not  -> To.Outcometree.Orec_not
  | From.Outcometree.Orec_first  -> To.Outcometree.Orec_first
  | From.Outcometree.Orec_next  -> To.Outcometree.Orec_next

and copy_out_class_type :
  From.Outcometree.out_class_type -> To.Outcometree.out_class_type =
  function
  | From.Outcometree.Octy_constr (x0,x1) ->
      To.Outcometree.Octy_constr
        ((copy_out_ident x0),
          (List.map copy_out_type x1))
  | From.Outcometree.Octy_arrow (x0,x1,x2) ->
      To.Outcometree.Octy_arrow
        (x0, (copy_out_type x1),
          (copy_out_class_type x2))
  | From.Outcometree.Octy_signature (x0,x1) ->
      To.Outcometree.Octy_signature
        ((copy_option copy_out_type x0),
          (List.map copy_out_class_sig_item x1))

and copy_out_class_sig_item :
  From.Outcometree.out_class_sig_item ->
    To.Outcometree.out_class_sig_item
  =
  function
  | From.Outcometree.Ocsg_constraint (x0,x1) ->
      To.Outcometree.Ocsg_constraint
        ((copy_out_type x0),
          (copy_out_type x1))
  | From.Outcometree.Ocsg_method (x0,x1,x2,x3) ->
      To.Outcometree.Ocsg_method
        (x0, (copy_bool x1), (copy_bool x2),
          (copy_out_type x3))
  | From.Outcometree.Ocsg_value (x0,x1,x2,x3) ->
      To.Outcometree.Ocsg_value
        (x0, (copy_bool x1), (copy_bool x2),
          (copy_out_type x3))

and copy_out_type :
  From.Outcometree.out_type -> To.Outcometree.out_type =
  function
  | From.Outcometree.Otyp_abstract  -> To.Outcometree.Otyp_abstract
  | From.Outcometree.Otyp_open  -> To.Outcometree.Otyp_open
  | From.Outcometree.Otyp_alias (x0,x1) ->
      To.Outcometree.Otyp_alias
        ((copy_out_type x0), x1)
  | From.Outcometree.Otyp_arrow (x0,x1,x2) ->
      To.Outcometree.Otyp_arrow
        (x0, (copy_out_type x1),
          (copy_out_type x2))
  | From.Outcometree.Otyp_class (x0,x1,x2) ->
      To.Outcometree.Otyp_class
        ((copy_bool x0), (copy_out_ident x1),
          (List.map copy_out_type x2))
  | From.Outcometree.Otyp_constr (x0,x1) ->
      To.Outcometree.Otyp_constr
        ((copy_out_ident x0),
          (List.map copy_out_type x1))
  | From.Outcometree.Otyp_manifest (x0,x1) ->
      To.Outcometree.Otyp_manifest
        ((copy_out_type x0),
          (copy_out_type x1))
  | From.Outcometree.Otyp_object (x0,x1) ->
      To.Outcometree.Otyp_object
        ((List.map
            (fun x  ->
               let (x0,x1) = x  in
               (x0, (copy_out_type x1))) x0),
          (copy_option copy_bool x1))
  | From.Outcometree.Otyp_record x0 ->
      To.Outcometree.Otyp_record
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (copy_bool x1), (copy_out_type x2)))
           x0)
  | From.Outcometree.Otyp_stuff x0 -> To.Outcometree.Otyp_stuff x0
  | From.Outcometree.Otyp_sum x0 ->
      To.Outcometree.Otyp_sum
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (List.map copy_out_type x1),
                (copy_option copy_out_type x2))) x0)
  | From.Outcometree.Otyp_tuple x0 ->
      To.Outcometree.Otyp_tuple
        (List.map copy_out_type x0)
  | From.Outcometree.Otyp_var (x0,x1) ->
      To.Outcometree.Otyp_var ((copy_bool x0), x1)
  | From.Outcometree.Otyp_variant (x0,x1,x2,x3) ->
      To.Outcometree.Otyp_variant
        ((copy_bool x0), (copy_out_variant x1),
          (copy_bool x2),
          (copy_option (fun x  -> List.map (fun x  -> x) x) x3))
  | From.Outcometree.Otyp_poly (x0,x1) ->
      To.Outcometree.Otyp_poly
        ((List.map (fun x  -> x) x0), (copy_out_type x1))
  | From.Outcometree.Otyp_module (x0,x1,x2) ->
      To.Outcometree.Otyp_module
        (x0, (List.map (fun x  -> x) x1),
          (List.map copy_out_type x2))
  | From.Outcometree.Otyp_attribute (x0,x1) ->
      To.Outcometree.Otyp_attribute
        ((copy_out_type x0),
          (copy_out_attribute x1))

and copy_out_attribute :
  From.Outcometree.out_attribute -> To.Outcometree.out_attribute =
  fun { From.Outcometree.oattr_name = oattr_name }  ->
    { To.Outcometree.oattr_name = oattr_name }

and copy_out_variant :
  From.Outcometree.out_variant -> To.Outcometree.out_variant =
  function
  | From.Outcometree.Ovar_fields x0 ->
      To.Outcometree.Ovar_fields
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (copy_bool x1),
                (List.map copy_out_type x2))) x0)
  | From.Outcometree.Ovar_typ x0 ->
      To.Outcometree.Ovar_typ (copy_out_type x0)

and copy_out_value :
  From.Outcometree.out_value -> To.Outcometree.out_value =
  function
  | From.Outcometree.Oval_array x0 ->
      To.Outcometree.Oval_array
        (List.map copy_out_value x0)
  | From.Outcometree.Oval_char x0 -> To.Outcometree.Oval_char x0
  | From.Outcometree.Oval_constr (x0,x1) ->
      To.Outcometree.Oval_constr
        ((copy_out_ident x0),
          (List.map copy_out_value x1))
  | From.Outcometree.Oval_ellipsis  -> To.Outcometree.Oval_ellipsis
  | From.Outcometree.Oval_float x0 ->
      To.Outcometree.Oval_float (copy_float x0)
  | From.Outcometree.Oval_int x0 -> To.Outcometree.Oval_int x0
  | From.Outcometree.Oval_int32 x0 -> To.Outcometree.Oval_int32 x0
  | From.Outcometree.Oval_int64 x0 -> To.Outcometree.Oval_int64 x0
  | From.Outcometree.Oval_nativeint x0 ->
      To.Outcometree.Oval_nativeint x0
  | From.Outcometree.Oval_list x0 ->
      To.Outcometree.Oval_list
        (List.map copy_out_value x0)
  | From.Outcometree.Oval_printer x0 ->
      To.Outcometree.Oval_printer x0
  | From.Outcometree.Oval_record x0 ->
      To.Outcometree.Oval_record
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_out_ident x0),
                (copy_out_value x1))) x0)
  | From.Outcometree.Oval_string x0 ->
      To.Outcometree.Oval_string (x0, max_int, Ostr_string)
  | From.Outcometree.Oval_stuff x0 -> To.Outcometree.Oval_stuff x0
  | From.Outcometree.Oval_tuple x0 ->
      To.Outcometree.Oval_tuple
        (List.map copy_out_value x0)
  | From.Outcometree.Oval_variant (x0,x1) ->
      To.Outcometree.Oval_variant
        (x0, (copy_option copy_out_value x1))

and copy_float : float -> float = fun x  -> x

and copy_out_ident :
  From.Outcometree.out_ident -> To.Outcometree.out_ident =
  function
  | From.Outcometree.Oide_apply (x0,x1) ->
      To.Outcometree.Oide_apply
        ((copy_out_ident x0),
          (copy_out_ident x1))
  | From.Outcometree.Oide_dot (x0,x1) ->
      To.Outcometree.Oide_dot
        ((copy_out_ident x0), x1)
  | From.Outcometree.Oide_ident x0 -> To.Outcometree.Oide_ident x0

let rec copy_toplevel_phrase :
  From.Parsetree.toplevel_phrase -> To.Parsetree.toplevel_phrase =
  function
  | From.Parsetree.Ptop_def x0 ->
      To.Parsetree.Ptop_def (copy_structure x0)
  | From.Parsetree.Ptop_dir (x0,x1) ->
      To.Parsetree.Ptop_dir
        (x0, (copy_directive_argument x1))

and copy_directive_argument :
  From.Parsetree.directive_argument -> To.Parsetree.directive_argument =
  function
  | From.Parsetree.Pdir_none  -> To.Parsetree.Pdir_none
  | From.Parsetree.Pdir_string x0 -> To.Parsetree.Pdir_string x0
  | From.Parsetree.Pdir_int (x0,x1) ->
      To.Parsetree.Pdir_int (x0, (copy_option (fun x  -> x) x1))
  | From.Parsetree.Pdir_ident x0 ->
      To.Parsetree.Pdir_ident (copy_longident x0)
  | From.Parsetree.Pdir_bool x0 ->
      To.Parsetree.Pdir_bool (copy_bool x0)

let copy_out_type_extension :
  From.Outcometree.out_type_extension -> To.Outcometree.out_type_extension =
  fun
    { From.Outcometree.otyext_name = otyext_name;
      From.Outcometree.otyext_params = otyext_params;
      From.Outcometree.otyext_constructors = otyext_constructors;
      From.Outcometree.otyext_private = otyext_private }
     ->
    {
      To.Outcometree.otyext_name = otyext_name;
      To.Outcometree.otyext_params =
        (List.map (fun x  -> x) otyext_params);
      To.Outcometree.otyext_constructors =
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (List.map copy_out_type x1),
                (copy_option copy_out_type x2)))
           otyext_constructors);
      To.Outcometree.otyext_private =
        (copy_private_flag otyext_private)
    }

let copy_cases x = List.map copy_case x
let copy_pat = copy_pattern
let copy_expr = copy_expression
let copy_typ = copy_core_type

end
module Migrate_parsetree_406_405_migrate
= struct
#1 "migrate_parsetree_406_405_migrate.ml"
# 1 "src/migrate_parsetree_406_405_migrate.ml"
# 1 "src/migrate_parsetree_406_405_migrate.ml"
# 1 "src/migrate_parsetree_406_405_migrate.ml"
# 1 "src/migrate_parsetree_406_405_migrate.ml"
# 1 "src/migrate_parsetree_406_405_migrate.ml"
# 1 "src/migrate_parsetree_406_405_migrate.ml"
# 1 "src/migrate_parsetree_406_405_migrate.ml"
# 1 "src/migrate_parsetree_406_405_migrate.ml"
# 1 "src/migrate_parsetree_406_405_migrate.ml"
# 1 "src/migrate_parsetree_406_405_migrate.ml"
# 1 "src/migrate_parsetree_406_405_migrate.ml"
# 1 "src/migrate_parsetree_406_405_migrate.ml"
# 1 "src/migrate_parsetree_406_405_migrate.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*                         Alain Frisch, LexiFi                           *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

module Def = Migrate_parsetree_def
module From = Ast_406
module To = Ast_405

let migration_error location feature =
  raise (Def.Migration_error (feature, location))

let rec copy_expression :
  From.Parsetree.expression -> To.Parsetree.expression =
  fun
    { From.Parsetree.pexp_desc = pexp_desc;
      From.Parsetree.pexp_loc = pexp_loc;
      From.Parsetree.pexp_attributes = pexp_attributes }
     ->
    {
      To.Parsetree.pexp_desc = (copy_expression_desc pexp_desc);
      To.Parsetree.pexp_loc = (copy_location pexp_loc);
      To.Parsetree.pexp_attributes = (copy_attributes pexp_attributes)
    }

and copy_expression_desc :
  From.Parsetree.expression_desc -> To.Parsetree.expression_desc =
  function
  | From.Parsetree.Pexp_ident x0 ->
      To.Parsetree.Pexp_ident
        (copy_loc copy_longident x0)
  | From.Parsetree.Pexp_constant x0 ->
      To.Parsetree.Pexp_constant (copy_constant x0)
  | From.Parsetree.Pexp_let (x0,x1,x2) ->
      To.Parsetree.Pexp_let
        ((copy_rec_flag x0),
          (List.map copy_value_binding x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_function x0 ->
      To.Parsetree.Pexp_function
        (List.map copy_case x0)
  | From.Parsetree.Pexp_fun (x0,x1,x2,x3) ->
      To.Parsetree.Pexp_fun
        ((copy_arg_label x0),
          (copy_option copy_expression x1),
          (copy_pattern x2),
          (copy_expression x3))
  | From.Parsetree.Pexp_apply (x0,x1) ->
      To.Parsetree.Pexp_apply
        ((copy_expression x0),
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                ((copy_arg_label x0),
                  (copy_expression x1))) x1))
  | From.Parsetree.Pexp_match (x0,x1) ->
      To.Parsetree.Pexp_match
        ((copy_expression x0),
          (List.map copy_case x1))
  | From.Parsetree.Pexp_try (x0,x1) ->
      To.Parsetree.Pexp_try
        ((copy_expression x0),
          (List.map copy_case x1))
  | From.Parsetree.Pexp_tuple x0 ->
      To.Parsetree.Pexp_tuple
        (List.map copy_expression x0)
  | From.Parsetree.Pexp_construct (x0,x1) ->
      To.Parsetree.Pexp_construct
        ((copy_loc copy_longident x0),
          (copy_option copy_expression x1))
  | From.Parsetree.Pexp_variant (x0,x1) ->
      To.Parsetree.Pexp_variant
        ((copy_label x0),
          (copy_option copy_expression x1))
  | From.Parsetree.Pexp_record (x0,x1) ->
      To.Parsetree.Pexp_record
        ((List.map
            (fun x  ->
               let (x0,x1) = x  in
               ((copy_loc copy_longident x0),
                 (copy_expression x1))) x0),
          (copy_option copy_expression x1))
  | From.Parsetree.Pexp_field (x0,x1) ->
      To.Parsetree.Pexp_field
        ((copy_expression x0),
          (copy_loc copy_longident x1))
  | From.Parsetree.Pexp_setfield (x0,x1,x2) ->
      To.Parsetree.Pexp_setfield
        ((copy_expression x0),
          (copy_loc copy_longident x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_array x0 ->
      To.Parsetree.Pexp_array
        (List.map copy_expression x0)
  | From.Parsetree.Pexp_ifthenelse (x0,x1,x2) ->
      To.Parsetree.Pexp_ifthenelse
        ((copy_expression x0),
          (copy_expression x1),
          (copy_option copy_expression x2))
  | From.Parsetree.Pexp_sequence (x0,x1) ->
      To.Parsetree.Pexp_sequence
        ((copy_expression x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_while (x0,x1) ->
      To.Parsetree.Pexp_while
        ((copy_expression x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_for (x0,x1,x2,x3,x4) ->
      To.Parsetree.Pexp_for
        ((copy_pattern x0),
          (copy_expression x1),
          (copy_expression x2),
          (copy_direction_flag x3),
          (copy_expression x4))
  | From.Parsetree.Pexp_constraint (x0,x1) ->
      To.Parsetree.Pexp_constraint
        ((copy_expression x0),
          (copy_core_type x1))
  | From.Parsetree.Pexp_coerce (x0,x1,x2) ->
      To.Parsetree.Pexp_coerce
        ((copy_expression x0),
          (copy_option copy_core_type x1),
          (copy_core_type x2))
  | From.Parsetree.Pexp_send (x0,x1) ->
      To.Parsetree.Pexp_send
        ((copy_expression x0), (copy_loc (fun x  -> x) x1))
  | From.Parsetree.Pexp_new x0 ->
      To.Parsetree.Pexp_new
        (copy_loc copy_longident x0)
  | From.Parsetree.Pexp_setinstvar (x0,x1) ->
      To.Parsetree.Pexp_setinstvar
        ((copy_loc (fun x  -> x) x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_override x0 ->
      To.Parsetree.Pexp_override
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_loc (fun x  -> x) x0),
                (copy_expression x1))) x0)
  | From.Parsetree.Pexp_letmodule (x0,x1,x2) ->
      To.Parsetree.Pexp_letmodule
        ((copy_loc (fun x  -> x) x0),
          (copy_module_expr x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_letexception (x0,x1) ->
      To.Parsetree.Pexp_letexception
        ((copy_extension_constructor x0),
          (copy_expression x1))
  | From.Parsetree.Pexp_assert x0 ->
      To.Parsetree.Pexp_assert (copy_expression x0)
  | From.Parsetree.Pexp_lazy x0 ->
      To.Parsetree.Pexp_lazy (copy_expression x0)
  | From.Parsetree.Pexp_poly (x0,x1) ->
      To.Parsetree.Pexp_poly
        ((copy_expression x0),
          (copy_option copy_core_type x1))
  | From.Parsetree.Pexp_object x0 ->
      To.Parsetree.Pexp_object
        (copy_class_structure x0)
  | From.Parsetree.Pexp_newtype (x0,x1) ->
      To.Parsetree.Pexp_newtype
        ((copy_loc (fun x  -> x) x0), (copy_expression x1))
  | From.Parsetree.Pexp_pack x0 ->
      To.Parsetree.Pexp_pack (copy_module_expr x0)
  | From.Parsetree.Pexp_open (x0,x1,x2) ->
      To.Parsetree.Pexp_open
        ((copy_override_flag x0),
          (copy_loc copy_longident x1),
          (copy_expression x2))
  | From.Parsetree.Pexp_extension x0 ->
      To.Parsetree.Pexp_extension (copy_extension x0)
  | From.Parsetree.Pexp_unreachable  -> To.Parsetree.Pexp_unreachable

and copy_direction_flag :
  From.Asttypes.direction_flag -> To.Asttypes.direction_flag =
  function
  | From.Asttypes.Upto  -> To.Asttypes.Upto
  | From.Asttypes.Downto  -> To.Asttypes.Downto

and copy_case :
  From.Parsetree.case -> To.Parsetree.case =
  fun
    { From.Parsetree.pc_lhs = pc_lhs;
      From.Parsetree.pc_guard = pc_guard;
      From.Parsetree.pc_rhs = pc_rhs }
     ->
    {
      To.Parsetree.pc_lhs = (copy_pattern pc_lhs);
      To.Parsetree.pc_guard =
        (copy_option copy_expression pc_guard);
      To.Parsetree.pc_rhs = (copy_expression pc_rhs)
    }

and copy_value_binding :
  From.Parsetree.value_binding -> To.Parsetree.value_binding =
  fun
    { From.Parsetree.pvb_pat = pvb_pat;
      From.Parsetree.pvb_expr = pvb_expr;
      From.Parsetree.pvb_attributes = pvb_attributes;
      From.Parsetree.pvb_loc = pvb_loc }
     ->
    {
      To.Parsetree.pvb_pat = (copy_pattern pvb_pat);
      To.Parsetree.pvb_expr =
        (copy_expression pvb_expr);
      To.Parsetree.pvb_attributes =
        (copy_attributes pvb_attributes);
      To.Parsetree.pvb_loc = (copy_location pvb_loc)
    }

and copy_pattern :
  From.Parsetree.pattern -> To.Parsetree.pattern =
  fun
    { From.Parsetree.ppat_desc = ppat_desc;
      From.Parsetree.ppat_loc = ppat_loc;
      From.Parsetree.ppat_attributes = ppat_attributes }
     ->
    {
      To.Parsetree.ppat_desc =
        (copy_pattern_desc ppat_desc);
      To.Parsetree.ppat_loc = (copy_location ppat_loc);
      To.Parsetree.ppat_attributes =
        (copy_attributes ppat_attributes)
    }

and copy_pattern_desc :
  From.Parsetree.pattern_desc -> To.Parsetree.pattern_desc =
  function
  | From.Parsetree.Ppat_any  -> To.Parsetree.Ppat_any
  | From.Parsetree.Ppat_var x0 ->
      To.Parsetree.Ppat_var (copy_loc (fun x  -> x) x0)
  | From.Parsetree.Ppat_alias (x0,x1) ->
      To.Parsetree.Ppat_alias
        ((copy_pattern x0),
          (copy_loc (fun x  -> x) x1))
  | From.Parsetree.Ppat_constant x0 ->
      To.Parsetree.Ppat_constant (copy_constant x0)
  | From.Parsetree.Ppat_interval (x0,x1) ->
      To.Parsetree.Ppat_interval
        ((copy_constant x0),
          (copy_constant x1))
  | From.Parsetree.Ppat_tuple x0 ->
      To.Parsetree.Ppat_tuple
        (List.map copy_pattern x0)
  | From.Parsetree.Ppat_construct (x0,x1) ->
      To.Parsetree.Ppat_construct
        ((copy_loc copy_longident x0),
          (copy_option copy_pattern x1))
  | From.Parsetree.Ppat_variant (x0,x1) ->
      To.Parsetree.Ppat_variant
        ((copy_label x0),
          (copy_option copy_pattern x1))
  | From.Parsetree.Ppat_record (x0,x1) ->
      To.Parsetree.Ppat_record
        ((List.map
            (fun x  ->
               let (x0,x1) = x  in
               ((copy_loc copy_longident x0),
                 (copy_pattern x1))) x0),
          (copy_closed_flag x1))
  | From.Parsetree.Ppat_array x0 ->
      To.Parsetree.Ppat_array
        (List.map copy_pattern x0)
  | From.Parsetree.Ppat_or (x0,x1) ->
      To.Parsetree.Ppat_or
        ((copy_pattern x0),
          (copy_pattern x1))
  | From.Parsetree.Ppat_constraint (x0,x1) ->
      To.Parsetree.Ppat_constraint
        ((copy_pattern x0),
          (copy_core_type x1))
  | From.Parsetree.Ppat_type x0 ->
      To.Parsetree.Ppat_type
        (copy_loc copy_longident x0)
  | From.Parsetree.Ppat_lazy x0 ->
      To.Parsetree.Ppat_lazy (copy_pattern x0)
  | From.Parsetree.Ppat_unpack x0 ->
      To.Parsetree.Ppat_unpack
        (copy_loc (fun x  -> x) x0)
  | From.Parsetree.Ppat_exception x0 ->
      To.Parsetree.Ppat_exception (copy_pattern x0)
  | From.Parsetree.Ppat_extension x0 ->
      To.Parsetree.Ppat_extension (copy_extension x0)
  | From.Parsetree.Ppat_open (x0,x1) ->
      To.Parsetree.Ppat_open
        ((copy_loc copy_longident x0),
          (copy_pattern x1))

and copy_core_type :
  From.Parsetree.core_type -> To.Parsetree.core_type =
  fun
    { From.Parsetree.ptyp_desc = ptyp_desc;
      From.Parsetree.ptyp_loc = ptyp_loc;
      From.Parsetree.ptyp_attributes = ptyp_attributes }
     ->
    {
      To.Parsetree.ptyp_desc =
        (copy_core_type_desc ptyp_desc);
      To.Parsetree.ptyp_loc = (copy_location ptyp_loc);
      To.Parsetree.ptyp_attributes =
        (copy_attributes ptyp_attributes)
    }

and copy_core_type_desc :
  From.Parsetree.core_type_desc -> To.Parsetree.core_type_desc =
  function
  | From.Parsetree.Ptyp_any  -> To.Parsetree.Ptyp_any
  | From.Parsetree.Ptyp_var x0 -> To.Parsetree.Ptyp_var x0
  | From.Parsetree.Ptyp_arrow (x0,x1,x2) ->
      To.Parsetree.Ptyp_arrow
        ((copy_arg_label x0),
          (copy_core_type x1),
          (copy_core_type x2))
  | From.Parsetree.Ptyp_tuple x0 ->
      To.Parsetree.Ptyp_tuple
        (List.map copy_core_type x0)
  | From.Parsetree.Ptyp_constr (x0,x1) ->
      To.Parsetree.Ptyp_constr
        ((copy_loc copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Ptyp_object (x0,x1) ->
      To.Parsetree.Ptyp_object
        ((List.map
            (fun x  ->
               let (x0,x1,x2) = x  in
               (copy_loc (fun x  -> x) x0, (copy_attributes x1),
                 (copy_core_type x2))) x0),
          (copy_closed_flag x1))
  | From.Parsetree.Ptyp_class (x0,x1) ->
      To.Parsetree.Ptyp_class
        ((copy_loc copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Ptyp_alias (x0,x1) ->
      To.Parsetree.Ptyp_alias
        ((copy_core_type x0), x1)
  | From.Parsetree.Ptyp_variant (x0,x1,x2) ->
      To.Parsetree.Ptyp_variant
        ((List.map copy_row_field x0),
          (copy_closed_flag x1),
          (copy_option (fun x  -> List.map copy_label x) x2))
  | From.Parsetree.Ptyp_poly (x0,x1) ->
      To.Parsetree.Ptyp_poly
        ((List.map (fun x  -> copy_loc (fun x  -> x) x) x0), (copy_core_type x1))
  | From.Parsetree.Ptyp_package x0 ->
      To.Parsetree.Ptyp_package (copy_package_type x0)
  | From.Parsetree.Ptyp_extension x0 ->
      To.Parsetree.Ptyp_extension (copy_extension x0)

and copy_package_type :
  From.Parsetree.package_type -> To.Parsetree.package_type =
  fun x  ->
    let (x0,x1) = x  in
    ((copy_loc copy_longident x0),
      (List.map
         (fun x  ->
            let (x0,x1) = x  in
            ((copy_loc copy_longident x0),
              (copy_core_type x1))) x1))

and copy_row_field :
  From.Parsetree.row_field -> To.Parsetree.row_field =
  function
  | From.Parsetree.Rtag (x0,x1,x2,x3) ->
      To.Parsetree.Rtag
        ((copy_label x0),
          (copy_attributes x1), (copy_bool x2),
          (List.map copy_core_type x3))
  | From.Parsetree.Rinherit x0 ->
      To.Parsetree.Rinherit (copy_core_type x0)

and copy_attributes :
  From.Parsetree.attributes -> To.Parsetree.attributes =
  fun x  -> List.map copy_attribute x

and copy_attribute :
  From.Parsetree.attribute -> To.Parsetree.attribute =
  fun x  ->
    let (x0,x1) = x  in
    ((copy_loc (fun x  -> x) x0),
      (copy_payload x1))

and copy_payload :
  From.Parsetree.payload -> To.Parsetree.payload =
  function
  | From.Parsetree.PStr x0 ->
      To.Parsetree.PStr (copy_structure x0)
  | From.Parsetree.PSig x0 ->
      To.Parsetree.PSig (copy_signature x0)
  | From.Parsetree.PTyp x0 ->
      To.Parsetree.PTyp (copy_core_type x0)
  | From.Parsetree.PPat (x0,x1) ->
      To.Parsetree.PPat
        ((copy_pattern x0),
          (copy_option copy_expression x1))

and copy_structure :
  From.Parsetree.structure -> To.Parsetree.structure =
  fun x  -> List.map copy_structure_item x

and copy_structure_item :
  From.Parsetree.structure_item -> To.Parsetree.structure_item =
  fun
    { From.Parsetree.pstr_desc = pstr_desc;
      From.Parsetree.pstr_loc = pstr_loc }
     ->
    {
      To.Parsetree.pstr_desc =
        (copy_structure_item_desc pstr_desc);
      To.Parsetree.pstr_loc = (copy_location pstr_loc)
    }

and copy_structure_item_desc :
  From.Parsetree.structure_item_desc ->
    To.Parsetree.structure_item_desc
  =
  function
  | From.Parsetree.Pstr_eval (x0,x1) ->
      To.Parsetree.Pstr_eval
        ((copy_expression x0),
          (copy_attributes x1))
  | From.Parsetree.Pstr_value (x0,x1) ->
      To.Parsetree.Pstr_value
        ((copy_rec_flag x0),
          (List.map copy_value_binding x1))
  | From.Parsetree.Pstr_primitive x0 ->
      To.Parsetree.Pstr_primitive
        (copy_value_description x0)
  | From.Parsetree.Pstr_type (x0,x1) ->
      To.Parsetree.Pstr_type
        ((copy_rec_flag x0),
          (List.map copy_type_declaration x1))
  | From.Parsetree.Pstr_typext x0 ->
      To.Parsetree.Pstr_typext
        (copy_type_extension x0)
  | From.Parsetree.Pstr_exception x0 ->
      To.Parsetree.Pstr_exception
        (copy_extension_constructor x0)
  | From.Parsetree.Pstr_module x0 ->
      To.Parsetree.Pstr_module
        (copy_module_binding x0)
  | From.Parsetree.Pstr_recmodule x0 ->
      To.Parsetree.Pstr_recmodule
        (List.map copy_module_binding x0)
  | From.Parsetree.Pstr_modtype x0 ->
      To.Parsetree.Pstr_modtype
        (copy_module_type_declaration x0)
  | From.Parsetree.Pstr_open x0 ->
      To.Parsetree.Pstr_open
        (copy_open_description x0)
  | From.Parsetree.Pstr_class x0 ->
      To.Parsetree.Pstr_class
        (List.map copy_class_declaration x0)
  | From.Parsetree.Pstr_class_type x0 ->
      To.Parsetree.Pstr_class_type
        (List.map copy_class_type_declaration x0)
  | From.Parsetree.Pstr_include x0 ->
      To.Parsetree.Pstr_include
        (copy_include_declaration x0)
  | From.Parsetree.Pstr_attribute x0 ->
      To.Parsetree.Pstr_attribute (copy_attribute x0)
  | From.Parsetree.Pstr_extension (x0,x1) ->
      To.Parsetree.Pstr_extension
        ((copy_extension x0),
          (copy_attributes x1))

and copy_include_declaration :
  From.Parsetree.include_declaration ->
    To.Parsetree.include_declaration
  =
  fun x  ->
    copy_include_infos copy_module_expr x

and copy_class_declaration :
  From.Parsetree.class_declaration -> To.Parsetree.class_declaration
  =
  fun x  ->
    copy_class_infos copy_class_expr x

and copy_class_expr :
  From.Parsetree.class_expr -> To.Parsetree.class_expr =
  fun
    { From.Parsetree.pcl_desc = pcl_desc;
      From.Parsetree.pcl_loc = pcl_loc;
      From.Parsetree.pcl_attributes = pcl_attributes }
     ->
    {
      To.Parsetree.pcl_desc =
        (copy_class_expr_desc pcl_desc);
      To.Parsetree.pcl_loc = (copy_location pcl_loc);
      To.Parsetree.pcl_attributes =
        (copy_attributes pcl_attributes)
    }

and copy_class_expr_desc :
  From.Parsetree.class_expr_desc -> To.Parsetree.class_expr_desc =
  function
  | From.Parsetree.Pcl_constr (x0,x1) ->
      To.Parsetree.Pcl_constr
        ((copy_loc copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Pcl_structure x0 ->
      To.Parsetree.Pcl_structure
        (copy_class_structure x0)
  | From.Parsetree.Pcl_fun (x0,x1,x2,x3) ->
      To.Parsetree.Pcl_fun
        ((copy_arg_label x0),
          (copy_option copy_expression x1),
          (copy_pattern x2),
          (copy_class_expr x3))
  | From.Parsetree.Pcl_apply (x0,x1) ->
      To.Parsetree.Pcl_apply
        ((copy_class_expr x0),
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                ((copy_arg_label x0),
                  (copy_expression x1))) x1))
  | From.Parsetree.Pcl_let (x0,x1,x2) ->
      To.Parsetree.Pcl_let
        ((copy_rec_flag x0),
          (List.map copy_value_binding x1),
          (copy_class_expr x2))
  | From.Parsetree.Pcl_constraint (x0,x1) ->
      To.Parsetree.Pcl_constraint
        ((copy_class_expr x0),
          (copy_class_type x1))
  | From.Parsetree.Pcl_extension x0 ->
      To.Parsetree.Pcl_extension (copy_extension x0)
  | From.Parsetree.Pcl_open (_, loc, _) ->
      migration_error loc.From.Location.loc Def.Pcl_open

and copy_class_structure :
  From.Parsetree.class_structure -> To.Parsetree.class_structure =
  fun
    { From.Parsetree.pcstr_self = pcstr_self;
      From.Parsetree.pcstr_fields = pcstr_fields }
     ->
    {
      To.Parsetree.pcstr_self =
        (copy_pattern pcstr_self);
      To.Parsetree.pcstr_fields =
        (List.map copy_class_field pcstr_fields)
    }

and copy_class_field :
  From.Parsetree.class_field -> To.Parsetree.class_field =
  fun
    { From.Parsetree.pcf_desc = pcf_desc;
      From.Parsetree.pcf_loc = pcf_loc;
      From.Parsetree.pcf_attributes = pcf_attributes }
     ->
    {
      To.Parsetree.pcf_desc =
        (copy_class_field_desc pcf_desc);
      To.Parsetree.pcf_loc = (copy_location pcf_loc);
      To.Parsetree.pcf_attributes =
        (copy_attributes pcf_attributes)
    }

and copy_class_field_desc :
  From.Parsetree.class_field_desc -> To.Parsetree.class_field_desc =
  function
  | From.Parsetree.Pcf_inherit (x0,x1,x2) ->
      To.Parsetree.Pcf_inherit
        ((copy_override_flag x0),
          (copy_class_expr x1),
          (copy_option (copy_loc (fun x  -> x)) x2))
  | From.Parsetree.Pcf_val x0 ->
      To.Parsetree.Pcf_val
        (let (x0,x1,x2) = x0  in
         ((copy_loc (fun x  -> x) x0),
           (copy_mutable_flag x1),
           (copy_class_field_kind x2)))
  | From.Parsetree.Pcf_method x0 ->
      To.Parsetree.Pcf_method
        (let (x0,x1,x2) = x0  in
         ((copy_loc (fun x  -> x) x0),
           (copy_private_flag x1),
           (copy_class_field_kind x2)))
  | From.Parsetree.Pcf_constraint x0 ->
      To.Parsetree.Pcf_constraint
        (let (x0,x1) = x0  in
         ((copy_core_type x0),
           (copy_core_type x1)))
  | From.Parsetree.Pcf_initializer x0 ->
      To.Parsetree.Pcf_initializer
        (copy_expression x0)
  | From.Parsetree.Pcf_attribute x0 ->
      To.Parsetree.Pcf_attribute (copy_attribute x0)
  | From.Parsetree.Pcf_extension x0 ->
      To.Parsetree.Pcf_extension (copy_extension x0)

and copy_class_field_kind :
  From.Parsetree.class_field_kind -> To.Parsetree.class_field_kind =
  function
  | From.Parsetree.Cfk_virtual x0 ->
      To.Parsetree.Cfk_virtual (copy_core_type x0)
  | From.Parsetree.Cfk_concrete (x0,x1) ->
      To.Parsetree.Cfk_concrete
        ((copy_override_flag x0),
          (copy_expression x1))

and copy_module_binding :
  From.Parsetree.module_binding -> To.Parsetree.module_binding =
  fun
    { From.Parsetree.pmb_name = pmb_name;
      From.Parsetree.pmb_expr = pmb_expr;
      From.Parsetree.pmb_attributes = pmb_attributes;
      From.Parsetree.pmb_loc = pmb_loc }
     ->
    {
      To.Parsetree.pmb_name =
        (copy_loc (fun x  -> x) pmb_name);
      To.Parsetree.pmb_expr =
        (copy_module_expr pmb_expr);
      To.Parsetree.pmb_attributes =
        (copy_attributes pmb_attributes);
      To.Parsetree.pmb_loc = (copy_location pmb_loc)
    }

and copy_module_expr :
  From.Parsetree.module_expr -> To.Parsetree.module_expr =
  fun
    { From.Parsetree.pmod_desc = pmod_desc;
      From.Parsetree.pmod_loc = pmod_loc;
      From.Parsetree.pmod_attributes = pmod_attributes }
     ->
    {
      To.Parsetree.pmod_desc =
        (copy_module_expr_desc pmod_desc);
      To.Parsetree.pmod_loc = (copy_location pmod_loc);
      To.Parsetree.pmod_attributes =
        (copy_attributes pmod_attributes)
    }

and copy_module_expr_desc :
  From.Parsetree.module_expr_desc -> To.Parsetree.module_expr_desc =
  function
  | From.Parsetree.Pmod_ident x0 ->
      To.Parsetree.Pmod_ident
        (copy_loc copy_longident x0)
  | From.Parsetree.Pmod_structure x0 ->
      To.Parsetree.Pmod_structure (copy_structure x0)
  | From.Parsetree.Pmod_functor (x0,x1,x2) ->
      To.Parsetree.Pmod_functor
        ((copy_loc (fun x  -> x) x0),
          (copy_option copy_module_type x1),
          (copy_module_expr x2))
  | From.Parsetree.Pmod_apply (x0,x1) ->
      To.Parsetree.Pmod_apply
        ((copy_module_expr x0),
          (copy_module_expr x1))
  | From.Parsetree.Pmod_constraint (x0,x1) ->
      To.Parsetree.Pmod_constraint
        ((copy_module_expr x0),
          (copy_module_type x1))
  | From.Parsetree.Pmod_unpack x0 ->
      To.Parsetree.Pmod_unpack (copy_expression x0)
  | From.Parsetree.Pmod_extension x0 ->
      To.Parsetree.Pmod_extension (copy_extension x0)

and copy_module_type :
  From.Parsetree.module_type -> To.Parsetree.module_type =
  fun
    { From.Parsetree.pmty_desc = pmty_desc;
      From.Parsetree.pmty_loc = pmty_loc;
      From.Parsetree.pmty_attributes = pmty_attributes }
     ->
    {
      To.Parsetree.pmty_desc =
        (copy_module_type_desc pmty_desc);
      To.Parsetree.pmty_loc = (copy_location pmty_loc);
      To.Parsetree.pmty_attributes =
        (copy_attributes pmty_attributes)
    }

and copy_module_type_desc :
  From.Parsetree.module_type_desc -> To.Parsetree.module_type_desc =
  function
  | From.Parsetree.Pmty_ident x0 ->
      To.Parsetree.Pmty_ident
        (copy_loc copy_longident x0)
  | From.Parsetree.Pmty_signature x0 ->
      To.Parsetree.Pmty_signature (copy_signature x0)
  | From.Parsetree.Pmty_functor (x0,x1,x2) ->
      To.Parsetree.Pmty_functor
        ((copy_loc (fun x  -> x) x0),
          (copy_option copy_module_type x1),
          (copy_module_type x2))
  | From.Parsetree.Pmty_with (x0,x1) ->
      To.Parsetree.Pmty_with
        ((copy_module_type x0),
          (List.map copy_with_constraint x1))
  | From.Parsetree.Pmty_typeof x0 ->
      To.Parsetree.Pmty_typeof (copy_module_expr x0)
  | From.Parsetree.Pmty_extension x0 ->
      To.Parsetree.Pmty_extension (copy_extension x0)
  | From.Parsetree.Pmty_alias x0 ->
      To.Parsetree.Pmty_alias
        (copy_loc copy_longident x0)

and copy_with_constraint :
  From.Parsetree.with_constraint -> To.Parsetree.with_constraint =
  function
  | From.Parsetree.Pwith_type (x0,x1) ->
      To.Parsetree.Pwith_type
        ((copy_loc copy_longident x0),
          (copy_type_declaration x1))
  | From.Parsetree.Pwith_module (x0,x1) ->
      To.Parsetree.Pwith_module
        ((copy_loc copy_longident x0),
          (copy_loc copy_longident x1))
  | From.Parsetree.Pwith_typesubst x0 ->
      To.Parsetree.Pwith_typesubst
        (copy_type_declaration x0)
  | From.Parsetree.Pwith_modsubst (x0,x1) ->
      To.Parsetree.Pwith_modsubst
        ((copy_loc (fun x  -> x) x0),
          (copy_loc copy_longident x1))

and copy_signature :
  From.Parsetree.signature -> To.Parsetree.signature =
  fun x  -> List.map copy_signature_item x

and copy_signature_item :
  From.Parsetree.signature_item -> To.Parsetree.signature_item =
  fun
    { From.Parsetree.psig_desc = psig_desc;
      From.Parsetree.psig_loc = psig_loc }
     ->
    {
      To.Parsetree.psig_desc =
        (copy_signature_item_desc psig_desc);
      To.Parsetree.psig_loc = (copy_location psig_loc)
    }

and copy_signature_item_desc :
  From.Parsetree.signature_item_desc ->
    To.Parsetree.signature_item_desc
  =
  function
  | From.Parsetree.Psig_value x0 ->
      To.Parsetree.Psig_value
        (copy_value_description x0)
  | From.Parsetree.Psig_type (x0,x1) ->
      To.Parsetree.Psig_type
        ((copy_rec_flag x0),
          (List.map copy_type_declaration x1))
  | From.Parsetree.Psig_typext x0 ->
      To.Parsetree.Psig_typext
        (copy_type_extension x0)
  | From.Parsetree.Psig_exception x0 ->
      To.Parsetree.Psig_exception
        (copy_extension_constructor x0)
  | From.Parsetree.Psig_module x0 ->
      To.Parsetree.Psig_module
        (copy_module_declaration x0)
  | From.Parsetree.Psig_recmodule x0 ->
      To.Parsetree.Psig_recmodule
        (List.map copy_module_declaration x0)
  | From.Parsetree.Psig_modtype x0 ->
      To.Parsetree.Psig_modtype
        (copy_module_type_declaration x0)
  | From.Parsetree.Psig_open x0 ->
      To.Parsetree.Psig_open
        (copy_open_description x0)
  | From.Parsetree.Psig_include x0 ->
      To.Parsetree.Psig_include
        (copy_include_description x0)
  | From.Parsetree.Psig_class x0 ->
      To.Parsetree.Psig_class
        (List.map copy_class_description x0)
  | From.Parsetree.Psig_class_type x0 ->
      To.Parsetree.Psig_class_type
        (List.map copy_class_type_declaration x0)
  | From.Parsetree.Psig_attribute x0 ->
      To.Parsetree.Psig_attribute (copy_attribute x0)
  | From.Parsetree.Psig_extension (x0,x1) ->
      To.Parsetree.Psig_extension
        ((copy_extension x0),
          (copy_attributes x1))

and copy_class_type_declaration :
  From.Parsetree.class_type_declaration ->
    To.Parsetree.class_type_declaration
  =
  fun x  ->
    copy_class_infos copy_class_type x

and copy_class_description :
  From.Parsetree.class_description -> To.Parsetree.class_description
  =
  fun x  ->
    copy_class_infos copy_class_type x

and copy_class_type :
  From.Parsetree.class_type -> To.Parsetree.class_type =
  fun
    { From.Parsetree.pcty_desc = pcty_desc;
      From.Parsetree.pcty_loc = pcty_loc;
      From.Parsetree.pcty_attributes = pcty_attributes }
     ->
    {
      To.Parsetree.pcty_desc =
        (copy_class_type_desc pcty_desc);
      To.Parsetree.pcty_loc = (copy_location pcty_loc);
      To.Parsetree.pcty_attributes =
        (copy_attributes pcty_attributes)
    }

and copy_class_type_desc :
  From.Parsetree.class_type_desc -> To.Parsetree.class_type_desc =
  function
  | From.Parsetree.Pcty_constr (x0,x1) ->
      To.Parsetree.Pcty_constr
        ((copy_loc copy_longident x0),
          (List.map copy_core_type x1))
  | From.Parsetree.Pcty_signature x0 ->
      To.Parsetree.Pcty_signature
        (copy_class_signature x0)
  | From.Parsetree.Pcty_arrow (x0,x1,x2) ->
      To.Parsetree.Pcty_arrow
        ((copy_arg_label x0),
          (copy_core_type x1),
          (copy_class_type x2))
  | From.Parsetree.Pcty_extension x0 ->
      To.Parsetree.Pcty_extension (copy_extension x0)
  | From.Parsetree.Pcty_open (_, loc, _) ->
      migration_error loc.From.Location.loc Def.Pcty_open

and copy_class_signature :
  From.Parsetree.class_signature -> To.Parsetree.class_signature =
  fun
    { From.Parsetree.pcsig_self = pcsig_self;
      From.Parsetree.pcsig_fields = pcsig_fields }
     ->
    {
      To.Parsetree.pcsig_self =
        (copy_core_type pcsig_self);
      To.Parsetree.pcsig_fields =
        (List.map copy_class_type_field pcsig_fields)
    }

and copy_class_type_field :
  From.Parsetree.class_type_field -> To.Parsetree.class_type_field =
  fun
    { From.Parsetree.pctf_desc = pctf_desc;
      From.Parsetree.pctf_loc = pctf_loc;
      From.Parsetree.pctf_attributes = pctf_attributes }
     ->
    {
      To.Parsetree.pctf_desc =
        (copy_class_type_field_desc pctf_desc);
      To.Parsetree.pctf_loc = (copy_location pctf_loc);
      To.Parsetree.pctf_attributes =
        (copy_attributes pctf_attributes)
    }

and copy_class_type_field_desc :
  From.Parsetree.class_type_field_desc ->
    To.Parsetree.class_type_field_desc
  =
  function
  | From.Parsetree.Pctf_inherit x0 ->
      To.Parsetree.Pctf_inherit (copy_class_type x0)
  | From.Parsetree.Pctf_val x0 ->
      To.Parsetree.Pctf_val
        (let (x0,x1,x2,x3) = x0  in
         (copy_loc (fun x  -> x) x0, (copy_mutable_flag x1),
           (copy_virtual_flag x2),
           (copy_core_type x3)))
  | From.Parsetree.Pctf_method x0 ->
      To.Parsetree.Pctf_method
        (let (x0,x1,x2,x3) = x0  in
         (copy_loc (fun x  -> x) x0, (copy_private_flag x1),
           (copy_virtual_flag x2),
           (copy_core_type x3)))
  | From.Parsetree.Pctf_constraint x0 ->
      To.Parsetree.Pctf_constraint
        (let (x0,x1) = x0  in
         ((copy_core_type x0),
           (copy_core_type x1)))
  | From.Parsetree.Pctf_attribute x0 ->
      To.Parsetree.Pctf_attribute (copy_attribute x0)
  | From.Parsetree.Pctf_extension x0 ->
      To.Parsetree.Pctf_extension (copy_extension x0)

and copy_extension :
  From.Parsetree.extension -> To.Parsetree.extension =
  fun x  ->
    let (x0,x1) = x  in
    ((copy_loc (fun x  -> x) x0),
      (copy_payload x1))

and copy_class_infos :
  'f0 'g0 .
    ('f0 -> 'g0) ->
      'f0 From.Parsetree.class_infos -> 'g0 To.Parsetree.class_infos
  =
  fun f0  ->
    fun
      { From.Parsetree.pci_virt = pci_virt;
        From.Parsetree.pci_params = pci_params;
        From.Parsetree.pci_name = pci_name;
        From.Parsetree.pci_expr = pci_expr;
        From.Parsetree.pci_loc = pci_loc;
        From.Parsetree.pci_attributes = pci_attributes }
       ->
      {
        To.Parsetree.pci_virt =
          (copy_virtual_flag pci_virt);
        To.Parsetree.pci_params =
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                ((copy_core_type x0),
                  (copy_variance x1))) pci_params);
        To.Parsetree.pci_name =
          (copy_loc (fun x  -> x) pci_name);
        To.Parsetree.pci_expr = (f0 pci_expr);
        To.Parsetree.pci_loc = (copy_location pci_loc);
        To.Parsetree.pci_attributes =
          (copy_attributes pci_attributes)
      }

and copy_virtual_flag :
  From.Asttypes.virtual_flag -> To.Asttypes.virtual_flag =
  function
  | From.Asttypes.Virtual  -> To.Asttypes.Virtual
  | From.Asttypes.Concrete  -> To.Asttypes.Concrete

and copy_include_description :
  From.Parsetree.include_description ->
    To.Parsetree.include_description
  =
  fun x  ->
    copy_include_infos copy_module_type x

and copy_include_infos :
  'f0 'g0 .
    ('f0 -> 'g0) ->
      'f0 From.Parsetree.include_infos ->
        'g0 To.Parsetree.include_infos
  =
  fun f0  ->
    fun
      { From.Parsetree.pincl_mod = pincl_mod;
        From.Parsetree.pincl_loc = pincl_loc;
        From.Parsetree.pincl_attributes = pincl_attributes }
       ->
      {
        To.Parsetree.pincl_mod = (f0 pincl_mod);
        To.Parsetree.pincl_loc = (copy_location pincl_loc);
        To.Parsetree.pincl_attributes =
          (copy_attributes pincl_attributes)
      }

and copy_open_description :
  From.Parsetree.open_description -> To.Parsetree.open_description =
  fun
    { From.Parsetree.popen_lid = popen_lid;
      From.Parsetree.popen_override = popen_override;
      From.Parsetree.popen_loc = popen_loc;
      From.Parsetree.popen_attributes = popen_attributes }
     ->
    {
      To.Parsetree.popen_lid =
        (copy_loc copy_longident popen_lid);
      To.Parsetree.popen_override =
        (copy_override_flag popen_override);
      To.Parsetree.popen_loc = (copy_location popen_loc);
      To.Parsetree.popen_attributes =
        (copy_attributes popen_attributes)
    }

and copy_override_flag :
  From.Asttypes.override_flag -> To.Asttypes.override_flag =
  function
  | From.Asttypes.Override  -> To.Asttypes.Override
  | From.Asttypes.Fresh  -> To.Asttypes.Fresh

and copy_module_type_declaration :
  From.Parsetree.module_type_declaration ->
    To.Parsetree.module_type_declaration
  =
  fun
    { From.Parsetree.pmtd_name = pmtd_name;
      From.Parsetree.pmtd_type = pmtd_type;
      From.Parsetree.pmtd_attributes = pmtd_attributes;
      From.Parsetree.pmtd_loc = pmtd_loc }
     ->
    {
      To.Parsetree.pmtd_name =
        (copy_loc (fun x  -> x) pmtd_name);
      To.Parsetree.pmtd_type =
        (copy_option copy_module_type pmtd_type);
      To.Parsetree.pmtd_attributes =
        (copy_attributes pmtd_attributes);
      To.Parsetree.pmtd_loc = (copy_location pmtd_loc)
    }

and copy_module_declaration :
  From.Parsetree.module_declaration ->
    To.Parsetree.module_declaration
  =
  fun
    { From.Parsetree.pmd_name = pmd_name;
      From.Parsetree.pmd_type = pmd_type;
      From.Parsetree.pmd_attributes = pmd_attributes;
      From.Parsetree.pmd_loc = pmd_loc }
     ->
    {
      To.Parsetree.pmd_name =
        (copy_loc (fun x  -> x) pmd_name);
      To.Parsetree.pmd_type =
        (copy_module_type pmd_type);
      To.Parsetree.pmd_attributes =
        (copy_attributes pmd_attributes);
      To.Parsetree.pmd_loc = (copy_location pmd_loc)
    }

and copy_type_extension :
  From.Parsetree.type_extension -> To.Parsetree.type_extension =
  fun
    { From.Parsetree.ptyext_path = ptyext_path;
      From.Parsetree.ptyext_params = ptyext_params;
      From.Parsetree.ptyext_constructors = ptyext_constructors;
      From.Parsetree.ptyext_private = ptyext_private;
      From.Parsetree.ptyext_attributes = ptyext_attributes }
     ->
    {
      To.Parsetree.ptyext_path =
        (copy_loc copy_longident ptyext_path);
      To.Parsetree.ptyext_params =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_core_type x0),
                (copy_variance x1))) ptyext_params);
      To.Parsetree.ptyext_constructors =
        (List.map copy_extension_constructor
           ptyext_constructors);
      To.Parsetree.ptyext_private =
        (copy_private_flag ptyext_private);
      To.Parsetree.ptyext_attributes =
        (copy_attributes ptyext_attributes)
    }

and copy_extension_constructor :
  From.Parsetree.extension_constructor ->
    To.Parsetree.extension_constructor
  =
  fun
    { From.Parsetree.pext_name = pext_name;
      From.Parsetree.pext_kind = pext_kind;
      From.Parsetree.pext_loc = pext_loc;
      From.Parsetree.pext_attributes = pext_attributes }
     ->
    {
      To.Parsetree.pext_name =
        (copy_loc (fun x  -> x) pext_name);
      To.Parsetree.pext_kind =
        (copy_extension_constructor_kind pext_kind);
      To.Parsetree.pext_loc = (copy_location pext_loc);
      To.Parsetree.pext_attributes =
        (copy_attributes pext_attributes)
    }

and copy_extension_constructor_kind :
  From.Parsetree.extension_constructor_kind ->
    To.Parsetree.extension_constructor_kind
  =
  function
  | From.Parsetree.Pext_decl (x0,x1) ->
      To.Parsetree.Pext_decl
        ((copy_constructor_arguments x0),
          (copy_option copy_core_type x1))
  | From.Parsetree.Pext_rebind x0 ->
      To.Parsetree.Pext_rebind
        (copy_loc copy_longident x0)

and copy_type_declaration :
  From.Parsetree.type_declaration -> To.Parsetree.type_declaration =
  fun
    { From.Parsetree.ptype_name = ptype_name;
      From.Parsetree.ptype_params = ptype_params;
      From.Parsetree.ptype_cstrs = ptype_cstrs;
      From.Parsetree.ptype_kind = ptype_kind;
      From.Parsetree.ptype_private = ptype_private;
      From.Parsetree.ptype_manifest = ptype_manifest;
      From.Parsetree.ptype_attributes = ptype_attributes;
      From.Parsetree.ptype_loc = ptype_loc }
     ->
    {
      To.Parsetree.ptype_name =
        (copy_loc (fun x  -> x) ptype_name);
      To.Parsetree.ptype_params =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_core_type x0),
                (copy_variance x1))) ptype_params);
      To.Parsetree.ptype_cstrs =
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              ((copy_core_type x0),
                (copy_core_type x1),
                (copy_location x2))) ptype_cstrs);
      To.Parsetree.ptype_kind =
        (copy_type_kind ptype_kind);
      To.Parsetree.ptype_private =
        (copy_private_flag ptype_private);
      To.Parsetree.ptype_manifest =
        (copy_option copy_core_type ptype_manifest);
      To.Parsetree.ptype_attributes =
        (copy_attributes ptype_attributes);
      To.Parsetree.ptype_loc = (copy_location ptype_loc)
    }

and copy_private_flag :
  From.Asttypes.private_flag -> To.Asttypes.private_flag =
  function
  | From.Asttypes.Private  -> To.Asttypes.Private
  | From.Asttypes.Public  -> To.Asttypes.Public

and copy_type_kind :
  From.Parsetree.type_kind -> To.Parsetree.type_kind =
  function
  | From.Parsetree.Ptype_abstract  -> To.Parsetree.Ptype_abstract
  | From.Parsetree.Ptype_variant x0 ->
      To.Parsetree.Ptype_variant
        (List.map copy_constructor_declaration x0)
  | From.Parsetree.Ptype_record x0 ->
      To.Parsetree.Ptype_record
        (List.map copy_label_declaration x0)
  | From.Parsetree.Ptype_open  -> To.Parsetree.Ptype_open

and copy_constructor_declaration :
  From.Parsetree.constructor_declaration ->
    To.Parsetree.constructor_declaration
  =
  fun
    { From.Parsetree.pcd_name = pcd_name;
      From.Parsetree.pcd_args = pcd_args;
      From.Parsetree.pcd_res = pcd_res;
      From.Parsetree.pcd_loc = pcd_loc;
      From.Parsetree.pcd_attributes = pcd_attributes }
     ->
    {
      To.Parsetree.pcd_name =
        (copy_loc (fun x  -> x) pcd_name);
      To.Parsetree.pcd_args =
        (copy_constructor_arguments pcd_args);
      To.Parsetree.pcd_res =
        (copy_option copy_core_type pcd_res);
      To.Parsetree.pcd_loc = (copy_location pcd_loc);
      To.Parsetree.pcd_attributes =
        (copy_attributes pcd_attributes)
    }

and copy_constructor_arguments :
  From.Parsetree.constructor_arguments ->
    To.Parsetree.constructor_arguments
  =
  function
  | From.Parsetree.Pcstr_tuple x0 ->
      To.Parsetree.Pcstr_tuple
        (List.map copy_core_type x0)
  | From.Parsetree.Pcstr_record x0 ->
      To.Parsetree.Pcstr_record
        (List.map copy_label_declaration x0)

and copy_label_declaration :
  From.Parsetree.label_declaration -> To.Parsetree.label_declaration
  =
  fun
    { From.Parsetree.pld_name = pld_name;
      From.Parsetree.pld_mutable = pld_mutable;
      From.Parsetree.pld_type = pld_type;
      From.Parsetree.pld_loc = pld_loc;
      From.Parsetree.pld_attributes = pld_attributes }
     ->
    {
      To.Parsetree.pld_name =
        (copy_loc (fun x  -> x) pld_name);
      To.Parsetree.pld_mutable =
        (copy_mutable_flag pld_mutable);
      To.Parsetree.pld_type =
        (copy_core_type pld_type);
      To.Parsetree.pld_loc = (copy_location pld_loc);
      To.Parsetree.pld_attributes =
        (copy_attributes pld_attributes)
    }

and copy_mutable_flag :
  From.Asttypes.mutable_flag -> To.Asttypes.mutable_flag =
  function
  | From.Asttypes.Immutable  -> To.Asttypes.Immutable
  | From.Asttypes.Mutable  -> To.Asttypes.Mutable

and copy_variance :
  From.Asttypes.variance -> To.Asttypes.variance =
  function
  | From.Asttypes.Covariant  -> To.Asttypes.Covariant
  | From.Asttypes.Contravariant  -> To.Asttypes.Contravariant
  | From.Asttypes.Invariant  -> To.Asttypes.Invariant

and copy_value_description :
  From.Parsetree.value_description -> To.Parsetree.value_description
  =
  fun
    { From.Parsetree.pval_name = pval_name;
      From.Parsetree.pval_type = pval_type;
      From.Parsetree.pval_prim = pval_prim;
      From.Parsetree.pval_attributes = pval_attributes;
      From.Parsetree.pval_loc = pval_loc }
     ->
    {
      To.Parsetree.pval_name =
        (copy_loc (fun x  -> x) pval_name);
      To.Parsetree.pval_type =
        (copy_core_type pval_type);
      To.Parsetree.pval_prim = (List.map (fun x  -> x) pval_prim);
      To.Parsetree.pval_attributes =
        (copy_attributes pval_attributes);
      To.Parsetree.pval_loc = (copy_location pval_loc)
    }

and copy_arg_label :
  From.Asttypes.arg_label -> To.Asttypes.arg_label =
  function
  | From.Asttypes.Nolabel  -> To.Asttypes.Nolabel
  | From.Asttypes.Labelled x0 -> To.Asttypes.Labelled x0
  | From.Asttypes.Optional x0 -> To.Asttypes.Optional x0

and copy_closed_flag :
  From.Asttypes.closed_flag -> To.Asttypes.closed_flag =
  function
  | From.Asttypes.Closed  -> To.Asttypes.Closed
  | From.Asttypes.Open  -> To.Asttypes.Open

and copy_label :
  From.Asttypes.label -> To.Asttypes.label = fun x  -> x

and copy_rec_flag :
  From.Asttypes.rec_flag -> To.Asttypes.rec_flag =
  function
  | From.Asttypes.Nonrecursive  -> To.Asttypes.Nonrecursive
  | From.Asttypes.Recursive  -> To.Asttypes.Recursive

and copy_constant :
  From.Parsetree.constant -> To.Parsetree.constant =
  function
  | From.Parsetree.Pconst_integer (x0,x1) ->
      To.Parsetree.Pconst_integer (x0, (copy_option (fun x  -> x) x1))
  | From.Parsetree.Pconst_char x0 -> To.Parsetree.Pconst_char x0
  | From.Parsetree.Pconst_string (x0,x1) ->
      To.Parsetree.Pconst_string (x0, (copy_option (fun x  -> x) x1))
  | From.Parsetree.Pconst_float (x0,x1) ->
      To.Parsetree.Pconst_float (x0, (copy_option (fun x  -> x) x1))

and copy_option : 'f0 'g0 . ('f0 -> 'g0) -> 'f0 option -> 'g0 option =
  fun f0  -> function | None  -> None | Some x0 -> Some (f0 x0)

and copy_longident : From.Longident.t -> To.Longident.t =
  function
  | From.Longident.Lident x0 -> To.Longident.Lident x0
  | From.Longident.Ldot (x0,x1) ->
      To.Longident.Ldot ((copy_longident x0), x1)
  | From.Longident.Lapply (x0,x1) ->
      To.Longident.Lapply
        ((copy_longident x0), (copy_longident x1))

and copy_loc :
  'f0 'g0 .
    ('f0 -> 'g0) -> 'f0 From.Asttypes.loc -> 'g0 To.Asttypes.loc
  =
  fun f0  ->
    fun { From.Asttypes.txt = txt; From.Asttypes.loc = loc }  ->
      {
        To.Asttypes.txt = (f0 txt);
        To.Asttypes.loc = (copy_location loc)
      }

and copy_location : From.Location.t -> To.Location.t =
  fun
    { From.Location.loc_start = loc_start;
      From.Location.loc_end = loc_end;
      From.Location.loc_ghost = loc_ghost }
     ->
    {
      To.Location.loc_start = (copy_Lexing_position loc_start);
      To.Location.loc_end = (copy_Lexing_position loc_end);
      To.Location.loc_ghost = (copy_bool loc_ghost)
    }

and copy_bool : bool -> bool = function | false  -> false | true  -> true

and copy_Lexing_position : Lexing.position -> Lexing.position =
  fun
    { Lexing.pos_fname = pos_fname; Lexing.pos_lnum = pos_lnum;
      Lexing.pos_bol = pos_bol; Lexing.pos_cnum = pos_cnum }
     ->
    {
      Lexing.pos_fname = pos_fname;
      Lexing.pos_lnum = pos_lnum;
      Lexing.pos_bol = pos_bol;
      Lexing.pos_cnum = pos_cnum
    }

let rec copy_out_phrase :
  From.Outcometree.out_phrase -> To.Outcometree.out_phrase =
  function
  | From.Outcometree.Ophr_eval (x0,x1) ->
      To.Outcometree.Ophr_eval
        ((copy_out_value x0),
          (copy_out_type x1))
  | From.Outcometree.Ophr_signature x0 ->
      To.Outcometree.Ophr_signature
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_out_sig_item x0),
                (copy_option copy_out_value x1))) x0)
  | From.Outcometree.Ophr_exception x0 ->
      To.Outcometree.Ophr_exception
        (let (x0,x1) = x0  in
         ((copy_exn x0), (copy_out_value x1)))

and copy_exn : exn -> exn = fun x  -> x

and copy_out_sig_item :
  From.Outcometree.out_sig_item -> To.Outcometree.out_sig_item =
  function
  | From.Outcometree.Osig_class (x0,x1,x2,x3,x4) ->
      To.Outcometree.Osig_class
        ((copy_bool x0), x1,
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))
             x2), (copy_out_class_type x3),
          (copy_out_rec_status x4))
  | From.Outcometree.Osig_class_type (x0,x1,x2,x3,x4) ->
      To.Outcometree.Osig_class_type
        ((copy_bool x0), x1,
          (List.map
             (fun x  ->
                let (x0,x1) = x  in
                (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))
             x2), (copy_out_class_type x3),
          (copy_out_rec_status x4))
  | From.Outcometree.Osig_typext (x0,x1) ->
      To.Outcometree.Osig_typext
        ((copy_out_extension_constructor x0),
          (copy_out_ext_status x1))
  | From.Outcometree.Osig_modtype (x0,x1) ->
      To.Outcometree.Osig_modtype
        (x0, (copy_out_module_type x1))
  | From.Outcometree.Osig_module (x0,x1,x2) ->
      To.Outcometree.Osig_module
        (x0, (copy_out_module_type x1),
          (copy_out_rec_status x2))
  | From.Outcometree.Osig_type (x0,x1) ->
      To.Outcometree.Osig_type
        ((copy_out_type_decl x0),
          (copy_out_rec_status x1))
  | From.Outcometree.Osig_value x0 ->
      To.Outcometree.Osig_value
        (copy_out_val_decl x0)
  | From.Outcometree.Osig_ellipsis  -> To.Outcometree.Osig_ellipsis

and copy_out_val_decl :
  From.Outcometree.out_val_decl -> To.Outcometree.out_val_decl =
  fun
    { From.Outcometree.oval_name = oval_name;
      From.Outcometree.oval_type = oval_type;
      From.Outcometree.oval_prims = oval_prims;
      From.Outcometree.oval_attributes = oval_attributes }
     ->
    {
      To.Outcometree.oval_name = oval_name;
      To.Outcometree.oval_type =
        (copy_out_type oval_type);
      To.Outcometree.oval_prims = (List.map (fun x  -> x) oval_prims);
      To.Outcometree.oval_attributes =
        (List.map copy_out_attribute oval_attributes)
    }

and copy_out_type_decl :
  From.Outcometree.out_type_decl -> To.Outcometree.out_type_decl =
  fun
    { From.Outcometree.otype_name = otype_name;
      From.Outcometree.otype_params = otype_params;
      From.Outcometree.otype_type = otype_type;
      From.Outcometree.otype_private = otype_private;
      From.Outcometree.otype_immediate = otype_immediate;
      From.Outcometree.otype_unboxed = otype_unboxed;
      From.Outcometree.otype_cstrs = otype_cstrs }
     ->
    {
      To.Outcometree.otype_name = otype_name;
      To.Outcometree.otype_params =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              (x0, (let (x0,x1) = x1  in ((copy_bool x0), (copy_bool x1)))))
           otype_params);
      To.Outcometree.otype_type =
        (copy_out_type otype_type);
      To.Outcometree.otype_private =
        (copy_From_Asttypes_private_flag otype_private);
      To.Outcometree.otype_immediate = (copy_bool otype_immediate);
      To.Outcometree.otype_unboxed = (copy_bool otype_unboxed);
      To.Outcometree.otype_cstrs =
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_out_type x0),
                (copy_out_type x1))) otype_cstrs)
    }

and copy_out_module_type :
  From.Outcometree.out_module_type -> To.Outcometree.out_module_type
  =
  function
  | From.Outcometree.Omty_abstract  -> To.Outcometree.Omty_abstract
  | From.Outcometree.Omty_functor (x0,x1,x2) ->
      To.Outcometree.Omty_functor
        (x0, (copy_option copy_out_module_type x1),
          (copy_out_module_type x2))
  | From.Outcometree.Omty_ident x0 ->
      To.Outcometree.Omty_ident (copy_out_ident x0)
  | From.Outcometree.Omty_signature x0 ->
      To.Outcometree.Omty_signature
        (List.map copy_out_sig_item x0)
  | From.Outcometree.Omty_alias x0 ->
      To.Outcometree.Omty_alias (copy_out_ident x0)

and copy_out_ext_status :
  From.Outcometree.out_ext_status -> To.Outcometree.out_ext_status =
  function
  | From.Outcometree.Oext_first  -> To.Outcometree.Oext_first
  | From.Outcometree.Oext_next  -> To.Outcometree.Oext_next
  | From.Outcometree.Oext_exception  -> To.Outcometree.Oext_exception

and copy_out_extension_constructor :
  From.Outcometree.out_extension_constructor ->
    To.Outcometree.out_extension_constructor
  =
  fun
    { From.Outcometree.oext_name = oext_name;
      From.Outcometree.oext_type_name = oext_type_name;
      From.Outcometree.oext_type_params = oext_type_params;
      From.Outcometree.oext_args = oext_args;
      From.Outcometree.oext_ret_type = oext_ret_type;
      From.Outcometree.oext_private = oext_private }
     ->
    {
      To.Outcometree.oext_name = oext_name;
      To.Outcometree.oext_type_name = oext_type_name;
      To.Outcometree.oext_type_params =
        (List.map (fun x  -> x) oext_type_params);
      To.Outcometree.oext_args =
        (List.map copy_out_type oext_args);
      To.Outcometree.oext_ret_type =
        (copy_option copy_out_type oext_ret_type);
      To.Outcometree.oext_private =
        (copy_From_Asttypes_private_flag oext_private)
    }

and copy_From_Asttypes_private_flag :
  From.Asttypes.private_flag -> To.Asttypes.private_flag =
  function
  | From.Asttypes.Private  -> To.Asttypes.Private
  | From.Asttypes.Public  -> To.Asttypes.Public

and copy_out_rec_status :
  From.Outcometree.out_rec_status -> To.Outcometree.out_rec_status =
  function
  | From.Outcometree.Orec_not  -> To.Outcometree.Orec_not
  | From.Outcometree.Orec_first  -> To.Outcometree.Orec_first
  | From.Outcometree.Orec_next  -> To.Outcometree.Orec_next

and copy_out_class_type :
  From.Outcometree.out_class_type -> To.Outcometree.out_class_type =
  function
  | From.Outcometree.Octy_constr (x0,x1) ->
      To.Outcometree.Octy_constr
        ((copy_out_ident x0),
          (List.map copy_out_type x1))
  | From.Outcometree.Octy_arrow (x0,x1,x2) ->
      To.Outcometree.Octy_arrow
        (x0, (copy_out_type x1),
          (copy_out_class_type x2))
  | From.Outcometree.Octy_signature (x0,x1) ->
      To.Outcometree.Octy_signature
        ((copy_option copy_out_type x0),
          (List.map copy_out_class_sig_item x1))

and copy_out_class_sig_item :
  From.Outcometree.out_class_sig_item ->
    To.Outcometree.out_class_sig_item
  =
  function
  | From.Outcometree.Ocsg_constraint (x0,x1) ->
      To.Outcometree.Ocsg_constraint
        ((copy_out_type x0),
          (copy_out_type x1))
  | From.Outcometree.Ocsg_method (x0,x1,x2,x3) ->
      To.Outcometree.Ocsg_method
        (x0, (copy_bool x1), (copy_bool x2),
          (copy_out_type x3))
  | From.Outcometree.Ocsg_value (x0,x1,x2,x3) ->
      To.Outcometree.Ocsg_value
        (x0, (copy_bool x1), (copy_bool x2),
          (copy_out_type x3))

and copy_out_type :
  From.Outcometree.out_type -> To.Outcometree.out_type =
  function
  | From.Outcometree.Otyp_abstract  -> To.Outcometree.Otyp_abstract
  | From.Outcometree.Otyp_open  -> To.Outcometree.Otyp_open
  | From.Outcometree.Otyp_alias (x0,x1) ->
      To.Outcometree.Otyp_alias
        ((copy_out_type x0), x1)
  | From.Outcometree.Otyp_arrow (x0,x1,x2) ->
      To.Outcometree.Otyp_arrow
        (x0, (copy_out_type x1),
          (copy_out_type x2))
  | From.Outcometree.Otyp_class (x0,x1,x2) ->
      To.Outcometree.Otyp_class
        ((copy_bool x0), (copy_out_ident x1),
          (List.map copy_out_type x2))
  | From.Outcometree.Otyp_constr (x0,x1) ->
      To.Outcometree.Otyp_constr
        ((copy_out_ident x0),
          (List.map copy_out_type x1))
  | From.Outcometree.Otyp_manifest (x0,x1) ->
      To.Outcometree.Otyp_manifest
        ((copy_out_type x0),
          (copy_out_type x1))
  | From.Outcometree.Otyp_object (x0,x1) ->
      To.Outcometree.Otyp_object
        ((List.map
            (fun x  ->
               let (x0,x1) = x  in
               (x0, (copy_out_type x1))) x0),
          (copy_option copy_bool x1))
  | From.Outcometree.Otyp_record x0 ->
      To.Outcometree.Otyp_record
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (copy_bool x1), (copy_out_type x2)))
           x0)
  | From.Outcometree.Otyp_stuff x0 -> To.Outcometree.Otyp_stuff x0
  | From.Outcometree.Otyp_sum x0 ->
      To.Outcometree.Otyp_sum
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (List.map copy_out_type x1),
                (copy_option copy_out_type x2))) x0)
  | From.Outcometree.Otyp_tuple x0 ->
      To.Outcometree.Otyp_tuple
        (List.map copy_out_type x0)
  | From.Outcometree.Otyp_var (x0,x1) ->
      To.Outcometree.Otyp_var ((copy_bool x0), x1)
  | From.Outcometree.Otyp_variant (x0,x1,x2,x3) ->
      To.Outcometree.Otyp_variant
        ((copy_bool x0), (copy_out_variant x1),
          (copy_bool x2),
          (copy_option (fun x  -> List.map (fun x  -> x) x) x3))
  | From.Outcometree.Otyp_poly (x0,x1) ->
      To.Outcometree.Otyp_poly
        ((List.map (fun x  -> x) x0), (copy_out_type x1))
  | From.Outcometree.Otyp_module (x0,x1,x2) ->
      To.Outcometree.Otyp_module
        (x0, (List.map (fun x  -> x) x1),
          (List.map copy_out_type x2))
  | From.Outcometree.Otyp_attribute (x0,x1) ->
      To.Outcometree.Otyp_attribute
        ((copy_out_type x0),
          (copy_out_attribute x1))

and copy_out_attribute :
  From.Outcometree.out_attribute -> To.Outcometree.out_attribute =
  fun { From.Outcometree.oattr_name = oattr_name }  ->
    { To.Outcometree.oattr_name = oattr_name }

and copy_out_variant :
  From.Outcometree.out_variant -> To.Outcometree.out_variant =
  function
  | From.Outcometree.Ovar_fields x0 ->
      To.Outcometree.Ovar_fields
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (copy_bool x1),
                (List.map copy_out_type x2))) x0)
  | From.Outcometree.Ovar_typ x0 ->
      To.Outcometree.Ovar_typ (copy_out_type x0)

and copy_out_value :
  From.Outcometree.out_value -> To.Outcometree.out_value =
  function
  | From.Outcometree.Oval_array x0 ->
      To.Outcometree.Oval_array
        (List.map copy_out_value x0)
  | From.Outcometree.Oval_char x0 -> To.Outcometree.Oval_char x0
  | From.Outcometree.Oval_constr (x0,x1) ->
      To.Outcometree.Oval_constr
        ((copy_out_ident x0),
          (List.map copy_out_value x1))
  | From.Outcometree.Oval_ellipsis  -> To.Outcometree.Oval_ellipsis
  | From.Outcometree.Oval_float x0 ->
      To.Outcometree.Oval_float (copy_float x0)
  | From.Outcometree.Oval_int x0 -> To.Outcometree.Oval_int x0
  | From.Outcometree.Oval_int32 x0 -> To.Outcometree.Oval_int32 x0
  | From.Outcometree.Oval_int64 x0 -> To.Outcometree.Oval_int64 x0
  | From.Outcometree.Oval_nativeint x0 ->
      To.Outcometree.Oval_nativeint x0
  | From.Outcometree.Oval_list x0 ->
      To.Outcometree.Oval_list
        (List.map copy_out_value x0)
  | From.Outcometree.Oval_printer x0 ->
      To.Outcometree.Oval_printer x0
  | From.Outcometree.Oval_record x0 ->
      To.Outcometree.Oval_record
        (List.map
           (fun x  ->
              let (x0,x1) = x  in
              ((copy_out_ident x0),
                (copy_out_value x1))) x0)
  | From.Outcometree.Oval_string (x0, _, _) -> To.Outcometree.Oval_string x0
  | From.Outcometree.Oval_stuff x0 -> To.Outcometree.Oval_stuff x0
  | From.Outcometree.Oval_tuple x0 ->
      To.Outcometree.Oval_tuple
        (List.map copy_out_value x0)
  | From.Outcometree.Oval_variant (x0,x1) ->
      To.Outcometree.Oval_variant
        (x0, (copy_option copy_out_value x1))

and copy_float : float -> float = fun x  -> x

and copy_out_ident :
  From.Outcometree.out_ident -> To.Outcometree.out_ident =
  function
  | From.Outcometree.Oide_apply (x0,x1) ->
      To.Outcometree.Oide_apply
        ((copy_out_ident x0),
          (copy_out_ident x1))
  | From.Outcometree.Oide_dot (x0,x1) ->
      To.Outcometree.Oide_dot
        ((copy_out_ident x0), x1)
  | From.Outcometree.Oide_ident x0 -> To.Outcometree.Oide_ident x0

let rec copy_toplevel_phrase :
  From.Parsetree.toplevel_phrase -> To.Parsetree.toplevel_phrase =
  function
  | From.Parsetree.Ptop_def x0 ->
      To.Parsetree.Ptop_def (copy_structure x0)
  | From.Parsetree.Ptop_dir (x0,x1) ->
      To.Parsetree.Ptop_dir
        (x0, (copy_directive_argument x1))

and copy_directive_argument :
  From.Parsetree.directive_argument -> To.Parsetree.directive_argument =
  function
  | From.Parsetree.Pdir_none  -> To.Parsetree.Pdir_none
  | From.Parsetree.Pdir_string x0 -> To.Parsetree.Pdir_string x0
  | From.Parsetree.Pdir_int (x0,x1) ->
      To.Parsetree.Pdir_int (x0, (copy_option (fun x  -> x) x1))
  | From.Parsetree.Pdir_ident x0 ->
      To.Parsetree.Pdir_ident (copy_longident x0)
  | From.Parsetree.Pdir_bool x0 ->
      To.Parsetree.Pdir_bool (copy_bool x0)

let copy_out_type_extension :
  From.Outcometree.out_type_extension -> To.Outcometree.out_type_extension =
  fun
    { From.Outcometree.otyext_name = otyext_name;
      From.Outcometree.otyext_params = otyext_params;
      From.Outcometree.otyext_constructors = otyext_constructors;
      From.Outcometree.otyext_private = otyext_private }
     ->
    {
      To.Outcometree.otyext_name = otyext_name;
      To.Outcometree.otyext_params =
        (List.map (fun x  -> x) otyext_params);
      To.Outcometree.otyext_constructors =
        (List.map
           (fun x  ->
              let (x0,x1,x2) = x  in
              (x0, (List.map copy_out_type x1),
                (copy_option copy_out_type x2)))
           otyext_constructors);
      To.Outcometree.otyext_private =
        (copy_private_flag otyext_private)
    }

let copy_cases x = List.map copy_case x
let copy_pat = copy_pattern
let copy_expr = copy_expression
let copy_typ = copy_core_type

end
module Migrate_parsetree_405_406
= struct
#1 "migrate_parsetree_405_406.ml"
# 1 "src/migrate_parsetree_405_406.ml"
# 1 "src/migrate_parsetree_405_406.ml"
# 1 "src/migrate_parsetree_405_406.ml"
# 1 "src/migrate_parsetree_405_406.ml"
# 1 "src/migrate_parsetree_405_406.ml"
# 1 "src/migrate_parsetree_405_406.ml"
# 1 "src/migrate_parsetree_405_406.ml"
# 1 "src/migrate_parsetree_405_406.ml"
# 1 "src/migrate_parsetree_405_406.ml"
# 1 "src/migrate_parsetree_405_406.ml"
# 1 "src/migrate_parsetree_405_406.ml"
# 1 "src/migrate_parsetree_405_406.ml"
# 1 "src/migrate_parsetree_405_406.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

include Migrate_parsetree_405_406_migrate

(*$ open Printf
    let fields = [
      "attribute"; "attributes"; "case"; "cases"; "class_declaration";
      "class_description"; "class_expr"; "class_field"; "class_signature";
      "class_structure"; "class_type"; "class_type_declaration";
      "class_type_field"; "constructor_declaration"; "expr"; "extension";
      "extension_constructor"; "include_declaration"; "include_description";
      "label_declaration"; "location"; "module_binding"; "module_declaration";
      "module_expr"; "module_type"; "module_type_declaration";
      "open_description"; "pat"; "signature"; "signature_item"; "structure";
      "structure_item"; "typ"; "type_declaration"; "type_extension";
      "type_kind"; "value_binding"; "value_description";
      "with_constraint"; "payload"
    ]
  let foreach_field f =
    printf "\n";
    List.iter f fields
*)(*$*)

let copy_mapper = fun
  ({ From.Ast_mapper.
     (*$ foreach_field (printf "%s;\n")*)
     attribute;
     attributes;
     case;
     cases;
     class_declaration;
     class_description;
     class_expr;
     class_field;
     class_signature;
     class_structure;
     class_type;
     class_type_declaration;
     class_type_field;
     constructor_declaration;
     expr;
     extension;
     extension_constructor;
     include_declaration;
     include_description;
     label_declaration;
     location;
     module_binding;
     module_declaration;
     module_expr;
     module_type;
     module_type_declaration;
     open_description;
     pat;
     signature;
     signature_item;
     structure;
     structure_item;
     typ;
     type_declaration;
     type_extension;
     type_kind;
     value_binding;
     value_description;
     with_constraint;
     payload;
     (*$*)
   } as mapper) ->
  let module R = Migrate_parsetree_406_405_migrate in
  {
    To.Ast_mapper.
    (*$ foreach_field (fun s ->
          printf
          "%s = (fun _ x -> copy_%s (%s mapper (R.copy_%s x)));\n" s s s s)
    *)
    attribute = (fun _ x -> copy_attribute (attribute mapper (R.copy_attribute x)));
    attributes = (fun _ x -> copy_attributes (attributes mapper (R.copy_attributes x)));
    case = (fun _ x -> copy_case (case mapper (R.copy_case x)));
    cases = (fun _ x -> copy_cases (cases mapper (R.copy_cases x)));
    class_declaration = (fun _ x -> copy_class_declaration (class_declaration mapper (R.copy_class_declaration x)));
    class_description = (fun _ x -> copy_class_description (class_description mapper (R.copy_class_description x)));
    class_expr = (fun _ x -> copy_class_expr (class_expr mapper (R.copy_class_expr x)));
    class_field = (fun _ x -> copy_class_field (class_field mapper (R.copy_class_field x)));
    class_signature = (fun _ x -> copy_class_signature (class_signature mapper (R.copy_class_signature x)));
    class_structure = (fun _ x -> copy_class_structure (class_structure mapper (R.copy_class_structure x)));
    class_type = (fun _ x -> copy_class_type (class_type mapper (R.copy_class_type x)));
    class_type_declaration = (fun _ x -> copy_class_type_declaration (class_type_declaration mapper (R.copy_class_type_declaration x)));
    class_type_field = (fun _ x -> copy_class_type_field (class_type_field mapper (R.copy_class_type_field x)));
    constructor_declaration = (fun _ x -> copy_constructor_declaration (constructor_declaration mapper (R.copy_constructor_declaration x)));
    expr = (fun _ x -> copy_expr (expr mapper (R.copy_expr x)));
    extension = (fun _ x -> copy_extension (extension mapper (R.copy_extension x)));
    extension_constructor = (fun _ x -> copy_extension_constructor (extension_constructor mapper (R.copy_extension_constructor x)));
    include_declaration = (fun _ x -> copy_include_declaration (include_declaration mapper (R.copy_include_declaration x)));
    include_description = (fun _ x -> copy_include_description (include_description mapper (R.copy_include_description x)));
    label_declaration = (fun _ x -> copy_label_declaration (label_declaration mapper (R.copy_label_declaration x)));
    location = (fun _ x -> copy_location (location mapper (R.copy_location x)));
    module_binding = (fun _ x -> copy_module_binding (module_binding mapper (R.copy_module_binding x)));
    module_declaration = (fun _ x -> copy_module_declaration (module_declaration mapper (R.copy_module_declaration x)));
    module_expr = (fun _ x -> copy_module_expr (module_expr mapper (R.copy_module_expr x)));
    module_type = (fun _ x -> copy_module_type (module_type mapper (R.copy_module_type x)));
    module_type_declaration = (fun _ x -> copy_module_type_declaration (module_type_declaration mapper (R.copy_module_type_declaration x)));
    open_description = (fun _ x -> copy_open_description (open_description mapper (R.copy_open_description x)));
    pat = (fun _ x -> copy_pat (pat mapper (R.copy_pat x)));
    signature = (fun _ x -> copy_signature (signature mapper (R.copy_signature x)));
    signature_item = (fun _ x -> copy_signature_item (signature_item mapper (R.copy_signature_item x)));
    structure = (fun _ x -> copy_structure (structure mapper (R.copy_structure x)));
    structure_item = (fun _ x -> copy_structure_item (structure_item mapper (R.copy_structure_item x)));
    typ = (fun _ x -> copy_typ (typ mapper (R.copy_typ x)));
    type_declaration = (fun _ x -> copy_type_declaration (type_declaration mapper (R.copy_type_declaration x)));
    type_extension = (fun _ x -> copy_type_extension (type_extension mapper (R.copy_type_extension x)));
    type_kind = (fun _ x -> copy_type_kind (type_kind mapper (R.copy_type_kind x)));
    value_binding = (fun _ x -> copy_value_binding (value_binding mapper (R.copy_value_binding x)));
    value_description = (fun _ x -> copy_value_description (value_description mapper (R.copy_value_description x)));
    with_constraint = (fun _ x -> copy_with_constraint (with_constraint mapper (R.copy_with_constraint x)));
    payload = (fun _ x -> copy_payload (payload mapper (R.copy_payload x)));
    (*$*)
  }

end
module Migrate_parsetree_406_405
= struct
#1 "migrate_parsetree_406_405.ml"
# 1 "src/migrate_parsetree_406_405.ml"
# 1 "src/migrate_parsetree_406_405.ml"
# 1 "src/migrate_parsetree_406_405.ml"
# 1 "src/migrate_parsetree_406_405.ml"
# 1 "src/migrate_parsetree_406_405.ml"
# 1 "src/migrate_parsetree_406_405.ml"
# 1 "src/migrate_parsetree_406_405.ml"
# 1 "src/migrate_parsetree_406_405.ml"
# 1 "src/migrate_parsetree_406_405.ml"
# 1 "src/migrate_parsetree_406_405.ml"
# 1 "src/migrate_parsetree_406_405.ml"
# 1 "src/migrate_parsetree_406_405.ml"
# 1 "src/migrate_parsetree_406_405.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

include Migrate_parsetree_406_405_migrate

(*$ open Printf
    let fields = [
      "attribute"; "attributes"; "case"; "cases"; "class_declaration";
      "class_description"; "class_expr"; "class_field"; "class_signature";
      "class_structure"; "class_type"; "class_type_declaration";
      "class_type_field"; "constructor_declaration"; "expr"; "extension";
      "extension_constructor"; "include_declaration"; "include_description";
      "label_declaration"; "location"; "module_binding"; "module_declaration";
      "module_expr"; "module_type"; "module_type_declaration";
      "open_description"; "pat"; "signature"; "signature_item"; "structure";
      "structure_item"; "typ"; "type_declaration"; "type_extension";
      "type_kind"; "value_binding"; "value_description";
      "with_constraint"; "payload"
    ]
  let foreach_field f =
    printf "\n";
    List.iter f fields
*)(*$*)

let copy_mapper = fun
  ({ From.Ast_mapper.
     (*$ foreach_field (printf "%s;\n")*)
     attribute;
     attributes;
     case;
     cases;
     class_declaration;
     class_description;
     class_expr;
     class_field;
     class_signature;
     class_structure;
     class_type;
     class_type_declaration;
     class_type_field;
     constructor_declaration;
     expr;
     extension;
     extension_constructor;
     include_declaration;
     include_description;
     label_declaration;
     location;
     module_binding;
     module_declaration;
     module_expr;
     module_type;
     module_type_declaration;
     open_description;
     pat;
     signature;
     signature_item;
     structure;
     structure_item;
     typ;
     type_declaration;
     type_extension;
     type_kind;
     value_binding;
     value_description;
     with_constraint;
     payload;
     (*$*)
   } as mapper) ->
  let module R = Migrate_parsetree_405_406_migrate in
  {
    To.Ast_mapper.
    (*$ foreach_field (fun s ->
          printf
          "%s = (fun _ x -> copy_%s (%s mapper (R.copy_%s x)));\n" s s s s)
    *)
    attribute = (fun _ x -> copy_attribute (attribute mapper (R.copy_attribute x)));
    attributes = (fun _ x -> copy_attributes (attributes mapper (R.copy_attributes x)));
    case = (fun _ x -> copy_case (case mapper (R.copy_case x)));
    cases = (fun _ x -> copy_cases (cases mapper (R.copy_cases x)));
    class_declaration = (fun _ x -> copy_class_declaration (class_declaration mapper (R.copy_class_declaration x)));
    class_description = (fun _ x -> copy_class_description (class_description mapper (R.copy_class_description x)));
    class_expr = (fun _ x -> copy_class_expr (class_expr mapper (R.copy_class_expr x)));
    class_field = (fun _ x -> copy_class_field (class_field mapper (R.copy_class_field x)));
    class_signature = (fun _ x -> copy_class_signature (class_signature mapper (R.copy_class_signature x)));
    class_structure = (fun _ x -> copy_class_structure (class_structure mapper (R.copy_class_structure x)));
    class_type = (fun _ x -> copy_class_type (class_type mapper (R.copy_class_type x)));
    class_type_declaration = (fun _ x -> copy_class_type_declaration (class_type_declaration mapper (R.copy_class_type_declaration x)));
    class_type_field = (fun _ x -> copy_class_type_field (class_type_field mapper (R.copy_class_type_field x)));
    constructor_declaration = (fun _ x -> copy_constructor_declaration (constructor_declaration mapper (R.copy_constructor_declaration x)));
    expr = (fun _ x -> copy_expr (expr mapper (R.copy_expr x)));
    extension = (fun _ x -> copy_extension (extension mapper (R.copy_extension x)));
    extension_constructor = (fun _ x -> copy_extension_constructor (extension_constructor mapper (R.copy_extension_constructor x)));
    include_declaration = (fun _ x -> copy_include_declaration (include_declaration mapper (R.copy_include_declaration x)));
    include_description = (fun _ x -> copy_include_description (include_description mapper (R.copy_include_description x)));
    label_declaration = (fun _ x -> copy_label_declaration (label_declaration mapper (R.copy_label_declaration x)));
    location = (fun _ x -> copy_location (location mapper (R.copy_location x)));
    module_binding = (fun _ x -> copy_module_binding (module_binding mapper (R.copy_module_binding x)));
    module_declaration = (fun _ x -> copy_module_declaration (module_declaration mapper (R.copy_module_declaration x)));
    module_expr = (fun _ x -> copy_module_expr (module_expr mapper (R.copy_module_expr x)));
    module_type = (fun _ x -> copy_module_type (module_type mapper (R.copy_module_type x)));
    module_type_declaration = (fun _ x -> copy_module_type_declaration (module_type_declaration mapper (R.copy_module_type_declaration x)));
    open_description = (fun _ x -> copy_open_description (open_description mapper (R.copy_open_description x)));
    pat = (fun _ x -> copy_pat (pat mapper (R.copy_pat x)));
    signature = (fun _ x -> copy_signature (signature mapper (R.copy_signature x)));
    signature_item = (fun _ x -> copy_signature_item (signature_item mapper (R.copy_signature_item x)));
    structure = (fun _ x -> copy_structure (structure mapper (R.copy_structure x)));
    structure_item = (fun _ x -> copy_structure_item (structure_item mapper (R.copy_structure_item x)));
    typ = (fun _ x -> copy_typ (typ mapper (R.copy_typ x)));
    type_declaration = (fun _ x -> copy_type_declaration (type_declaration mapper (R.copy_type_declaration x)));
    type_extension = (fun _ x -> copy_type_extension (type_extension mapper (R.copy_type_extension x)));
    type_kind = (fun _ x -> copy_type_kind (type_kind mapper (R.copy_type_kind x)));
    value_binding = (fun _ x -> copy_value_binding (value_binding mapper (R.copy_value_binding x)));
    value_description = (fun _ x -> copy_value_description (value_description mapper (R.copy_value_description x)));
    with_constraint = (fun _ x -> copy_with_constraint (with_constraint mapper (R.copy_with_constraint x)));
    payload = (fun _ x -> copy_payload (payload mapper (R.copy_payload x)));
    (*$*)
  }

end
module Migrate_parsetree_versions : sig 
#1 "migrate_parsetree_versions.mli"
# 1 "src/migrate_parsetree_versions.mli"
# 1 "src/migrate_parsetree_versions.mli"
# 1 "src/migrate_parsetree_versions.mli"
# 1 "src/migrate_parsetree_versions.mli"
# 1 "src/migrate_parsetree_versions.mli"
# 1 "src/migrate_parsetree_versions.mli"
# 1 "src/migrate_parsetree_versions.mli"
# 1 "src/migrate_parsetree_versions.mli"
# 1 "src/migrate_parsetree_versions.mli"
# 1 "src/migrate_parsetree_versions.mli"
# 1 "src/migrate_parsetree_versions.mli"
# 1 "src/migrate_parsetree_versions.mli"
# 1 "src/migrate_parsetree_versions.mli"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*                   Jérémie Dimino, Jane Street Europe                   *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(*$ #use "src/cinaps_helpers" $*)

(** {1 Abstracting an OCaml frontend} *)

(** Abstract view of a version of an OCaml Ast *)
module type Ast = sig
  (*$ foreach_module (fun m types ->
        printf "module %s : sig\n" m;
        List.iter types ~f:(printf "type %s\n");
        printf "end\n"
      )
  *)
  module Parsetree : sig
    type structure
    type signature
    type toplevel_phrase
    type core_type
    type expression
    type pattern
    type case
    type type_declaration
    type type_extension
    type extension_constructor
  end
  module Outcometree : sig
    type out_value
    type out_type
    type out_class_type
    type out_module_type
    type out_sig_item
    type out_type_extension
    type out_phrase
  end
  module Ast_mapper : sig
    type mapper
  end
  (*$*)
  module Config : sig
    val ast_impl_magic_number : string
    val ast_intf_magic_number : string
  end
  val shallow_identity : Ast_mapper.mapper
  val map_signature : Ast_mapper.mapper -> Parsetree.signature -> Parsetree.signature
  val map_structure : Ast_mapper.mapper -> Parsetree.structure -> Parsetree.structure
  val make_top_mapper
    :  signature:(Parsetree.signature -> Parsetree.signature)
    -> structure:(Parsetree.structure -> Parsetree.structure)
    -> Ast_mapper.mapper
end

(* Shortcuts for talking about ast types outside of the module language *)

type 'a _types = 'a constraint 'a
  = <
  (*$ foreach_type (fun _ s -> printf "%-21s : _;\n" s) *)
  structure             : _;
  signature             : _;
  toplevel_phrase       : _;
  core_type             : _;
  expression            : _;
  pattern               : _;
  case                  : _;
  type_declaration      : _;
  type_extension        : _;
  extension_constructor : _;
  out_value             : _;
  out_type              : _;
  out_class_type        : _;
  out_module_type       : _;
  out_sig_item          : _;
  out_type_extension    : _;
  out_phrase            : _;
  mapper                : _;
  (*$*)
  >
;;

(*$ foreach_type (fun _ s ->
      printf "type 'a get_%s = 'x constraint 'a _types = < %s : 'x; .. >\n" s s
    );
    printf ";;\n" *)
type 'a get_structure = 'x constraint 'a _types = < structure : 'x; .. >
type 'a get_signature = 'x constraint 'a _types = < signature : 'x; .. >
type 'a get_toplevel_phrase = 'x constraint 'a _types = < toplevel_phrase : 'x; .. >
type 'a get_core_type = 'x constraint 'a _types = < core_type : 'x; .. >
type 'a get_expression = 'x constraint 'a _types = < expression : 'x; .. >
type 'a get_pattern = 'x constraint 'a _types = < pattern : 'x; .. >
type 'a get_case = 'x constraint 'a _types = < case : 'x; .. >
type 'a get_type_declaration = 'x constraint 'a _types = < type_declaration : 'x; .. >
type 'a get_type_extension = 'x constraint 'a _types = < type_extension : 'x; .. >
type 'a get_extension_constructor = 'x constraint 'a _types = < extension_constructor : 'x; .. >
type 'a get_out_value = 'x constraint 'a _types = < out_value : 'x; .. >
type 'a get_out_type = 'x constraint 'a _types = < out_type : 'x; .. >
type 'a get_out_class_type = 'x constraint 'a _types = < out_class_type : 'x; .. >
type 'a get_out_module_type = 'x constraint 'a _types = < out_module_type : 'x; .. >
type 'a get_out_sig_item = 'x constraint 'a _types = < out_sig_item : 'x; .. >
type 'a get_out_type_extension = 'x constraint 'a _types = < out_type_extension : 'x; .. >
type 'a get_out_phrase = 'x constraint 'a _types = < out_phrase : 'x; .. >
type 'a get_mapper = 'x constraint 'a _types = < mapper : 'x; .. >
;;
(*$*)

(** A version of the OCaml frontend packs the ast with type witnesses
    so that equalities can be recovered dynamically. *)
type _ witnesses

(** [migration_info] is an opaque type that is used to generate migration
    functions. *)
type _ migration_info

(** An OCaml frontend versions an Ast, version number and some witnesses for
    conversion. *)
module type OCaml_version = sig

  (** Ast definition for this version *)
  module Ast : Ast

  (* Version number as an integer, 402, 403, 404, ... *)
  val version : int

  (* Version number as a user-friendly string *)
  val string_version : string (* 4.02, 4.03, 4.04, ... *)

  (** Shortcut for talking about Ast types *)
  type types = <
    (*$ foreach_type (fun m s -> printf "%-21s : Ast.%s.%s;\n" s m s) *)
    structure             : Ast.Parsetree.structure;
    signature             : Ast.Parsetree.signature;
    toplevel_phrase       : Ast.Parsetree.toplevel_phrase;
    core_type             : Ast.Parsetree.core_type;
    expression            : Ast.Parsetree.expression;
    pattern               : Ast.Parsetree.pattern;
    case                  : Ast.Parsetree.case;
    type_declaration      : Ast.Parsetree.type_declaration;
    type_extension        : Ast.Parsetree.type_extension;
    extension_constructor : Ast.Parsetree.extension_constructor;
    out_value             : Ast.Outcometree.out_value;
    out_type              : Ast.Outcometree.out_type;
    out_class_type        : Ast.Outcometree.out_class_type;
    out_module_type       : Ast.Outcometree.out_module_type;
    out_sig_item          : Ast.Outcometree.out_sig_item;
    out_type_extension    : Ast.Outcometree.out_type_extension;
    out_phrase            : Ast.Outcometree.out_phrase;
    mapper                : Ast.Ast_mapper.mapper;
    (*$*)
  > _types

  (** A construtor for recovering type equalities between two arbitrary
      versions. *)
  type _ witnesses += Version : types witnesses

  (** Information used to derive migration functions, see below *)
  val migration_info : types migration_info
end

(** Representing an ocaml version in type language *)
type 'types ocaml_version =
  (module OCaml_version
    (*$ let sep = with_then_and () in
        foreach_type (fun m s ->
          printf "%t type Ast.%s.%s = 'types get_%s\n" sep m s s) *)
    with type Ast.Parsetree.structure = 'types get_structure
     and type Ast.Parsetree.signature = 'types get_signature
     and type Ast.Parsetree.toplevel_phrase = 'types get_toplevel_phrase
     and type Ast.Parsetree.core_type = 'types get_core_type
     and type Ast.Parsetree.expression = 'types get_expression
     and type Ast.Parsetree.pattern = 'types get_pattern
     and type Ast.Parsetree.case = 'types get_case
     and type Ast.Parsetree.type_declaration = 'types get_type_declaration
     and type Ast.Parsetree.type_extension = 'types get_type_extension
     and type Ast.Parsetree.extension_constructor = 'types get_extension_constructor
     and type Ast.Outcometree.out_value = 'types get_out_value
     and type Ast.Outcometree.out_type = 'types get_out_type
     and type Ast.Outcometree.out_class_type = 'types get_out_class_type
     and type Ast.Outcometree.out_module_type = 'types get_out_module_type
     and type Ast.Outcometree.out_sig_item = 'types get_out_sig_item
     and type Ast.Outcometree.out_type_extension = 'types get_out_type_extension
     and type Ast.Outcometree.out_phrase = 'types get_out_phrase
     and type Ast.Ast_mapper.mapper = 'types get_mapper
     (*$*)
  )

(** {1 Concrete frontend instances} *)

(*$foreach_version (fun suffix _ ->
     printf "module OCaml_%s : OCaml_version with module Ast = Ast_%s\n"
       suffix suffix;
     printf "val ocaml_%s : OCaml_%s.types ocaml_version\n" suffix suffix;
  )*)
module OCaml_402 : OCaml_version with module Ast = Ast_402
val ocaml_402 : OCaml_402.types ocaml_version
module OCaml_403 : OCaml_version with module Ast = Ast_403
val ocaml_403 : OCaml_403.types ocaml_version
module OCaml_404 : OCaml_version with module Ast = Ast_404
val ocaml_404 : OCaml_404.types ocaml_version
module OCaml_405 : OCaml_version with module Ast = Ast_405
val ocaml_405 : OCaml_405.types ocaml_version
module OCaml_406 : OCaml_version with module Ast = Ast_406
val ocaml_406 : OCaml_406.types ocaml_version
(*$*)

(* An alias to the current compiler version *)
module OCaml_current = OCaml_402          
val ocaml_current : OCaml_current.types ocaml_version

val all_versions : (module OCaml_version) list

(** {1 Migrating between different versions} *)

type ('a, 'b) type_comparison =
  | Lt : ('a, 'b) type_comparison
  | Eq : ('a, 'a) type_comparison
  | Gt : ('a, 'b) type_comparison

val compare_ocaml_version : 'a ocaml_version -> 'b ocaml_version -> ('a, 'b) type_comparison

(** A record for migrating each AST construct between two known versions *)
type ('from, 'to_) migration_functions = {
  (*$ foreach_type (fun _ s ->
        printf "copy_%s: 'from get_%s -> 'to_ get_%s;\n" s s s) *)
  copy_structure: 'from get_structure -> 'to_ get_structure;
  copy_signature: 'from get_signature -> 'to_ get_signature;
  copy_toplevel_phrase: 'from get_toplevel_phrase -> 'to_ get_toplevel_phrase;
  copy_core_type: 'from get_core_type -> 'to_ get_core_type;
  copy_expression: 'from get_expression -> 'to_ get_expression;
  copy_pattern: 'from get_pattern -> 'to_ get_pattern;
  copy_case: 'from get_case -> 'to_ get_case;
  copy_type_declaration: 'from get_type_declaration -> 'to_ get_type_declaration;
  copy_type_extension: 'from get_type_extension -> 'to_ get_type_extension;
  copy_extension_constructor: 'from get_extension_constructor -> 'to_ get_extension_constructor;
  copy_out_value: 'from get_out_value -> 'to_ get_out_value;
  copy_out_type: 'from get_out_type -> 'to_ get_out_type;
  copy_out_class_type: 'from get_out_class_type -> 'to_ get_out_class_type;
  copy_out_module_type: 'from get_out_module_type -> 'to_ get_out_module_type;
  copy_out_sig_item: 'from get_out_sig_item -> 'to_ get_out_sig_item;
  copy_out_type_extension: 'from get_out_type_extension -> 'to_ get_out_type_extension;
  copy_out_phrase: 'from get_out_phrase -> 'to_ get_out_phrase;
  copy_mapper: 'from get_mapper -> 'to_ get_mapper;
  (*$*)
}

(** Migrating to the same version is no-op *)
val migration_identity : ('a, 'a) migration_functions

(** Migrations can be composed *)
val migration_compose : ('a, 'b) migration_functions -> ('b, 'c) migration_functions -> ('a, 'c) migration_functions

(** Represent the next or previous version of an Ast *)

type 'from immediate_migration =
  | No_migration : 'from immediate_migration
  (** Cannot migrate earliest or latest supported version *)
  |
    Immediate_migration :
      ('from, 'to_) migration_functions * 'to_ ocaml_version -> 'from immediate_migration
  (** Pack the migration functions and the new version *)

val immediate_migration : 'types ocaml_version -> [< `Next | `Previous ] -> 'types immediate_migration

val migrate : 'from ocaml_version -> 'to_ ocaml_version -> ('from, 'to_) migration_functions

(** {1 Convenience definitions} *)

(** Module level migration *)
module Convert (A : OCaml_version) (B : OCaml_version) : sig
  (*$ foreach_type (fun m s ->
        let fq = sprintf "%s.%s" m s in
        printf "  val copy_%-21s : A.Ast.%-31s -> B.Ast.%s\n" s fq fq) *)
  val copy_structure             : A.Ast.Parsetree.structure             -> B.Ast.Parsetree.structure
  val copy_signature             : A.Ast.Parsetree.signature             -> B.Ast.Parsetree.signature
  val copy_toplevel_phrase       : A.Ast.Parsetree.toplevel_phrase       -> B.Ast.Parsetree.toplevel_phrase
  val copy_core_type             : A.Ast.Parsetree.core_type             -> B.Ast.Parsetree.core_type
  val copy_expression            : A.Ast.Parsetree.expression            -> B.Ast.Parsetree.expression
  val copy_pattern               : A.Ast.Parsetree.pattern               -> B.Ast.Parsetree.pattern
  val copy_case                  : A.Ast.Parsetree.case                  -> B.Ast.Parsetree.case
  val copy_type_declaration      : A.Ast.Parsetree.type_declaration      -> B.Ast.Parsetree.type_declaration
  val copy_type_extension        : A.Ast.Parsetree.type_extension        -> B.Ast.Parsetree.type_extension
  val copy_extension_constructor : A.Ast.Parsetree.extension_constructor -> B.Ast.Parsetree.extension_constructor
  val copy_out_value             : A.Ast.Outcometree.out_value           -> B.Ast.Outcometree.out_value
  val copy_out_type              : A.Ast.Outcometree.out_type            -> B.Ast.Outcometree.out_type
  val copy_out_class_type        : A.Ast.Outcometree.out_class_type      -> B.Ast.Outcometree.out_class_type
  val copy_out_module_type       : A.Ast.Outcometree.out_module_type     -> B.Ast.Outcometree.out_module_type
  val copy_out_sig_item          : A.Ast.Outcometree.out_sig_item        -> B.Ast.Outcometree.out_sig_item
  val copy_out_type_extension    : A.Ast.Outcometree.out_type_extension  -> B.Ast.Outcometree.out_type_extension
  val copy_out_phrase            : A.Ast.Outcometree.out_phrase          -> B.Ast.Outcometree.out_phrase
  val copy_mapper                : A.Ast.Ast_mapper.mapper               -> B.Ast.Ast_mapper.mapper
  (*$*)
end

end = struct
#1 "migrate_parsetree_versions.ml"
# 1 "src/migrate_parsetree_versions.ml"
# 1 "src/migrate_parsetree_versions.ml"
# 1 "src/migrate_parsetree_versions.ml"
# 1 "src/migrate_parsetree_versions.ml"
# 1 "src/migrate_parsetree_versions.ml"
# 1 "src/migrate_parsetree_versions.ml"
# 1 "src/migrate_parsetree_versions.ml"
# 1 "src/migrate_parsetree_versions.ml"
# 1 "src/migrate_parsetree_versions.ml"
# 1 "src/migrate_parsetree_versions.ml"
# 1 "src/migrate_parsetree_versions.ml"
# 1 "src/migrate_parsetree_versions.ml"
# 1 "src/migrate_parsetree_versions.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*                   Jérémie Dimino, Jane Street Europe                   *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(* BEGIN of BLACK MAGIC *)
(*$ #use "src/cinaps_helpers" $*)

type _ witnesses = ..

type _ migration = ..
type _ migration += Undefined : _ migration

type 'a migration_info = {
  mutable next_version : 'a migration;
  mutable previous_version : 'a migration;
}

(** Abstract view of a version of an OCaml Ast *)
module type Ast = sig
  (*$ foreach_module (fun m types ->
        printf "module %s : sig\n" m;
        List.iter types ~f:(printf "type %s\n");
        printf "end\n"
      )
  *)
  module Parsetree : sig
    type structure
    type signature
    type toplevel_phrase
    type core_type
    type expression
    type pattern
    type case
    type type_declaration
    type type_extension
    type extension_constructor
  end
  module Outcometree : sig
    type out_value
    type out_type
    type out_class_type
    type out_module_type
    type out_sig_item
    type out_type_extension
    type out_phrase
  end
  module Ast_mapper : sig
    type mapper
  end
  (*$*)
  module Config : sig
    val ast_impl_magic_number : string
    val ast_intf_magic_number : string
  end
  val shallow_identity : Ast_mapper.mapper
  val map_signature : Ast_mapper.mapper -> Parsetree.signature -> Parsetree.signature
  val map_structure : Ast_mapper.mapper -> Parsetree.structure -> Parsetree.structure
  val make_top_mapper
    :  signature:(Parsetree.signature -> Parsetree.signature)
    -> structure:(Parsetree.structure -> Parsetree.structure)
    -> Ast_mapper.mapper
end

(* Shortcuts for talking about ast types outside of the module language *)

type 'a _types = 'a constraint 'a
  = <
  (*$ foreach_type (fun _ s -> printf "%-21s : _;\n" s) *)
  structure             : _;
  signature             : _;
  toplevel_phrase       : _;
  core_type             : _;
  expression            : _;
  pattern               : _;
  case                  : _;
  type_declaration      : _;
  type_extension        : _;
  extension_constructor : _;
  out_value             : _;
  out_type              : _;
  out_class_type        : _;
  out_module_type       : _;
  out_sig_item          : _;
  out_type_extension    : _;
  out_phrase            : _;
  mapper                : _;
  (*$*)
  >
;;

(*$ foreach_type (fun _ s ->
      printf "type 'a get_%s =\n" s;
      printf " 'x constraint 'a _types = < %s : 'x; .. >\n" s
    ) *)
type 'a get_structure =
  'x constraint 'a _types = < structure : 'x; .. >
type 'a get_signature =
  'x constraint 'a _types = < signature : 'x; .. >
type 'a get_toplevel_phrase =
  'x constraint 'a _types = < toplevel_phrase : 'x; .. >
type 'a get_core_type =
  'x constraint 'a _types = < core_type : 'x; .. >
type 'a get_expression =
  'x constraint 'a _types = < expression : 'x; .. >
type 'a get_pattern =
  'x constraint 'a _types = < pattern : 'x; .. >
type 'a get_case =
  'x constraint 'a _types = < case : 'x; .. >
type 'a get_type_declaration =
  'x constraint 'a _types = < type_declaration : 'x; .. >
type 'a get_type_extension =
  'x constraint 'a _types = < type_extension : 'x; .. >
type 'a get_extension_constructor =
  'x constraint 'a _types = < extension_constructor : 'x; .. >
type 'a get_out_value =
  'x constraint 'a _types = < out_value : 'x; .. >
type 'a get_out_type =
  'x constraint 'a _types = < out_type : 'x; .. >
type 'a get_out_class_type =
  'x constraint 'a _types = < out_class_type : 'x; .. >
type 'a get_out_module_type =
  'x constraint 'a _types = < out_module_type : 'x; .. >
type 'a get_out_sig_item =
  'x constraint 'a _types = < out_sig_item : 'x; .. >
type 'a get_out_type_extension =
  'x constraint 'a _types = < out_type_extension : 'x; .. >
type 'a get_out_phrase =
  'x constraint 'a _types = < out_phrase : 'x; .. >
type 'a get_mapper =
  'x constraint 'a _types = < mapper : 'x; .. >
       (*$*)

module type OCaml_version = sig
  module Ast : Ast
  val version : int
  val string_version : string
  type types = <
    (*$ foreach_type (fun m s -> printf "%-21s : Ast.%s.%s;\n" s m s)*)
    structure             : Ast.Parsetree.structure;
    signature             : Ast.Parsetree.signature;
    toplevel_phrase       : Ast.Parsetree.toplevel_phrase;
    core_type             : Ast.Parsetree.core_type;
    expression            : Ast.Parsetree.expression;
    pattern               : Ast.Parsetree.pattern;
    case                  : Ast.Parsetree.case;
    type_declaration      : Ast.Parsetree.type_declaration;
    type_extension        : Ast.Parsetree.type_extension;
    extension_constructor : Ast.Parsetree.extension_constructor;
    out_value             : Ast.Outcometree.out_value;
    out_type              : Ast.Outcometree.out_type;
    out_class_type        : Ast.Outcometree.out_class_type;
    out_module_type       : Ast.Outcometree.out_module_type;
    out_sig_item          : Ast.Outcometree.out_sig_item;
    out_type_extension    : Ast.Outcometree.out_type_extension;
    out_phrase            : Ast.Outcometree.out_phrase;
    mapper                : Ast.Ast_mapper.mapper;
    (*$*)
  > _types
  type _ witnesses += Version : types witnesses
  val migration_info : types migration_info
end

module Make_witness(Ast : Ast) =
struct
  type types = <
    (*$ foreach_type (fun m s -> printf "%-21s : Ast.%s.%s;\n" s m s)*)
    structure             : Ast.Parsetree.structure;
    signature             : Ast.Parsetree.signature;
    toplevel_phrase       : Ast.Parsetree.toplevel_phrase;
    core_type             : Ast.Parsetree.core_type;
    expression            : Ast.Parsetree.expression;
    pattern               : Ast.Parsetree.pattern;
    case                  : Ast.Parsetree.case;
    type_declaration      : Ast.Parsetree.type_declaration;
    type_extension        : Ast.Parsetree.type_extension;
    extension_constructor : Ast.Parsetree.extension_constructor;
    out_value             : Ast.Outcometree.out_value;
    out_type              : Ast.Outcometree.out_type;
    out_class_type        : Ast.Outcometree.out_class_type;
    out_module_type       : Ast.Outcometree.out_module_type;
    out_sig_item          : Ast.Outcometree.out_sig_item;
    out_type_extension    : Ast.Outcometree.out_type_extension;
    out_phrase            : Ast.Outcometree.out_phrase;
    mapper                : Ast.Ast_mapper.mapper;
    (*$*)
  > _types
  type _ witnesses += Version : types witnesses
  let migration_info : types migration_info =
    { next_version = Undefined; previous_version = Undefined }
end

type 'types ocaml_version =
  (module OCaml_version
    (*$ let sep = with_then_and () in
        foreach_type (fun m s ->
          printf "%t type Ast.%s.%s = 'types get_%s\n" sep m s s) *)
    with type Ast.Parsetree.structure = 'types get_structure
     and type Ast.Parsetree.signature = 'types get_signature
     and type Ast.Parsetree.toplevel_phrase = 'types get_toplevel_phrase
     and type Ast.Parsetree.core_type = 'types get_core_type
     and type Ast.Parsetree.expression = 'types get_expression
     and type Ast.Parsetree.pattern = 'types get_pattern
     and type Ast.Parsetree.case = 'types get_case
     and type Ast.Parsetree.type_declaration = 'types get_type_declaration
     and type Ast.Parsetree.type_extension = 'types get_type_extension
     and type Ast.Parsetree.extension_constructor = 'types get_extension_constructor
     and type Ast.Outcometree.out_value = 'types get_out_value
     and type Ast.Outcometree.out_type = 'types get_out_type
     and type Ast.Outcometree.out_class_type = 'types get_out_class_type
     and type Ast.Outcometree.out_module_type = 'types get_out_module_type
     and type Ast.Outcometree.out_sig_item = 'types get_out_sig_item
     and type Ast.Outcometree.out_type_extension = 'types get_out_type_extension
     and type Ast.Outcometree.out_phrase = 'types get_out_phrase
     and type Ast.Ast_mapper.mapper = 'types get_mapper
     (*$*)
  )

type ('a, 'b) type_comparison =
  | Lt : ('a, 'b) type_comparison
  | Eq : ('a, 'a) type_comparison
  | Gt : ('a, 'b) type_comparison

let compare_ocaml_version
    (*$ foreach_type (fun _ s -> printf "(type %s1) (type %s2)\n" s s) *)
    (type structure1) (type structure2)
    (type signature1) (type signature2)
    (type toplevel_phrase1) (type toplevel_phrase2)
    (type core_type1) (type core_type2)
    (type expression1) (type expression2)
    (type pattern1) (type pattern2)
    (type case1) (type case2)
    (type type_declaration1) (type type_declaration2)
    (type type_extension1) (type type_extension2)
    (type extension_constructor1) (type extension_constructor2)
    (type out_value1) (type out_value2)
    (type out_type1) (type out_type2)
    (type out_class_type1) (type out_class_type2)
    (type out_module_type1) (type out_module_type2)
    (type out_sig_item1) (type out_sig_item2)
    (type out_type_extension1) (type out_type_extension2)
    (type out_phrase1) (type out_phrase2)
    (type mapper1) (type mapper2)
    (*$*)
    ((module A) : <
     (*$ foreach_type (fun _ s -> printf "%-21s : %s1;\n" s s) *)
     structure             : structure1;
     signature             : signature1;
     toplevel_phrase       : toplevel_phrase1;
     core_type             : core_type1;
     expression            : expression1;
     pattern               : pattern1;
     case                  : case1;
     type_declaration      : type_declaration1;
     type_extension        : type_extension1;
     extension_constructor : extension_constructor1;
     out_value             : out_value1;
     out_type              : out_type1;
     out_class_type        : out_class_type1;
     out_module_type       : out_module_type1;
     out_sig_item          : out_sig_item1;
     out_type_extension    : out_type_extension1;
     out_phrase            : out_phrase1;
     mapper                : mapper1;
     (*$*)
     > ocaml_version)
    ((module B) : <
     (*$ foreach_type (fun _ s -> printf "%-21s : %s2;\n" s s) *)
     structure             : structure2;
     signature             : signature2;
     toplevel_phrase       : toplevel_phrase2;
     core_type             : core_type2;
     expression            : expression2;
     pattern               : pattern2;
     case                  : case2;
     type_declaration      : type_declaration2;
     type_extension        : type_extension2;
     extension_constructor : extension_constructor2;
     out_value             : out_value2;
     out_type              : out_type2;
     out_class_type        : out_class_type2;
     out_module_type       : out_module_type2;
     out_sig_item          : out_sig_item2;
     out_type_extension    : out_type_extension2;
     out_phrase            : out_phrase2;
     mapper                : mapper2;
     (*$*)
     > ocaml_version)
  : (A.types, B.types) type_comparison
  =
  match A.Version with
  | B.Version -> Eq
  | _ when A.version < B.version -> Lt
  | _ when A.version > B.version -> Gt
  | _ -> assert false

type ('from, 'to_) migration_functions = {
  (*$ foreach_type (fun _ s ->
        printf "copy_%s: 'from get_%s -> 'to_ get_%s;\n" s s s) *)
  copy_structure: 'from get_structure -> 'to_ get_structure;
  copy_signature: 'from get_signature -> 'to_ get_signature;
  copy_toplevel_phrase: 'from get_toplevel_phrase -> 'to_ get_toplevel_phrase;
  copy_core_type: 'from get_core_type -> 'to_ get_core_type;
  copy_expression: 'from get_expression -> 'to_ get_expression;
  copy_pattern: 'from get_pattern -> 'to_ get_pattern;
  copy_case: 'from get_case -> 'to_ get_case;
  copy_type_declaration: 'from get_type_declaration -> 'to_ get_type_declaration;
  copy_type_extension: 'from get_type_extension -> 'to_ get_type_extension;
  copy_extension_constructor: 'from get_extension_constructor -> 'to_ get_extension_constructor;
  copy_out_value: 'from get_out_value -> 'to_ get_out_value;
  copy_out_type: 'from get_out_type -> 'to_ get_out_type;
  copy_out_class_type: 'from get_out_class_type -> 'to_ get_out_class_type;
  copy_out_module_type: 'from get_out_module_type -> 'to_ get_out_module_type;
  copy_out_sig_item: 'from get_out_sig_item -> 'to_ get_out_sig_item;
  copy_out_type_extension: 'from get_out_type_extension -> 'to_ get_out_type_extension;
  copy_out_phrase: 'from get_out_phrase -> 'to_ get_out_phrase;
  copy_mapper: 'from get_mapper -> 'to_ get_mapper;
  (*$*)
}

let id x = x
let migration_identity : ('a, 'a) migration_functions = {
  (*$ foreach_type (fun _ s -> printf "copy_%s = id;\n" s) *)
  copy_structure = id;
  copy_signature = id;
  copy_toplevel_phrase = id;
  copy_core_type = id;
  copy_expression = id;
  copy_pattern = id;
  copy_case = id;
  copy_type_declaration = id;
  copy_type_extension = id;
  copy_extension_constructor = id;
  copy_out_value = id;
  copy_out_type = id;
  copy_out_class_type = id;
  copy_out_module_type = id;
  copy_out_sig_item = id;
  copy_out_type_extension = id;
  copy_out_phrase = id;
  copy_mapper = id;
  (*$*)
}

let compose f g x = f (g x)
let migration_compose (ab : ('a, 'b) migration_functions) (bc : ('b, 'c) migration_functions) : ('a, 'c) migration_functions = {
  (*$ foreach_type (fun _ s ->
        printf "copy_%-21s = compose bc.copy_%-21s ab.copy_%s;\n" s s s) *)
  copy_structure             = compose bc.copy_structure             ab.copy_structure;
  copy_signature             = compose bc.copy_signature             ab.copy_signature;
  copy_toplevel_phrase       = compose bc.copy_toplevel_phrase       ab.copy_toplevel_phrase;
  copy_core_type             = compose bc.copy_core_type             ab.copy_core_type;
  copy_expression            = compose bc.copy_expression            ab.copy_expression;
  copy_pattern               = compose bc.copy_pattern               ab.copy_pattern;
  copy_case                  = compose bc.copy_case                  ab.copy_case;
  copy_type_declaration      = compose bc.copy_type_declaration      ab.copy_type_declaration;
  copy_type_extension        = compose bc.copy_type_extension        ab.copy_type_extension;
  copy_extension_constructor = compose bc.copy_extension_constructor ab.copy_extension_constructor;
  copy_out_value             = compose bc.copy_out_value             ab.copy_out_value;
  copy_out_type              = compose bc.copy_out_type              ab.copy_out_type;
  copy_out_class_type        = compose bc.copy_out_class_type        ab.copy_out_class_type;
  copy_out_module_type       = compose bc.copy_out_module_type       ab.copy_out_module_type;
  copy_out_sig_item          = compose bc.copy_out_sig_item          ab.copy_out_sig_item;
  copy_out_type_extension    = compose bc.copy_out_type_extension    ab.copy_out_type_extension;
  copy_out_phrase            = compose bc.copy_out_phrase            ab.copy_out_phrase;
  copy_mapper                = compose bc.copy_mapper                ab.copy_mapper;
  (*$*)
}

type _ migration += Migration : 'from ocaml_version * ('from, 'to_) migration_functions * 'to_ ocaml_version -> 'from migration

module type Migrate_module = sig
  module From : Ast
  module To : Ast
  (*$ foreach_type (fun m s ->
        printf "val copy_%-21s: From.%s.%s -> To.%s.%s\n" s m s m s) *)
  val copy_structure            : From.Parsetree.structure -> To.Parsetree.structure
  val copy_signature            : From.Parsetree.signature -> To.Parsetree.signature
  val copy_toplevel_phrase      : From.Parsetree.toplevel_phrase -> To.Parsetree.toplevel_phrase
  val copy_core_type            : From.Parsetree.core_type -> To.Parsetree.core_type
  val copy_expression           : From.Parsetree.expression -> To.Parsetree.expression
  val copy_pattern              : From.Parsetree.pattern -> To.Parsetree.pattern
  val copy_case                 : From.Parsetree.case -> To.Parsetree.case
  val copy_type_declaration     : From.Parsetree.type_declaration -> To.Parsetree.type_declaration
  val copy_type_extension       : From.Parsetree.type_extension -> To.Parsetree.type_extension
  val copy_extension_constructor: From.Parsetree.extension_constructor -> To.Parsetree.extension_constructor
  val copy_out_value            : From.Outcometree.out_value -> To.Outcometree.out_value
  val copy_out_type             : From.Outcometree.out_type -> To.Outcometree.out_type
  val copy_out_class_type       : From.Outcometree.out_class_type -> To.Outcometree.out_class_type
  val copy_out_module_type      : From.Outcometree.out_module_type -> To.Outcometree.out_module_type
  val copy_out_sig_item         : From.Outcometree.out_sig_item -> To.Outcometree.out_sig_item
  val copy_out_type_extension   : From.Outcometree.out_type_extension -> To.Outcometree.out_type_extension
  val copy_out_phrase           : From.Outcometree.out_phrase -> To.Outcometree.out_phrase
  val copy_mapper               : From.Ast_mapper.mapper -> To.Ast_mapper.mapper
  (*$*)
end

module Migration_functions
    (A : OCaml_version) (B : OCaml_version)
    (A_to_B : Migrate_module with module From = A.Ast and module To = B.Ast)
=
struct
  let migration_functions : (A.types, B.types) migration_functions =
    let open A_to_B in
    {
      (*$ foreach_type (fun _ s -> printf "copy_%s;\n" s) *)
      copy_structure;
      copy_signature;
      copy_toplevel_phrase;
      copy_core_type;
      copy_expression;
      copy_pattern;
      copy_case;
      copy_type_declaration;
      copy_type_extension;
      copy_extension_constructor;
      copy_out_value;
      copy_out_type;
      copy_out_class_type;
      copy_out_module_type;
      copy_out_sig_item;
      copy_out_type_extension;
      copy_out_phrase;
      copy_mapper;
      (*$*)
    }
end

module Register_migration (A : OCaml_version) (B : OCaml_version)
    (A_to_B : Migrate_module with module From = A.Ast and module To = B.Ast)
    (B_to_A : Migrate_module with module From = B.Ast and module To = A.Ast)
=
struct
  let () = (
    let is_undefined : type a. a migration -> bool = function
      | Undefined -> true
      | _ -> false
    in
    assert (A.version < B.version);
    assert (is_undefined A.migration_info.next_version);
    assert (is_undefined B.migration_info.previous_version);
    let module A_to_B_fun = Migration_functions(A)(B)(A_to_B) in
    let module B_to_A_fun = Migration_functions(B)(A)(B_to_A) in
    A.migration_info.next_version <-
      Migration ((module A), A_to_B_fun.migration_functions, (module B));
    B.migration_info.previous_version <-
      Migration ((module B), B_to_A_fun.migration_functions, (module A));
  )
end

type 'from immediate_migration =
  | No_migration : 'from immediate_migration
  | Immediate_migration
    :  ('from, 'to_) migration_functions * 'to_ ocaml_version
    -> 'from immediate_migration

let immediate_migration
    (*$ foreach_type (fun _ s -> printf "(type %s)\n" s) *)
    (type structure)
    (type signature)
    (type toplevel_phrase)
    (type core_type)
    (type expression)
    (type pattern)
    (type case)
    (type type_declaration)
    (type type_extension)
    (type extension_constructor)
    (type out_value)
    (type out_type)
    (type out_class_type)
    (type out_module_type)
    (type out_sig_item)
    (type out_type_extension)
    (type out_phrase)
    (type mapper)
    (*$*)
    ((module A) : <
     (*$ foreach_type (fun _ s -> printf "%-21s : %s;\n" s s) *)
     structure             : structure;
     signature             : signature;
     toplevel_phrase       : toplevel_phrase;
     core_type             : core_type;
     expression            : expression;
     pattern               : pattern;
     case                  : case;
     type_declaration      : type_declaration;
     type_extension        : type_extension;
     extension_constructor : extension_constructor;
     out_value             : out_value;
     out_type              : out_type;
     out_class_type        : out_class_type;
     out_module_type       : out_module_type;
     out_sig_item          : out_sig_item;
     out_type_extension    : out_type_extension;
     out_phrase            : out_phrase;
     mapper                : mapper;
     (*$*)
     > ocaml_version)
    direction
  =
  let version = match direction with
    | `Next -> A.migration_info.next_version
    | `Previous -> A.migration_info.previous_version
  in
  match version with
  | Undefined -> No_migration
  | Migration (_, funs, to_) -> Immediate_migration (funs, to_)
  | _ -> assert false

let migrate
    (*$ foreach_type (fun _ s -> printf "(type %s1) (type %s2)\n" s s) *)
    (type structure1) (type structure2)
    (type signature1) (type signature2)
    (type toplevel_phrase1) (type toplevel_phrase2)
    (type core_type1) (type core_type2)
    (type expression1) (type expression2)
    (type pattern1) (type pattern2)
    (type case1) (type case2)
    (type type_declaration1) (type type_declaration2)
    (type type_extension1) (type type_extension2)
    (type extension_constructor1) (type extension_constructor2)
    (type out_value1) (type out_value2)
    (type out_type1) (type out_type2)
    (type out_class_type1) (type out_class_type2)
    (type out_module_type1) (type out_module_type2)
    (type out_sig_item1) (type out_sig_item2)
    (type out_type_extension1) (type out_type_extension2)
    (type out_phrase1) (type out_phrase2)
    (type mapper1) (type mapper2)
    (*$*)
    ((module A) : <
     (*$ foreach_type (fun _ s -> printf "%-21s : %s1;\n" s s) *)
     structure             : structure1;
     signature             : signature1;
     toplevel_phrase       : toplevel_phrase1;
     core_type             : core_type1;
     expression            : expression1;
     pattern               : pattern1;
     case                  : case1;
     type_declaration      : type_declaration1;
     type_extension        : type_extension1;
     extension_constructor : extension_constructor1;
     out_value             : out_value1;
     out_type              : out_type1;
     out_class_type        : out_class_type1;
     out_module_type       : out_module_type1;
     out_sig_item          : out_sig_item1;
     out_type_extension    : out_type_extension1;
     out_phrase            : out_phrase1;
     mapper                : mapper1;
     (*$*)
     > ocaml_version)
    ((module B) : <
     (*$ foreach_type (fun _ s -> printf "%-21s : %s2;\n" s s) *)
     structure             : structure2;
     signature             : signature2;
     toplevel_phrase       : toplevel_phrase2;
     core_type             : core_type2;
     expression            : expression2;
     pattern               : pattern2;
     case                  : case2;
     type_declaration      : type_declaration2;
     type_extension        : type_extension2;
     extension_constructor : extension_constructor2;
     out_value             : out_value2;
     out_type              : out_type2;
     out_class_type        : out_class_type2;
     out_module_type       : out_module_type2;
     out_sig_item          : out_sig_item2;
     out_type_extension    : out_type_extension2;
     out_phrase            : out_phrase2;
     mapper                : mapper2;
     (*$*)
     > ocaml_version)
  : (A.types, B.types) migration_functions
  =
  match A.Version with
  | B.Version -> migration_identity
  | _ ->
    let direction = if A.version < B.version then `Next else `Previous in
    let rec migrate (m : A.types immediate_migration) : (A.types, B.types) migration_functions =
      match m with
      | No_migration -> assert false
      | Immediate_migration (f, (module To)) ->
        match To.Version with
        | B.Version -> f
        | _ ->
          match immediate_migration (module To) direction with
          | No_migration -> assert false
          | Immediate_migration (g, to2) ->
            migrate (Immediate_migration (migration_compose f g, to2))
    in
    migrate (immediate_migration (module A) direction)

module Convert (A : OCaml_version) (B : OCaml_version) = struct
  let {
    (*$ foreach_type (fun _ s -> printf "copy_%s;\n" s) *)
    copy_structure;
    copy_signature;
    copy_toplevel_phrase;
    copy_core_type;
    copy_expression;
    copy_pattern;
    copy_case;
    copy_type_declaration;
    copy_type_extension;
    copy_extension_constructor;
    copy_out_value;
    copy_out_type;
    copy_out_class_type;
    copy_out_module_type;
    copy_out_sig_item;
    copy_out_type_extension;
    copy_out_phrase;
    copy_mapper;
    (*$*)
  } : (A.types, B.types) migration_functions =
    migrate (module A) (module B)
end

(*$ foreach_version (fun suffix version ->
      printf "module OCaml_%s = struct\n" suffix;
      printf "  module Ast = Ast_%s\n" suffix;
      printf "  include Make_witness(Ast_%s)\n" suffix;
      printf "  let version = %s\n" suffix;
      printf "  let string_version = %S\n" version;
      printf "end\n";
      printf "let ocaml_%s : OCaml_%s.types ocaml_version = (module OCaml_%s)\n"
        suffix suffix suffix;
    )
*)
module OCaml_402 = struct
  module Ast = Ast_402
  include Make_witness(Ast_402)
  let version = 402
  let string_version = "4.02"
end
let ocaml_402 : OCaml_402.types ocaml_version = (module OCaml_402)
module OCaml_403 = struct
  module Ast = Ast_403
  include Make_witness(Ast_403)
  let version = 403
  let string_version = "4.03"
end
let ocaml_403 : OCaml_403.types ocaml_version = (module OCaml_403)
module OCaml_404 = struct
  module Ast = Ast_404
  include Make_witness(Ast_404)
  let version = 404
  let string_version = "4.04"
end
let ocaml_404 : OCaml_404.types ocaml_version = (module OCaml_404)
module OCaml_405 = struct
  module Ast = Ast_405
  include Make_witness(Ast_405)
  let version = 405
  let string_version = "4.05"
end
let ocaml_405 : OCaml_405.types ocaml_version = (module OCaml_405)
module OCaml_406 = struct
  module Ast = Ast_406
  include Make_witness(Ast_406)
  let version = 406
  let string_version = "4.06"
end
let ocaml_406 : OCaml_406.types ocaml_version = (module OCaml_406)
(*$*)

let all_versions : (module OCaml_version) list = [
  (*$foreach_version (fun suffix _ ->
       printf "(module OCaml_%s : OCaml_version);\n" suffix)*)
  (module OCaml_402 : OCaml_version);
  (module OCaml_403 : OCaml_version);
  (module OCaml_404 : OCaml_version);
  (module OCaml_405 : OCaml_version);
  (module OCaml_406 : OCaml_version);
  (*$*)
]

(*$foreach_version_pair (fun a b ->
   printf "include Register_migration(OCaml_%s)(OCaml_%s)\n" a b;
   printf "  (Migrate_parsetree_%s_%s)(Migrate_parsetree_%s_%s)\n" a b b a
  )
*)
include Register_migration(OCaml_402)(OCaml_403)
    (Migrate_parsetree_402_403)(Migrate_parsetree_403_402)
include Register_migration(OCaml_403)(OCaml_404)
    (Migrate_parsetree_403_404)(Migrate_parsetree_404_403)
include Register_migration(OCaml_404)(OCaml_405)
    (Migrate_parsetree_404_405)(Migrate_parsetree_405_404)
include Register_migration(OCaml_405)(OCaml_406)
    (Migrate_parsetree_405_406)(Migrate_parsetree_406_405)
(*$*)

module OCaml_current = OCaml_402          
let ocaml_current : OCaml_current.types ocaml_version = (module OCaml_current)

(* Make sure the preprocessing worked as expected *)
let _f (x : Parsetree.expression) : OCaml_current.Ast.Parsetree.expression = x

end
module Migrate_parsetree_ast_io : sig 
#1 "migrate_parsetree_ast_io.mli"
# 1 "src/migrate_parsetree_ast_io.mli"
# 1 "src/migrate_parsetree_ast_io.mli"
# 1 "src/migrate_parsetree_ast_io.mli"
# 1 "src/migrate_parsetree_ast_io.mli"
# 1 "src/migrate_parsetree_ast_io.mli"
# 1 "src/migrate_parsetree_ast_io.mli"
# 1 "src/migrate_parsetree_ast_io.mli"
# 1 "src/migrate_parsetree_ast_io.mli"
# 1 "src/migrate_parsetree_ast_io.mli"
# 1 "src/migrate_parsetree_ast_io.mli"
# 1 "src/migrate_parsetree_ast_io.mli"
# 1 "src/migrate_parsetree_ast_io.mli"
# 1 "src/migrate_parsetree_ast_io.mli"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(** A marshalled ast packs the ast with the corresponding version of the
    frontend *)
type ast =
  | Impl : (module Migrate_parsetree_versions.OCaml_version with
             type Ast.Parsetree.structure = 'concrete) * 'concrete -> ast
  | Intf : (module Migrate_parsetree_versions.OCaml_version with
             type Ast.Parsetree.signature = 'concrete) * 'concrete -> ast

(** A simple alias used for the filename of the source that produced an AST *)
type filename = string

type read_error =
  | Not_a_binary_ast of string
  (** The input doesn't contain a binary AST. The argument corresponds
      to the bytes from the input that were consumed. *)
  | Unknown_version of string
  (** The input contains a binary AST for an unknown version of OCaml.
      The argument is the unknown magic number. *)

(** Load a marshalled AST from a channel

    Any exception raised during unmarshalling (see [Marshal]) can escape.  *)
val from_channel : in_channel -> (filename * ast, read_error) result

(** Load a marshalled AST from a byte string.

    See [from_channel] description for exception that can be raised. *)
val from_bytes : bytes -> int -> (filename * ast, read_error) result

(** Marshal an AST to a channel *)
val to_channel : out_channel -> filename -> ast -> unit

(** Marshal an AST to a byte string *)
val to_bytes : filename -> ast -> bytes

end = struct
#1 "migrate_parsetree_ast_io.ml"
# 1 "src/migrate_parsetree_ast_io.ml"
# 1 "src/migrate_parsetree_ast_io.ml"
# 1 "src/migrate_parsetree_ast_io.ml"
# 1 "src/migrate_parsetree_ast_io.ml"
# 1 "src/migrate_parsetree_ast_io.ml"
# 1 "src/migrate_parsetree_ast_io.ml"
# 1 "src/migrate_parsetree_ast_io.ml"
# 1 "src/migrate_parsetree_ast_io.ml"
# 1 "src/migrate_parsetree_ast_io.ml"
# 1 "src/migrate_parsetree_ast_io.ml"
# 1 "src/migrate_parsetree_ast_io.ml"
# 1 "src/migrate_parsetree_ast_io.ml"
# 1 "src/migrate_parsetree_ast_io.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

type ast =
  | Impl : (module Migrate_parsetree_versions.OCaml_version with
             type Ast.Parsetree.structure = 'concrete) * 'concrete -> ast
  | Intf : (module Migrate_parsetree_versions.OCaml_version with
             type Ast.Parsetree.signature = 'concrete) * 'concrete -> ast

type filename = string

let magic_length = String.length Ast_402.Config.ast_impl_magic_number

let read_magic ic =
  let buf = Bytes.create magic_length in
  let len = input ic buf 0 magic_length in
  let s = Bytes.sub_string buf 0 len in
  if len = magic_length then
    Ok s
  else
    Error s

type read_error =
  | Not_a_binary_ast of string
  | Unknown_version of string

let find_magic magic =
  let rec loop = function
    | [] ->
        let prefix = String.sub magic 0 9 in
        if prefix = String.sub Ast_402.Config.ast_impl_magic_number 0 9 ||
           prefix = String.sub Ast_402.Config.ast_intf_magic_number 0 9 then
          Error (Unknown_version magic)
        else
          Error (Not_a_binary_ast magic)
    | (module Frontend : Migrate_parsetree_versions.OCaml_version) :: tail ->
        if Frontend.Ast.Config.ast_impl_magic_number = magic then
          Ok (fun x -> Impl ((module Frontend), Obj.obj x))
        else if Frontend.Ast.Config.ast_intf_magic_number = magic then
          Ok (fun x -> Intf ((module Frontend), Obj.obj x))
        else
          loop tail
  in
  loop Migrate_parsetree_versions.all_versions

let from_channel ic =
  match read_magic ic with
  | Error s -> Error (Not_a_binary_ast s)
  | Ok s ->
    match find_magic s with
    | Ok inj ->
      let filename : filename = input_value ic in
      let payload = inj (input_value ic) in
      Ok (filename, payload)
    | Error _ as e  -> e

let from_bytes bytes pos =
  if Bytes.length bytes - pos < magic_length then
    Error (Not_a_binary_ast "")
  else
    let magic = Bytes.to_string (Bytes.sub bytes pos magic_length) in
    match find_magic magic with
    | Ok inj ->
      let filename_pos = pos + magic_length in
      let filename : filename = Marshal.from_bytes bytes filename_pos in
      let payload_pos = filename_pos + Marshal.total_size bytes filename_pos in
      let payload = inj (Marshal.from_bytes bytes payload_pos) in
      Ok (filename, payload)
    | Error _ as e -> e

let decompose_ast = function
  | Impl ((module Frontend), tree) ->
      (Frontend.Ast.Config.ast_impl_magic_number, Obj.repr tree)
  | Intf ((module Frontend), tree) ->
      (Frontend.Ast.Config.ast_intf_magic_number, Obj.repr tree)

let to_channel oc (filename : filename) x =
  let magic_number, payload = decompose_ast x in
  output_string oc magic_number;
  output_value oc filename;
  output_value oc payload

let to_bytes (filename : filename) x =
  let magic_number, payload = decompose_ast x in
  Bytes.cat (
    Bytes.cat
      (Bytes.of_string magic_number)
      (Marshal.to_bytes filename [])
  ) (Marshal.to_bytes payload [])

end
module Migrate_parsetree_compiler_functions
= struct
#1 "migrate_parsetree_compiler_functions.ml"
# 1 "src/migrate_parsetree_compiler_functions.ml"
# 1 "src/migrate_parsetree_compiler_functions.ml"
# 1 "src/migrate_parsetree_compiler_functions.ml"
# 1 "src/migrate_parsetree_compiler_functions.ml"
# 1 "src/migrate_parsetree_compiler_functions.ml"
# 1 "src/migrate_parsetree_compiler_functions.ml"
# 1 "src/migrate_parsetree_compiler_functions.ml"
# 1 "src/migrate_parsetree_compiler_functions.ml"
# 1 "src/migrate_parsetree_compiler_functions.ml"
# 1 "src/migrate_parsetree_compiler_functions.ml"
# 1 "src/migrate_parsetree_compiler_functions.ml"
# 1 "src/migrate_parsetree_compiler_functions.ml"
# 1 "src/migrate_parsetree_compiler_functions.ml"
# 1 "src/compiler-functions/lt_406.ml"
let error_of_exn = Location.error_of_exn

end
module Migrate_parsetree_driver : sig 
#1 "migrate_parsetree_driver.mli"
# 1 "src/migrate_parsetree_driver.mli"
# 1 "src/migrate_parsetree_driver.mli"
# 1 "src/migrate_parsetree_driver.mli"
# 1 "src/migrate_parsetree_driver.mli"
# 1 "src/migrate_parsetree_driver.mli"
# 1 "src/migrate_parsetree_driver.mli"
# 1 "src/migrate_parsetree_driver.mli"
# 1 "src/migrate_parsetree_driver.mli"
# 1 "src/migrate_parsetree_driver.mli"
# 1 "src/migrate_parsetree_driver.mli"
# 1 "src/migrate_parsetree_driver.mli"
# 1 "src/migrate_parsetree_driver.mli"
# 1 "src/migrate_parsetree_driver.mli"
open Migrate_parsetree_versions

(** {1 State a rewriter can access} *)

type extra = ..

type config = {
  tool_name       : string;
  include_dirs    : string list;
  load_path       : string list;
  debug           : bool;
  for_package     : string option;
  (** Additional parameters that can be passed by a caller of
      [rewrite_{signature,structure}] to a specific register rewriter. *)
  extras          : extra list;
}

val make_config
  :  tool_name:string
  -> ?include_dirs:string list
  -> ?load_path:string list
  -> ?debug:bool
  -> ?for_package:string
  -> ?extras:extra list
  -> unit
  -> config

type cookies

val get_cookie
  : cookies
  -> string
  -> 'types ocaml_version -> 'types get_expression option

val set_cookie
  : cookies
  -> string
  -> 'types ocaml_version -> 'types get_expression
  -> unit

(** {1 Registering rewriters} *)

type 'types rewriter = config -> cookies -> 'types get_mapper

val register
  :  name:string
  -> ?reset_args:(unit -> unit) -> ?args:(Arg.key * Arg.spec * Arg.doc) list
  -> 'types ocaml_version -> 'types rewriter
  -> unit

(** {1 Running registered rewriters} *)

val run_as_ast_mapper : string list -> Ast_mapper.mapper

val run_as_ppx_rewriter : unit -> 'a

val run_main : unit -> 'a

(** {1 Manual mapping} *)

type some_signature =
  | Sig : (module Migrate_parsetree_versions.OCaml_version with
            type Ast.Parsetree.signature = 'concrete) * 'concrete -> some_signature

type some_structure =
  | Str : (module Migrate_parsetree_versions.OCaml_version with
            type Ast.Parsetree.structure = 'concrete) * 'concrete -> some_structure

val migrate_some_signature
  :  'version ocaml_version
  -> some_signature
  -> 'version get_signature

val migrate_some_structure
  :  'version ocaml_version
  -> some_structure
  -> 'version get_structure

val rewrite_signature
  :  config
  -> 'version ocaml_version
  -> 'version get_signature
  -> some_signature

val rewrite_structure
  :  config
  -> 'version ocaml_version
  -> 'version get_structure
  -> some_structure

end = struct
#1 "migrate_parsetree_driver.ml"
# 1 "src/migrate_parsetree_driver.ml"
# 1 "src/migrate_parsetree_driver.ml"
# 1 "src/migrate_parsetree_driver.ml"
# 1 "src/migrate_parsetree_driver.ml"
# 1 "src/migrate_parsetree_driver.ml"
# 1 "src/migrate_parsetree_driver.ml"
# 1 "src/migrate_parsetree_driver.ml"
# 1 "src/migrate_parsetree_driver.ml"
# 1 "src/migrate_parsetree_driver.ml"
# 1 "src/migrate_parsetree_driver.ml"
# 1 "src/migrate_parsetree_driver.ml"
# 1 "src/migrate_parsetree_driver.ml"
# 1 "src/migrate_parsetree_driver.ml"
open Migrate_parsetree_versions
module Ast_io = Migrate_parsetree_ast_io

(** {1 State a rewriter can access} *)

type extra = ..

type config = {
  tool_name: string;
  include_dirs : string list;
  load_path : string list;
  debug : bool;
  for_package : string option;
  extras : extra list;
}

let make_config ~tool_name ?(include_dirs=[]) ?(load_path=[]) ?(debug=false)
      ?for_package ?(extras=[]) () =
  { tool_name
  ; include_dirs
  ; load_path
  ; debug
  ; for_package
  ; extras
  }

type cookie = Cookie : 'types ocaml_version * 'types get_expression -> cookie

type cookies = (string, cookie) Hashtbl.t

let create_cookies () = Hashtbl.create 3

let get_cookie table name version =
  match
    match Hashtbl.find table name with
    | result -> Some result
    | exception Not_found ->
        match Ast_mapper.get_cookie name with
        | None -> None
        | Some expr -> Some (Cookie ((module OCaml_current), expr))
  with
  | None -> None
  | Some (Cookie (version', expr)) ->
    Some ((migrate version' version).copy_expression expr)

let set_cookie table name version expr =
  Hashtbl.replace table name (Cookie (version, expr))

let apply_cookies table =
  Hashtbl.iter (fun name (Cookie (version, expr)) ->
      Ast_mapper.set_cookie name
        ((migrate version (module OCaml_current)).copy_expression expr)
    ) table

let initial_state () =
  {
    tool_name = Ast_mapper.tool_name ();
    include_dirs = !Clflags.include_dirs;
    load_path = !Config.load_path;
    debug = !Clflags.debug;
    for_package = !Clflags.for_package;
    extras = [];
  }

(** {1 Registering rewriters} *)

type 'types rewriter = config -> cookies -> 'types get_mapper

type rewriter_group =
    Rewriters : 'types ocaml_version * (string * 'types rewriter) list -> rewriter_group

let uniq_rewriter = Hashtbl.create 7
let registered_rewriters = ref []

let uniq_arg = Hashtbl.create 7
let registered_args_reset = ref []
let registered_args = ref []

let () =
  let set_cookie s =
    match String.index s '=' with
    | exception _ ->
      raise (Arg.Bad "invalid cookie, must be of the form \"<name>=<expr>\"")
    | i ->
      let name = String.sub s 0 i in
      let value = String.sub s (i + 1) (String.length s - i - 1) in
      let input_name = "<command-line>" in
      Location.input_name := input_name;
      let lexbuf = Lexing.from_string value in
      lexbuf.Lexing.lex_curr_p <-
        { Lexing.
          pos_fname = input_name
        ; pos_lnum  = 1
        ; pos_bol   = 0
        ; pos_cnum  = 0
        };
      let expr = Parse.expression lexbuf in
      Ast_mapper.set_cookie name expr
  in
  registered_args :=
    ("--cookie", Arg.String set_cookie,
     "NAME=EXPR Set the cookie NAME to EXPR") :: !registered_args

type ('types, 'version, 'rewriter) is_rewriter =
  | Is_rewriter : ('types, 'types ocaml_version, 'types rewriter) is_rewriter

let add_rewriter
    (type types) (type version) (type rewriter)
    (Is_rewriter : (types, version, rewriter) is_rewriter)
    (version : version) name (rewriter : rewriter) =
  let rec add_rewriter = function
  | [] -> [Rewriters (version, [name, rewriter])]
  | (Rewriters (version', rewriters) as x) :: xs ->
      match compare_ocaml_version version version' with
      | Eq -> Rewriters (version', (name, rewriter) :: rewriters) :: xs
      | Lt -> Rewriters (version, [name, rewriter]) :: x :: xs
      | Gt -> x :: add_rewriter xs
  in
  add_rewriter

let register ~name ?reset_args ?(args=[]) version rewriter =
  (* Validate name *)
  if name = "" then
    invalid_arg "Migrate_parsetree_driver.register: name is empty";
  if Hashtbl.mem uniq_rewriter name then
    invalid_arg ("Migrate_parsetree_driver.register: rewriter " ^ name ^ " has already been registered")
  else Hashtbl.add uniq_rewriter name ();
  (* Validate arguments *)
  List.iter (fun (arg_name, _, _) ->
      match Hashtbl.find uniq_arg arg_name with
      | other_rewriter ->
          invalid_arg (Printf.sprintf
                         "Migrate_parsetree_driver.register: argument %s is used by %s and %s" arg_name name other_rewriter)
      | exception Not_found ->
          Hashtbl.add uniq_arg arg_name name
    ) args;
  (* Register *)
  begin match reset_args with
  | None -> ()
  | Some f -> registered_args_reset := f :: !registered_args_reset
  end;
  registered_args := List.rev_append args !registered_args;
  registered_rewriters :=
    add_rewriter Is_rewriter version name rewriter !registered_rewriters

(** {1 Accessing or running registered rewriters} *)

type ('types, 'version, 'tree) is_signature =
    Signature : ('types, 'types ocaml_version, 'types get_signature) is_signature

type ('types, 'version, 'tree) is_structure =
    Structure : ('types, 'types ocaml_version, 'types get_structure) is_structure

type some_structure =
  | Str : (module Migrate_parsetree_versions.OCaml_version with
            type Ast.Parsetree.structure = 'concrete) * 'concrete -> some_structure

type some_signature =
  | Sig : (module Migrate_parsetree_versions.OCaml_version with
            type Ast.Parsetree.signature = 'concrete) * 'concrete -> some_signature

let migrate_some_structure dst (Str ((module Version), st)) =
  (migrate (module Version) dst).copy_structure st

let migrate_some_signature dst (Sig ((module Version), sg)) =
  (migrate (module Version) dst).copy_signature sg

let rec rewrite_signature
  : type types version tree.
    config -> cookies ->
    (types, version, tree) is_signature -> version -> tree ->
    rewriter_group list -> some_signature
  = fun (type types) (type version) (type tree)
    config cookies
    (Signature : (types, version, tree) is_signature)
    (version : version)
    (tree : tree)
    -> function
      | [] ->
        let (module Version) = version in
        Sig ((module Version), tree)
      | Rewriters (version', rewriters) :: rest ->
          let rewrite (_name, rewriter) tree =
            let (module Version) = version' in
            Version.Ast.map_signature (rewriter config cookies) tree
          in
          let tree = (migrate version version').copy_signature tree in
          let tree = List.fold_right rewrite rewriters tree in
          rewrite_signature config cookies Signature version' tree rest

let rewrite_signature config version sg =
  let cookies = create_cookies () in
  let sg = rewrite_signature config cookies Signature version sg !registered_rewriters in
  apply_cookies cookies;
  sg

let rec rewrite_structure
  : type types version tree.
    config -> cookies ->
    (types, version, tree) is_structure -> version -> tree ->
    rewriter_group list -> some_structure
  = fun (type types) (type version) (type tree)
    config cookies
    (Structure : (types, version, tree) is_structure)
    (version : version)
    (tree : tree)
    -> function
      | [] ->
        let (module Version) = version in
        Str ((module Version), tree)
      | Rewriters (version', rewriters) :: rest ->
          let rewriter (_name, rewriter) tree =
            let (module Version) = version' in
            Version.Ast.map_structure (rewriter config cookies) tree
          in
          let tree = (migrate version version').copy_structure tree in
          let tree = List.fold_right rewriter rewriters tree in
          rewrite_structure config cookies Structure version' tree rest

let rewrite_structure config version st =
  let cookies = create_cookies () in
  let st = rewrite_structure config cookies Structure version st !registered_rewriters in
  apply_cookies cookies;
  st

let run_as_ast_mapper args =
  let spec = List.rev !registered_args in
  let args, usage =
    let me = Filename.basename Sys.executable_name in
    let args = match args with "--as-ppx" :: args -> args | args -> args in
    (Array.of_list (me :: args),
     Printf.sprintf "%s [options] <input ast file> <output ast file>" me)
  in
  List.iter (fun f -> f ()) !registered_args_reset;
  match
    Arg.parse_argv args spec
      (fun arg -> raise (Arg.Bad (Printf.sprintf "invalid argument %S" arg)))
      usage
  with
  | exception (Arg.Help msg) ->
      prerr_endline msg;
      exit 1
  | () ->
      OCaml_current.Ast.make_top_mapper
        ~signature:(fun sg ->
            let config = initial_state () in
            rewrite_signature config (module OCaml_current) sg
            |> migrate_some_signature (module OCaml_current)
          )
        ~structure:(fun str ->
            let config = initial_state () in
            rewrite_structure config (module OCaml_current) str
            |> migrate_some_structure (module OCaml_current)
          )

let protectx x ~finally ~f =
  match f x with
  | y -> finally x; y
  | exception e -> finally x; raise e

let with_file_in fn ~f =
  protectx (open_in_bin fn) ~finally:close_in ~f

let with_file_out fn ~f =
  protectx (open_out_bin fn) ~finally:close_out ~f

type ('a, 'b) intf_or_impl =
  | Intf of 'a
  | Impl of 'b

let guess_file_kind fn =
  if Filename.check_suffix fn ".ml" then
    Impl fn
  else if Filename.check_suffix fn ".mli" then
    Intf fn
  else
    Location.raise_errorf ~loc:(Location.in_file fn)
      "I can't decide whether %s is an implementation or interface file"
      fn

let check_kind fn ~expected ~got =
  let describe = function
    | Intf _ -> "interface"
    | Impl _ -> "implementation"
  in
  match expected, got with
  | Impl _, Impl _
  | Intf _, Intf _ -> ()
  | _ ->
    Location.raise_errorf ~loc:(Location.in_file fn)
      "Expected an %s got an %s instead"
      (describe expected)
      (describe got)

let load_file file =
  let fn =
    match file with
    | Intf fn -> fn
    | Impl fn -> fn
  in
  with_file_in fn ~f:(fun ic ->
    match Ast_io.from_channel ic with
    | Ok (fn, Ast_io.Intf ((module V), sg)) ->
      check_kind fn ~expected:file ~got:(Intf ());
      (* We need to convert to the current version in order to interpret the cookies using
         [Ast_mapper.drop_ppx_context_*] from the compiler *)
      (fn, Intf ((migrate (module V) (module OCaml_current)).copy_signature sg))
    | Ok (fn, Ast_io.Impl ((module V), st)) ->
      check_kind fn ~expected:file ~got:(Impl ());
      (fn, Impl ((migrate (module V) (module OCaml_current)).copy_structure st))
    | Error (Ast_io.Unknown_version _) ->
      Location.raise_errorf ~loc:(Location.in_file fn)
        "File is a binary ast for an unknown version of OCaml"
    | Error (Ast_io.Not_a_binary_ast prefix_read_from_file) ->
      (* To test if a file is a binary AST file, we have to read the first few bytes of
         the file.

         If it is not a binary AST, we have to parse these bytes and the rest of the file
         as source code. To do that, we prefill the lexbuf buffer with what we read from
         the file to do the test. *)
      let lexbuf = Lexing.from_channel ic in
      let len = String.length prefix_read_from_file in
      String.blit prefix_read_from_file 0 lexbuf.Lexing.lex_buffer 0 len;
      lexbuf.Lexing.lex_buffer_len <- len;
      lexbuf.Lexing.lex_curr_p <-
        { Lexing.
          pos_fname = fn
        ; pos_lnum  = 1
        ; pos_bol   = 0
        ; pos_cnum  = 0
        };
      Location.input_name := fn;
      if Filename.check_suffix fn ".ml" then
        (fn, Impl (Parse.implementation lexbuf))
      else if Filename.check_suffix fn ".mli" then
        (fn, Intf (Parse.interface lexbuf))
      else
        (* TODO: add support for -intf and -impl *)
        Location.raise_errorf ~loc:(Location.in_file fn)
          "I can't decide whether %s is an implementation or interface file"
          fn)

let with_output output ~f =
  match output with
  | None -> f stdout
  | Some fn -> with_file_out fn ~f

let process_file ~config ~output ~dump_ast ~embed_errors file =
  let fn, ast = load_file file in
  let ast =
    match ast with
    | Intf sg ->
      let sg = Ast_mapper.drop_ppx_context_sig ~restore:true sg in
      let sg =
        try
          rewrite_signature config (module OCaml_current) sg
          |> migrate_some_signature (module OCaml_current)
        with exn when embed_errors ->
        match Migrate_parsetree_compiler_functions.error_of_exn exn with
        | None -> raise exn
        | Some error ->
          [ Ast_helper.Sig.extension ~loc:Location.none
              (Ast_mapper.extension_of_error error) ]
      in
      Intf (sg, Ast_mapper.add_ppx_context_sig ~tool_name:config.tool_name sg)
    | Impl st ->
      let st = Ast_mapper.drop_ppx_context_str ~restore:true st in
      let st =
        try
          rewrite_structure config (module OCaml_current) st
          |> migrate_some_structure (module OCaml_current)
        with exn when embed_errors ->
        match Migrate_parsetree_compiler_functions.error_of_exn exn with
        | None -> raise exn
        | Some error ->
          [ Ast_helper.Str.extension ~loc:Location.none
              (Ast_mapper.extension_of_error error) ]
      in
      Impl (st, Ast_mapper.add_ppx_context_str ~tool_name:config.tool_name st)
  in
  with_output output ~f:(fun oc ->
    if dump_ast then begin
      let ast =
        match ast with
        | Intf (_, sg) -> Ast_io.Intf ((module OCaml_current), sg)
        | Impl (_, st) -> Ast_io.Impl ((module OCaml_current), st)
      in
      Ast_io.to_channel oc fn ast
    end else begin
      let ppf = Format.formatter_of_out_channel oc in
      (match ast with
       | Intf (sg, _) -> Pprintast.signature ppf sg
       | Impl (st, _) -> Pprintast.structure ppf st);
      Format.pp_print_newline ppf ()
    end)

let run_as_standalone_driver () =
  let output = ref None in
  let dump_ast = ref false in
  let files = ref [] in
  let embed_errors = ref false in
  let spec =
    let as_ppx () =
      raise (Arg.Bad "--as-ppx must be passed as first argument")
    in
    let as_pp () =
      dump_ast := true;
      embed_errors := true
    in
    [ "--as-ppx", Arg.Unit as_ppx,
      " Act as a -ppx rewriter"
    ; "--as-pp", Arg.Unit as_pp,
      " Shorthand for: --dump-ast --embed-errors"
    ; "--dump-ast", Arg.Set dump_ast,
      " Output a binary AST instead of source code"
    ; "-o", Arg.String (fun o -> output := Some o),
      "FILE Output to this file instead of the standard output"
    ; "--intf", Arg.String (fun fn -> files := Intf fn :: !files),
      "FILE Treat FILE as a .mli file"
    ; "--impl", Arg.String (fun fn -> files := Impl fn :: !files),
      "FILE Treat FILE as a .ml file"
    ; "--embed-errors", Arg.Set embed_errors,
      " Embed error reported by rewriters into the AST"
    ]
  in
  let spec = Arg.align (spec @ List.rev !registered_args) in
  let me = Filename.basename Sys.executable_name in
  let usage = Printf.sprintf "%s [options] [<files>]" me in
  try
    List.iter (fun f -> f ()) !registered_args_reset;
    Arg.parse spec (fun anon -> files := guess_file_kind anon :: !files) usage;
    let output = !output in
    let dump_ast = !dump_ast in
    let embed_errors = !embed_errors in
    let config =
      (* TODO: we could add -I, -L and -g options to populate these fields. *)
      { tool_name    = "migrate_driver"
      ; include_dirs = []
      ; load_path    = []
      ; debug        = false
      ; for_package  = None
      ; extras       = []
      }
    in
    List.iter (process_file ~config ~output ~dump_ast ~embed_errors) (List.rev !files)
  with exn ->
    Location.report_exception Format.err_formatter exn;
    exit 1

let run_as_ppx_rewriter () =
  let a = Sys.argv in
  let n = Array.length a in
  if n <= 2 then begin
    let me = Filename.basename Sys.executable_name in
    Arg.usage (List.rev !registered_args)
      (Printf.sprintf "%s [options] <input ast file> <output ast file>" me);
    exit 2
  end;
  match
    Ast_mapper.apply ~source:a.(n - 2) ~target:a.(n - 1)
      (run_as_ast_mapper (Array.to_list (Array.sub a 1 (n - 3))))
  with
  | () -> exit 0
  | exception (Arg.Bad help) ->
      prerr_endline help;
      exit 1
  | exception exn ->
      Location.report_exception Format.err_formatter exn;
      exit 1

let run_main () =
  if Array.length Sys.argv >= 2 && Sys.argv.(1) = "--as-ppx" then
    run_as_ppx_rewriter ()
  else
    run_as_standalone_driver ();
  exit 0

end
module Migrate_parsetree
= struct
#1 "migrate_parsetree.ml"
# 1 "src/migrate_parsetree.ml"
# 1 "src/migrate_parsetree.ml"
# 1 "src/migrate_parsetree.ml"
# 1 "src/migrate_parsetree.ml"
# 1 "src/migrate_parsetree.ml"
# 1 "src/migrate_parsetree.ml"
# 1 "src/migrate_parsetree.ml"
# 1 "src/migrate_parsetree.ml"
# 1 "src/migrate_parsetree.ml"
# 1 "src/migrate_parsetree.ml"
# 1 "src/migrate_parsetree.ml"
# 1 "src/migrate_parsetree.ml"
# 1 "src/migrate_parsetree.ml"
(**************************************************************************)
(*                                                                        *)
(*                         OCaml Migrate Parsetree                        *)
(*                                                                        *)
(*                             Frédéric Bour                              *)
(*                   Jérémie Dimino, Jane Street Europe                   *)
(*                                                                        *)
(*   Copyright 2017 Institut National de Recherche en Informatique et     *)
(*     en Automatique (INRIA).                                            *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(* Shared definitions.
   Mostly errors about features missing in older versions. *)
module Def = Migrate_parsetree_def

(* Copy of OCaml parsetrees *)
module Ast_402 = Ast_402
module Ast_403 = Ast_403
module Ast_404 = Ast_404
module Ast_405 = Ast_405

(* A module for marshalling/unmarshalling arbitrary versions of Asts *)
module Ast_io = Migrate_parsetree_ast_io

(* Manual migration between versions *)
module Migrate_402_403 = Migrate_parsetree_402_403
module Migrate_403_402 = Migrate_parsetree_403_402
module Migrate_403_404 = Migrate_parsetree_403_404
module Migrate_404_403 = Migrate_parsetree_404_403
module Migrate_404_405 = Migrate_parsetree_404_405
module Migrate_405_404 = Migrate_parsetree_405_404

(* An abstraction of OCaml compiler versions *)
module Versions = Migrate_parsetree_versions

(* All versions are compatible with this signature *)
module type OCaml_version = Versions.OCaml_version

module OCaml_402 = Versions.OCaml_402
module OCaml_403 = Versions.OCaml_403
module OCaml_404 = Versions.OCaml_404
module OCaml_405 = Versions.OCaml_405
module OCaml_current = Versions.OCaml_current

(* A Functor taking two OCaml versions and producing a module of functions
   migrating from one to the other. *)
module Convert = Versions.Convert

(* Entrypoints for registering rewriters and making a ppx binary *)
module Driver = Migrate_parsetree_driver

(* Aliases for compiler-libs modules that might be shadowed *)
module Compiler_libs = struct
  module Location = Location
  module Longident = Longident

  module type Asttypes = module type of struct include Asttypes end
  module rec Asttypes : Asttypes = Asttypes

  module type Parsetree = module type of struct include Parsetree end
  module rec Parsetree : Parsetree = Parsetree

  module Docstrings = Docstrings
  module Ast_helper = Ast_helper
  module Ast_mapper = Ast_mapper
end

end
module Re_fmt
= struct
#1 "re_fmt.ml"
(** Very small tooling for format printers. *)

include Format

type 'a t = Format.formatter -> 'a -> unit

(* Only in the stdlib since 4.02, so we copy. *)
let rec list ?(pp_sep = pp_print_cut) pp ppf = function
  | [] -> ()
  | [v] -> pp ppf v
  | v :: vs ->
    pp ppf v;
    pp_sep ppf ();
    list ~pp_sep pp ppf vs

(* want this name to make sure we don't use pp_print_list from stdlib
   accidentally *)
let pp_print_list = list

let str = pp_print_string
let sexp fmt s pp x = fprintf fmt "@[<3>(%s@ %a)@]" s pp x
let pair pp1 pp2 fmt (v1,v2) =
  pp1 fmt v1; pp_print_space fmt () ; pp2 fmt v2
let triple pp1 pp2 pp3 fmt (v1, v2, v3) =
  pp1 fmt v1; pp_print_space fmt () ;
  pp2 fmt v2; pp_print_space fmt () ;
  pp3 fmt v3
let int = pp_print_int
let optint fmt = function
  | None -> ()
  | Some i -> fprintf fmt "@ %d" i

let quote fmt s = Format.fprintf fmt "\"%s\"" s

let pp_olist pp_elem fmt =
  Format.fprintf fmt "@[<3>[@ %a@ ]@]"
    (pp_print_list
       ~pp_sep:(fun fmt () -> fprintf fmt ";@ ")
       pp_elem)

let pp_str_list = pp_olist quote

let to_to_string pp x =
  let b = Buffer.create 16 in
  let fmt = Format.formatter_of_buffer b in
  pp fmt x;
  Buffer.contents b

end
module Re_cset : sig 
#1 "re_cset.mli"
(*
   RE - A regular expression library

   Copyright (C) 2001 Jerome Vouillon
   email: Jerome.Vouillon@pps.jussieu.fr

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation, with
   linking exception; either version 2.1 of the License, or (at
   your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
*)

(* Character sets, represented as sorted list of intervals *)

type c = int
type t

val iter : t -> f:(c -> c -> unit) -> unit

val union : t -> t -> t
val inter : t -> t -> t
val diff : t -> t -> t
val offset : int -> t -> t

val empty : t
val single : c -> t
val seq : c -> c -> t
val add : c -> t -> t

val mem : c -> t -> bool

type hash
val hash : t -> hash

val pp : Format.formatter -> t -> unit

val one_char : t -> c option

val fold_right : t -> init:'acc -> f:(c * c -> 'acc ->  'acc) -> 'acc

val hash_rec : t -> int

module CSetMap : Map.S with type key = int * t

val cany : t

val csingle : char -> t

val is_empty : t -> bool

val prepend : t -> 'a list -> (t * 'a list) list -> (t * 'a list) list

val pick : t -> c

end = struct
#1 "re_cset.ml"
(*
   RE - A regular expression library

   Copyright (C) 2001 Jerome Vouillon
   email: Jerome.Vouillon@pps.jussieu.fr

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation, with
   linking exception; either version 2.1 of the License, or (at
   your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
*)

type c = int
type t = (c * c) list

let rec union l l' =
  match l, l' with
    _, [] -> l
  | [], _ -> l'
  | (c1, c2)::r, (c1', c2')::r' ->
    if c2 + 1 < c1' then
      (c1, c2)::union r l'
    else if c2' + 1 < c1 then
      (c1', c2')::union l r'
    else if c2 < c2' then
      union r ((min c1 c1', c2')::r')
    else
      union ((min c1 c1', c2)::r) r'

let rec inter l l' =
  match l, l' with
    _, [] -> []
  | [], _ -> []
  | (c1, c2)::r, (c1', c2')::r' ->
    if c2 < c1' then
      inter r l'
    else if c2' < c1 then
      inter l r'
    else if c2 < c2' then
      (max c1 c1', c2)::inter r l'
    else
      (max c1 c1', c2')::inter l r'

let rec diff l l' =
  match l, l' with
    _, [] -> l
  | [], _ -> []
  | (c1, c2)::r, (c1', c2')::r' ->
    if c2 < c1' then
      (c1, c2)::diff r l'
    else if c2' < c1 then
      diff l r'
    else
      let r'' = if c2' < c2 then (c2' + 1, c2) :: r else r in
      if c1 < c1' then
        (c1, c1' - 1)::diff r'' r'
      else
        diff r'' r'

let single c = [c, c]

let add c l = union (single c) l

let seq c c' = if c <= c' then [c, c'] else [c', c]

let rec offset o l =
  match l with
    []            -> []
  | (c1, c2) :: r -> (c1 + o, c2 + o) :: offset o r

let empty = []

let rec mem (c : int) s =
  match s with
    []              -> false
  | (c1, c2) :: rem -> if c <= c2 then c >= c1 else mem c rem

(****)

type hash = int

let rec hash_rec = function
  | []        -> 0
  | (i, j)::r -> i + 13 * j + 257 * hash_rec r
let hash l = (hash_rec l) land 0x3FFFFFFF

(****)

let print_one ch (c1, c2) =
  if c1 = c2 then
    Format.fprintf ch "%d" c1
  else
    Format.fprintf ch "%d-%d" c1 c2

let pp = Re_fmt.list print_one

let rec iter t ~f =
  match t with
  | [] -> ()
  | (x, y)::xs ->
    f x y;
    iter xs  ~f

let one_char = function
  | [i, j] when i = j -> Some i
  | _ -> None


module CSetMap = Map.Make (struct
    type t = int * (int * int) list
    let compare (i, u) (j, v) =
      let c = compare i j in
      if c <> 0
      then c
      else compare u v
  end)

let fold_right t ~init ~f = List.fold_right f t init

let csingle c = single (Char.code c)

let cany = [0, 255]

let is_empty = function
  | [] -> true
  | _ -> false

let rec prepend s x l =
  match s, l with
  | [], _ -> l
  | _r, [] -> []
  | (_c, c') :: r, ([d, _d'], _x') :: _r' when c' < d -> prepend r x l
  | (c, c') :: r, ([d, d'], x') :: r' ->
    if c <= d then begin
      if c' < d'
      then ([d, c'], x @ x') :: prepend r x (([c' + 1, d'], x') :: r')
      else ([d, d'], x @ x') :: prepend s x r'
    end else begin
      if c > d'
      then ([d, d'], x') :: prepend s x r'
      else ([d, c - 1], x') :: prepend s x (([c, d'], x') :: r')
    end
  | _ -> assert false

let pick = function
  | [] -> invalid_arg "Re_cset.pick"
  | (x, _)::_ -> x

end
module Re_automata : sig 
#1 "re_automata.mli"
(*
   RE - A regular expression library

   Copyright (C) 2001 Jerome Vouillon
   email: Jerome.Vouillon@pps.jussieu.fr

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation, with
   linking exception; either version 2.1 of the License, or (at
   your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
*)

(* Regular expressions *)

(** Categories represent the various kinds of characters that can be tested
    by look-ahead and look-behind operations.

    This is more restricted than Cset, but faster.
*)
module Category : sig
  type t
  val (++) : t -> t -> t
  val from_char : char -> t

  val inexistant : t
  val letter : t
  val not_letter : t
  val newline : t
  val lastnewline : t
  val search_boundary : t
end

type mark = int

type sem = [ `Longest | `Shortest | `First ]
type rep_kind = [ `Greedy | `Non_greedy ]

val pp_sem : Format.formatter -> sem -> unit
val pp_rep_kind : Format.formatter -> rep_kind -> unit

module Pmark : sig
  type t = private int
  val equal : t -> t -> bool
  val compare : t -> t -> int
  val gen : unit -> t
  val pp : Format.formatter -> t -> unit
end

type expr
val is_eps : expr -> bool
val pp : Format.formatter -> expr -> unit

type ids
val create_ids : unit -> ids

val cst : ids -> Re_cset.t -> expr
val empty : ids -> expr
val alt : ids -> expr list -> expr
val seq : ids -> sem -> expr -> expr -> expr
val eps : ids -> expr
val rep : ids -> rep_kind -> sem -> expr -> expr
val mark : ids -> mark -> expr
val pmark : ids -> Pmark.t -> expr
val erase : ids -> mark -> mark -> expr
val before : ids -> Category.t -> expr
val after : ids -> Category.t -> expr

val rename : ids -> expr -> expr

(****)

module PmarkSet : Set.S with type elt = Pmark.t

(* States of the automata *)

type idx = int
module Marks : sig
  type t =
    { marks: (mark * idx) list
    ; pmarks: PmarkSet.t }
end

module E : sig
  type t
  val pp : Format.formatter -> t -> unit
end

type hash
type mark_infos = int array
type status = Failed | Match of mark_infos * PmarkSet.t | Running

module State : sig
  type t =
    { idx: idx
    ; category: Category.t
    ; desc: E.t list
    ; mutable status: status option
    ; hash: hash }
  val dummy : t
  val create : Category.t -> expr -> t
  module Table : Hashtbl.S with type key = t
end

(****)

(* Computation of the states following a given state *)

type working_area
val create_working_area : unit -> working_area
val index_count : working_area -> int

val delta : working_area -> Category.t -> Re_cset.c -> State.t -> State.t
val deriv :
  working_area -> Re_cset.t -> (Category.t * Re_cset.t) list -> State.t ->
  (Re_cset.t * State.t) list

(****)

val status : State.t -> status

end = struct
#1 "re_automata.ml"
(*
   RE - A regular expression library

   Copyright (C) 2001 Jerome Vouillon
   email: Jerome.Vouillon@pps.jussieu.fr

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation, with
   linking exception; either version 2.1 of the License, or (at
   your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
*)

module Cset = Re_cset

type sem = [ `Longest | `Shortest | `First ]

type rep_kind = [ `Greedy | `Non_greedy ]


module Category : sig
  type t
  val equal : t -> t -> bool
  val compare : t -> t -> int
  val pp : Format.formatter -> t -> unit
  val to_int : t -> int

  val intersect : t -> t -> bool
  val (++) : t -> t -> t
  val from_char : char -> t

  val dummy : t
  val inexistant : t
  val letter : t
  val not_letter : t
  val newline : t
  val lastnewline : t
  val search_boundary : t
end = struct
  type t = int
  let equal (x : int) (y : int) = x = y
  let compare (x : int) (y : int) = compare x y
  let to_int x = x
  let pp = Format.pp_print_int

  let intersect x y = x land y <> 0
  let (++) x y = x lor y

  let dummy = -1
  let inexistant = 1
  let letter = 2
  let not_letter = 4
  let newline = 8
  let lastnewline = 16
  let search_boundary = 32

  let from_char = function
    (* Should match [cword] definition *)
    | 'a'..'z' | 'A'..'Z' | '0'..'9' | '_' | '\170' | '\181' | '\186'
    | '\192'..'\214' | '\216'..'\246' | '\248'..'\255' ->
      letter
    | '\n' ->
      not_letter ++ newline
    | _ ->
      not_letter
end

type mark = int
type idx = int

module Pmark : sig
  type t = private int
  val equal : t -> t -> bool
  val compare : t -> t -> int
  val gen : unit -> t
  val pp : Format.formatter -> t -> unit
end
= struct
  type t = int
  let equal (x : int) (y : int) = x = y
  let compare (x : int) (y : int) = compare x y
  let r = ref 0
  let gen () = incr r ; !r

  let pp = Format.pp_print_int
end

type expr = { id : int; def : def }

and def =
    Cst of Cset.t
  | Alt of expr list
  | Seq of sem * expr * expr
  | Eps
  | Rep of rep_kind * sem * expr
  | Mark of int
  | Erase of int * int
  | Before of Category.t
  | After of Category.t
  | Pmark of Pmark.t

module PmarkSet = Set.Make(Pmark)

let hash_combine h accu = accu * 65599 + h

module Marks = struct
  type t =
    { marks : (int * int) list
    ; pmarks : PmarkSet.t }

  let empty = { marks = [] ; pmarks = PmarkSet.empty }

  let rec merge_marks_offset old = function
    | [] ->
      old
    | (i, v) :: rem ->
      let nw' = merge_marks_offset (List.remove_assq i old) rem in
      if v = -2 then
        nw'
      else
        (i, v) :: nw'

  let merge old nw =
    { marks = merge_marks_offset old.marks nw.marks
    ; pmarks = PmarkSet.union old.pmarks nw.pmarks }

  let rec hash_marks_offset l accu =
    match l with
      []          -> accu
    | (a, i) :: r -> hash_marks_offset r (hash_combine a (hash_combine i accu))

  let hash m accu =
    hash_marks_offset m.marks (hash_combine (Hashtbl.hash m.pmarks) accu)

  let rec marks_set_idx idx = function
    | (a, -1) :: rem ->
      (a, idx) :: marks_set_idx idx rem
    | marks ->
      marks

  let marks_set_idx marks idx =
    { marks with marks = marks_set_idx idx marks.marks }

  let pp_marks ch t =
    match t.marks with
    | [] ->
      ()
    | (a, i) :: r ->
      Format.fprintf ch "%d-%d" a i;
      List.iter (fun (a, i) -> Format.fprintf ch " %d-%d" a i) r
end

(****)

let pp_sem ch k =
  Format.pp_print_string ch
    (match k with
       `Shortest -> "short"
     | `Longest  -> "long"
     | `First    -> "first")


let pp_rep_kind fmt = function
  | `Greedy -> Format.pp_print_string fmt "Greedy"
  | `Non_greedy -> Format.pp_print_string fmt "Non_greedy"

let rec pp ch e =
  let open Re_fmt in
  match e.def with
    Cst l ->
    sexp ch "cst" Cset.pp l;
  | Alt l ->
    sexp ch "alt" (list pp) l
  | Seq (k, e, e') ->
    sexp ch "seq" (triple pp_sem pp pp) (k, e, e')
  | Eps ->
    str ch "eps"
  | Rep (_rk, k, e) ->
    sexp ch "rep" (pair pp_sem pp) (k, e)
  | Mark i ->
    sexp ch "mark" int i
  | Pmark i ->
    sexp ch "pmark" int (i :> int)
  | Erase (b, e) ->
    sexp ch "erase" (pair int int) (b, e)
  | Before c ->
    sexp ch "before" Category.pp c
  | After c ->
    sexp ch "after" Category.pp c


(****)

let rec first f = function
  | [] ->
    None
  | x :: r ->
    match f x with
      None          -> first f r
    | Some _ as res -> res

(****)

type ids = int ref
let create_ids () = ref 0

let eps_expr = { id = 0; def = Eps }

let mk_expr ids def =
  incr ids;
  { id = !ids; def = def }

let empty ids = mk_expr ids (Alt [])

let cst ids s =
  if Re_cset.is_empty s
  then empty ids
  else mk_expr ids (Cst s)

let alt ids = function
  | []  -> empty ids
  | [c] -> c
  | l   -> mk_expr ids (Alt l)

let seq ids kind x y =
  match x.def, y.def with
    Alt [], _                 -> x
  | _, Alt []                 -> y
  | Eps, _                    -> y
  | _, Eps when kind = `First -> x
  | _                         -> mk_expr ids (Seq (kind, x, y))

let is_eps expr =
  match expr.def with
  | Eps -> true
  | _ -> false

let eps ids = mk_expr ids Eps

let rep ids kind sem x = mk_expr ids (Rep (kind, sem, x))

let mark ids m = mk_expr ids (Mark m)

let pmark ids i = mk_expr ids (Pmark i)

let erase ids m m' = mk_expr ids (Erase (m, m'))

let before ids c = mk_expr ids (Before c)

let after ids c = mk_expr ids (After c)

(****)

let rec rename ids x =
  match x.def with
    Cst _ | Eps | Mark _ | Pmark _ | Erase _ | Before _ | After _ ->
    mk_expr ids x.def
  | Alt l ->
    mk_expr ids (Alt (List.map (rename ids) l))
  | Seq (k, y, z) ->
    mk_expr ids (Seq (k, rename ids y, rename ids z))
  | Rep (g, k, y) ->
    mk_expr ids (Rep (g, k, rename ids y))

(****)

type hash = int
type mark_infos = int array
type status = Failed | Match of mark_infos * PmarkSet.t | Running

module E = struct
  type t =
    | TSeq of t list * expr * sem
    | TExp of Marks.t * expr
    | TMatch of Marks.t

  let rec equal l1 l2 =
    match l1, l2 with
    | [], [] ->
      true
    | TSeq (l1', e1, _) :: r1, TSeq (l2', e2, _) :: r2 ->
      e1.id = e2.id && equal l1' l2' && equal r1 r2
    | TExp (marks1, e1) :: r1, TExp (marks2, e2) :: r2 ->
      e1.id = e2.id && marks1 = marks2 && equal r1 r2
    | TMatch marks1 :: r1, TMatch marks2 :: r2 ->
      marks1 = marks2 && equal r1 r2
    | _ ->
      false

  let rec hash l accu =
    match l with
    | [] ->
      accu
    | TSeq (l', e, _) :: r ->
      hash r (hash_combine 0x172a1bce (hash_combine e.id (hash l' accu)))
    | TExp (marks, e) :: r ->
      hash r
        (hash_combine 0x2b4c0d77 (hash_combine e.id (Marks.hash marks accu)))
    | TMatch marks :: r ->
      hash r (hash_combine 0x1c205ad5 (Marks.hash marks accu))

  let texp marks x = TExp (marks, x)

  let tseq kind x y rem =
    match x with
      []                              -> rem
    | [TExp (marks, {def = Eps ; _})] -> TExp (marks, y) :: rem
    | _                               -> TSeq (x, y, kind) :: rem

  let rec print_state_rec ch e y =
    match e with
    | TMatch marks ->
      Format.fprintf ch "@[<2>(Match@ %a)@]" Marks.pp_marks marks
    | TSeq (l', x, _kind) ->
      Format.fprintf ch "@[<2>(Seq@ ";
      print_state_lst ch l' x;
      Format.fprintf ch " %a)@]" pp x
    | TExp (marks, {def = Eps; _}) ->
      Format.fprintf ch "(Exp %d (%a) (eps))" y.id Marks.pp_marks marks
    | TExp (marks, x) ->
      Format.fprintf ch "(Exp %d (%a) %a)" x.id Marks.pp_marks marks pp x

  and print_state_lst ch l y =
    match l with
      [] ->
      Format.fprintf ch "()"
    | e :: rem ->
      print_state_rec ch e y;
      List.iter
        (fun e ->
           Format.fprintf ch " | ";
           print_state_rec ch e y)
        rem

  let pp ch t = print_state_lst ch [t] { id = 0; def = Eps }
end

module State = struct
  type t =
    { idx: idx
    ; category: Category.t
    ; desc: E.t list
    ; mutable status: status option
    ; hash: hash }

  let dummy =
    { idx = -1
    ; category = Category.dummy
    ; desc = []
    ; status = None
    ; hash = -1 }

  let hash idx cat desc =
    E.hash desc (hash_combine idx (hash_combine (Category.to_int cat) 0)) land 0x3FFFFFFF

  let mk idx cat desc =
    { idx
    ; category = cat
    ; desc
    ; status = None
    ; hash = hash idx cat desc}

  let create cat e = mk 0 cat [E.TExp (Marks.empty, e)]

  let equal x y =
    (x.hash : int) = y.hash && (x.idx : int) = y.idx &&
    Category.equal x.category y.category && E.equal x.desc y.desc

  let compare x y =
    let c = compare (x.hash : int) y.hash in
    if c <> 0 then c else
      let c = Category.compare x.category y.category in
      if c <> 0 then c else
        compare x.desc y.desc

  type t' = t
  module Table = Hashtbl.Make(
    struct
      type t = t'
      let equal = equal
      let hash t = t.hash
    end)
end

(**** Find a free index ****)

type working_area = bool array ref

let create_working_area () = ref [| false |]

let index_count w = Array.length !w

let reset_table a = Array.fill a 0 (Array.length a) false

let rec mark_used_indices tbl =
  List.iter (function
      | E.TSeq (l, _, _) -> mark_used_indices tbl l
      | E.TExp (marks, _)
      | E.TMatch marks ->
        List.iter (fun (_, i) -> if i >= 0 then tbl.(i) <- true)
          marks.Marks.marks)

let rec find_free tbl idx len =
  if idx = len || not tbl.(idx) then idx else find_free tbl (idx + 1) len

let free_index tbl_ref l =
  let tbl = !tbl_ref in
  reset_table tbl;
  mark_used_indices tbl l;
  let len = Array.length tbl in
  let idx = find_free tbl 0 len in
  if idx = len then tbl_ref := Array.make (2 * len) false;
  idx

(**** Computation of the next state ****)

let remove_matches = List.filter (function E.TMatch _ -> false | _ -> true)

let rec split_at_match_rec l' = function
  | []            -> assert false
  | E.TMatch _ :: r -> (List.rev l', remove_matches r)
  | x :: r        -> split_at_match_rec (x :: l') r

let split_at_match l = split_at_match_rec [] l

let rec remove_duplicates prev l y =
  match l with
    [] ->
    ([], prev)
  | E.TMatch _ as x :: _ -> (* Truncate after first match *)
    ([x], prev)
  | E.TSeq (l', x, kind) :: r ->
    let (l'', prev') = remove_duplicates prev l' x in
    let (r', prev'') = remove_duplicates prev' r y in
    (E.tseq kind l'' x r', prev'')
  | E.TExp (_marks, {def = Eps; _}) as e :: r ->
    if List.memq y.id prev then
      remove_duplicates prev r y
    else
      let (r', prev') = remove_duplicates (y.id :: prev) r y in
      (e :: r', prev')
  | E.TExp (_marks, x) as e :: r ->
    if List.memq x.id prev then
      remove_duplicates prev r y
    else
      let (r', prev') = remove_duplicates (x.id :: prev) r y in
      (e :: r', prev')

let rec set_idx idx = function
  | [] ->
    []
  | E.TMatch marks :: r ->
    E.TMatch (Marks.marks_set_idx marks idx) :: set_idx idx r
  | E.TSeq (l', x, kind) :: r ->
    E.TSeq (set_idx idx l', x, kind) :: set_idx idx r
  | E.TExp (marks, x) :: r ->
    E.TExp ((Marks.marks_set_idx marks idx), x) :: set_idx idx r

let filter_marks b e marks =
  {marks with Marks.marks = List.filter (fun (i, _) -> i < b || i > e) marks.Marks.marks }

let rec delta_1 marks c ~next_cat ~prev_cat x rem =
  (*Format.eprintf "%d@." x.id;*)
  match x.def with
    Cst s ->
    if Cset.mem c s then E.texp marks eps_expr :: rem else rem
  | Alt l ->
    delta_2 marks c ~next_cat ~prev_cat l rem
  | Seq (kind, y, z) ->
    let y' = delta_1 marks c ~next_cat ~prev_cat y [] in
    delta_seq c ~next_cat ~prev_cat kind y' z rem
  | Rep (rep_kind, kind, y) ->
    let y' = delta_1 marks c ~next_cat ~prev_cat y [] in
    let (y'', marks') =
      match
        first
          (function E.TMatch marks -> Some marks | _ -> None) y'
      with
        None        -> (y', marks)
      | Some marks' -> (remove_matches y', marks')
    in
    begin match rep_kind with
        `Greedy     -> E.tseq kind y'' x (E.TMatch marks' :: rem)
      | `Non_greedy -> E.TMatch marks :: E.tseq kind y'' x rem
    end
  | Eps ->
    E.TMatch marks :: rem
  | Mark i ->
    let marks = { marks with Marks.marks = (i, -1) :: List.remove_assq i marks.Marks.marks } in
    E.TMatch marks :: rem
  | Pmark i ->
    let marks = { marks with Marks.pmarks = PmarkSet.add i marks.Marks.pmarks } in
    E.TMatch marks :: rem
  | Erase (b, e) ->
    E.TMatch (filter_marks b e marks) :: rem
  | Before cat'' ->
    if Category.intersect next_cat cat'' then E.TMatch marks :: rem else rem
  | After cat'' ->
    if Category.intersect prev_cat cat'' then E.TMatch marks :: rem else rem

and delta_2 marks c ~next_cat ~prev_cat l rem =
  match l with
    []     -> rem
  | y :: r ->
    delta_1 marks c ~next_cat ~prev_cat y
      (delta_2 marks c ~next_cat ~prev_cat r rem)

and delta_seq c ~next_cat ~prev_cat kind y z rem =
  match
    first (function E.TMatch marks -> Some marks | _ -> None) y
  with
    None ->
    E.tseq kind y z rem
  | Some marks ->
    match kind with
      `Longest ->
      E.tseq kind (remove_matches y) z
        (delta_1 marks c ~next_cat ~prev_cat z rem)
    | `Shortest ->
      delta_1 marks c ~next_cat ~prev_cat z
        (E.tseq kind (remove_matches y) z rem)
    | `First ->
      let (y', y'') = split_at_match y in
      E.tseq kind y' z
        (delta_1 marks c ~next_cat ~prev_cat z (E.tseq kind y'' z rem))

let rec delta_3 c ~next_cat ~prev_cat x rem =
  match x with
    E.TSeq (y, z, kind) ->
    let y' = delta_4 c ~next_cat ~prev_cat y [] in
    delta_seq c ~next_cat ~prev_cat kind y' z rem
  | E.TExp (marks, e) ->
    delta_1 marks c ~next_cat ~prev_cat e rem
  | E.TMatch _ ->
    x :: rem

and delta_4 c ~next_cat ~prev_cat l rem =
  match l with
    []     -> rem
  | y :: r ->
    delta_3 c ~next_cat ~prev_cat y
      (delta_4 c ~next_cat ~prev_cat r rem)

let delta tbl_ref next_cat char st =
  let prev_cat = st.State.category in
  let (expr', _) =
    remove_duplicates []
      (delta_4 char ~next_cat ~prev_cat st.State.desc [])
      eps_expr in
  let idx = free_index tbl_ref expr' in
  let expr'' = set_idx idx expr' in
  State.mk idx next_cat expr''

(****)

let rec red_tr = function
  | [] | [_] as l ->
    l
  | ((s1, st1) as tr1) :: ((s2, st2) as tr2) :: rem ->
    if State.equal st1 st2 then
      red_tr ((Cset.union s1 s2, st1) :: rem)
    else
      tr1 :: red_tr (tr2 :: rem)

let simpl_tr l =
  List.sort
    (fun (s1, _) (s2, _) -> compare s1 s2)
    (red_tr (List.sort (fun (_, st1) (_, st2) -> State.compare st1 st2) l))

(****)

let prepend_deriv = List.fold_right (fun (s, x) l -> Cset.prepend s x l)

let rec restrict s = function
  | [] -> []
  | (s', x') :: rem ->
    let s'' = Cset.inter s s' in
    if Cset.is_empty s''
    then restrict s rem
    else (s'', x') :: restrict s rem

let rec remove_marks b e rem =
  if b > e then rem else remove_marks b (e - 1) ((e, -2) :: rem)

let rec prepend_marks_expr m = function
  | E.TSeq (l, e', s) -> E.TSeq (prepend_marks_expr_lst m l, e', s)
  | E.TExp (m', e')   -> E.TExp (Marks.merge m m', e')
  | E.TMatch m'       -> E.TMatch (Marks.merge m m')

and prepend_marks_expr_lst m l =
  List.map (prepend_marks_expr m) l

let prepend_marks m =
  List.map (fun (s, x) -> (s, prepend_marks_expr_lst m x))

let rec deriv_1 all_chars categories marks cat x rem =
  match x.def with
  | Cst s ->
    Cset.prepend s [E.texp marks eps_expr] rem
  | Alt l ->
    deriv_2 all_chars categories marks cat l rem
  | Seq (kind, y, z) ->
    let y' = deriv_1 all_chars categories marks cat y [(all_chars, [])] in
    deriv_seq all_chars categories cat kind y' z rem
  | Rep (rep_kind, kind, y) ->
    let y' = deriv_1 all_chars categories marks cat y [(all_chars, [])] in
    List.fold_right
      (fun (s, z) rem ->
         let (z', marks') =
           match
             first
               (function E.TMatch marks -> Some marks | _ -> None)
               z
           with
             None        -> (z, marks)
           | Some marks' -> (remove_matches z, marks')
         in
         Cset.prepend s
           (match rep_kind with
              `Greedy     -> E.tseq kind z' x [E.TMatch marks']
            | `Non_greedy -> E.TMatch marks :: E.tseq kind z' x [])
           rem)
      y' rem
  | Eps ->
    Cset.prepend all_chars [E.TMatch marks] rem
  | Mark i ->
    Cset.prepend all_chars [E.TMatch {marks with Marks.marks = ((i, -1) :: List.remove_assq i marks.Marks.marks)}] rem
  | Pmark _ ->
    Cset.prepend all_chars [E.TMatch marks] rem
  | Erase (b, e) ->
    Cset.prepend all_chars
      [E.TMatch {marks with Marks.marks = (remove_marks b e (filter_marks b e marks).Marks.marks)}] rem
  | Before cat' ->
    Cset.prepend (List.assq cat' categories) [E.TMatch marks] rem
  | After cat' ->
    if Category.intersect cat cat' then Cset.prepend all_chars [E.TMatch marks] rem else rem

and deriv_2 all_chars categories marks cat l rem =
  match l with
    []     -> rem
  | y :: r -> deriv_1 all_chars categories marks cat y
                (deriv_2 all_chars categories marks cat r rem)

and deriv_seq all_chars categories cat kind y z rem =
  if
    List.exists
      (fun (_s, xl) ->
         List.exists (function E.TMatch _ -> true | _ -> false) xl)
      y
  then
    let z' = deriv_1 all_chars categories Marks.empty cat z [(all_chars, [])] in
    List.fold_right
      (fun (s, y) rem ->
         match
           first (function E.TMatch marks -> Some marks | _ -> None)
             y
         with
           None ->
           Cset.prepend s (E.tseq kind y z []) rem
         | Some marks ->
           let z'' = prepend_marks marks z' in
           match kind with
             `Longest ->
             Cset.prepend s (E.tseq kind (remove_matches y) z []) (
               prepend_deriv (restrict s z'') rem)
           | `Shortest ->
             prepend_deriv (restrict s z'') (
               Cset.prepend s (E.tseq kind (remove_matches y) z []) rem)
           | `First ->
             let (y', y'') = split_at_match y in
             Cset.prepend s (E.tseq kind y' z []) (
               prepend_deriv (restrict s z'') (
                 Cset.prepend s (E.tseq kind y'' z []) rem)))
      y rem
  else
    List.fold_right
      (fun (s, xl) rem -> Cset.prepend s (E.tseq kind xl z []) rem) y rem

let rec deriv_3 all_chars categories cat x rem =
  match x with
    E.TSeq (y, z, kind) ->
    let y' = deriv_4 all_chars categories cat y [(all_chars, [])] in
    deriv_seq all_chars categories cat kind y' z rem
  | E.TExp (marks, e) ->
    deriv_1 all_chars categories marks cat e rem
  | E.TMatch _ ->
    Cset.prepend all_chars [x] rem

and deriv_4 all_chars categories cat l rem =
  match l with
    []     -> rem
  | y :: r -> deriv_3 all_chars categories cat y
                (deriv_4 all_chars categories cat r rem)

let deriv tbl_ref all_chars categories st =
  let der = deriv_4 all_chars categories st.State.category st.State.desc
      [(all_chars, [])] in
  simpl_tr (
    List.fold_right (fun (s, expr) rem ->
        let (expr', _) = remove_duplicates [] expr eps_expr in
(*
Format.eprintf "@[<3>@[%a@]: %a / %a@]@." Cset.print s print_state expr print_state expr';
*)
        let idx = free_index tbl_ref expr' in
        let expr'' = set_idx idx expr' in
        List.fold_right (fun (cat', s') rem ->
            let s'' = Cset.inter s s' in
            if Cset.is_empty s''
            then rem
            else (s'', State.mk idx cat' expr'') :: rem)
          categories rem) der [])

(****)

let flatten_match m =
  let ma = List.fold_left (fun ma (i, _) -> max ma i) (-1) m in
  let res = Array.make (ma + 1) (-1) in
  List.iter (fun (i, v) -> res.(i) <- v) m;
  res

let status s =
  match s.State.status with
    Some st ->
    st
  | None ->
    let st =
      match s.State.desc with
        []              -> Failed
      | E.TMatch m :: _ -> Match (flatten_match m.Marks.marks, m.Marks.pmarks)
      | _               -> Running
    in
    s.State.status <- Some st;
    st

end
module Re : sig 
#1 "re.mli"
(*
   RE - A regular expression library

   Copyright (C) 2001 Jerome Vouillon
   email: Jerome.Vouillon@pps.jussieu.fr

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation, with
   linking exception; either version 2.1 of the License, or (at
   your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
*)

(** Module [Re]: regular expressions commons *)

type t
(** Regular expression *)

type re
(** Compiled regular expression *)

type groups
(** Information about groups in a match. *)

(** {2 Compilation and execution of a regular expression} *)

val compile : t -> re
(** Compile a regular expression into an executable version that can be
    used to match strings, e.g. with {!exec}. *)

val exec :
  ?pos:int ->    (* Default: 0 *)
  ?len:int ->    (* Default: -1 (until end of string) *)
  re -> string -> groups
(** [exec re str] matches [str] against the compiled expression [re],
    and returns the matched groups if any.
    @param pos optional beginning of the string (default 0)
    @param len length of the substring of [str] that can be matched (default [-1],
      meaning to the end of the string
    @raise Not_found if the regular expression can't be found in [str]
*)

val exec_opt :
  ?pos:int ->    (* Default: 0 *)
  ?len:int ->    (* Default: -1 (until end of string) *)
  re -> string -> groups option
(** Similar to {!exec}, but returns an option instead of using an exception. *)

val execp :
  ?pos:int ->    (* Default: 0 *)
  ?len:int ->    (* Default: -1 (until end of string) *)
  re -> string -> bool
(** Similar to {!exec}, but returns [true] if the expression matches,
    and [false] if it doesn't *)

val exec_partial :
  ?pos:int ->    (* Default: 0 *)
  ?len:int ->    (* Default: -1 (until end of string) *)
  re -> string -> [ `Full | `Partial | `Mismatch ]
(** More detailed version of {!exec_p} *)

(** Manipulate matching groups. *)
module Group : sig

  type t = groups
  (** Information about groups in a match. *)

  val get : t -> int -> string
  (** Raise [Not_found] if the group did not match *)

  val offset : t -> int -> int * int
  (** Raise [Not_found] if the group did not match *)

  val start : t -> int -> int
  (** Return the start of the match. Raise [Not_found] if the group did not match. *)

  val stop : t -> int -> int
  (** Return the end of the match. Raise [Not_found] if the group did not match. *)

  val all : t -> string array
  (** Return the empty string for each group which did not match *)

  val all_offset : t -> (int * int) array
  (** Return [(-1,-1)] for each group which did not match *)

  val test : t -> int -> bool
  (** Test whether a group matched *)

  val nb_groups : t -> int
  (** Returns the total number of groups defined - matched or not.
      This function is experimental. *)

  val pp : Format.formatter -> t -> unit

end

(** Marks *)
module Mark : sig

  type t
  (** Mark id *)

  val test : Group.t -> t -> bool
  (** Tell if a mark was matched. *)

  module Set : Set.S with type elt = t

  val all : Group.t -> Set.t
  (** Return all the mark matched. *)

  val equal : t -> t -> bool
  val compare : t -> t -> int

end

(** {2 High Level Operations} *)

type 'a gen = unit -> 'a option

val all :
  ?pos:int ->    (** Default: 0 *)
  ?len:int ->
  re -> string -> Group.t list
(** Repeatedly calls {!exec} on the given string, starting at given
    position and length.*)

val all_gen :
  ?pos:int ->    (** Default: 0 *)
  ?len:int ->
  re -> string -> Group.t gen
(** Same as {!all} but returns a generator *)

val matches :
  ?pos:int ->    (** Default: 0 *)
  ?len:int ->
  re -> string -> string list
(** Same as {!all}, but extracts the matched substring rather than
    returning the whole group. This basically iterates over matched
    strings *)

val matches_gen :
  ?pos:int ->    (** Default: 0 *)
  ?len:int ->
  re -> string -> string gen
(** Same as {!matches}, but returns a generator. *)

val split :
  ?pos:int ->    (** Default: 0 *)
  ?len:int ->
  re -> string -> string list
(** [split re s] splits [s] into chunks separated by [re]. It yields
    the chunks themselves, not the separator. For instance
    this can be used with a whitespace-matching re such as ["[\t ]+"]. *)

val split_gen :
  ?pos:int ->    (** Default: 0 *)
  ?len:int ->
  re -> string -> string gen

type split_token =
  [ `Text of string  (** Text between delimiters *)
  | `Delim of Group.t (** Delimiter *)
  ]

val split_full :
  ?pos:int ->    (** Default: 0 *)
  ?len:int ->
  re -> string -> split_token list

val split_full_gen :
  ?pos:int ->    (** Default: 0 *)
  ?len:int ->
  re -> string -> split_token gen

val replace :
  ?pos:int ->    (** Default: 0 *)
  ?len:int ->
  ?all:bool ->   (** Default: true. Otherwise only replace first occurrence *)
  re ->          (** matched groups *)
  f:(Group.t -> string) ->  (* how to replace *)
  string ->     (** string to replace in *)
  string
(** [replace ~all re ~f s] iterates on [s], and replaces every occurrence
    of [re] with [f substring] where [substring] is the current match.
    If [all = false], then only the first occurrence of [re] is replaced. *)

val replace_string :
  ?pos:int ->    (** Default: 0 *)
  ?len:int ->
  ?all:bool ->   (** Default: true. Otherwise only replace first occurrence *)
  re ->          (** matched groups *)
  by:string ->   (** replacement string *)
  string ->      (** string to replace in *)
  string
(** [replace_string ~all re ~by s] iterates on [s], and replaces every
    occurrence of [re] with [by]. If [all = false], then only the first
    occurrence of [re] is replaced. *)

(** {2 String expressions (literal match)} *)

val str : string -> t
val char : char -> t

(** {2 Basic operations on regular expressions} *)

val alt : t list -> t
(** Alternative *)

val seq : t list -> t
(** Sequence *)

val empty : t
(** Match nothing *)

val epsilon : t
(** Empty word *)

val rep : t -> t
(** 0 or more matches *)

val rep1 : t -> t
(** 1 or more matches *)

val repn : t -> int -> int option -> t
(** [repn re i j] matches [re] at least [i] times
    and at most [j] times, bounds included.
    [j = None] means no upper bound.
*)

val opt : t -> t
(** 0 or 1 matches *)

(** {2 String, line, word} *)

val bol : t
(** Beginning of line *)

val eol : t
(** End of line *)

val bow : t
(** Beginning of word *)

val eow : t
(** End of word *)

val bos : t
(** Beginning of string *)

val eos : t
(** End of string *)

val leol : t
(** Last end of line or end of string *)

val start : t
(** Initial position *)

val stop : t
(** Final position *)

val word : t -> t
(** Word *)

val not_boundary : t
(** Not at a word boundary *)

val whole_string : t -> t
(** Only matches the whole string *)

(** {2 Match semantics} *)

val longest : t -> t
(** Longest match *)

val shortest : t -> t
(** Shortest match *)

val first : t -> t
(** First match *)

(** {2 Repeated match modifiers} *)

val greedy : t -> t
(** Greedy *)

val non_greedy : t -> t
(** Non-greedy *)

(** {2 Groups (or submatches)} *)

val group : t -> t
(** Delimit a group *)

val no_group : t -> t
(** Remove all groups *)

val nest : t -> t
(** when matching against [nest e], only the group matching in the
       last match of e will be considered as matching *)



val mark : t -> Mark.t * t
(** Mark a regexp. the markid can then be used to know if this regexp was used. *)

(** {2 Character sets} *)

val set : string -> t
(** Any character of the string *)

val rg : char -> char -> t
(** Character ranges *)

val inter : t list -> t
(** Intersection of character sets *)

val diff : t -> t -> t
(** Difference of character sets *)

val compl : t list -> t
(** Complement of union *)

(** {2 Predefined character sets} *)

val any : t
(** Any character *)

val notnl : t
(** Any character but a newline *)

val alnum : t
val wordc : t
val alpha : t
val ascii : t
val blank : t
val cntrl : t
val digit : t
val graph : t
val lower : t
val print : t
val punct : t
val space : t
val upper : t
val xdigit : t

(** {2 Case modifiers} *)

val case : t -> t
(** Case sensitive matching *)

val no_case : t -> t
(** Case insensitive matching *)

(****)

(** {2 Internal debugging}  *)

val pp : Format.formatter -> t -> unit

val pp_re : Format.formatter -> re -> unit

(** Alias for {!pp_re}. Deprecated *)
val print_re : Format.formatter -> re -> unit

(** {2 Experimental functions}. *)

val witness : t -> string
(** [witness r] generates a string [s] such that [execp (compile r) s] is
    true *)

(** {2 Deprecated functions} *)

type substrings = Group.t
(** Alias for {!Group.t}. Deprecated *)

val get : Group.t -> int -> string
(** Same as {!Group.get}. Deprecated *)

val get_ofs : Group.t -> int -> int * int
(** Same as {!Group.offset}. Deprecated *)

val get_all : Group.t -> string array
(** Same as {!Group.all}. Deprecated *)

val get_all_ofs : Group.t -> (int * int) array
(** Same as {!Group.all_offset}. Deprecated *)

val test : Group.t -> int -> bool
(** Same as {!Group.test}. Deprecated *)

type markid = Mark.t
(** Alias for {!Mark.t}. Deprecated *)

val marked : Group.t -> Mark.t -> bool
(** Same as {!Mark.test}. Deprecated *)

val mark_set : Group.t -> Mark.Set.t
(** Same as {!Mark.all}. Deprecated *)

end = struct
#1 "re.ml"
(*
   RE - A regular expression library

   Copyright (C) 2001 Jerome Vouillon
   email: Jerome.Vouillon@pps.jussieu.fr

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation, with
   linking exception; either version 2.1 of the License, or (at
   your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
*)

module Cset = Re_cset
module Automata = Re_automata
module MarkSet = Automata.PmarkSet
module Category = Automata.Category

let rec iter n f v = if n = 0 then v else iter (n - 1) f (f v)

(****)

let unknown = -2
let break = -3

(* Result of a successful match. *)
type groups =
  { s : string
  (* Input string. Matched strings are substrings of s *)

  ; marks : Automata.mark_infos
  (* Mapping from group indices to positions in gpos. group i has positions 2*i
     - 1, 2*i + 1 in gpos. If the group wasn't matched, then its corresponding
     values in marks will be -1,-1 *)

  ; pmarks : MarkSet.t
  (* Marks positions. i.e. those marks created with Re.marks *)

  ; gpos : int array
  (* Group positions. Adjacent elements are (start, stop) of group match.
     indexed by the values in marks. So group i in an re would be the substring:

     start = t.gpos.(marks.(2*i)) - 1
     stop = t.gpos.(marks.(2*i + 1)) - 1 *)

  ; gcount : int
  (* Number of groups the regular expression contains. Matched or not *) }

type match_info =
  | Match of groups
  | Failed
  | Running

type state =
  { idx : int;
    (* Index of the current position in the position table.
       Not yet computed transitions point to a dummy state where
       [idx] is set to [unknown];
       If [idx] is set to [break] for states that either always
       succeed or always fail. *)
    real_idx : int;
    (* The real index, in case [idx] is set to [break] *)
    next : state array;
    (* Transition table, indexed by color *)
    mutable final :
      (Category.t *
       (Automata.idx * Automata.status)) list;
    (* Mapping from the category of the next character to
       - the index where the next position should be saved
       - possibly, the list of marks (and the corresponding indices)
         corresponding to the best match *)
    desc : Automata.State.t
    (* Description of this state of the automata *) }

(* Automata (compiled regular expression) *)
type re =
  { initial : Automata.expr;
    (* The whole regular expression *)
    mutable initial_states : (Category.t * state) list;
    (* Initial states, indexed by initial category *)
    cols : Bytes.t;
    (* Color table *)
    col_repr : Bytes.t;
    (* Table from colors to one character of this color *)
    ncol : int;
    (* Number of colors. *)
    lnl : int;
    (* Color of the last newline *)
    tbl : Automata.working_area;
    (* Temporary table used to compute the first available index
       when computing a new state *)
    states : state Automata.State.Table.t;
    (* States of the deterministic automata *)
    group_count : int
    (* Number of groups in the regular expression *) }

let pp_re ch re = Automata.pp ch re.initial

let print_re = pp_re

(* Information used during matching *)
type info =
  { re : re;
    (* The automata *)
    i_cols : Bytes.t;
    (* Color table ([x.i_cols = x.re.cols])
       Shortcut used for performance reasons *)
    mutable positions : int array;
    (* Array of mark positions
       The mark are off by one for performance reasons *)
    pos : int;
    (* Position where the match is started *)
    last : int
    (* Position where the match should stop *) }


(****)

let category re c =
  if c = -1 then
    Category.inexistant
    (* Special category for the last newline *)
  else if c = re.lnl then
    Category.(lastnewline ++ newline ++ not_letter)
  else
    Category.from_char (Bytes.get re.col_repr c)

(****)

let dummy_next = [||]

let unknown_state =
  { idx = unknown; real_idx = 0;
    next = dummy_next; final = [];
    desc = Automata.State.dummy }

let mk_state ncol desc =
  let break_state =
    match Automata.status desc with
    | Automata.Running -> false
    | Automata.Failed
    | Automata.Match _ -> true
  in
  { idx = if break_state then break else desc.Automata.State.idx;
    real_idx = desc.Automata.State.idx;
    next = if break_state then dummy_next else Array.make ncol unknown_state;
    final = [];
    desc = desc }

let find_state re desc =
  try
    Automata.State.Table.find re.states desc
  with Not_found ->
    let st = mk_state re.ncol desc in
    Automata.State.Table.add re.states desc st;
    st

(**** Match with marks ****)

let delta info cat c st =
  let desc = Automata.delta info.re.tbl cat c st.desc in
  let len = Array.length info.positions in
  if desc.Automata.State.idx = len && len > 0 then begin
    let pos = info.positions in
    info.positions <- Array.make (2 * len) 0;
    Array.blit pos 0 info.positions 0 len
  end;
  desc

let validate info (s:string) pos st =
  let c = Char.code (Bytes.get info.i_cols (Char.code s.[pos])) in
  let cat = category info.re c in
  let desc' = delta info cat c st in
  let st' = find_state info.re desc' in
  st.next.(c) <- st'

(*
let rec loop info s pos st =
  if pos < info.last then
    let st' = st.next.(Char.code info.i_cols.[Char.code s.[pos]]) in
    let idx = st'.idx in
    if idx >= 0 then begin
      info.positions.(idx) <- pos;
      loop info s (pos + 1) st'
    end else if idx = break then begin
      info.positions.(st'.real_idx) <- pos;
      st'
    end else begin (* Unknown *)
      validate info s pos st;
      loop info s pos st
    end
  else
    st
*)

let rec loop info (s:string) pos st =
  if pos < info.last then
    let st' = st.next.(Char.code (Bytes.get info.i_cols (Char.code s.[pos]))) in
    loop2 info s pos st st'
  else
    st

and loop2 info s pos st st' =
  if st'.idx >= 0 then begin
    let pos = pos + 1 in
    if pos < info.last then begin
      (* It is important to place these reads before the write *)
      (* But then, we don't have enough registers left to store the
         right position.  So, we store the position plus one. *)
      let st'' = st'.next.(Char.code (Bytes.get info.i_cols (Char.code s.[pos]))) in
      info.positions.(st'.idx) <- pos;
      loop2 info s pos st' st''
    end else begin
      info.positions.(st'.idx) <- pos;
      st'
    end
  end else if st'.idx = break then begin
    info.positions.(st'.real_idx) <- pos + 1;
    st'
  end else begin (* Unknown *)
    validate info s pos st;
    loop info s pos st
  end

let rec loop_no_mark info s pos last st =
  if pos < last then
    let st' = st.next.(Char.code (Bytes.get info.i_cols (Char.code s.[pos]))) in
    if st'.idx >= 0 then
      loop_no_mark info s (pos + 1) last st'
    else if st'.idx = break then
      st'
    else begin (* Unknown *)
      validate info s pos st;
      loop_no_mark info s pos last st
    end
  else
    st

let final info st cat =
  try
    List.assq cat st.final
  with Not_found ->
    let st' = delta info cat (-1) st in
    let res = (st'.Automata.State.idx, Automata.status st') in
    st.final <- (cat, res) :: st.final;
    res

let find_initial_state re cat =
  try
    List.assq cat re.initial_states
  with Not_found ->
    let st = find_state re (Automata.State.create cat re.initial) in
    re.initial_states <- (cat, st) :: re.initial_states;
    st

let get_color re (s:string) pos =
  if pos < 0 then
    -1
  else
    let slen = String.length s in
    if pos >= slen then
      -1
    else if pos = slen - 1 && re.lnl <> -1 && s.[pos] = '\n' then
      (* Special case for the last newline *)
      re.lnl
    else
      Char.code (Bytes.get re.cols (Char.code s.[pos]))

let rec handle_last_newline info pos st groups =
  let st' = st.next.(info.re.lnl) in
  if st'.idx >= 0 then begin
    if groups then info.positions.(st'.idx) <- pos + 1;
    st'
  end else if st'.idx = break then begin
    if groups then info.positions.(st'.real_idx) <- pos + 1;
    st'
  end else begin (* Unknown *)
    let c = info.re.lnl in
    let real_c = Char.code (Bytes.get info.i_cols (Char.code '\n')) in
    let cat = category info.re c in
    let desc' = delta info cat real_c st in
    let st' = find_state info.re desc' in
    st.next.(c) <- st';
    handle_last_newline info pos st groups
  end

let rec scan_str info (s:string) initial_state groups =
  let pos = info.pos in
  let last = info.last in
  if (last = String.length s
      && info.re.lnl <> -1
      && last > pos
      && String.get s (last - 1) = '\n')
  then begin
    let info = { info with last = last - 1 } in
    let st = scan_str info s initial_state groups in
    if st.idx = break then
      st
    else
      handle_last_newline info (last - 1) st groups
  end else if groups then
    loop info s pos initial_state
  else
    loop_no_mark info s pos last initial_state

let match_str ~groups ~partial re s ~pos ~len =
  let slen = String.length s in
  let last = if len = -1 then slen else pos + len in
  let info =
    { re = re; i_cols = re.cols; pos = pos; last = last;
      positions =
        if groups then begin
          let n = Automata.index_count re.tbl + 1 in
          if n <= 10 then
            [|0;0;0;0;0;0;0;0;0;0|]
          else
            Array.make n 0
        end else
          [||] }
  in
  let initial_cat =
    if pos = 0 then
      Category.(search_boundary ++ inexistant)
    else
      Category.(search_boundary ++ category re (get_color re s (pos - 1))) in
  let initial_state = find_initial_state re initial_cat in
  let st = scan_str info s initial_state groups in
  let res =
    if st.idx = break || partial then
      Automata.status st.desc
    else
      let final_cat =
        if last = slen then
          Category.(search_boundary ++ inexistant)
        else
          Category.(search_boundary ++ category re (get_color re s last)) in
      let (idx, res) = final info st final_cat in
      if groups then info.positions.(idx) <- last + 1;
      res
  in
  match res with
    Automata.Match (marks, pmarks) ->
    Match { s ; marks; pmarks ; gpos = info.positions; gcount = re.group_count}
  | Automata.Failed -> Failed
  | Automata.Running -> Running

let mk_re init cols col_repr ncol lnl group_count =
  { initial = init;
    initial_states = [];
    cols = cols;
    col_repr = col_repr;
    ncol = ncol;
    lnl = lnl;
    tbl = Automata.create_working_area ();
    states = Automata.State.Table.create 97;
    group_count = group_count }

(**** Character sets ****)

let cseq c c' = Cset.seq (Char.code c) (Char.code c')
let cadd c s = Cset.add (Char.code c) s

let trans_set cache cm s =
  match Cset.one_char s with
  | Some i -> Cset.csingle (Bytes.get cm i)
  | None ->
    let v = (Cset.hash_rec s, s) in
    try
      Cset.CSetMap.find v !cache
    with Not_found ->
      let l =
        Cset.fold_right
          s
          ~f:(fun (i, j) l -> Cset.union (cseq (Bytes.get cm i)
                                            (Bytes.get cm j)) l)
          ~init:Cset.empty
      in
      cache := Cset.CSetMap.add v l !cache;
      l

(****)

type regexp =
    Set of Cset.t
  | Sequence of regexp list
  | Alternative of regexp list
  | Repeat of regexp * int * int option
  | Beg_of_line | End_of_line
  | Beg_of_word | End_of_word | Not_bound
  | Beg_of_str | End_of_str
  | Last_end_of_line | Start | Stop
  | Sem of Automata.sem * regexp
  | Sem_greedy of Automata.rep_kind * regexp
  | Group of regexp | No_group of regexp | Nest of regexp
  | Case of regexp | No_case of regexp
  | Intersection of regexp list
  | Complement of regexp list
  | Difference of regexp * regexp
  | Pmark of Automata.Pmark.t * regexp

let rec pp fmt t =
  let open Re_fmt in
  let var s re = sexp fmt s pp re in
  let seq s rel = sexp fmt s (list pp) rel in
  match t with
  | Set s ->  sexp fmt "Set" Cset.pp s
  | Sequence sq -> seq "Sequence" sq
  | Alternative alt -> seq "Alternative" alt
  | Repeat (re, start, stop) ->
    let pp' fmt () = fprintf fmt "%a@ %d%a" pp re   start   optint stop in
    sexp fmt "Repeat" pp' ()
  | Beg_of_line      -> str fmt "Beg_of_line"
  | End_of_line      -> str fmt "End_of_line"
  | Beg_of_word      -> str fmt "Beg_of_word"
  | End_of_word      -> str fmt "End_of_word"
  | Not_bound        -> str fmt "Not_bound"
  | Beg_of_str       -> str fmt "Beg_of_str"
  | End_of_str       -> str fmt "End_of_str"
  | Last_end_of_line -> str fmt "Last_end_of_line"
  | Start            -> str fmt "Start"
  | Stop             -> str fmt "Stop"
  | Sem (sem, re)    ->
    sexp fmt "Sem" (pair Automata.pp_sem pp) (sem, re)
  | Sem_greedy (k, re) ->
    sexp fmt "Sem_greedy" (pair Automata.pp_rep_kind pp) (k, re)
  | Group c        -> var "Group" c
  | No_group c     -> var "No_group" c
  | Nest c         -> var "Nest" c
  | Case c         -> var "Case" c
  | No_case c      -> var "No_case" c
  | Intersection c -> seq "Intersection" c
  | Complement c   -> seq "Complement" c
  | Difference (a, b) -> sexp fmt "Difference" (pair pp pp) (a, b)
  | Pmark (m, r)      -> sexp fmt "Pmark" (pair Automata.Pmark.pp pp) (m, r)

let rec is_charset = function
  | Set _ ->
    true
  | Alternative l | Intersection l | Complement l ->
    List.for_all is_charset l
  | Difference (r, r') ->
    is_charset r && is_charset r'
  | Sem (_, r) | Sem_greedy (_, r)
  | No_group r | Case r | No_case r ->
    is_charset r
  | Sequence _ | Repeat _ | Beg_of_line | End_of_line
  | Beg_of_word | End_of_word | Beg_of_str | End_of_str
  | Not_bound | Last_end_of_line | Start | Stop
  | Group _ | Nest _ | Pmark (_,_)->
    false

(**** Colormap ****)

(*XXX Use a better algorithm allowing non-contiguous regions? *)
let split s cm =
  Re_cset.iter s ~f:(fun i j ->
      Bytes.set cm i '\001';
      Bytes.set cm (j + 1) '\001';
    )

let cupper =
  Cset.union (cseq 'A' 'Z')
    (Cset.union (cseq '\192' '\214') (cseq '\216' '\222'))
let clower = Cset.offset 32 cupper
let calpha =
  List.fold_right cadd ['\170'; '\181'; '\186'; '\223'; '\255']
    (Cset.union clower cupper)
let cdigit = cseq '0' '9'
let calnum = Cset.union calpha cdigit
let cword = cadd '_' calnum

let colorize c regexp =
  let lnl = ref false in
  let rec colorize regexp =
    match regexp with
      Set s                     -> split s c
    | Sequence l                -> List.iter colorize l
    | Alternative l             -> List.iter colorize l
    | Repeat (r, _, _)          -> colorize r
    | Beg_of_line | End_of_line -> split (Cset.csingle '\n') c
    | Beg_of_word | End_of_word
    | Not_bound                 -> split cword c
    | Beg_of_str | End_of_str
    | Start | Stop              -> ()
    | Last_end_of_line          -> lnl := true
    | Sem (_, r)
    | Sem_greedy (_, r)
    | Group r | No_group r
    | Nest r | Pmark (_,r)     -> colorize r
    | Case _ | No_case _
    | Intersection _
    | Complement _
    | Difference _              -> assert false
  in
  colorize regexp;
  !lnl

let make_cmap () = Bytes.make 257 '\000'

let flatten_cmap cm =
  let c = Bytes.create 256 in
  let col_repr = Bytes.create 256 in
  let v = ref 0 in
  Bytes.set c 0 '\000';
  Bytes.set col_repr 0 '\000';
  for i = 1 to 255 do
    if Bytes.get cm i <> '\000' then incr v;
    Bytes.set c i (Char.chr !v);
    Bytes.set col_repr !v (Char.chr i)
  done;
  (c, Bytes.sub col_repr 0 (!v + 1), !v + 1)

(**** Compilation ****)

let rec equal x1 x2 =
  match x1, x2 with
    Set s1, Set s2 ->
    s1 = s2
  | Sequence l1, Sequence l2 ->
    eq_list l1 l2
  | Alternative l1, Alternative l2 ->
    eq_list l1 l2
  | Repeat (x1', i1, j1), Repeat (x2', i2, j2) ->
    i1 = i2 && j1 = j2 && equal x1' x2'
  | Beg_of_line, Beg_of_line
  | End_of_line, End_of_line
  | Beg_of_word, Beg_of_word
  | End_of_word, End_of_word
  | Not_bound, Not_bound
  | Beg_of_str, Beg_of_str
  | End_of_str, End_of_str
  | Last_end_of_line, Last_end_of_line
  | Start, Start
  | Stop, Stop ->
    true
  | Sem (sem1, x1'), Sem (sem2, x2') ->
    sem1 = sem2 && equal x1' x2'
  | Sem_greedy (k1, x1'), Sem_greedy (k2, x2') ->
    k1 = k2 && equal x1' x2'
  | Group _, Group _ -> (* Do not merge groups! *)
    false
  | No_group x1', No_group x2' ->
    equal x1' x2'
  | Nest x1', Nest x2' ->
    equal x1' x2'
  | Case x1', Case x2' ->
    equal x1' x2'
  | No_case x1', No_case x2' ->
    equal x1' x2'
  | Intersection l1, Intersection l2 ->
    eq_list l1 l2
  | Complement l1, Complement l2 ->
    eq_list l1 l2
  | Difference (x1', x1''), Difference (x2', x2'') ->
    equal x1' x2' && equal x1'' x2''
  | Pmark (m1, r1), Pmark (m2, r2) ->
    Automata.Pmark.equal m1 m2 && equal r1 r2
  | _ ->
    false

and eq_list l1 l2 =
  match l1, l2 with
    [], [] ->
    true
  | x1 :: r1, x2 :: r2 ->
    equal x1 x2 && eq_list r1 r2
  | _ ->
    false

let sequence = function
  | [x] -> x
  | l   -> Sequence l

let rec merge_sequences = function
  | [] ->
    []
  | Alternative l' :: r ->
    merge_sequences (l' @ r)
  | Sequence (x :: y) :: r ->
    begin match merge_sequences r with
        Sequence (x' :: y') :: r' when equal x x' ->
        Sequence [x; Alternative [sequence y; sequence y']] :: r'
      | r' ->
        Sequence (x :: y) :: r'
    end
  | x :: r ->
    x :: merge_sequences r

module A = Automata

let enforce_kind ids kind kind' cr =
  match kind, kind' with
    `First, `First -> cr
  | `First, k       -> A.seq ids k cr (A.eps ids)
  |  _               -> cr

(* XXX should probably compute a category mask *)
let rec translate ids kind ign_group ign_case greedy pos cache c = function
  | Set s ->
    (A.cst ids (trans_set cache c s), kind)
  | Sequence l ->
    (trans_seq ids kind ign_group ign_case greedy pos cache c l, kind)
  | Alternative l ->
    begin match merge_sequences l with
        [r'] ->
        let (cr, kind') =
          translate ids kind ign_group ign_case greedy pos cache c r' in
        (enforce_kind ids kind kind' cr, kind)
      | merged_sequences ->
        (A.alt ids
           (List.map
              (fun r' ->
                 let (cr, kind') =
                   translate ids kind ign_group ign_case greedy
                     pos cache c r' in
                 enforce_kind ids kind kind' cr)
              merged_sequences),
         kind)
    end
  | Repeat (r', i, j) ->
    let (cr, kind') =
      translate ids kind ign_group ign_case greedy pos cache c r' in
    let rem =
      match j with
        None ->
        A.rep ids greedy kind' cr
      | Some j ->
        let f =
          match greedy with
            `Greedy ->
            fun rem ->
              A.alt ids
                [A.seq ids kind' (A.rename ids cr) rem; A.eps ids]
          | `Non_greedy ->
            fun rem ->
              A.alt ids
                [A.eps ids; A.seq ids kind' (A.rename ids cr) rem]
        in
        iter (j - i) f (A.eps ids)
    in
    (iter i (fun rem -> A.seq ids kind' (A.rename ids cr) rem) rem, kind)
  | Beg_of_line ->
    (A.after ids Category.(inexistant ++ newline), kind)
  | End_of_line ->
    (A.before ids Category.(inexistant ++ newline), kind)
  | Beg_of_word ->
    (A.seq ids `First
       (A.after ids Category.(inexistant ++ not_letter))
       (A.before ids Category.(inexistant ++ letter)),
     kind)
  | End_of_word ->
    (A.seq ids `First
       (A.after ids Category.(inexistant ++ letter))
       (A.before ids Category.(inexistant ++ not_letter)),
     kind)
  | Not_bound ->
    (A.alt ids [A.seq ids `First
                  (A.after ids Category.letter)
                  (A.before ids Category.letter);
                A.seq ids `First
                  (A.after ids Category.letter)
                  (A.before ids Category.letter)],
     kind)
  | Beg_of_str ->
    (A.after ids Category.inexistant, kind)
  | End_of_str ->
    (A.before ids Category.inexistant, kind)
  | Last_end_of_line ->
    (A.before ids Category.(inexistant ++ lastnewline), kind)
  | Start ->
    (A.after ids Category.search_boundary, kind)
  | Stop ->
    (A.before ids Category.search_boundary, kind)
  | Sem (kind', r') ->
    let (cr, kind'') =
      translate ids kind' ign_group ign_case greedy pos cache c r' in
    (enforce_kind ids kind' kind'' cr,
     kind')
  | Sem_greedy (greedy', r') ->
    translate ids kind ign_group ign_case greedy' pos cache c r'
  | Group r' ->
    if ign_group then
      translate ids kind ign_group ign_case greedy pos cache c r'
    else
      let p = !pos in
      pos := !pos + 2;
      let (cr, kind') =
        translate ids kind ign_group ign_case greedy pos cache c r' in
      (A.seq ids `First (A.mark ids p) (
          A.seq ids `First cr (A.mark ids (p + 1))),
       kind')
  | No_group r' ->
    translate ids kind true ign_case greedy pos cache c r'
  | Nest r' ->
    let b = !pos in
    let (cr, kind') =
      translate ids kind ign_group ign_case greedy pos cache c r'
    in
    let e = !pos - 1 in
    if e < b then
      (cr, kind')
    else
      (A.seq ids `First (A.erase ids b e) cr, kind')
  | Difference _ | Complement _ | Intersection _ | No_case _ | Case _ ->
    assert false
  | Pmark (i, r') ->
    let (cr, kind') =
      translate ids kind ign_group ign_case greedy pos cache c r' in
    (A.seq ids `First (A.pmark ids i) cr, kind')

and trans_seq ids kind ign_group ign_case greedy pos cache c = function
  | [] ->
    A.eps ids
  | [r] ->
    let (cr', kind') =
      translate ids kind ign_group ign_case greedy pos cache c r in
    enforce_kind ids kind kind' cr'
  | r :: rem ->
    let (cr', kind') =
      translate ids kind ign_group ign_case greedy pos cache c r in
    let cr'' =
      trans_seq ids kind ign_group ign_case greedy pos cache c rem in
    if A.is_eps cr'' then
      cr'
    else if A.is_eps cr' then
      cr''
    else
      A.seq ids kind' cr' cr''

(**** Case ****)

let case_insens s =
  Cset.union s (Cset.union (Cset.offset 32 (Cset.inter s cupper))
                  (Cset.offset (-32) (Cset.inter s clower)))

let as_set = function
  | Set s -> s
  | _     -> assert false

(* XXX Should split alternatives into (1) charsets and (2) more
   complex regular expressions; alternative should therefore probably
   be flatten here *)
let rec handle_case ign_case = function
  | Set s ->
    Set (if ign_case then case_insens s else s)
  | Sequence l ->
    Sequence (List.map (handle_case ign_case) l)
  | Alternative l ->
    let l' = List.map (handle_case ign_case) l in
    if is_charset (Alternative l') then
      Set (List.fold_left (fun s r -> Cset.union s (as_set r)) Cset.empty l')
    else
      Alternative l'
  | Repeat (r, i, j) ->
    Repeat (handle_case ign_case r, i, j)
  | Beg_of_line | End_of_line | Beg_of_word | End_of_word | Not_bound
  | Beg_of_str | End_of_str | Last_end_of_line | Start | Stop as r ->
    r
  | Sem (k, r) ->
    let r' = handle_case ign_case r in
    if is_charset r' then r' else Sem (k, r')
  | Sem_greedy (k, r) ->
    let r' = handle_case ign_case r in
    if is_charset r' then r' else Sem_greedy (k, r')
  | Group r ->
    Group (handle_case ign_case r)
  | No_group r ->
    let r' = handle_case ign_case r in
    if is_charset r' then r' else No_group r'
  | Nest r ->
    let r' = handle_case ign_case r in
    if is_charset r' then r' else Nest r'
  | Case r ->
    handle_case false r
  | No_case r ->
    handle_case true r
  | Intersection l ->
    let l' = List.map (fun r -> handle_case ign_case r) l in
    Set (List.fold_left (fun s r -> Cset.inter s (as_set r)) Cset.cany l')
  | Complement l ->
    let l' = List.map (fun r -> handle_case ign_case r) l in
    Set (Cset.diff Cset.cany
           (List.fold_left (fun s r -> Cset.union s (as_set r))
              Cset.empty l'))
  | Difference (r, r') ->
    Set (Cset.inter (as_set (handle_case ign_case r))
           (Cset.diff Cset.cany (as_set (handle_case ign_case r'))))
  | Pmark (i,r) -> Pmark (i,handle_case ign_case r)

(****)

let compile_1 regexp =
  let regexp = handle_case false regexp in
  let c = make_cmap () in
  let need_lnl = colorize c regexp in
  let (col, col_repr, ncol) = flatten_cmap c in
  let lnl = if need_lnl then ncol else -1 in
  let ncol = if need_lnl then ncol + 1 else ncol in
  let ids = A.create_ids () in
  let pos = ref 0 in
  let (r, kind) =
    translate ids
      `First false false `Greedy pos (ref Cset.CSetMap.empty) col regexp in
  let r = enforce_kind ids `First kind r in
  (*Format.eprintf "<%d %d>@." !ids ncol;*)
  mk_re r col col_repr ncol lnl (!pos / 2)

(****)

let rec anchored = function
  | Sequence l ->
    List.exists anchored l
  | Alternative l ->
    List.for_all anchored l
  | Repeat (r, i, _) ->
    i > 0 && anchored r
  | Set _ | Beg_of_line | End_of_line | Beg_of_word | End_of_word
  | Not_bound | End_of_str | Last_end_of_line | Stop
  | Intersection _ | Complement _ | Difference _ ->
    false
  | Beg_of_str | Start ->
    true
  | Sem (_, r) | Sem_greedy (_, r) | Group r | No_group r | Nest r
  | Case r | No_case r | Pmark (_, r) ->
    anchored r

(****)

type t = regexp

let str s =
  let l = ref [] in
  for i = String.length s - 1 downto 0 do
    l := Set (Cset.csingle s.[i]) :: !l
  done;
  Sequence !l
let char c = Set (Cset.csingle c)

let alt = function
  | [r] -> r
  | l   -> Alternative l
let seq = function
  | [r] -> r
  | l   -> Sequence l

let empty = alt []
let epsilon = seq []
let repn r i j =
  if i < 0 then invalid_arg "Re.repn";
  begin match j with
    | Some j when j < i -> invalid_arg "Re.repn"
    | _ -> ()
  end;
  Repeat (r, i, j)
let rep r = repn r 0 None
let rep1 r = repn r 1 None
let opt r = repn r 0 (Some 1)
let bol = Beg_of_line
let eol = End_of_line
let bow = Beg_of_word
let eow = End_of_word
let word r = seq [bow; r; eow]
let not_boundary = Not_bound
let bos = Beg_of_str
let eos = End_of_str
let whole_string r = seq [bos; r; eos]
let leol = Last_end_of_line
let start = Start
let stop = Stop
let longest r = Sem (`Longest, r)
let shortest r = Sem (`Shortest, r)
let first r = Sem (`First, r)
let greedy r = Sem_greedy (`Greedy, r)
let non_greedy r = Sem_greedy (`Non_greedy, r)
let group r = Group r
let no_group r = No_group r
let nest r = Nest r
let mark r = let i = Automata.Pmark.gen () in (i,Pmark (i,r))

let set str =
  let s = ref Cset.empty in
  for i = 0 to String.length str - 1 do
    s := Cset.union (Cset.csingle str.[i]) !s
  done;
  Set !s

let rg c c' = Set (cseq c c')

let inter l =
  let r = Intersection l in
  if is_charset r then
    r
  else
    invalid_arg "Re.inter"

let compl l =
  let r = Complement l in
  if is_charset r then
    r
  else
    invalid_arg "Re.compl"

let diff r r' =
  let r'' = Difference (r, r') in
  if is_charset r'' then
    r''
  else
    invalid_arg "Re.diff"

let any = Set Cset.cany
let notnl = Set (Cset.diff Cset.cany (Cset.csingle '\n'))

let lower = alt [rg 'a' 'z'; char '\181'; rg '\223' '\246'; rg '\248' '\255']
let upper = alt [rg 'A' 'Z'; rg '\192' '\214'; rg '\216' '\222']
let alpha = alt [lower; upper; char '\170'; char '\186']
let digit = rg '0' '9'
let alnum = alt [alpha; digit]
let wordc = alt [alnum; char '_']
let ascii = rg '\000' '\127'
let blank = set "\t "
let cntrl = alt [rg '\000' '\031'; rg '\127' '\159']
let graph = alt [rg '\033' '\126'; rg '\160' '\255']
let print = alt [rg '\032' '\126'; rg '\160' '\255']
let punct =
  alt [rg '\033' '\047'; rg '\058' '\064'; rg '\091' '\096';
       rg '\123' '\126'; rg '\160' '\169'; rg '\171' '\180';
       rg '\182' '\185'; rg '\187' '\191'; char '\215'; char '\247']
let space = alt [char ' '; rg '\009' '\013']
let xdigit = alt [digit; rg 'a' 'f'; rg 'A' 'F']

let case r = Case r
let no_case r = No_case r

(****)

let compile r =
  compile_1 (
    if anchored r then
      group r
    else
      seq [shortest (rep any); group r]
  )

let exec_internal name ?(pos=0) ?(len = -1) ~groups re s =
  if pos < 0 || len < -1 || pos + len > String.length s then
    invalid_arg name;
  match_str ~groups ~partial:false re s ~pos ~len

let exec ?pos ?len re s =
  match exec_internal "Re.exec" ?pos ?len ~groups:true re s with
    Match substr -> substr
  | _            -> raise Not_found

let exec_opt ?pos ?len re s =
  match exec_internal "Re.exec_opt" ?pos ?len ~groups:true re s with
    Match substr -> Some substr
  | _            -> None

let execp ?pos ?len re s =
  match exec_internal ~groups:false "Re.execp" ?pos ?len re s with
    Match _substr -> true
  | _             -> false

let exec_partial ?pos ?len re s =
  match exec_internal ~groups:false "Re.exec_partial" ?pos ?len re s with
    Match _ -> `Full
  | Running -> `Partial
  | Failed  -> `Mismatch

module Group = struct

  type t = groups

  let offset t i =
    if 2 * i + 1 >= Array.length t.marks then raise Not_found;
    let m1 = t.marks.(2 * i) in
    if m1 = -1 then raise Not_found;
    let p1 = t.gpos.(m1) - 1 in
    let p2 = t.gpos.(t.marks.(2 * i + 1)) - 1 in
    (p1, p2)

  let get t i =
    let (p1, p2) = offset t i in
    String.sub t.s p1 (p2 - p1)

  let start subs i = fst (offset subs i)

  let stop subs i = snd (offset subs i)

  let test t i =
    if 2 * i >= Array.length t.marks then
      false
    else
      let idx = t.marks.(2 * i) in
      idx <> -1

  let dummy_offset = (-1, -1)

  let all_offset t =
    let res = Array.make t.gcount dummy_offset in
    for i = 0 to Array.length t.marks / 2 - 1 do
      let m1 = t.marks.(2 * i) in
      if m1 <> -1 then begin
        let p1 = t.gpos.(m1) in
        let p2 = t.gpos.(t.marks.(2 * i + 1)) in
        res.(i) <- (p1 - 1, p2 - 1)
      end
    done;
    res

  let dummy_string = ""

  let all t =
    let res = Array.make t.gcount dummy_string in
    for i = 0 to Array.length t.marks / 2 - 1 do
      let m1 = t.marks.(2 * i) in
      if m1 <> -1 then begin
        let p1 = t.gpos.(m1) in
        let p2 = t.gpos.(t.marks.(2 * i + 1)) in
        res.(i) <- String.sub t.s (p1 - 1) (p2 - p1)
      end
    done;
    res

  let pp fmt t =
    let matches =
      let offsets = all_offset t in
      let strs = all t in
      Array.to_list (
        Array.init (Array.length strs) (fun i -> strs.(i), offsets.(i))
      ) in
    let open Re_fmt in
    let pp_match fmt (str, (start, stop)) =
      fprintf fmt "@[(%s (%d %d))@]" str start stop in
    sexp fmt "Group" (list pp_match) matches

  let nb_groups t = t.gcount
end

module Mark = struct

  type t = Automata.Pmark.t

  let test {pmarks ; _} p =
    Automata.PmarkSet.mem p pmarks

  let all s = s.pmarks

  module Set = MarkSet

  let equal = Automata.Pmark.equal

  let compare = Automata.Pmark.compare

end

type 'a gen = unit -> 'a option

let all_gen ?(pos=0) ?len re s =
  if pos < 0 then invalid_arg "Re.all";
  (* index of the first position we do not consider.
     !pos < limit is an invariant *)
  let limit = match len with
    | None -> String.length s
    | Some l ->
      if l<0 || pos+l > String.length s then invalid_arg "Re.all";
      pos+l
  in
  (* iterate on matches. When a match is found, search for the next
     one just after its end *)
  let pos = ref pos in
  fun () ->
    if !pos >= limit
    then None  (* no more matches *)
    else
      match match_str ~groups:true ~partial:false re s
              ~pos:!pos ~len:(limit - !pos) with
      | Match substr ->
        let p1, p2 = Group.offset substr 0 in
        pos := if p1=p2 then p2+1 else p2;
        Some substr
      | Running
      | Failed -> None

let all ?pos ?len re s =
  let l = ref [] in
  let g = all_gen ?pos ?len re s in
  let rec iter () = match g() with
    | None -> List.rev !l
    | Some sub -> l := sub :: !l; iter ()
  in iter ()

let matches_gen ?pos ?len re s =
  let g = all_gen ?pos ?len re s in
  fun () ->
    match g() with
    | None -> None
    | Some sub -> Some (Group.get sub 0)

let matches ?pos ?len re s =
  let l = ref [] in
  let g = all_gen ?pos ?len re s in
  let rec iter () = match g() with
    | None -> List.rev !l
    | Some sub -> l := Group.get sub 0 :: !l; iter ()
  in iter ()

type split_token =
  [ `Text of string
  | `Delim of groups
  ]

let split_full_gen ?(pos=0) ?len re s =
  if pos < 0 then invalid_arg "Re.split";
  let limit = match len with
    | None -> String.length s
    | Some l ->
      if l<0 || pos+l > String.length s then invalid_arg "Re.split";
      pos+l
  in
  (* i: start of delimited string
     pos: first position after last match of [re]
     limit: first index we ignore (!pos < limit is an invariant) *)
  let pos0 = pos in
  let state = ref `Idle in
  let i = ref pos and pos = ref pos in
  let next () = match !state with
    | `Idle when !pos >= limit ->
      if !i < limit then (
        let sub = String.sub s !i (limit - !i) in
        incr i;
        Some (`Text sub)
      ) else None
    | `Idle ->
      begin match match_str ~groups:true ~partial:false re s ~pos:!pos
                    ~len:(limit - !pos) with
      | Match substr ->
        let p1, p2 = Group.offset substr 0 in
        pos := if p1=p2 then p2+1 else p2;
        let old_i = !i in
        i := p2;
        if p1 > pos0 then (
          (* string does not start by a delimiter *)
          let text = String.sub s old_i (p1 - old_i) in
          state := `Yield (`Delim substr);
          Some (`Text text)
        ) else Some (`Delim substr)
      | Running -> None
      | Failed ->
        if !i < limit
        then (
          let text = String.sub s !i (limit - !i) in
          i := limit;
          Some (`Text text)  (* yield last string *)
        ) else
          None
      end
    | `Yield x ->
      state := `Idle;
      Some x
  in next

let split_full ?pos ?len re s =
  let l = ref [] in
  let g = split_full_gen ?pos ?len re s in
  let rec iter () = match g() with
    | None -> List.rev !l
    | Some s -> l := s :: !l; iter ()
  in iter ()

let split_gen ?pos ?len re s =
  let g = split_full_gen ?pos ?len re s in
  let rec next() = match g()  with
    | None -> None
    | Some (`Delim _) -> next()
    | Some (`Text s) -> Some s
  in next

let split ?pos ?len re s =
  let l = ref [] in
  let g = split_full_gen ?pos ?len re s in
  let rec iter () = match g() with
    | None -> List.rev !l
    | Some (`Delim _) -> iter()
    | Some (`Text s) -> l := s :: !l; iter ()
  in iter ()

let replace ?(pos=0) ?len ?(all=true) re ~f s =
  if pos < 0 then invalid_arg "Re.replace";
  let limit = match len with
    | None -> String.length s
    | Some l ->
      if l<0 || pos+l > String.length s then invalid_arg "Re.replace";
      pos+l
  in
  (* buffer into which we write the result *)
  let buf = Buffer.create (String.length s) in
  (* iterate on matched substrings. *)
  let rec iter pos =
    if pos < limit
    then
      match match_str ~groups:true ~partial:false re s ~pos ~len:(limit-pos) with
      | Match substr ->
        let p1, p2 = Group.offset substr 0 in
        (* add string between previous match and current match *)
        Buffer.add_substring buf s pos (p1-pos);
        (* what should we replace the matched group with? *)
        let replacing = f substr in
        Buffer.add_string buf replacing;
        if all then
          (* if we matched a non-char e.g. ^ we must manually advance by 1 *)
          iter (
            if p1=p2 then (
              (* a non char could be past the end of string. e.g. $ *)
              if p2 < limit then Buffer.add_char buf s.[p2];
              p2+1
            ) else
              p2)
        else
          Buffer.add_substring buf s p2 (limit-p2)
      | Running -> ()
      | Failed ->
        Buffer.add_substring buf s pos (limit-pos)
  in
  iter pos;
  Buffer.contents buf

let replace_string ?pos ?len ?all re ~by s =
  replace ?pos ?len ?all re s ~f:(fun _ -> by)

let witness t =
  let rec witness = function
    | Set c -> String.make 1 (Char.chr (Cset.pick c))
    | Sequence xs -> String.concat "" (List.map witness xs)
    | Alternative (x :: _) -> witness x
    | Alternative [] -> assert false
    | Repeat (r, from, _to) ->
      let w = witness r in
      let b = Buffer.create (String.length w * from) in
      for _i=1 to from do
        Buffer.add_string b w
      done;
      Buffer.contents b
    | No_case r -> witness r
    | Intersection _
    | Complement _
    | Difference (_, _) -> assert false
    | Group r
    | No_group r
    | Nest r
    | Sem (_, r)
    | Pmark (_, r)
    | Case r
    | Sem_greedy (_, r) -> witness r
    | Beg_of_line
    | End_of_line
    | Beg_of_word
    | End_of_word
    | Not_bound
    | Beg_of_str
    | Last_end_of_line
    | Start
    | Stop
    | End_of_str -> "" in
  witness (handle_case false t)

(** {2 Deprecated functions} *)

type substrings = groups

let get = Group.get
let get_ofs = Group.offset
let get_all = Group.all
let get_all_ofs = Group.all_offset
let test = Group.test

type markid = Mark.t

let marked = Mark.test
let mark_set = Mark.all

(**********************************)

(*
Information about the previous character:
- does not exists
- is a letter
- is not a letter
- is a newline
- is last newline

Beginning of word:
- previous is not a letter or does not exist
- current is a letter or does not exist

End of word:
- previous is a letter or does not exist
- current is not a letter or does not exist

Beginning of line:
- previous is a newline or does not exist

Beginning of buffer:
- previous does not exist

End of buffer
- current does not exist

End of line
- current is a newline or does not exist
*)

(*
Rep: e = T,e | ()
  - semantics of the comma (shortest/longest/first)
  - semantics of the union (greedy/non-greedy)

Bounded repetition
  a{0,3} = (a,(a,a?)?)?
*)

end
module Ppx_bsx
= struct
#1 "ppx_bsx.ml"
module STR = Str                (* Avoid shadowed by Ast_helper.Str *)

open Migrate_parsetree
open Ast_404
open Ast_mapper
open Ast_helper
open Asttypes
open Parsetree
open Location
open Longident

module ExprMap = Map.Make(String)

type collector =
  { html_frags: string list;
    exprs: expression ExprMap.t;
    placeholder_index: int;
  }

type tag = string
type prop_name = string
type props = (arg_label * expression) list
type dom_repr =
  | Empty
  | Text of Location.t * expression list
  | Element of Location.t * tag * props * dom_repr list

let expr_placeholder_prefix = "__b_s_x__"

let fragment_placeholder = "ppx_bsx_fragment"

let re_id = Re.compile Re.(seq [ str expr_placeholder_prefix; rep digit ])

let collect e =
  let rec loop col e =
    match e.pexp_desc with
    | Pexp_apply ({ pexp_desc = Pexp_constant Pconst_string (str, None) }, al) ->
      let expr_list = snd @@ List.split al in
      let c = List.fold_left loop col expr_list in
      let html_frags = str :: (List.rev c.html_frags) in
      { c with html_frags  }
    | Pexp_constant Pconst_string (str, None) ->
      { col with html_frags = str :: col.html_frags }
    | _ ->
      let html =
        Printf.sprintf "%s%i" expr_placeholder_prefix col.placeholder_index
      in
      let html_frags = html :: col.html_frags in
      let exprs = ExprMap.add html e col.exprs in
      let placeholder_index = col.placeholder_index + 1 in
      { html_frags; exprs; placeholder_index }
  in
  loop { html_frags = []; exprs = ExprMap.empty; placeholder_index = 0 } e

type text_expr_type =
  | Pure_text of expression
  | Ocaml_expr of expression

let rec text_to_exprs loc expr_map str =
  let convert_to_j_if_neccessary e = match e.pexp_desc with
    | Pexp_constant Pconst_string (str, Some "") ->
      Exp.constant ~loc:e.pexp_loc (Pconst_string (str, Some "j"))
    | _ -> e
  in
  let to_expr s g =
    let slen = String.length s in
    let (i,j) = Re.Group.offset g 0 in
    let key = String.sub s i (j-i) in
    let e =
      try
        ExprMap.find key expr_map
      with _ ->
        let err =
          Location.error
            ~loc "Wrong OCaml expression, you may missed the parentheses."
        in
        raise (Location.Error err)
    in
    let oe = [Ocaml_expr (convert_to_j_if_neccessary e)] in
    let isWhole = i = 0 && j = slen in
    if isWhole then oe else begin
      let es = ref oe in
      if i > 0 then
        es := text_to_exprs loc expr_map (String.sub s 0 i) @ !es
      else ();
      if j < slen then
        es := !es @ text_to_exprs loc expr_map (String.sub s j (slen-j))
      else ();
      !es
    end
  in
  match Re.exec_opt re_id str with
  | None ->
    begin
      match String.trim str with
      | "" -> [ ]
      | _ as s ->
        let nl_to_sp = STR.(global_replace (regexp "\n") " " s) in
        [ Pure_text (Exp.constant (Pconst_string (nl_to_sp, None))) ]
    end
  | Some g -> to_expr str g

let handle_text loc expr_map xs =
  let str =
    xs
    |> List.map (fun x ->
        STR.(split (regexp "\n+") x)
        |> List.map String.trim
        |> String.concat "\n"
        |> String.trim
      )
    |> String.concat ""
  in
  match str with
  | "" -> Empty
  | _ ->
    let exprs = text_to_exprs loc expr_map str in
    let to_react_el e =
      let loc = e.pexp_loc in
      let rrste =
        Exp.ident ~loc { loc; txt = Ldot (Lident "ReasonReact", "string")}
      in
      Exp.apply rrste [ (Nolabel, e)]
    in
    let fold acc item = match item with
      | Pure_text e -> to_react_el e :: acc
      | Ocaml_expr e ->
        match e.pexp_desc with
        | Pexp_constant Pconst_string (_, Some "j") -> to_react_el e :: acc
        | _ -> e :: acc
    in
    Text (loc, (exprs |> List.fold_left fold [] |> List.rev))

let tidy_attr =
  function
  | "class" -> "className"
  | "for" -> "htmlFor"
  | "type" -> "type_"
  | "to" -> "to_"
  | "open" -> "open_"
  | "begin" -> "begin_"
  | "end" -> "end_"
  | "in" -> "in_"
  | _ as origin -> origin

let handle_element loc expr_map (_, name) attrs children =
  let attrs_map ((_,n), v) =
    let n = tidy_attr n in
    match v with
    | "" -> [ (Labelled n, Exp.ident { loc; txt = Lident n }) ]
    | _ ->
      let v_exprs = text_to_exprs loc expr_map v in
      let to_e item  = match item with Pure_text e -> e | Ocaml_expr e -> e in
      match (List.length v_exprs) with
      | 0 -> []
      | 1 -> [ (Labelled n,  to_e (List.hd v_exprs)) ]
      | _ ->
        let str_cat acc item =
          let e = to_e item in
          let loc = e.pexp_loc in
          Exp.apply
            ~loc
            (Exp.ident ~loc { loc; txt = Lident "^"})
            ([ (Nolabel, acc); (Nolabel, e) ])
        in
        [ ( Labelled n
          , List.tl v_exprs
            |> List.fold_left str_cat (List.hd v_exprs |> to_e )) ]
  in
  Element (loc, name, attrs |> List.map attrs_map |> List.concat, children)

let is_titlecase str =
  let fstc = String.get str 0 in
  Char.uppercase fstc = fstc

let handle_titlecase loc tag_name props children_expr =
  let create_comp =
    Exp.ident
      ~loc { loc; txt = Ldot (Lident "ReasonReact", "element")}
  in
  let is_key_or_ref (label, _) = match label with
    | Labelled l -> l = "key" || l = "ref"
    | _ -> false
  in
  let (kr_props, mk_props) = List.partition is_key_or_ref props in
  let modules = (STR.split (STR.regexp "\\.") tag_name) @ [ "make" ] in
  let mk_ldot acc m =  Ldot (acc, m) in
  let ident =
    List.tl modules
    |> List.fold_left mk_ldot (Lident (List.hd modules)) in
  let make = Exp.ident ~loc { loc; txt = ident } in
  let comp =
    Exp.apply make (mk_props @ [ (Nolabel, Exp.array children_expr) ])
  in
  Exp.apply create_comp (kr_props @ [ (Nolabel, comp) ])

let handle_lowercase loc tag_name props children_expr =
  let create_dom_el =
    Exp.ident ~ loc { loc; txt = Ldot (Lident "ReactDOMRe", "createElement")}
  in
  let tag_name_expr =
    if tag_name = fragment_placeholder then
      ( Nolabel
      , Exp.ident ~ loc { loc; txt = Ldot (Lident "ReasonReact", "fragment")}
      )
    else
      (Nolabel, Exp.constant (Pconst_string (tag_name, None))) in
  let args = match List.length props with
    | 0 -> [ tag_name_expr; (Nolabel, Exp.array children_expr) ]
    | _ ->
      let create_props =
        Exp.ident ~loc { loc; txt = Ldot (Lident "ReactDOMRe", "props")}
      in
      let unit_ = (Nolabel, Exp.construct ~loc {loc; txt = Lident "()"} None) in
      let props_expr = Exp.apply create_props (props @ [ unit_ ]) in
      [ tag_name_expr; (Labelled "props", props_expr)
      ; (Nolabel, Exp.array children_expr) ]
  in
  Exp.apply create_dom_el args

let expr mapper e =
  match e.pexp_desc with
  | Pexp_extension ({ txt = "bsx" }, PStr [{pstr_desc = Pstr_eval (e, _)}]) ->
    let open Markup in
    let c = collect e in
    let html = String.concat "" c.html_frags |> String.trim in
    let rec dom_to_expr = function
      | Element (loc, tag_name, props, children) ->
        let fold acc item = match item with
          | Element _ -> acc @ [ dom_to_expr item ]
          | Text (loc, els) -> acc @ els
          | _ -> acc
        in
        let handler =
          if is_titlecase tag_name then handle_titlecase
          else handle_lowercase
        in
        handler loc tag_name props (children |> List.fold_left fold [])
      | _ -> default_mapper.expr mapper e
    in
    let report location (error: Markup.Error.t) =
      match error with
      | `Bad_token _ -> ()         (* ignore this error because our attrs missing quotations*)
      | _ ->
        let open Lexing in
        let loc = e.pexp_loc in
        let location =
          fst location + loc.loc_start.pos_lnum
        , snd location + loc.loc_start.pos_cnum
        in
        let errstr = Error.to_string ~location error in
        raise (Location.Error (Location.error ~loc errstr))
    in
    begin match
        html
        |> STR.global_replace
          (STR.regexp "<>") ("<" ^ fragment_placeholder ^ ">")
        |> STR.global_replace
          (STR.regexp "</>") ("</" ^ fragment_placeholder ^ ">")
        |> string
        |> parse_xml ~report
        |> signals
        |> tree
          ~text: (handle_text e.pexp_loc c.exprs)
          ~element: (handle_element e.pexp_loc c.exprs)
      with
      | Some de -> dom_to_expr de
      | None -> default_mapper.expr mapper e
    end
  | _ -> default_mapper.expr mapper e

let mapper _ =
  let module To_current = Convert(OCaml_404)(OCaml_current) in
  To_current.copy_mapper {default_mapper with expr}

let () = Compiler_libs.Ast_mapper.register "bsx"  mapper

end
